/*
MICROSOFT SOFTWARE LICENSE TERMS
MICROSOFT AZURE MAPS WEB SDK
These license terms are an agreement between you and Microsoft Corporation (or one of its affiliates). They apply to the software named above and any Microsoft services or software updates (except to the extent such services or updates are accompanied by new or additional terms, in which case those different terms apply prospectively and do not alter your or Microsoft’s rights relating to pre-updated software or services). IF YOU COMPLY WITH THESE LICENSE TERMS, YOU HAVE THE RIGHTS BELOW.  BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.
1. INSTALLATION AND USE RIGHTS.
  a) General. You may install and use any number of copies of the software to develop and test your applications.
  b) User Region Parameters. The software will allow you to select from a View list to set the map view within your application for a given customer. By default the View parameter (also referred to as “user region parameter” is set to “Unified”.  Countries/Regions that are not on the View list will default to the “Unified” View. It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via the software is made available. 
  c) Third Party Software. The software may include third party applications that Microsoft, not the third party, licenses to you under this agreement. Any included notices for third party applications are for your information only.
  d) Microsoft Online Subscription Agreement. Some features of the software provide access to, or rely on, Microsoft Azure Services. The use of those services (but not the software) is governed by the separate terms and privacy policies associated with your Microsoft Azure subscription. The services may not be available in all regions. For more information see https://go.microsoft.com/fwLink/?LinkID=522330&amp;clcid=0x9.
2. DISTRIBUTABLE CODE. The software is comprised of “Distributable Code”. “Distributable Code” is code that you are permitted to distribute in applications you develop if you comply with the terms below and otherwise set forth in these license terms. 
  a) Distribution Rights. 
    i. You may copy and distribute the object code form of the software.
    i. Third Party Distribution. You may permit distributors of your applications to copy and distribute any of this distributable code you elect to distribute with your applications.
  b) Distribution Requirements. For any code you distribute, you must:
    i. add significant primary functionality to it in your applications;
    ii. require distributors and external end users to agree to terms that protect it and Microsoft at least as much as this agreement; and
    iii. indemnify, defend, and hold harmless Microsoft from any claims, including attorneys’ fees, related to the distribution or use of your applications, except to the extent that any claim is based solely on the unmodified distributable code.
  c) Distribution Restrictions. You may not:
    i. use Microsoft’s trademarks or trade dress in your application in any way that suggests your application comes from or is endorsed by Microsoft; or
    ii. modify or distribute the source code of any distributable code so that any part of it becomes subject to any license that requires that the distributable code, any other part of the software, or any of Microsoft’s other intellectual property be disclosed or distributed in source code form, or that others have the right to modify it.
3. DATA COLLECTION. The software may collect information about you and your use of the software and send that to Microsoft. Microsoft may use this information to provide services and improve Microsoft’s products and services. Your opt-out rights, if any, are described in the product documentation. Some features in the software may enable collection of data from users of your applications that access or use the software. If you use these features to enable data collection in your applications, you must comply with applicable law, including getting any required user consent, and maintain a prominent privacy policy that accurately informs users about how you use, collect, and share their data. You can learn more about Microsoft’s data collection and use in the product documentation and the Microsoft Privacy Statement at https://go.microsoft.com/fwlink/?LinkId=512132. You agree to comply with all applicable provisions of the Microsoft Privacy Statement.
4. SCOPE OF LICENSE. The software is licensed, not sold. Microsoft reserves all other rights. Unless applicable law gives you more rights despite this limitation, you will not (and have no right to):
  a) work around any technical limitations in the software that only allow you to use it in certain ways;
  b) reverse engineer, decompile, or disassemble the software, or attempt to do so, except and only to the extent permitted by licensing terms governing the use of open-source components that may be included with the software;
  c) remove, minimize, block, or modify any notices of Microsoft or its suppliers in the software;
  d) use the software in any way that is against the law or to create or propagate malware; or
  e) share, publish, distribute, or lend the software (except for any distributable code, subject to the terms above), provide the software as a stand-alone hosted solution for others to use, or transfer the software or this agreement to any third party.
5. EXPORT RESTRICTIONS. You must comply with all domestic and international export laws and regulations that apply to the software, which include restrictions on destinations, end users, and end use. For further information on export restrictions, visit http://aka.ms/exporting.
6. SUPPORT SERVICES. Microsoft is not obligated under this agreement to provide any support services for the software. Any support provided is “as is”, “with all faults”, and without warranty of any kind.
7. UPDATES. The software may periodically check for updates, and download and install them for you. You may obtain updates only from Microsoft or authorized sources. Microsoft may need to update your system to provide you with updates. You agree to receive these automatic updates without any additional notice. Updates may not include or support all existing software features, services, or peripheral devices.
8. ENTIRE AGREEMENT. This agreement, and any other terms Microsoft may provide for supplements, updates, or third-party applications, is the entire agreement for the software.
9. APPLICABLE LAW AND PLACE TO RESOLVE DISPUTES. If you acquired the software in the United States or Canada, the laws of the state or province where you live (or, if a business, where your principal place of business is located) govern the interpretation of this agreement, claims for its breach, and all other claims (including consumer protection, unfair competition, and tort claims), regardless of conflict of laws principles. If you acquired the software in any other country, its laws apply. If U.S. federal jurisdiction exists, you and Microsoft consent to exclusive jurisdiction and venue in the federal court in King County, Washington for all disputes heard in court. If not, you and Microsoft consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington for all disputes heard in court.
10. CONSUMER RIGHTS; REGIONAL VARIATIONS. This agreement describes certain legal rights. You may have other rights, including consumer rights, under the laws of your state or country. Separate and apart from your relationship with Microsoft, you may also have rights with respect to the party from which you acquired the software. This agreement does not change those other rights if the laws of your state or country do not permit it to do so. For example, if you acquired the software in one of the below regions, or mandatory country law applies, then the following provisions apply to you:
  a) Australia. You have statutory guarantees under the Australian Consumer Law and nothing in this agreement is intended to affect those rights.
  b) Canada. If you acquired this software in Canada, you may stop receiving updates by turning off the automatic update feature, disconnecting your device from the Internet (if and when you re-connect to the Internet, however, the software will resume checking for and installing updates), or uninstalling the software. The product documentation, if any, may also specify how to turn off updates for your specific device or software.
  c) Germany and Austria.
    i. Warranty. The properly licensed software will perform substantially as described in any Microsoft materials that accompany the software. However, Microsoft gives no contractual guarantee in relation to the licensed software.
    ii. Limitation of Liability. In case of intentional conduct, gross negligence, claims based on the Product Liability Act, as well as, in case of death or personal or physical injury, Microsoft is liable according to the statutory law.
  Subject to the foregoing clause ii., Microsoft will only be liable for slight negligence if Microsoft is in breach of such material contractual obligations, the fulfillment of which facilitate the due performance of this agreement, the breach of which would endanger the purpose of this agreement and the compliance with which a party may constantly trust in (so-called "cardinal obligations"). In other cases of slight negligence, Microsoft will not be liable for slight negligence.
11. DISCLAIMER OF WARRANTY. THE SOFTWARE IS LICENSED “AS IS.” YOU BEAR THE RISK OF USING IT. MICROSOFT GIVES NO EXPRESS WARRANTIES, GUARANTEES, OR CONDITIONS. TO THE EXTENT PERMITTED UNDER APPLICABLE LAWS, MICROSOFT EXCLUDES ALL IMPLIED WARRANTIES, INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
12. LIMITATION ON AND EXCLUSION OF DAMAGES. IF YOU HAVE ANY BASIS FOR RECOVERING DAMAGES DESPITE THE PRECEDING DISCLAIMER OF WARRANTY, YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT, OR INCIDENTAL DAMAGES.
This limitation applies to (a) anything related to the software, services, content (including code) on third party Internet sites, or third party applications; and (b) claims for breach of contract, warranty, guarantee, or condition; strict liability, negligence, or other tort; or any other claim; in each case to the extent permitted by applicable law.
It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your state, province, or country may not allow the exclusion or limitation of incidental, consequential, or other damages.
Please note: As this software is distributed in Canada, some of the clauses in this agreement are provided below in French.
Remarque: Ce logiciel étant distribué au Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en français.
EXONÉRATION DE GARANTIE. Le logiciel visé par une licence est offert « tel quel ». Toute utilisation de ce logiciel est à votre seule risque et péril. Microsoft n’accorde aucune autre garantie expresse. Vous pouvez bénéficier de droits additionnels en vertu du droit local sur la protection des consommateurs, que ce contrat ne peut modifier. La ou elles sont permises par le droit locale, les garanties implicites de qualité marchande, d’adéquation à un usage particulier et d’absence de contrefaçon sont exclues.
LIMITATION DES DOMMAGES-INTÉRÊTS ET EXCLUSION DE RESPONSABILITÉ POUR LES DOMMAGES. Vous pouvez obtenir de Microsoft et de ses fournisseurs une indemnisation en cas de dommages directs uniquement à hauteur de 5,00 $ US. Vous ne pouvez prétendre à aucune indemnisation pour les autres dommages, y compris les dommages spéciaux, indirects ou accessoires et pertes de bénéfices.
Cette limitation concerne:
• tout ce qui est relié au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers; et
• les réclamations au titre de violation de contrat ou de garantie, ou au titre de responsabilité stricte, de négligence ou d’une autre faute dans la limite autorisée par la loi en vigueur.
Elle s’applique également, même si Microsoft connaissait ou devrait connaître l’éventualité d’un tel dommage. Si votre pays n’autorise pas l’exclusion ou la limitation de responsabilité pour les dommages indirects, accessoires ou de quelque nature que ce soit, il se peut que la limitation ou l’exclusion ci-dessus ne s’appliquera pas à votre égard.
EFFET JURIDIQUE. Le présent contrat décrit certains droits juridiques. Vous pourriez avoir d’autres droits prévus par les lois de votre pays. Le présent contrat ne modifie pas les droits que vous confèrent les lois de votre pays si celles-ci ne le permettent pas.
---
title: THIRD PARTY NOTICES FOR Azure Maps SDK
preamble: |
	Do Not Translate or Localize

	This file is based on or incorporates material from the projects listed below (Third Party IP).
	The original copyright notice and the license under which Microsoft received such Third Party IP,
	are set forth below. Such licenses and notices are provided for informational purposes only.
	Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.
	Microsoft reserves all other rights not expressly granted under this agreement, whether by implication,
	estoppel or otherwise.


registrations:
	- component:
		name: @mapbox/mapbox-gl-rtl-text
		version: 0.1.2
		license: |
mapbox-gl-rtl-text copyright (c) 2017 Mapbox.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This source code is derived from the International Components for Unicode (ICU) library, available from [http://site.icu-project.org/](). ICU C++ code original license as follows:

COPYRIGHT AND PERMISSION NOTICE (ICU 58 and later)

Copyright © 1991-2016 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in http://www.unicode.org/copyright.html

Permission is hereby granted, free of charge, to any person obtaining
a copy of the Unicode data files and any associated documentation
(the "Data Files") or Unicode software and any associated documentation
(the "Software") to deal in the Data Files or Software
without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, and/or sell copies of
the Data Files or Software, and to permit persons to whom the Data Files
or Software are furnished to do so, provided that either
(a) this copyright and permission notice appear with all copies
of the Data Files or Software, or
(b) this copyright and permission notice appear in associated
Documentation.

THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THE DATA FILES OR SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in these Data Files or Software without prior
written authorization of the copyright holder.


	- component:
		name: @microsoft/applicationinsights-web
		version: 2.2.2
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @microsoft/applicationinsights-analytics-js
		version: 2.2.2
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @microsoft/applicationinsights-common
		version: 2.2.2
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @microsoft/applicationinsights-core-js
		version: 2.2.2
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: tslib
		version: 1.10.0
		license: |
Apache License

Version 2.0, January 2004

http://www.apache.org/licenses/ 

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.

"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.

"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:

You must give any other recipients of the Work or Derivative Works a copy of this License; and

You must cause any modified files to carry prominent notices stating that You changed the files; and

You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and

If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS


	- component:
		name: @microsoft/applicationinsights-channel-js
		version: 2.2.2
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @microsoft/applicationinsights-dependencies-js
		version: 2.2.2
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @microsoft/applicationinsights-properties-js
		version: 2.2.2
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/adal-angular
		version: 1.0.1
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/color
		version: 3.0.0
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/color-convert
		version: 1.9.0
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/color-name
		version: 1.1.1
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/jwt-decode
		version: 2.2.1
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/lodash
		version: 4.14.136
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/mapbox-gl
		version: 0.54.5
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: @types/geojson
		version: 7946.0.7
		license: |
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE


	- component:
		name: adal-angular
		version: 1.0.17
		license: |
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


	- component:
		name: color
		version: 3.1.2
		license: |
Copyright (c) 2012 Heather Arthur

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



	- component:
		name: color-convert
		version: 1.9.3
		license: |
Copyright (c) 2011-2016 Heather Arthur <fayearthur@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



	- component:
		name: color-name
		version: 1.1.3
		license: |
The MIT License (MIT)
Copyright (c) 2015 Dmitry Ivanov

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	- component:
		name: color-string
		version: 1.5.3
		license: |
Copyright (c) 2011 Heather Arthur <fayearthur@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



	- component:
		name: simple-swizzle
		version: 0.2.2
		license: |
The MIT License (MIT)

Copyright (c) 2015 Josh Junon

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


	- component:
		name: is-arrayish
		version: 0.3.2
		license: |
The MIT License (MIT)

Copyright (c) 2015 JD Ballard

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


	- component:
		name: jwt-decode
		version: 2.2.0
		license: |
The MIT License (MIT)
 
Copyright (c) 2015 Auth0, Inc. <support@auth0.com> (http://auth0.com)
 
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
 
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


	- component:
		name: lodash
		version: 4.17.15
		license: |
Copyright OpenJS Foundation and other contributors <https://openjsf.org/>

Based on Underscore.js, copyright Jeremy Ashkenas,
DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>

This software consists of voluntary contributions made by many
individuals. For exact contribution history, see the revision history
available at https://github.com/lodash/lodash

The following license applies to all parts of this software except as
documented below:

====

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

====

Copyright and related rights for sample code are waived via CC0. Sample
code is defined as all source code displayed within the prose of the
documentation.

CC0: http://creativecommons.org/publicdomain/zero/1.0/

====

Files located in the node_modules and vendor directories are externally
maintained libraries used by this software which have their own
licenses; we recommend you read them, as their terms may differ from the
terms above.


	- component:
		name: mapbox-gl
		version: 1.4.1
		license: |
Copyright (c) 2016, Mapbox

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of Mapbox GL JS nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-------------------------------------------------------------------------------

Contains Hershey Simplex Font: http://paulbourke.net/dataformats/hershey/

-------------------------------------------------------------------------------

Contains code from glfx.js

Copyright (C) 2011 by Evan Wallace

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

--------------------------------------------------------------------------------

Contains a portion of d3-color https://github.com/d3/d3-color

Copyright 2010-2016 Mike Bostock
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the author nor the names of contributors may be used to
  endorse or promote products derived from this software without specific prior
  written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


	- component:
		name: @mapbox/geojson-rewind
		version: 0.4.0
		license: |
Copyright (c) {{ year }}, {{ organization }}

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.


	- component:
		name: @mapbox/geojson-area
		version: 0.2.2
		license: |
Copyright 2005-2013 OpenLayers Contributors. All rights reserved. See
authors.txt for full list.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY OPENLAYERS CONTRIBUTORS ``AS IS'' AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of OpenLayers Contributors.


	- component:
		name: wgs84
		version: 0.0.0
		license: |
BSD 2-Clause License

Copyright (c) 2017, Mapbox
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	- component:
		name: minimist
		version: 1.2.0
		license: |
This software is released under the MIT license:

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: minimist
		version: 0.0.5
		license: |
This software is released under the MIT license:

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: minimist
		version: 0.0.8
		license: |
This software is released under the MIT license:

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: concat-stream
		version: 1.6.2
		license: |
The MIT License

Copyright (c) 2013 Max Ogden

Permission is hereby granted, free of charge, 
to any person obtaining a copy of this software and 
associated documentation files (the "Software"), to 
deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom 
the Software is furnished to do so, 
subject to the following conditions:

The above copyright notice and this permission notice 
shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	- component:
		name: buffer-from
		version: 1.1.1
		license: |
MIT License

Copyright (c) 2016, 2018 Linus Unnebäck

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

	- component:
		name: inherits
		version: 2.0.4
		license: |
The ISC License

Copyright (c) Isaac Z. Schlueter

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.



	- component:
		name: readable-stream
		version: 2.3.6
		license: |
Node.js is licensed for use as follows:

"""
Copyright Node.js contributors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

This license applies to parts of Node.js originating from the
https://github.com/joyent/node repository:

"""
Copyright Joyent, Inc. and other Node contributors. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""


	- component:
		name: core-util-is
		version: 1.0.2
		license: |
Copyright Node.js contributors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.


	- component:
		name: isarray
		version: 1.0.0
		license: |
(MIT)

Copyright (c) 2013 Julian Gruber <julian@juliangruber.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	- component:
		name: process-nextick-args
		version: 2.0.1
		license: |
# Copyright (c) 2015 Calvin Metcalf

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

**THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.**


	- component:
		name: safe-buffer
		version: 5.1.2
		license: |
The MIT License (MIT)

Copyright (c) Feross Aboukhadijeh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


	- component:
		name: string_decoder
		version: 1.1.1
		license: |
Node.js is licensed for use as follows:

"""
Copyright Node.js contributors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

This license applies to parts of Node.js originating from the
https://github.com/joyent/node repository:

"""
Copyright Joyent, Inc. and other Node contributors. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""



	- component:
		name: util-deprecate
		version: 1.0.2
		license: |
(The MIT License)

Copyright (c) 2014 Nathan Rajlich <nathan@tootallnate.net>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: typedarray
		version: 0.0.6
		license: |
 Copyright (c) 2010, Linden Research, Inc.
 Copyright (c) 2012, Joshua Bell

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 $/LicenseInfo$

// Original can be found at:
//   https://bitbucket.org/lindenlab/llsd
// Modifications by Joshua Bell inexorabletash@gmail.com
//   https://github.com/inexorabletash/polyfill

// ES3/ES5 implementation of the Krhonos Typed Array Specification
//   Ref: http://www.khronos.org/registry/typedarray/specs/latest/
//   Date: 2011-02-01
//
// Variations:
//  * Allows typed_array.get/set() as alias for subscripts (typed_array[])

	- component:
		name: sharkdown
		version: 0.1.1
		license: |
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by:

(a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or
(b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution.
Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise.

DISCLAIMER

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	- component:
		name: cardinal
		version: 0.4.4
		license: |
Copyright 2012 Thorsten Lorenz. 
All rights reserved.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: ansicolors
		version: 0.2.1
		license: |
Copyright 2013 Thorsten Lorenz. 
All rights reserved.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: redeyed
		version: 0.4.4
		license: |
Copyright 2012 Thorsten Lorenz. 
All rights reserved.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: esprima
		version: 1.0.4
		license: |
Copyright JS Foundation and other contributors, https://js.foundation/

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	- component:
		name: split
		version: 0.2.10
		license: |
Copyright (c) 2011 Dominic Tarr

Permission is hereby granted, free of charge, 
to any person obtaining a copy of this software and 
associated documentation files (the "Software"), to 
deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom 
the Software is furnished to do so, 
subject to the following conditions:

The above copyright notice and this permission notice 
shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	- component:
		name: through
		version: 2.3.8
		license: |
Apache License, Version 2.0

Copyright (c) 2011 Dominic Tarr

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


The MIT License

Copyright (c) 2011 Dominic Tarr

Permission is hereby granted, free of charge, 
to any person obtaining a copy of this software and 
associated documentation files (the "Software"), to 
deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom 
the Software is furnished to do so, 
subject to the following conditions:

The above copyright notice and this permission notice 
shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


	- component:
		name: @mapbox/geojson-types
		version: 1.0.2
		license: |
MIT License

Copyright (c) 2018 Mapbox

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


	- component:
		name: @mapbox/jsonlint-lines-primitives
		version: 2.0.2
		license: |
No license information found

	- component:
		name: @mapbox/mapbox-gl-supported
		version: 1.4.1
		license: |

BSD 3-Clause License

Copyright (c) 2017, Mapbox
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


	- component:
		name: @mapbox/point-geometry
		version: 0.1.0
		license: |
Copyright (c) 2015, Mapbox <>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


	- component:
		name: @mapbox/tiny-sdf
		version: 1.1.1
		license: |
Copyright © 2016-2017 Mapbox, Inc.
This code available under the terms of the BSD 2-Clause license.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
© 2018 GitHub, Inc.

	- component:
		name: @mapbox/unitbezier
		version: 0.0.0
		license: |
BSD-2-Clause

Copyright (C) 2008 Apple Inc. All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Ported from Webkit
http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h

	- component:
		name: @mapbox/vector-tile
		version: 1.3.1
		license: |
Copyright (c) 2014, Mapbox


All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of Mapbox nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


	- component:
		name: @mapbox/whoots-js
		version: 3.1.0
		license: |
ISC License

Copyright (c) 2017, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: csscolorparser
		version: 1.0.3
		license: |
(c) Dean McNamee <dean@gmail.com>, 2012.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

	- component:
		name: earcut
		version: 2.2.1
		license: |
ISC License

Copyright (c) 2016, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: geojson-vt
		version: 3.2.1
		license: |
ISC License

Copyright (c) 2015, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: gl-matrix
		version: 3.1.0
		license: |
Copyright (c) 2015-2019, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

	- component:
		name: grid-index
		version: 1.1.0
		license: |
Copyright (c) 2016, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: murmurhash-js
		version: 1.0.0
		license: |
The MIT License (MIT)

Copyright (c) 2011 Gary Court

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	- component:
		name: pbf
		version: 3.2.1
		license: |
Copyright (c) 2017, Mapbox
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of pbf nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


	- component:
		name: ieee754
		version: 1.1.13
		license: |
Copyright 2008 Fair Oaks Labs, Inc.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


	- component:
		name: resolve-protobuf-schema
		version: 2.1.0
		license: |
The MIT License (MIT)

Copyright (c) 2014 Mathias Buus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


	- component:
		name: protocol-buffers-schema
		version: 3.3.2
		license: |
The MIT License (MIT)

Copyright (c) 2014 Mathias Buus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

	- component:
		name: potpack
		version: 1.0.1
		license: |
ISC License

Copyright (c) 2018, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: quickselect
		version: 2.0.0
		license: |
ISC License

Copyright (c) 2018, Vladimir Agafonkin

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: rw
		version: 1.3.3
		license: |
Copyright (c) 2014-2016, Michael Bostock
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* The name Michael Bostock may not be used to endorse or promote products
  derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


	- component:
		name: supercluster
		version: 6.0.2
		license: |
ISC License

Copyright (c) 2016, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: kdbush
		version: 3.0.0
		license: |
ISC License

Copyright (c) 2018, Vladimir Agafonkin

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.

	- component:
		name: tinyqueue
		version: 2.0.3
		license: |
ISC License

Copyright (c) 2017, Vladimir Agafonkin

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.


	- component:
		name: vt-pbf
		version: 3.1.1
		license: |
The MIT License (MIT)

Copyright (c) 2015 Anand Thakker

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------

Contains geojson_wrapper.js from https://github.com/mapbox/mapbox-gl-js

Copyright (c) 2014, Mapbox

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of Mapbox GL JS nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



	- component:
		name: typescript
		version: 3.7.2
		license: |
Apache License

Version 2.0, January 2004

http://www.apache.org/licenses/ 

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.

"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.

"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:

You must give any other recipients of the Work or Derivative Works a copy of this License; and

You must cause any modified files to carry prominent notices stating that You changed the files; and

You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and

If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS


	- component:
		name: uuid-random
		version: 1.0.9
		license: |
Copyright (c) 2016-2019 Wes Roberts

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.atlas = global.atlas || {}));
}(this, function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var mapboxGl = createCommonjsModule(function (module, exports) {
	/* Mapbox GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/mapbox/mapbox-gl-js/blob/v1.4.1/LICENSE.txt */
	(function (global, factory) {
	 module.exports = factory() ;
	}(commonjsGlobal, function () {
	/* eslint-disable */

	var shared, worker, mapboxgl;
	// define gets called three times: one for each chunk. we rely on the order
	// they're imported to know which is which
	function define(_, chunk) {
	if (!shared) {
	    shared = chunk;
	} else if (!worker) {
	    worker = chunk;
	} else {
	    var workerBundleString = 'var sharedChunk = {}; (' + shared + ')(sharedChunk); (' + worker + ')(sharedChunk);';

	    var sharedChunk = {};
	    shared(sharedChunk);
	    mapboxgl = chunk(sharedChunk);
	    mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
	}
	}


	define(["exports"],function(t){function e(t,e){return t(e={exports:{}},e.exports),e.exports}var r=n;function n(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=n,this.p2x=r,this.p2y=n;}n.prototype.sampleCurveX=function(t){return ((this.ax*t+this.bx)*t+this.cx)*t},n.prototype.sampleCurveY=function(t){return ((this.ay*t+this.by)*t+this.cy)*t},n.prototype.sampleCurveDerivativeX=function(t){return (3*this.ax*t+2*this.bx)*t+this.cx},n.prototype.solveCurveX=function(t,e){var r,n,i,a,o;for(void 0===e&&(e=1e-6),i=t,o=0;o<8;o++){if(a=this.sampleCurveX(i)-t,Math.abs(a)<e)return i;var s=this.sampleCurveDerivativeX(i);if(Math.abs(s)<1e-6)break;i-=a/s;}if((i=t)<(r=0))return r;if(i>(n=1))return n;for(;r<n;){if(a=this.sampleCurveX(i),Math.abs(a-t)<e)return i;t>a?r=i:n=i,i=.5*(n-r)+r;}return i},n.prototype.solve=function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))};var i=a;function a(t,e){this.x=t,this.y=e;}function o(t,e){if(Array.isArray(t)){if(!Array.isArray(e)||t.length!==e.length)return !1;for(var r=0;r<t.length;r++)if(!o(t[r],e[r]))return !1;return !0}if("object"==typeof t&&null!==t&&null!==e){if("object"!=typeof e)return !1;if(Object.keys(t).length!==Object.keys(e).length)return !1;for(var n in t)if(!o(t[n],e[n]))return !1;return !0}return t===e}function s(t,e,n,i){var a=new r(t,e,n,i);return function(t){return a.solve(t)}}a.prototype={clone:function(){return new a(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[0]*this.x+t[1]*this.y,r=t[2]*this.x+t[3]*this.y;return this.x=e,this.y=r,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=e*this.x-r*this.y,i=r*this.x+e*this.y;return this.x=n,this.y=i,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),i=e.x+r*(this.x-e.x)-n*(this.y-e.y),a=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=i,this.y=a,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},a.convert=function(t){return t instanceof a?t:Array.isArray(t)?new a(t[0],t[1]):t};var u=s(.25,.1,.25,1);function l(t,e,r){return Math.min(r,Math.max(e,t))}function p(t,e,r){var n=r-e,i=((t-e)%n+n)%n+e;return i===e?r:i}function c(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];for(var n=0,i=e;n<i.length;n+=1){var a=i[n];for(var o in a)t[o]=a[o];}return t}var h=1;function f(){return h++}function y(){return function t(e){return e?(e^16*Math.random()>>e/4).toString(16):([1e7]+-[1e3]+-4e3+-8e3+-1e11).replace(/[018]/g,t)}()}function d(t){return !!t&&/^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)}function m(t,e){t.forEach(function(t){e[t]&&(e[t]=e[t].bind(e));});}function v(t,e){return -1!==t.indexOf(e,t.length-e.length)}function g(t,e,r){var n={};for(var i in t)n[i]=e.call(r||this,t[i],i,t);return n}function x(t,e,r){var n={};for(var i in t)e.call(r||this,t[i],i,t)&&(n[i]=t[i]);return n}function b(t){return Array.isArray(t)?t.map(b):"object"==typeof t&&t?g(t,b):t}var _={};function w(t){_[t]||("undefined"!=typeof console&&console.warn(t),_[t]=!0);}function A(t,e,r){return (r.y-t.y)*(e.x-t.x)>(e.y-t.y)*(r.x-t.x)}function k(t){for(var e=0,r=0,n=t.length,i=n-1,a=void 0,o=void 0;r<n;i=r++)a=t[r],e+=((o=t[i]).x-a.x)*(a.y+o.y);return e}function S(t){var e={};if(t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,function(t,r,n,i){var a=n||i;return e[r]=!a||a.toLowerCase(),""}),e["max-age"]){var r=parseInt(e["max-age"],10);isNaN(r)?delete e["max-age"]:e["max-age"]=r;}return e}function z(t){try{var e=self[t];return e.setItem("_mapbox_test_",1),e.removeItem("_mapbox_test_"),!0}catch(t){return !1}}var I,C,B,E,P=self.performance&&self.performance.now?self.performance.now.bind(self.performance):Date.now.bind(Date),M=self.requestAnimationFrame||self.mozRequestAnimationFrame||self.webkitRequestAnimationFrame||self.msRequestAnimationFrame,T=self.cancelAnimationFrame||self.mozCancelAnimationFrame||self.webkitCancelAnimationFrame||self.msCancelAnimationFrame,V={now:P,frame:function(t){var e=M(t);return {cancel:function(){return T(e)}}},getImageData:function(t,e){void 0===e&&(e=0);var r=self.document.createElement("canvas"),n=r.getContext("2d");if(!n)throw new Error("failed to create canvas 2d context");return r.width=t.width,r.height=t.height,n.drawImage(t,0,0,t.width,t.height),n.getImageData(-e,-e,t.width+2*e,t.height+2*e)},resolveURL:function(t){return I||(I=self.document.createElement("a")),I.href=t,I.href},hardwareConcurrency:self.navigator.hardwareConcurrency||4,get devicePixelRatio(){return self.devicePixelRatio},get prefersReducedMotion(){return !!self.matchMedia&&(null==C&&(C=self.matchMedia("(prefers-reduced-motion: reduce)")),C.matches)}},F={API_URL:"https://api.mapbox.com",get EVENTS_URL(){return this.API_URL?0===this.API_URL.indexOf("https://api.mapbox.cn")?"https://events.mapbox.cn/events/v2":0===this.API_URL.indexOf("https://api.mapbox.com")?"https://events.mapbox.com/events/v2":null:null},FEEDBACK_URL:"https://apps.mapbox.com/feedback",REQUIRE_ACCESS_TOKEN:!0,ACCESS_TOKEN:null,MAX_PARALLEL_IMAGE_REQUESTS:16},O={supported:!1,testSupport:function(t){if(L||!E)return;D?U(t):B=t;}},L=!1,D=!1;function U(t){var e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);try{if(t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,E),t.isContextLost())return;O.supported=!0;}catch(t){}t.deleteTexture(e),L=!0;}self.document&&((E=self.document.createElement("img")).onload=function(){B&&U(B),B=null,D=!0;},E.onerror=function(){L=!0,B=null;},E.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");var R="01";var j=function(t,e){this._transformRequestFn=t,this._customAccessToken=e,this._createSkuToken();};function q(t){return 0===t.indexOf("mapbox:")}j.prototype._createSkuToken=function(){var t=function(){for(var t="",e=0;e<10;e++)t+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62*Math.random())];return {token:["1",R,t].join(""),tokenExpiresAt:Date.now()+432e5}}();this._skuToken=t.token,this._skuTokenExpiresAt=t.tokenExpiresAt;},j.prototype._isSkuTokenExpired=function(){return Date.now()>this._skuTokenExpiresAt},j.prototype.transformRequest=function(t,e){return this._transformRequestFn&&this._transformRequestFn(t,e)||{url:t}},j.prototype.normalizeStyleURL=function(t,e){if(!q(t))return t;var r=X(t);return r.path="/styles/v1"+r.path,this._makeAPIURL(r,this._customAccessToken||e)},j.prototype.normalizeGlyphsURL=function(t,e){if(!q(t))return t;var r=X(t);return r.path="/fonts/v1"+r.path,this._makeAPIURL(r,this._customAccessToken||e)},j.prototype.normalizeSourceURL=function(t,e){if(!q(t))return t;var r=X(t);return r.path="/v4/"+r.authority+".json",r.params.push("secure"),this._makeAPIURL(r,this._customAccessToken||e)},j.prototype.normalizeSpriteURL=function(t,e,r,n){var i=X(t);return q(t)?(i.path="/styles/v1"+i.path+"/sprite"+e+r,this._makeAPIURL(i,this._customAccessToken||n)):(i.path+=""+e+r,G(i))},j.prototype.normalizeTileURL=function(t,e,r){if(this._isSkuTokenExpired()&&this._createSkuToken(),!e||!q(e))return t;var n=X(t),i=V.devicePixelRatio>=2||512===r?"@2x":"",a=O.supported?".webp":"$1";return n.path=n.path.replace(/(\.(png|jpg)\d*)(?=$)/,""+i+a),n.path=n.path.replace(/^.+\/v4\//,"/"),n.path="/v4"+n.path,F.REQUIRE_ACCESS_TOKEN&&(F.ACCESS_TOKEN||this._customAccessToken)&&this._skuToken&&n.params.push("sku="+this._skuToken),this._makeAPIURL(n,this._customAccessToken)},j.prototype.canonicalizeTileURL=function(t){var e=X(t);if(!e.path.match(/(^\/v4\/)/)||!e.path.match(/\.[\w]+$/))return t;var r="mapbox://tiles/";r+=e.path.replace("/v4/","");var n=e.params.filter(function(t){return !t.match(/^access_token=/)});return n.length&&(r+="?"+n.join("&")),r},j.prototype.canonicalizeTileset=function(t,e){if(!q(e))return t.tiles||[];for(var r=[],n=0,i=t.tiles;n<i.length;n+=1){var a=i[n],o=this.canonicalizeTileURL(a);r.push(o);}return r},j.prototype._makeAPIURL=function(t,e){var r="See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",n=X(F.API_URL);if(t.protocol=n.protocol,t.authority=n.authority,"/"!==n.path&&(t.path=""+n.path+t.path),!F.REQUIRE_ACCESS_TOKEN)return G(t);if(!(e=e||F.ACCESS_TOKEN))throw new Error("An API access token is required to use Mapbox GL. "+r);if("s"===e[0])throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). "+r);return t.params=t.params.filter(function(t){return -1===t.indexOf("access_token")}),t.params.push("access_token="+e),G(t)};var N=/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;function K(t){return N.test(t)}var Z=/^(\w+):\/\/([^\/?]*)(\/[^?]+)?\??(.+)?/;function X(t){var e=t.match(Z);if(!e)throw new Error("Unable to parse URL object");return {protocol:e[1],authority:e[2],path:e[3]||"/",params:e[4]?e[4].split("&"):[]}}function G(t){var e=t.params.length?"?"+t.params.join("&"):"";return t.protocol+"://"+t.authority+t.path+e}function J(t){if(!t)return null;var e,r=t.split(".");if(!r||3!==r.length)return null;try{return JSON.parse((e=r[1],decodeURIComponent(self.atob(e).split("").map(function(t){return "%"+("00"+t.charCodeAt(0).toString(16)).slice(-2)}).join(""))))}catch(t){return null}}var H=function(t){this.type=t,this.anonId=null,this.eventData={},this.queue=[],this.pendingRequest=null;};H.prototype.getStorageKey=function(t){var e,r=J(F.ACCESS_TOKEN),n="";return r&&r.u?(e=r.u,n=self.btoa(encodeURIComponent(e).replace(/%([0-9A-F]{2})/g,function(t,e){return String.fromCharCode(Number("0x"+e))}))):n=F.ACCESS_TOKEN||"",t?"mapbox.eventData."+t+":"+n:"mapbox.eventData:"+n},H.prototype.fetchEventData=function(){var t=z("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid");if(t)try{var n=self.localStorage.getItem(e);n&&(this.eventData=JSON.parse(n));var i=self.localStorage.getItem(r);i&&(this.anonId=i);}catch(t){w("Unable to read from LocalStorage");}},H.prototype.saveEventData=function(){var t=z("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid");if(t)try{self.localStorage.setItem(r,this.anonId),Object.keys(this.eventData).length>=1&&self.localStorage.setItem(e,JSON.stringify(this.eventData));}catch(t){w("Unable to write to LocalStorage");}},H.prototype.processRequests=function(t){},H.prototype.postEvent=function(t,e,r,n){var i=this;if(F.EVENTS_URL){var a=X(F.EVENTS_URL);a.params.push("access_token="+(n||F.ACCESS_TOKEN||""));var o={event:this.type,created:new Date(t).toISOString(),sdkIdentifier:"mapbox-gl-js",sdkVersion:"1.4.1",skuId:R,userId:this.anonId},s=e?c(o,e):o,u={url:G(a),headers:{"Content-Type":"text/plain"},body:JSON.stringify([s])};this.pendingRequest=vt(u,function(t){i.pendingRequest=null,r(t),i.saveEventData(),i.processRequests(n);});}},H.prototype.queueRequest=function(t,e){this.queue.push(t),this.processRequests(e);};var Y,$=function(t){function e(){t.call(this,"map.load"),this.success={},this.skuToken="";}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.postMapLoadEvent=function(t,e,r,n){this.skuToken=r,(F.EVENTS_URL&&n||F.ACCESS_TOKEN&&Array.isArray(t)&&t.some(function(t){return q(t)||K(t)}))&&this.queueRequest({id:e,timestamp:Date.now()},n);},e.prototype.processRequests=function(t){var e=this;if(!this.pendingRequest&&0!==this.queue.length){var r=this.queue.shift(),n=r.id,i=r.timestamp;n&&this.success[n]||(this.anonId||this.fetchEventData(),d(this.anonId)||(this.anonId=y()),this.postEvent(i,{skuToken:this.skuToken},function(t){t||n&&(e.success[n]=!0);},t));}},e}(H),W=new(function(t){function e(e){t.call(this,"appUserTurnstile"),this._customAccessToken=e;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.postTurnstileEvent=function(t,e){F.EVENTS_URL&&F.ACCESS_TOKEN&&Array.isArray(t)&&t.some(function(t){return q(t)||K(t)})&&this.queueRequest(Date.now(),e);},e.prototype.processRequests=function(t){var e=this;if(!this.pendingRequest&&0!==this.queue.length){this.anonId&&this.eventData.lastSuccess&&this.eventData.tokenU||this.fetchEventData();var r=J(F.ACCESS_TOKEN),n=r?r.u:F.ACCESS_TOKEN,i=n!==this.eventData.tokenU;d(this.anonId)||(this.anonId=y(),i=!0);var a=this.queue.shift();if(this.eventData.lastSuccess){var o=new Date(this.eventData.lastSuccess),s=new Date(a),u=(a-this.eventData.lastSuccess)/864e5;i=i||u>=1||u<-1||o.getDate()!==s.getDate();}else i=!0;if(!i)return this.processRequests();this.postEvent(a,{"enabled.telemetry":!1},function(t){t||(e.eventData.lastSuccess=a,e.eventData.tokenU=n);},t);}},e}(H)),Q=W.postTurnstileEvent.bind(W),tt=new $,et=tt.postMapLoadEvent.bind(tt),rt="mapbox-tiles",nt=500,it=50,at=42e4;function ot(t,e,r){if(self.caches){var n={status:e.status,statusText:e.statusText,headers:new self.Headers};e.headers.forEach(function(t,e){return n.headers.set(e,t)});var i=S(e.headers.get("Cache-Control")||"");if(!i["no-store"])i["max-age"]&&n.headers.set("Expires",new Date(r+1e3*i["max-age"]).toUTCString()),new Date(n.headers.get("Expires")).getTime()-r<at||function(t,e){if(void 0===Y)try{new Response(new ReadableStream),Y=!0;}catch(t){Y=!1;}Y?e(t.body):t.blob().then(e);}(e,function(e){var r=new self.Response(e,n);self.caches.open(rt).then(function(e){return e.put(st(t.url),r)}).catch(function(t){return w(t.message)});});}}function st(t){var e=t.indexOf("?");return e<0?t:t.slice(0,e)}function ut(t,e){if(!self.caches)return e(null);var r=st(t.url);self.caches.open(rt).then(function(t){t.match(r).catch(e).then(function(n){var i=function(t){if(!t)return !1;var e=new Date(t.headers.get("Expires")),r=S(t.headers.get("Cache-Control")||"");return e>Date.now()&&!r["no-cache"]}(n);t.delete(r),i&&t.put(r,n.clone()),e(null,n,i);});}).catch(e);}var lt=1/0;var pt={Unknown:"Unknown",Style:"Style",Source:"Source",Tile:"Tile",Glyphs:"Glyphs",SpriteImage:"SpriteImage",SpriteJSON:"SpriteJSON",Image:"Image"};"function"==typeof Object.freeze&&Object.freeze(pt);var ct=function(t){function e(e,r,n){401===r&&K(n)&&(e+=": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"),t.call(this,e),this.status=r,this.url=n,this.name=this.constructor.name,this.message=e;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.toString=function(){return this.name+": "+this.message+" ("+this.status+"): "+this.url},e}(Error);function ht(){return "undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope}var ft=ht()?function(){return self.worker&&self.worker.referrer}:function(){return ("blob:"===self.location.protocol?self.parent:self).location.href};function yt(t,e){var r,n=new self.AbortController,i=new self.Request(t.url,{method:t.method||"GET",body:t.body,credentials:t.credentials,headers:t.headers,referrer:ft(),signal:n.signal}),a=!1,o=!1,s=(r=i.url).indexOf("sku=")>0&&K(r);"json"===t.type&&i.headers.set("Accept","application/json");var u=function(r,n,a){if(!o){if(r&&"SecurityError"!==r.message&&w(r),n&&a)return l(n);var u=Date.now();self.fetch(i).then(function(r){if(r.ok){var n=s?r.clone():null;return l(r,n,u)}return e(new ct(r.statusText,r.status,t.url))}).catch(function(t){20!==t.code&&e(new Error(t.message));});}},l=function(r,n,s){("arrayBuffer"===t.type?r.arrayBuffer():"json"===t.type?r.json():r.text()).then(function(t){o||(n&&s&&ot(i,n,s),a=!0,e(null,t,r.headers.get("Cache-Control"),r.headers.get("Expires")));}).catch(function(t){return e(new Error(t.message))});};return s?ut(i,u):u(null,null),{cancel:function(){o=!0,a||n.abort();}}}var dt=function(t,e){if(r=t.url,!(/^file:/.test(r)||/^file:/.test(ft())&&!/^\w+:/.test(r))){if(self.fetch&&self.Request&&self.AbortController&&self.Request.prototype.hasOwnProperty("signal"))return yt(t,e);if(ht()&&self.worker&&self.worker.actor)return self.worker.actor.send("getResource",t,e)}var r;return function(t,e){var r=new self.XMLHttpRequest;for(var n in r.open(t.method||"GET",t.url,!0),"arrayBuffer"===t.type&&(r.responseType="arraybuffer"),t.headers)r.setRequestHeader(n,t.headers[n]);return "json"===t.type&&(r.responseType="text",r.setRequestHeader("Accept","application/json")),r.withCredentials="include"===t.credentials,r.onerror=function(){e(new Error(r.statusText));},r.onload=function(){if((r.status>=200&&r.status<300||0===r.status)&&null!==r.response){var n=r.response;if("json"===t.type)try{n=JSON.parse(r.response);}catch(t){return e(t)}e(null,n,r.getResponseHeader("Cache-Control"),r.getResponseHeader("Expires"));}else e(new ct(r.statusText,r.status,t.url));},r.send(t.body),{cancel:function(){return r.abort()}}}(t,e)},mt=function(t,e){return dt(c(t,{type:"arrayBuffer"}),e)},vt=function(t,e){return dt(c(t,{method:"POST"}),e)};var gt,xt;gt=[],xt=0;var bt=function(t,e){if(xt>=F.MAX_PARALLEL_IMAGE_REQUESTS){var r={requestParameters:t,callback:e,cancelled:!1,cancel:function(){this.cancelled=!0;}};return gt.push(r),r}xt++;var n=!1,i=function(){if(!n)for(n=!0,xt--;gt.length&&xt<F.MAX_PARALLEL_IMAGE_REQUESTS;){var t=gt.shift(),e=t.requestParameters,r=t.callback;t.cancelled||(t.cancel=bt(e,r).cancel);}},a=mt(t,function(t,r,n,a){if(i(),t)e(t);else if(r){var o=new self.Image,s=self.URL||self.webkitURL;o.onload=function(){e(null,o),s.revokeObjectURL(o.src);},o.onerror=function(){return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))};var u=new self.Blob([new Uint8Array(r)],{type:"image/png"});o.cacheControl=n,o.expires=a,o.src=r.byteLength?s.createObjectURL(u):"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";}});return {cancel:function(){a.cancel(),i();}}};function _t(t,e,r){r[t]&&-1!==r[t].indexOf(e)||(r[t]=r[t]||[],r[t].push(e));}function wt(t,e,r){if(r&&r[t]){var n=r[t].indexOf(e);-1!==n&&r[t].splice(n,1);}}var At=function(t,e){void 0===e&&(e={}),c(this,e),this.type=t;},kt=function(t){function e(e,r){void 0===r&&(r={}),t.call(this,"error",c({error:e},r));}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(At),St=function(){};St.prototype.on=function(t,e){return this._listeners=this._listeners||{},_t(t,e,this._listeners),this},St.prototype.off=function(t,e){return wt(t,e,this._listeners),wt(t,e,this._oneTimeListeners),this},St.prototype.once=function(t,e){return this._oneTimeListeners=this._oneTimeListeners||{},_t(t,e,this._oneTimeListeners),this},St.prototype.fire=function(t,e){"string"==typeof t&&(t=new At(t,e||{}));var r=t.type;if(this.listens(r)){t.target=this;for(var n=0,i=this._listeners&&this._listeners[r]?this._listeners[r].slice():[];n<i.length;n+=1){i[n].call(this,t);}for(var a=0,o=this._oneTimeListeners&&this._oneTimeListeners[r]?this._oneTimeListeners[r].slice():[];a<o.length;a+=1){var s=o[a];wt(r,s,this._oneTimeListeners),s.call(this,t);}var u=this._eventedParent;u&&(c(t,"function"==typeof this._eventedParentData?this._eventedParentData():this._eventedParentData),u.fire(t));}else t instanceof kt&&console.error(t.error);return this},St.prototype.listens=function(t){return this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t)},St.prototype.setEventedParent=function(t,e){return this._eventedParent=t,this._eventedParentData=e,this};var zt={$version:8,$root:{version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},light:{type:"light"},sources:{required:!0,type:"sources"},sprite:{type:"string"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},sources:{"*":{type:"source"}},source:["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],source_vector:{type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},"*":{type:"*"}},source_raster:{type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},"*":{type:"*"}},source_raster_dem:{type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{}},default:"mapbox"},"*":{type:"*"}},source_geojson:{type:{required:!0,type:"enum",values:{geojson:{}}},data:{type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1}},source_video:{type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},source_image:{type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},layer:{id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},layout:["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background"],layout_background:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_fill:{"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_circle:{"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_heatmap:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:{"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_symbol:{"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"image",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_raster:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_hillshade:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},filter:{type:"array",value:"*"},filter_operator:{type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{}}},geometry_type:{type:"enum",values:{Point:{},LineString:{},Polygon:{}}},function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:{type:"array",minimum:0,maximum:22,value:["number","color"],length:2},expression:{type:"array",value:"*",minimum:1},expression_name:{type:"enum",values:{let:{group:"Variable binding"},var:{group:"Variable binding"},literal:{group:"Types"},array:{group:"Types"},at:{group:"Lookup"},case:{group:"Decision"},match:{group:"Decision"},coalesce:{group:"Decision"},step:{group:"Ramps, scales, curves"},interpolate:{group:"Ramps, scales, curves"},"interpolate-hcl":{group:"Ramps, scales, curves"},"interpolate-lab":{group:"Ramps, scales, curves"},ln2:{group:"Math"},pi:{group:"Math"},e:{group:"Math"},typeof:{group:"Types"},string:{group:"Types"},number:{group:"Types"},boolean:{group:"Types"},object:{group:"Types"},collator:{group:"Types"},format:{group:"Types"},image:{group:"Types"},"number-format":{group:"Types"},"to-string":{group:"Types"},"to-number":{group:"Types"},"to-boolean":{group:"Types"},"to-rgba":{group:"Color"},"to-color":{group:"Types"},rgb:{group:"Color"},rgba:{group:"Color"},get:{group:"Lookup"},has:{group:"Lookup"},length:{group:"Lookup"},properties:{group:"Feature data"},"feature-state":{group:"Feature data"},"geometry-type":{group:"Feature data"},id:{group:"Feature data"},zoom:{group:"Zoom"},"heatmap-density":{group:"Heatmap"},"line-progress":{group:"Feature data"},accumulated:{group:"Feature data"},"+":{group:"Math"},"*":{group:"Math"},"-":{group:"Math"},"/":{group:"Math"},"%":{group:"Math"},"^":{group:"Math"},sqrt:{group:"Math"},log10:{group:"Math"},ln:{group:"Math"},log2:{group:"Math"},sin:{group:"Math"},cos:{group:"Math"},tan:{group:"Math"},asin:{group:"Math"},acos:{group:"Math"},atan:{group:"Math"},min:{group:"Math"},max:{group:"Math"},round:{group:"Math"},abs:{group:"Math"},ceil:{group:"Math"},floor:{group:"Math"},"==":{group:"Decision"},"!=":{group:"Decision"},">":{group:"Decision"},"<":{group:"Decision"},">=":{group:"Decision"},"<=":{group:"Decision"},all:{group:"Decision"},any:{group:"Decision"},"!":{group:"Decision"},"is-supported-script":{group:"String"},upcase:{group:"String"},downcase:{group:"String"},concat:{group:"String"},"resolved-locale":{group:"String"}}},light:{anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},paint:["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background"],paint_fill:{"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"image",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"image",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:{"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"image",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},paint_circle:{"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},paint_heatmap:{"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_symbol:{"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_raster:{"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_hillshade:{"hillshade-illumination-direction":{type:"number",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"color",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_background:{"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"image",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},transition:{duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}}},It=function(t,e,r,n){this.message=(t?t+": ":"")+r,n&&(this.identifier=n),null!=e&&e.__line__&&(this.line=e.__line__);};function Ct(t){var e=t.key,r=t.value;return r?[new It(e,r,"constants have been deprecated as of v8")]:[]}function Bt(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];for(var n=0,i=e;n<i.length;n+=1){var a=i[n];for(var o in a)t[o]=a[o];}return t}function Et(t){return t instanceof Number||t instanceof String||t instanceof Boolean}function Pt(t){return Et(t)?t.valueOf():t}function Mt(t){if(Array.isArray(t))return t.map(Mt);if(t instanceof Object&&!Et(t)){var e={};for(var r in t)e[r]=Mt(t[r]);return e}return Pt(t)}var Tt=function(t){function e(e,r){t.call(this,r),this.message=r,this.key=e;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Error),Vt=function(t,e){void 0===e&&(e=[]),this.parent=t,this.bindings={};for(var r=0,n=e;r<n.length;r+=1){var i=n[r],a=i[0],o=i[1];this.bindings[a]=o;}};Vt.prototype.concat=function(t){return new Vt(this,t)},Vt.prototype.get=function(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error(t+" not found in scope.")},Vt.prototype.has=function(t){return !!this.bindings[t]||!!this.parent&&this.parent.has(t)};var Ft={kind:"null"},Ot={kind:"number"},Lt={kind:"string"},Dt={kind:"boolean"},Ut={kind:"color"},Rt={kind:"object"},jt={kind:"value"},qt={kind:"collator"},Nt={kind:"formatted"},Kt={kind:"image"};function Zt(t,e){return {kind:"array",itemType:t,N:e}}function Xt(t){if("array"===t.kind){var e=Xt(t.itemType);return "number"==typeof t.N?"array<"+e+", "+t.N+">":"value"===t.itemType.kind?"array":"array<"+e+">"}return t.kind}var Gt=[Ft,Ot,Lt,Dt,Ut,Nt,Rt,Zt(jt),Kt];function Jt(t,e){if("error"===e.kind)return null;if("array"===t.kind){if("array"===e.kind&&(0===e.N&&"value"===e.itemType.kind||!Jt(t.itemType,e.itemType))&&("number"!=typeof t.N||t.N===e.N))return null}else{if(t.kind===e.kind)return null;if("value"===t.kind)for(var r=0,n=Gt;r<n.length;r+=1){if(!Jt(n[r],e))return null}}return "Expected "+Xt(t)+" but found "+Xt(e)+" instead."}var Ht=e(function(t,e){var r={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function n(t){return (t=Math.round(t))<0?0:t>255?255:t}function i(t){return t<0?0:t>1?1:t}function a(t){return "%"===t[t.length-1]?n(parseFloat(t)/100*255):n(parseInt(t))}function o(t){return "%"===t[t.length-1]?i(parseFloat(t)/100):i(parseFloat(t))}function s(t,e,r){return r<0?r+=1:r>1&&(r-=1),6*r<1?t+(e-t)*r*6:2*r<1?e:3*r<2?t+(e-t)*(2/3-r)*6:t}try{e.parseCSSColor=function(t){var e,i=t.replace(/ /g,"").toLowerCase();if(i in r)return r[i].slice();if("#"===i[0])return 4===i.length?(e=parseInt(i.substr(1),16))>=0&&e<=4095?[(3840&e)>>4|(3840&e)>>8,240&e|(240&e)>>4,15&e|(15&e)<<4,1]:null:7===i.length&&(e=parseInt(i.substr(1),16))>=0&&e<=16777215?[(16711680&e)>>16,(65280&e)>>8,255&e,1]:null;var u=i.indexOf("("),l=i.indexOf(")");if(-1!==u&&l+1===i.length){var p=i.substr(0,u),c=i.substr(u+1,l-(u+1)).split(","),h=1;switch(p){case"rgba":if(4!==c.length)return null;h=o(c.pop());case"rgb":return 3!==c.length?null:[a(c[0]),a(c[1]),a(c[2]),h];case"hsla":if(4!==c.length)return null;h=o(c.pop());case"hsl":if(3!==c.length)return null;var f=(parseFloat(c[0])%360+360)%360/360,y=o(c[1]),d=o(c[2]),m=d<=.5?d*(y+1):d+y-d*y,v=2*d-m;return [n(255*s(v,m,f+1/3)),n(255*s(v,m,f)),n(255*s(v,m,f-1/3)),h];default:return null}}return null};}catch(t){}}).parseCSSColor,Yt=function(t,e,r,n){void 0===n&&(n=1),this.r=t,this.g=e,this.b=r,this.a=n;};Yt.parse=function(t){if(t){if(t instanceof Yt)return t;if("string"==typeof t){var e=Ht(t);if(e)return new Yt(e[0]/255*e[3],e[1]/255*e[3],e[2]/255*e[3],e[3])}}},Yt.prototype.toString=function(){var t=this.toArray(),e=t[0],r=t[1],n=t[2],i=t[3];return "rgba("+Math.round(e)+","+Math.round(r)+","+Math.round(n)+","+i+")"},Yt.prototype.toArray=function(){var t=this.r,e=this.g,r=this.b,n=this.a;return 0===n?[0,0,0,0]:[255*t/n,255*e/n,255*r/n,n]},Yt.black=new Yt(0,0,0,1),Yt.white=new Yt(1,1,1,1),Yt.transparent=new Yt(0,0,0,0),Yt.red=new Yt(1,0,0,1);var $t=function(t,e,r){this.sensitivity=t?e?"variant":"case":e?"accent":"base",this.locale=r,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"});};$t.prototype.compare=function(t,e){return this.collator.compare(t,e)},$t.prototype.resolvedLocale=function(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale};var Wt=function(t,e,r,n){this.text=t,this.scale=e,this.fontStack=r,this.textColor=n;},Qt=function(t){this.sections=t;};Qt.fromString=function(t){return new Qt([new Wt(t,null,null,null)])},Qt.prototype.toString=function(){return this.sections.map(function(t){return t.text}).join("")},Qt.prototype.serialize=function(){for(var t=["format"],e=0,r=this.sections;e<r.length;e+=1){var n=r[e];t.push(n.text);var i={};n.fontStack&&(i["text-font"]=["literal",n.fontStack.split(",")]),n.scale&&(i["font-scale"]=n.scale),n.textColor&&(i["text-color"]=["rgba"].concat(n.textColor.toArray())),t.push(i);}return t};var te=function(t){this.name=t.name,this.available=t.available;};function ee(t,e,r,n){return "number"==typeof t&&t>=0&&t<=255&&"number"==typeof e&&e>=0&&e<=255&&"number"==typeof r&&r>=0&&r<=255?void 0===n||"number"==typeof n&&n>=0&&n<=1?null:"Invalid rgba value ["+[t,e,r,n].join(", ")+"]: 'a' must be between 0 and 1.":"Invalid rgba value ["+("number"==typeof n?[t,e,r,n]:[t,e,r]).join(", ")+"]: 'r', 'g', and 'b' must be between 0 and 255."}function re(t){if(null===t)return Ft;if("string"==typeof t)return Lt;if("boolean"==typeof t)return Dt;if("number"==typeof t)return Ot;if(t instanceof Yt)return Ut;if(t instanceof $t)return qt;if(t instanceof Qt)return Nt;if(t instanceof te)return Kt;if(Array.isArray(t)){for(var e,r=t.length,n=0,i=t;n<i.length;n+=1){var a=re(i[n]);if(e){if(e===a)continue;e=jt;break}e=a;}return Zt(e||jt,r)}return Rt}function ne(t){var e=typeof t;return null===t?"":"string"===e||"number"===e||"boolean"===e?String(t):t instanceof Yt||t instanceof Qt||t instanceof te?t.toString():JSON.stringify(t)}te.prototype.toString=function(){return this.name},te.fromString=function(t){return new te(t)},te.prototype.serialize=function(){return ["image",this.name]};var ie=function(t,e){this.type=t,this.value=e;};ie.parse=function(t,e){if(2!==t.length)return e.error("'literal' expression requires exactly one argument, but found "+(t.length-1)+" instead.");if(!function t(e){if(null===e)return !0;if("string"==typeof e)return !0;if("boolean"==typeof e)return !0;if("number"==typeof e)return !0;if(e instanceof Yt)return !0;if(e instanceof $t)return !0;if(e instanceof Qt)return !0;if(e instanceof te)return !0;if(Array.isArray(e)){for(var r=0,n=e;r<n.length;r+=1)if(!t(n[r]))return !1;return !0}if("object"==typeof e){for(var i in e)if(!t(e[i]))return !1;return !0}return !1}(t[1]))return e.error("invalid value");var r=t[1],n=re(r),i=e.expectedType;return "array"!==n.kind||0!==n.N||!i||"array"!==i.kind||"number"==typeof i.N&&0!==i.N||(n=i),new ie(n,r)},ie.prototype.evaluate=function(){return this.value},ie.prototype.eachChild=function(){},ie.prototype.possibleOutputs=function(){return [this.value]},ie.prototype.serialize=function(){return "array"===this.type.kind||"object"===this.type.kind?["literal",this.value]:this.value instanceof Yt?["rgba"].concat(this.value.toArray()):this.value instanceof Qt?this.value.serialize():this.value};var ae=function(t){this.name="ExpressionEvaluationError",this.message=t;};ae.prototype.toJSON=function(){return this.message};var oe={string:Lt,number:Ot,boolean:Dt,object:Rt},se=function(t,e){this.type=t,this.args=e;};se.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r,n=1,i=t[0];if("array"===i){var a,o;if(t.length>2){var s=t[1];if("string"!=typeof s||!(s in oe)||"object"===s)return e.error('The item type argument of "array" must be one of string, number, boolean',1);a=oe[s],n++;}else a=jt;if(t.length>3){if(null!==t[2]&&("number"!=typeof t[2]||t[2]<0||t[2]!==Math.floor(t[2])))return e.error('The length argument to "array" must be a positive integer literal',2);o=t[2],n++;}r=Zt(a,o);}else r=oe[i];for(var u=[];n<t.length;n++){var l=e.parse(t[n],n,jt);if(!l)return null;u.push(l);}return new se(r,u)},se.prototype.evaluate=function(t){for(var e=0;e<this.args.length;e++){var r=this.args[e].evaluate(t);if(!Jt(this.type,re(r)))return r;if(e===this.args.length-1)throw new ae("Expected value to be of type "+Xt(this.type)+", but found "+Xt(re(r))+" instead.")}return null},se.prototype.eachChild=function(t){this.args.forEach(t);},se.prototype.possibleOutputs=function(){var t;return (t=[]).concat.apply(t,this.args.map(function(t){return t.possibleOutputs()}))},se.prototype.serialize=function(){var t=this.type,e=[t.kind];if("array"===t.kind){var r=t.itemType;if("string"===r.kind||"number"===r.kind||"boolean"===r.kind){e.push(r.kind);var n=t.N;("number"==typeof n||this.args.length>1)&&e.push(n);}}return e.concat(this.args.map(function(t){return t.serialize()}))};var ue=function(t){this.type=Nt,this.sections=t;};ue.parse=function(t,e){if(t.length<3)return e.error("Expected at least two arguments.");if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");for(var r=[],n=1;n<t.length-1;n+=2){var i=e.parse(t[n],1,jt);if(!i)return null;var a=i.type.kind;if("string"!==a&&"value"!==a&&"null"!==a)return e.error("Formatted text type must be 'string', 'value', or 'null'.");var o=t[n+1];if("object"!=typeof o||Array.isArray(o))return e.error("Format options argument must be an object.");var s=null;if(o["font-scale"]&&!(s=e.parse(o["font-scale"],1,Ot)))return null;var u=null;if(o["text-font"]&&!(u=e.parse(o["text-font"],1,Zt(Lt))))return null;var l=null;if(o["text-color"]&&!(l=e.parse(o["text-color"],1,Ut)))return null;r.push({text:i,scale:s,font:u,textColor:l});}return new ue(r)},ue.prototype.evaluate=function(t){return new Qt(this.sections.map(function(e){return new Wt(ne(e.text.evaluate(t)),e.scale?e.scale.evaluate(t):null,e.font?e.font.evaluate(t).join(","):null,e.textColor?e.textColor.evaluate(t):null)}))},ue.prototype.eachChild=function(t){for(var e=0,r=this.sections;e<r.length;e+=1){var n=r[e];t(n.text),n.scale&&t(n.scale),n.font&&t(n.font),n.textColor&&t(n.textColor);}},ue.prototype.possibleOutputs=function(){return [void 0]},ue.prototype.serialize=function(){for(var t=["format"],e=0,r=this.sections;e<r.length;e+=1){var n=r[e];t.push(n.text.serialize());var i={};n.scale&&(i["font-scale"]=n.scale.serialize()),n.font&&(i["text-font"]=n.font.serialize()),n.textColor&&(i["text-color"]=n.textColor.serialize()),t.push(i);}return t};var le=function(t){this.type=Kt,this.input=t;};le.parse=function(t,e){if(2!==t.length)return e.error("Expected two arguments.");var r=e.parse(t[1],1,Lt);return r?new le(r):e.error("No image name provided.")},le.prototype.evaluate=function(t){var e=this.input.evaluate(t),r=!1;return t.availableImages&&t.availableImages.indexOf(e)>-1&&(r=!0),{name:e,available:r}},le.prototype.eachChild=function(t){t(this.input);},le.prototype.possibleOutputs=function(){return [void 0]},le.prototype.serialize=function(){return ["image",this.input.serialize()]};var pe={"to-boolean":Dt,"to-color":Ut,"to-number":Ot,"to-string":Lt},ce=function(t,e){this.type=t,this.args=e;};ce.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r=t[0];if(("to-boolean"===r||"to-string"===r)&&2!==t.length)return e.error("Expected one argument.");for(var n=pe[r],i=[],a=1;a<t.length;a++){var o=e.parse(t[a],a,jt);if(!o)return null;i.push(o);}return new ce(n,i)},ce.prototype.evaluate=function(t){if("boolean"===this.type.kind)return Boolean(this.args[0].evaluate(t));if("color"===this.type.kind){for(var e,r,n=0,i=this.args;n<i.length;n+=1){if(r=null,(e=i[n].evaluate(t))instanceof Yt)return e;if("string"==typeof e){var a=t.parseColor(e);if(a)return a}else if(Array.isArray(e)&&!(r=e.length<3||e.length>4?"Invalid rbga value "+JSON.stringify(e)+": expected an array containing either three or four numeric values.":ee(e[0],e[1],e[2],e[3])))return new Yt(e[0]/255,e[1]/255,e[2]/255,e[3])}throw new ae(r||"Could not parse color from value '"+("string"==typeof e?e:String(JSON.stringify(e)))+"'")}if("number"===this.type.kind){for(var o=null,s=0,u=this.args;s<u.length;s+=1){if(null===(o=u[s].evaluate(t)))return 0;var l=Number(o);if(!isNaN(l))return l}throw new ae("Could not convert "+JSON.stringify(o)+" to number.")}if("formatted"===this.type.kind)return Qt.fromString(ne(this.args[0].evaluate(t)));if("image"===this.type.kind){var p=this.args[0].evaluate(t);return "string"==typeof p?te.fromString({name:p,available:!1}):p}return ne(this.args[0].evaluate(t))},ce.prototype.eachChild=function(t){this.args.forEach(t);},ce.prototype.possibleOutputs=function(){var t;return (t=[]).concat.apply(t,this.args.map(function(t){return t.possibleOutputs()}))},ce.prototype.serialize=function(){if("formatted"===this.type.kind)return new ue([{text:this.args[0],scale:null,font:null,textColor:null}]).serialize();if("image"===this.type.kind)return new le(this.args[0]).serialize();var t=["to-"+this.type.kind];return this.eachChild(function(e){t.push(e.serialize());}),t};var he=["Unknown","Point","LineString","Polygon"],fe=function(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null;};fe.prototype.id=function(){return this.feature&&"id"in this.feature?this.feature.id:null},fe.prototype.geometryType=function(){return this.feature?"number"==typeof this.feature.type?he[this.feature.type]:this.feature.type:null},fe.prototype.properties=function(){return this.feature&&this.feature.properties||{}},fe.prototype.parseColor=function(t){var e=this._parseColorCache[t];return e||(e=this._parseColorCache[t]=Yt.parse(t)),e};var ye=function(t,e,r,n){this.name=t,this.type=e,this._evaluate=r,this.args=n;};ye.prototype.evaluate=function(t){return this._evaluate(t,this.args)},ye.prototype.eachChild=function(t){this.args.forEach(t);},ye.prototype.possibleOutputs=function(){return [void 0]},ye.prototype.serialize=function(){return [this.name].concat(this.args.map(function(t){return t.serialize()}))},ye.parse=function(t,e){var r,n=t[0],i=ye.definitions[n];if(!i)return e.error('Unknown expression "'+n+'". If you wanted a literal array, use ["literal", [...]].',0);for(var a=Array.isArray(i)?i[0]:i.type,o=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=o.filter(function(e){var r=e[0];return !Array.isArray(r)||r.length===t.length-1}),u=null,l=0,p=s;l<p.length;l+=1){var c=p[l],h=c[0],f=c[1];u=new be(e.registry,e.path,null,e.scope);for(var y=[],d=!1,m=1;m<t.length;m++){var v=t[m],g=Array.isArray(h)?h[m-1]:h.type,x=u.parse(v,1+y.length,g);if(!x){d=!0;break}y.push(x);}if(!d)if(Array.isArray(h)&&h.length!==y.length)u.error("Expected "+h.length+" arguments, but found "+y.length+" instead.");else{for(var b=0;b<y.length;b++){var _=Array.isArray(h)?h[b]:h.type,w=y[b];u.concat(b+1).checkSubtype(_,w.type);}if(0===u.errors.length)return new ye(n,a,f,y)}}if(1===s.length)(r=e.errors).push.apply(r,u.errors);else{for(var A=(s.length?s:o).map(function(t){var e,r=t[0];return e=r,Array.isArray(e)?"("+e.map(Xt).join(", ")+")":"("+Xt(e.type)+"...)"}).join(" | "),k=[],S=1;S<t.length;S++){var z=e.parse(t[S],1+k.length);if(!z)return null;k.push(Xt(z.type));}e.error("Expected arguments of type "+A+", but found ("+k.join(", ")+") instead.");}return null},ye.register=function(t,e){for(var r in ye.definitions=e,e)t[r]=ye;};var de=function(t,e,r){this.type=qt,this.locale=r,this.caseSensitive=t,this.diacriticSensitive=e;};function me(t){if(t instanceof ye){if("get"===t.name&&1===t.args.length)return !1;if("feature-state"===t.name)return !1;if("has"===t.name&&1===t.args.length)return !1;if("properties"===t.name||"geometry-type"===t.name||"id"===t.name)return !1;if(/^filter-/.test(t.name))return !1}var e=!0;return t.eachChild(function(t){e&&!me(t)&&(e=!1);}),e}function ve(t){if(t instanceof ye&&"feature-state"===t.name)return !1;var e=!0;return t.eachChild(function(t){e&&!ve(t)&&(e=!1);}),e}function ge(t,e){if(t instanceof ye&&e.indexOf(t.name)>=0)return !1;var r=!0;return t.eachChild(function(t){r&&!ge(t,e)&&(r=!1);}),r}de.parse=function(t,e){if(2!==t.length)return e.error("Expected one argument.");var r=t[1];if("object"!=typeof r||Array.isArray(r))return e.error("Collator options argument must be an object.");var n=e.parse(void 0!==r["case-sensitive"]&&r["case-sensitive"],1,Dt);if(!n)return null;var i=e.parse(void 0!==r["diacritic-sensitive"]&&r["diacritic-sensitive"],1,Dt);if(!i)return null;var a=null;return r.locale&&!(a=e.parse(r.locale,1,Lt))?null:new de(n,i,a)},de.prototype.evaluate=function(t){return new $t(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)},de.prototype.eachChild=function(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale);},de.prototype.possibleOutputs=function(){return [void 0]},de.prototype.serialize=function(){var t={};return t["case-sensitive"]=this.caseSensitive.serialize(),t["diacritic-sensitive"]=this.diacriticSensitive.serialize(),this.locale&&(t.locale=this.locale.serialize()),["collator",t]};var xe=function(t,e){this.type=e.type,this.name=t,this.boundExpression=e;};xe.parse=function(t,e){if(2!==t.length||"string"!=typeof t[1])return e.error("'var' expression requires exactly one string literal argument.");var r=t[1];return e.scope.has(r)?new xe(r,e.scope.get(r)):e.error('Unknown variable "'+r+'". Make sure "'+r+'" has been bound in an enclosing "let" expression before using it.',1)},xe.prototype.evaluate=function(t){return this.boundExpression.evaluate(t)},xe.prototype.eachChild=function(){},xe.prototype.possibleOutputs=function(){return [void 0]},xe.prototype.serialize=function(){return ["var",this.name]};var be=function(t,e,r,n,i){void 0===e&&(e=[]),void 0===n&&(n=new Vt),void 0===i&&(i=[]),this.registry=t,this.path=e,this.key=e.map(function(t){return "["+t+"]"}).join(""),this.scope=n,this.errors=i,this.expectedType=r;};function _e(t,e){for(var r,n,i=t.length-1,a=0,o=i,s=0;a<=o;)if(r=t[s=Math.floor((a+o)/2)],n=t[s+1],r<=e){if(s===i||e<n)return s;a=s+1;}else{if(!(r>e))throw new ae("Input is not a number.");o=s-1;}return 0}be.prototype.parse=function(t,e,r,n,i){return void 0===i&&(i={}),e?this.concat(e,r,n)._parse(t,i):this._parse(t,i)},be.prototype._parse=function(t,e){function r(t,e,r){return "assert"===r?new se(e,[t]):"coerce"===r?new ce(e,[t]):t}if(null!==t&&"string"!=typeof t&&"boolean"!=typeof t&&"number"!=typeof t||(t=["literal",t]),Array.isArray(t)){if(0===t.length)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');var n=t[0];if("string"!=typeof n)return this.error("Expression name must be a string, but found "+typeof n+' instead. If you wanted a literal array, use ["literal", [...]].',0),null;var i=this.registry[n];if(i){var a=i.parse(t,this);if(!a)return null;if(this.expectedType){var o=this.expectedType,s=a.type;if("string"!==o.kind&&"number"!==o.kind&&"boolean"!==o.kind&&"object"!==o.kind&&"array"!==o.kind||"value"!==s.kind)if("color"!==o.kind&&"formatted"!==o.kind&&"image"!==o.kind||"value"!==s.kind&&"string"!==s.kind){if(this.checkSubtype(o,s))return null}else a=r(a,o,e.typeAnnotation||"coerce");else a=r(a,o,e.typeAnnotation||"assert");}if(!(a instanceof ie)&&"image"!==a.type.kind&&function t(e){if(e instanceof xe)return t(e.boundExpression);if(e instanceof ye&&"error"===e.name)return !1;if(e instanceof de)return !1;var r=e instanceof ce||e instanceof se;var n=!0;e.eachChild(function(e){n=r?n&&t(e):n&&e instanceof ie;});if(!n)return !1;return me(e)&&ge(e,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"])}(a)){var u=new fe;try{a=new ie(a.type,a.evaluate(u));}catch(t){return this.error(t.message),null}}return a}return this.error('Unknown expression "'+n+'". If you wanted a literal array, use ["literal", [...]].',0)}return void 0===t?this.error("'undefined' value invalid. Use null instead."):"object"==typeof t?this.error('Bare objects invalid. Use ["literal", {...}] instead.'):this.error("Expected an array, but found "+typeof t+" instead.")},be.prototype.concat=function(t,e,r){var n="number"==typeof t?this.path.concat(t):this.path,i=r?this.scope.concat(r):this.scope;return new be(this.registry,n,e||null,i,this.errors)},be.prototype.error=function(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];var n=""+this.key+e.map(function(t){return "["+t+"]"}).join("");this.errors.push(new Tt(n,t));},be.prototype.checkSubtype=function(t,e){var r=Jt(t,e);return r&&this.error(r),r};var we=function(t,e,r){this.type=t,this.input=e,this.labels=[],this.outputs=[];for(var n=0,i=r;n<i.length;n+=1){var a=i[n],o=a[0],s=a[1];this.labels.push(o),this.outputs.push(s);}};function Ae(t,e,r){return t*(1-r)+e*r}we.parse=function(t,e){if(t.length-1<4)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");var r=e.parse(t[1],1,Ot);if(!r)return null;var n=[],i=null;e.expectedType&&"value"!==e.expectedType.kind&&(i=e.expectedType);for(var a=1;a<t.length;a+=2){var o=1===a?-1/0:t[a],s=t[a+1],u=a,l=a+1;if("number"!=typeof o)return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',u);if(n.length&&n[n.length-1][0]>=o)return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',u);var p=e.parse(s,l,i);if(!p)return null;i=i||p.type,n.push([o,p]);}return new we(i,r,n)},we.prototype.evaluate=function(t){var e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);var n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);var i=e.length;return n>=e[i-1]?r[i-1].evaluate(t):r[_e(e,n)].evaluate(t)},we.prototype.eachChild=function(t){t(this.input);for(var e=0,r=this.outputs;e<r.length;e+=1){t(r[e]);}},we.prototype.possibleOutputs=function(){var t;return (t=[]).concat.apply(t,this.outputs.map(function(t){return t.possibleOutputs()}))},we.prototype.serialize=function(){for(var t=["step",this.input.serialize()],e=0;e<this.labels.length;e++)e>0&&t.push(this.labels[e]),t.push(this.outputs[e].serialize());return t};var ke=Object.freeze({number:Ae,color:function(t,e,r){return new Yt(Ae(t.r,e.r,r),Ae(t.g,e.g,r),Ae(t.b,e.b,r),Ae(t.a,e.a,r))},array:function(t,e,r){return t.map(function(t,n){return Ae(t,e[n],r)})}}),Se=.95047,ze=1,Ie=1.08883,Ce=4/29,Be=6/29,Ee=3*Be*Be,Pe=Be*Be*Be,Me=Math.PI/180,Te=180/Math.PI;function Ve(t){return t>Pe?Math.pow(t,1/3):t/Ee+Ce}function Fe(t){return t>Be?t*t*t:Ee*(t-Ce)}function Oe(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function Le(t){return (t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function De(t){var e=Le(t.r),r=Le(t.g),n=Le(t.b),i=Ve((.4124564*e+.3575761*r+.1804375*n)/Se),a=Ve((.2126729*e+.7151522*r+.072175*n)/ze);return {l:116*a-16,a:500*(i-a),b:200*(a-Ve((.0193339*e+.119192*r+.9503041*n)/Ie)),alpha:t.a}}function Ue(t){var e=(t.l+16)/116,r=isNaN(t.a)?e:e+t.a/500,n=isNaN(t.b)?e:e-t.b/200;return e=ze*Fe(e),r=Se*Fe(r),n=Ie*Fe(n),new Yt(Oe(3.2404542*r-1.5371385*e-.4985314*n),Oe(-.969266*r+1.8760108*e+.041556*n),Oe(.0556434*r-.2040259*e+1.0572252*n),t.alpha)}function Re(t,e,r){var n=e-t;return t+r*(n>180||n<-180?n-360*Math.round(n/360):n)}var je={forward:De,reverse:Ue,interpolate:function(t,e,r){return {l:Ae(t.l,e.l,r),a:Ae(t.a,e.a,r),b:Ae(t.b,e.b,r),alpha:Ae(t.alpha,e.alpha,r)}}},qe={forward:function(t){var e=De(t),r=e.l,n=e.a,i=e.b,a=Math.atan2(i,n)*Te;return {h:a<0?a+360:a,c:Math.sqrt(n*n+i*i),l:r,alpha:t.a}},reverse:function(t){var e=t.h*Me,r=t.c;return Ue({l:t.l,a:Math.cos(e)*r,b:Math.sin(e)*r,alpha:t.alpha})},interpolate:function(t,e,r){return {h:Re(t.h,e.h,r),c:Ae(t.c,e.c,r),l:Ae(t.l,e.l,r),alpha:Ae(t.alpha,e.alpha,r)}}},Ne=Object.freeze({lab:je,hcl:qe}),Ke=function(t,e,r,n,i){this.type=t,this.operator=e,this.interpolation=r,this.input=n,this.labels=[],this.outputs=[];for(var a=0,o=i;a<o.length;a+=1){var s=o[a],u=s[0],l=s[1];this.labels.push(u),this.outputs.push(l);}};function Ze(t,e,r,n){var i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}Ke.interpolationFactor=function(t,e,n,i){var a=0;if("exponential"===t.name)a=Ze(e,t.base,n,i);else if("linear"===t.name)a=Ze(e,1,n,i);else if("cubic-bezier"===t.name){var o=t.controlPoints;a=new r(o[0],o[1],o[2],o[3]).solve(Ze(e,1,n,i));}return a},Ke.parse=function(t,e){var r=t[0],n=t[1],i=t[2],a=t.slice(3);if(!Array.isArray(n)||0===n.length)return e.error("Expected an interpolation type expression.",1);if("linear"===n[0])n={name:"linear"};else if("exponential"===n[0]){var o=n[1];if("number"!=typeof o)return e.error("Exponential interpolation requires a numeric base.",1,1);n={name:"exponential",base:o};}else{if("cubic-bezier"!==n[0])return e.error("Unknown interpolation type "+String(n[0]),1,0);var s=n.slice(1);if(4!==s.length||s.some(function(t){return "number"!=typeof t||t<0||t>1}))return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);n={name:"cubic-bezier",controlPoints:s};}if(t.length-1<4)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");if(!(i=e.parse(i,2,Ot)))return null;var u=[],l=null;"interpolate-hcl"===r||"interpolate-lab"===r?l=Ut:e.expectedType&&"value"!==e.expectedType.kind&&(l=e.expectedType);for(var p=0;p<a.length;p+=2){var c=a[p],h=a[p+1],f=p+3,y=p+4;if("number"!=typeof c)return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',f);if(u.length&&u[u.length-1][0]>=c)return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',f);var d=e.parse(h,y,l);if(!d)return null;l=l||d.type,u.push([c,d]);}return "number"===l.kind||"color"===l.kind||"array"===l.kind&&"number"===l.itemType.kind&&"number"==typeof l.N?new Ke(l,r,n,i,u):e.error("Type "+Xt(l)+" is not interpolatable.")},Ke.prototype.evaluate=function(t){var e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);var n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);var i=e.length;if(n>=e[i-1])return r[i-1].evaluate(t);var a=_e(e,n),o=e[a],s=e[a+1],u=Ke.interpolationFactor(this.interpolation,n,o,s),l=r[a].evaluate(t),p=r[a+1].evaluate(t);return "interpolate"===this.operator?ke[this.type.kind.toLowerCase()](l,p,u):"interpolate-hcl"===this.operator?qe.reverse(qe.interpolate(qe.forward(l),qe.forward(p),u)):je.reverse(je.interpolate(je.forward(l),je.forward(p),u))},Ke.prototype.eachChild=function(t){t(this.input);for(var e=0,r=this.outputs;e<r.length;e+=1){t(r[e]);}},Ke.prototype.possibleOutputs=function(){var t;return (t=[]).concat.apply(t,this.outputs.map(function(t){return t.possibleOutputs()}))},Ke.prototype.serialize=function(){var t;t="linear"===this.interpolation.name?["linear"]:"exponential"===this.interpolation.name?1===this.interpolation.base?["linear"]:["exponential",this.interpolation.base]:["cubic-bezier"].concat(this.interpolation.controlPoints);for(var e=[this.operator,t,this.input.serialize()],r=0;r<this.labels.length;r++)e.push(this.labels[r],this.outputs[r].serialize());return e};var Xe=function(t,e){this.type=t,this.args=e;};Xe.parse=function(t,e){if(t.length<2)return e.error("Expectected at least one argument.");var r=null,n=e.expectedType;n&&"value"!==n.kind&&(r=n);for(var i=[],a=0,o=t.slice(1);a<o.length;a+=1){var s=o[a],u=e.parse(s,1+i.length,r,void 0,{typeAnnotation:"omit"});if(!u)return null;r=r||u.type,i.push(u);}var l=n&&i.some(function(t){return Jt(n,t.type)});return new Xe(l?jt:r,i)},Xe.prototype.evaluate=function(t){for(var e,r=null,n=0,i=0,a=this.args;i<a.length;i+=1){var o=a[i];if(n++,r=o.evaluate(t),"image"!==o.type.kind||r.available||(e||(e=o.evaluate(t).name),r=null,n===this.args.length&&(r=e)),null!==r)break}return r},Xe.prototype.eachChild=function(t){this.args.forEach(t);},Xe.prototype.possibleOutputs=function(){var t;return (t=[]).concat.apply(t,this.args.map(function(t){return t.possibleOutputs()}))},Xe.prototype.serialize=function(){var t=["coalesce"];return this.eachChild(function(e){t.push(e.serialize());}),t};var Ge=function(t,e){this.type=e.type,this.bindings=[].concat(t),this.result=e;};Ge.prototype.evaluate=function(t){return this.result.evaluate(t)},Ge.prototype.eachChild=function(t){for(var e=0,r=this.bindings;e<r.length;e+=1){t(r[e][1]);}t(this.result);},Ge.parse=function(t,e){if(t.length<4)return e.error("Expected at least 3 arguments, but found "+(t.length-1)+" instead.");for(var r=[],n=1;n<t.length-1;n+=2){var i=t[n];if("string"!=typeof i)return e.error("Expected string, but found "+typeof i+" instead.",n);if(/[^a-zA-Z0-9_]/.test(i))return e.error("Variable names must contain only alphanumeric characters or '_'.",n);var a=e.parse(t[n+1],n+1);if(!a)return null;r.push([i,a]);}var o=e.parse(t[t.length-1],t.length-1,e.expectedType,r);return o?new Ge(r,o):null},Ge.prototype.possibleOutputs=function(){return this.result.possibleOutputs()},Ge.prototype.serialize=function(){for(var t=["let"],e=0,r=this.bindings;e<r.length;e+=1){var n=r[e],i=n[0],a=n[1];t.push(i,a.serialize());}return t.push(this.result.serialize()),t};var Je=function(t,e,r){this.type=t,this.index=e,this.input=r;};Je.parse=function(t,e){if(3!==t.length)return e.error("Expected 2 arguments, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1,Ot),n=e.parse(t[2],2,Zt(e.expectedType||jt));if(!r||!n)return null;var i=n.type;return new Je(i.itemType,r,n)},Je.prototype.evaluate=function(t){var e=this.index.evaluate(t),r=this.input.evaluate(t);if(e<0)throw new ae("Array index out of bounds: "+e+" < 0.");if(e>=r.length)throw new ae("Array index out of bounds: "+e+" > "+(r.length-1)+".");if(e!==Math.floor(e))throw new ae("Array index must be an integer, but found "+e+" instead.");return r[e]},Je.prototype.eachChild=function(t){t(this.index),t(this.input);},Je.prototype.possibleOutputs=function(){return [void 0]},Je.prototype.serialize=function(){return ["at",this.index.serialize(),this.input.serialize()]};var He=function(t,e,r,n,i,a){this.inputType=t,this.type=e,this.input=r,this.cases=n,this.outputs=i,this.otherwise=a;};He.parse=function(t,e){if(t.length<5)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if(t.length%2!=1)return e.error("Expected an even number of arguments.");var r,n;e.expectedType&&"value"!==e.expectedType.kind&&(n=e.expectedType);for(var i={},a=[],o=2;o<t.length-1;o+=2){var s=t[o],u=t[o+1];Array.isArray(s)||(s=[s]);var l=e.concat(o);if(0===s.length)return l.error("Expected at least one branch label.");for(var p=0,c=s;p<c.length;p+=1){var h=c[p];if("number"!=typeof h&&"string"!=typeof h)return l.error("Branch labels must be numbers or strings.");if("number"==typeof h&&Math.abs(h)>Number.MAX_SAFE_INTEGER)return l.error("Branch labels must be integers no larger than "+Number.MAX_SAFE_INTEGER+".");if("number"==typeof h&&Math.floor(h)!==h)return l.error("Numeric branch labels must be integer values.");if(r){if(l.checkSubtype(r,re(h)))return null}else r=re(h);if(void 0!==i[String(h)])return l.error("Branch labels must be unique.");i[String(h)]=a.length;}var f=e.parse(u,o,n);if(!f)return null;n=n||f.type,a.push(f);}var y=e.parse(t[1],1,jt);if(!y)return null;var d=e.parse(t[t.length-1],t.length-1,n);return d?"value"!==y.type.kind&&e.concat(1).checkSubtype(r,y.type)?null:new He(r,n,y,i,a,d):null},He.prototype.evaluate=function(t){var e=this.input.evaluate(t);return (re(e)===this.inputType&&this.outputs[this.cases[e]]||this.otherwise).evaluate(t)},He.prototype.eachChild=function(t){t(this.input),this.outputs.forEach(t),t(this.otherwise);},He.prototype.possibleOutputs=function(){var t;return (t=[]).concat.apply(t,this.outputs.map(function(t){return t.possibleOutputs()})).concat(this.otherwise.possibleOutputs())},He.prototype.serialize=function(){for(var t=this,e=["match",this.input.serialize()],r=[],n={},i=0,a=Object.keys(this.cases).sort();i<a.length;i+=1){var o=a[i];void 0===(c=n[this.cases[o]])?(n[this.cases[o]]=r.length,r.push([this.cases[o],[o]])):r[c][1].push(o);}for(var s=function(e){return "number"===t.inputType.kind?Number(e):e},u=0,l=r;u<l.length;u+=1){var p=l[u],c=p[0],h=p[1];1===h.length?e.push(s(h[0])):e.push(h.map(s)),e.push(this.outputs[outputIndex$1].serialize());}return e.push(this.otherwise.serialize()),e};var Ye=function(t,e,r){this.type=t,this.branches=e,this.otherwise=r;};function $e(t,e){return "=="===t||"!="===t?"boolean"===e.kind||"string"===e.kind||"number"===e.kind||"null"===e.kind||"value"===e.kind:"string"===e.kind||"number"===e.kind||"value"===e.kind}function We(t,e,r,n){return 0===n.compare(e,r)}function Qe(t,e,r){var n="=="!==t&&"!="!==t;return function(){function i(t,e,r){this.type=Dt,this.lhs=t,this.rhs=e,this.collator=r,this.hasUntypedArgument="value"===t.type.kind||"value"===e.type.kind;}return i.parse=function(t,e){if(3!==t.length&&4!==t.length)return e.error("Expected two or three arguments.");var r=t[0],a=e.parse(t[1],1,jt);if(!a)return null;if(!$e(r,a.type))return e.concat(1).error('"'+r+"\" comparisons are not supported for type '"+Xt(a.type)+"'.");var o=e.parse(t[2],2,jt);if(!o)return null;if(!$e(r,o.type))return e.concat(2).error('"'+r+"\" comparisons are not supported for type '"+Xt(o.type)+"'.");if(a.type.kind!==o.type.kind&&"value"!==a.type.kind&&"value"!==o.type.kind)return e.error("Cannot compare types '"+Xt(a.type)+"' and '"+Xt(o.type)+"'.");n&&("value"===a.type.kind&&"value"!==o.type.kind?a=new se(o.type,[a]):"value"!==a.type.kind&&"value"===o.type.kind&&(o=new se(a.type,[o])));var s=null;if(4===t.length){if("string"!==a.type.kind&&"string"!==o.type.kind&&"value"!==a.type.kind&&"value"!==o.type.kind)return e.error("Cannot use collator to compare non-string types.");if(!(s=e.parse(t[3],3,qt)))return null}return new i(a,o,s)},i.prototype.evaluate=function(i){var a=this.lhs.evaluate(i),o=this.rhs.evaluate(i);if(n&&this.hasUntypedArgument){var s=re(a),u=re(o);if(s.kind!==u.kind||"string"!==s.kind&&"number"!==s.kind)throw new ae('Expected arguments for "'+t+'" to be (string, string) or (number, number), but found ('+s.kind+", "+u.kind+") instead.")}if(this.collator&&!n&&this.hasUntypedArgument){var l=re(a),p=re(o);if("string"!==l.kind||"string"!==p.kind)return e(i,a,o)}return this.collator?r(i,a,o,this.collator.evaluate(i)):e(i,a,o)},i.prototype.eachChild=function(t){t(this.lhs),t(this.rhs),this.collator&&t(this.collator);},i.prototype.possibleOutputs=function(){return [!0,!1]},i.prototype.serialize=function(){var e=[t];return this.eachChild(function(t){e.push(t.serialize());}),e},i}()}Ye.parse=function(t,e){if(t.length<4)return e.error("Expected at least 3 arguments, but found only "+(t.length-1)+".");if(t.length%2!=0)return e.error("Expected an odd number of arguments.");var r;e.expectedType&&"value"!==e.expectedType.kind&&(r=e.expectedType);for(var n=[],i=1;i<t.length-1;i+=2){var a=e.parse(t[i],i,Dt);if(!a)return null;var o=e.parse(t[i+1],i+1,r);if(!o)return null;n.push([a,o]),r=r||o.type;}var s=e.parse(t[t.length-1],t.length-1,r);return s?new Ye(r,n,s):null},Ye.prototype.evaluate=function(t){for(var e=0,r=this.branches;e<r.length;e+=1){var n=r[e],i=n[0],a=n[1];if(i.evaluate(t))return a.evaluate(t)}return this.otherwise.evaluate(t)},Ye.prototype.eachChild=function(t){for(var e=0,r=this.branches;e<r.length;e+=1){var n=r[e],i=n[0],a=n[1];t(i),t(a);}t(this.otherwise);},Ye.prototype.possibleOutputs=function(){var t;return (t=[]).concat.apply(t,this.branches.map(function(t){t[0];return t[1].possibleOutputs()})).concat(this.otherwise.possibleOutputs())},Ye.prototype.serialize=function(){var t=["case"];return this.eachChild(function(e){t.push(e.serialize());}),t};var tr=Qe("==",function(t,e,r){return e===r},We),er=Qe("!=",function(t,e,r){return e!==r},function(t,e,r,n){return !We(0,e,r,n)}),rr=Qe("<",function(t,e,r){return e<r},function(t,e,r,n){return n.compare(e,r)<0}),nr=Qe(">",function(t,e,r){return e>r},function(t,e,r,n){return n.compare(e,r)>0}),ir=Qe("<=",function(t,e,r){return e<=r},function(t,e,r,n){return n.compare(e,r)<=0}),ar=Qe(">=",function(t,e,r){return e>=r},function(t,e,r,n){return n.compare(e,r)>=0}),or=function(t,e,r,n,i){this.type=Lt,this.number=t,this.locale=e,this.currency=r,this.minFractionDigits=n,this.maxFractionDigits=i;};or.parse=function(t,e){if(3!==t.length)return e.error("Expected two arguments.");var r=e.parse(t[1],1,Ot);if(!r)return null;var n=t[2];if("object"!=typeof n||Array.isArray(n))return e.error("NumberFormat options argument must be an object.");var i=null;if(n.locale&&!(i=e.parse(n.locale,1,Lt)))return null;var a=null;if(n.currency&&!(a=e.parse(n.currency,1,Lt)))return null;var o=null;if(n["min-fraction-digits"]&&!(o=e.parse(n["min-fraction-digits"],1,Ot)))return null;var s=null;return n["max-fraction-digits"]&&!(s=e.parse(n["max-fraction-digits"],1,Ot))?null:new or(r,i,a,o,s)},or.prototype.evaluate=function(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))},or.prototype.eachChild=function(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits);},or.prototype.possibleOutputs=function(){return [void 0]},or.prototype.serialize=function(){var t={};return this.locale&&(t.locale=this.locale.serialize()),this.currency&&(t.currency=this.currency.serialize()),this.minFractionDigits&&(t["min-fraction-digits"]=this.minFractionDigits.serialize()),this.maxFractionDigits&&(t["max-fraction-digits"]=this.maxFractionDigits.serialize()),["number-format",this.number.serialize(),t]};var sr=function(t){this.type=Ot,this.input=t;};sr.parse=function(t,e){if(2!==t.length)return e.error("Expected 1 argument, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1);return r?"array"!==r.type.kind&&"string"!==r.type.kind&&"value"!==r.type.kind?e.error("Expected argument of type string or array, but found "+Xt(r.type)+" instead."):new sr(r):null},sr.prototype.evaluate=function(t){var e=this.input.evaluate(t);if("string"==typeof e)return e.length;if(Array.isArray(e))return e.length;throw new ae("Expected value to be of type string or array, but found "+Xt(re(e))+" instead.")},sr.prototype.eachChild=function(t){t(this.input);},sr.prototype.possibleOutputs=function(){return [void 0]},sr.prototype.serialize=function(){var t=["length"];return this.eachChild(function(e){t.push(e.serialize());}),t};var ur={"==":tr,"!=":er,">":nr,"<":rr,">=":ar,"<=":ir,array:se,at:Je,boolean:se,case:Ye,coalesce:Xe,collator:de,format:ue,image:le,interpolate:Ke,"interpolate-hcl":Ke,"interpolate-lab":Ke,length:sr,let:Ge,literal:ie,match:He,number:se,"number-format":or,object:se,step:we,string:se,"to-boolean":ce,"to-color":ce,"to-number":ce,"to-string":ce,var:xe};function lr(t,e){var r=e[0],n=e[1],i=e[2],a=e[3];r=r.evaluate(t),n=n.evaluate(t),i=i.evaluate(t);var o=a?a.evaluate(t):1,s=ee(r,n,i,o);if(s)throw new ae(s);return new Yt(r/255*o,n/255*o,i/255*o,o)}function pr(t,e){return t in e}function cr(t,e){var r=e[t];return void 0===r?null:r}function hr(t){return {type:t}}function fr(t){return {result:"success",value:t}}function yr(t){return {result:"error",value:t}}function dr(t){return "data-driven"===t["property-type"]||"cross-faded-data-driven"===t["property-type"]}function mr(t){return !!t.expression&&t.expression.parameters.indexOf("zoom")>-1}function vr(t){return !!t.expression&&t.expression.interpolated}function gr(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":null===t?"null":typeof t}function xr(t){return "object"==typeof t&&null!==t&&!Array.isArray(t)}function br(t){return t}function _r(t,e,r){return void 0!==t?t:void 0!==e?e:void 0!==r?r:void 0}function wr(t,e,r,n,i){return _r(typeof r===i?n[r]:void 0,t.default,e.default)}function Ar(t,e,r){if("number"!==gr(r))return _r(t.default,e.default);var n=t.stops.length;if(1===n)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[n-1][0])return t.stops[n-1][1];var i=_e(t.stops.map(function(t){return t[0]}),r);return t.stops[i][1]}function kr(t,e,r){var n=void 0!==t.base?t.base:1;if("number"!==gr(r))return _r(t.default,e.default);var i=t.stops.length;if(1===i)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[i-1][0])return t.stops[i-1][1];var a=_e(t.stops.map(function(t){return t[0]}),r),o=function(t,e,r,n){var i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}(r,n,t.stops[a][0],t.stops[a+1][0]),s=t.stops[a][1],u=t.stops[a+1][1],l=ke[e.type]||br;if(t.colorSpace&&"rgb"!==t.colorSpace){var p=Ne[t.colorSpace];l=function(t,e){return p.reverse(p.interpolate(p.forward(t),p.forward(e),o))};}return "function"==typeof s.evaluate?{evaluate:function(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];var r=s.evaluate.apply(void 0,t),n=u.evaluate.apply(void 0,t);if(void 0!==r&&void 0!==n)return l(r,n,o)}}:l(s,u,o)}function Sr(t,e,r){return "color"===e.type?r=Yt.parse(r):"formatted"===e.type?r=Qt.fromString(r.toString()):"image"===e.type?r=te.fromString({name:r.toString(),available:!1}):gr(r)===e.type||"enum"===e.type&&e.values[r]||(r=void 0),_r(r,t.default,e.default)}ye.register(ur,{error:[{kind:"error"},[Lt],function(t,e){var r=e[0];throw new ae(r.evaluate(t))}],typeof:[Lt,[jt],function(t,e){return Xt(re(e[0].evaluate(t)))}],"to-rgba":[Zt(Ot,4),[Ut],function(t,e){return e[0].evaluate(t).toArray()}],rgb:[Ut,[Ot,Ot,Ot],lr],rgba:[Ut,[Ot,Ot,Ot,Ot],lr],has:{type:Dt,overloads:[[[Lt],function(t,e){return pr(e[0].evaluate(t),t.properties())}],[[Lt,Rt],function(t,e){var r=e[0],n=e[1];return pr(r.evaluate(t),n.evaluate(t))}]]},get:{type:jt,overloads:[[[Lt],function(t,e){return cr(e[0].evaluate(t),t.properties())}],[[Lt,Rt],function(t,e){var r=e[0],n=e[1];return cr(r.evaluate(t),n.evaluate(t))}]]},"feature-state":[jt,[Lt],function(t,e){return cr(e[0].evaluate(t),t.featureState||{})}],properties:[Rt,[],function(t){return t.properties()}],"geometry-type":[Lt,[],function(t){return t.geometryType()}],id:[jt,[],function(t){return t.id()}],zoom:[Ot,[],function(t){return t.globals.zoom}],"heatmap-density":[Ot,[],function(t){return t.globals.heatmapDensity||0}],"line-progress":[Ot,[],function(t){return t.globals.lineProgress||0}],accumulated:[jt,[],function(t){return void 0===t.globals.accumulated?null:t.globals.accumulated}],"+":[Ot,hr(Ot),function(t,e){for(var r=0,n=0,i=e;n<i.length;n+=1){r+=i[n].evaluate(t);}return r}],"*":[Ot,hr(Ot),function(t,e){for(var r=1,n=0,i=e;n<i.length;n+=1){r*=i[n].evaluate(t);}return r}],"-":{type:Ot,overloads:[[[Ot,Ot],function(t,e){var r=e[0],n=e[1];return r.evaluate(t)-n.evaluate(t)}],[[Ot],function(t,e){return -e[0].evaluate(t)}]]},"/":[Ot,[Ot,Ot],function(t,e){var r=e[0],n=e[1];return r.evaluate(t)/n.evaluate(t)}],"%":[Ot,[Ot,Ot],function(t,e){var r=e[0],n=e[1];return r.evaluate(t)%n.evaluate(t)}],ln2:[Ot,[],function(){return Math.LN2}],pi:[Ot,[],function(){return Math.PI}],e:[Ot,[],function(){return Math.E}],"^":[Ot,[Ot,Ot],function(t,e){var r=e[0],n=e[1];return Math.pow(r.evaluate(t),n.evaluate(t))}],sqrt:[Ot,[Ot],function(t,e){var r=e[0];return Math.sqrt(r.evaluate(t))}],log10:[Ot,[Ot],function(t,e){var r=e[0];return Math.log(r.evaluate(t))/Math.LN10}],ln:[Ot,[Ot],function(t,e){var r=e[0];return Math.log(r.evaluate(t))}],log2:[Ot,[Ot],function(t,e){var r=e[0];return Math.log(r.evaluate(t))/Math.LN2}],sin:[Ot,[Ot],function(t,e){var r=e[0];return Math.sin(r.evaluate(t))}],cos:[Ot,[Ot],function(t,e){var r=e[0];return Math.cos(r.evaluate(t))}],tan:[Ot,[Ot],function(t,e){var r=e[0];return Math.tan(r.evaluate(t))}],asin:[Ot,[Ot],function(t,e){var r=e[0];return Math.asin(r.evaluate(t))}],acos:[Ot,[Ot],function(t,e){var r=e[0];return Math.acos(r.evaluate(t))}],atan:[Ot,[Ot],function(t,e){var r=e[0];return Math.atan(r.evaluate(t))}],min:[Ot,hr(Ot),function(t,e){return Math.min.apply(Math,e.map(function(e){return e.evaluate(t)}))}],max:[Ot,hr(Ot),function(t,e){return Math.max.apply(Math,e.map(function(e){return e.evaluate(t)}))}],abs:[Ot,[Ot],function(t,e){var r=e[0];return Math.abs(r.evaluate(t))}],round:[Ot,[Ot],function(t,e){var r=e[0].evaluate(t);return r<0?-Math.round(-r):Math.round(r)}],floor:[Ot,[Ot],function(t,e){var r=e[0];return Math.floor(r.evaluate(t))}],ceil:[Ot,[Ot],function(t,e){var r=e[0];return Math.ceil(r.evaluate(t))}],"filter-==":[Dt,[Lt,jt],function(t,e){var r=e[0],n=e[1];return t.properties()[r.value]===n.value}],"filter-id-==":[Dt,[jt],function(t,e){var r=e[0];return t.id()===r.value}],"filter-type-==":[Dt,[Lt],function(t,e){var r=e[0];return t.geometryType()===r.value}],"filter-<":[Dt,[Lt,jt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i<a}],"filter-id-<":[Dt,[jt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n<i}],"filter->":[Dt,[Lt,jt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i>a}],"filter-id->":[Dt,[jt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n>i}],"filter-<=":[Dt,[Lt,jt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i<=a}],"filter-id-<=":[Dt,[jt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n<=i}],"filter->=":[Dt,[Lt,jt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i>=a}],"filter-id->=":[Dt,[jt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n>=i}],"filter-has":[Dt,[jt],function(t,e){return e[0].value in t.properties()}],"filter-has-id":[Dt,[],function(t){return null!==t.id()}],"filter-type-in":[Dt,[Zt(Lt)],function(t,e){return e[0].value.indexOf(t.geometryType())>=0}],"filter-id-in":[Dt,[Zt(jt)],function(t,e){return e[0].value.indexOf(t.id())>=0}],"filter-in-small":[Dt,[Lt,Zt(jt)],function(t,e){var r=e[0];return e[1].value.indexOf(t.properties()[r.value])>=0}],"filter-in-large":[Dt,[Lt,Zt(jt)],function(t,e){var r=e[0],n=e[1];return function(t,e,r,n){for(;r<=n;){var i=r+n>>1;if(e[i]===t)return !0;e[i]>t?n=i-1:r=i+1;}return !1}(t.properties()[r.value],n.value,0,n.value.length-1)}],all:{type:Dt,overloads:[[[Dt,Dt],function(t,e){var r=e[0],n=e[1];return r.evaluate(t)&&n.evaluate(t)}],[hr(Dt),function(t,e){for(var r=0,n=e;r<n.length;r+=1){if(!n[r].evaluate(t))return !1}return !0}]]},any:{type:Dt,overloads:[[[Dt,Dt],function(t,e){var r=e[0],n=e[1];return r.evaluate(t)||n.evaluate(t)}],[hr(Dt),function(t,e){for(var r=0,n=e;r<n.length;r+=1){if(n[r].evaluate(t))return !0}return !1}]]},"!":[Dt,[Dt],function(t,e){return !e[0].evaluate(t)}],"is-supported-script":[Dt,[Lt],function(t,e){var r=e[0],n=t.globals&&t.globals.isSupportedScript;return !n||n(r.evaluate(t))}],upcase:[Lt,[Lt],function(t,e){return e[0].evaluate(t).toUpperCase()}],downcase:[Lt,[Lt],function(t,e){return e[0].evaluate(t).toLowerCase()}],concat:[Lt,hr(jt),function(t,e){return e.map(function(e){return ne(e.evaluate(t))}).join("")}],"resolved-locale":[Lt,[qt],function(t,e){return e[0].evaluate(t).resolvedLocale()}]});var zr=function(t,e){this.expression=t,this._warningHistory={},this._evaluator=new fe,this._defaultValue=e?function(t){return "color"===t.type&&xr(t.default)?new Yt(0,0,0,0):"color"===t.type?Yt.parse(t.default)||null:void 0===t.default?null:t.default}(e):null,this._enumValues=e&&"enum"===e.type?e.values:null;};function Ir(t){return Array.isArray(t)&&t.length>0&&"string"==typeof t[0]&&t[0]in ur}function Cr(t,e){var r=new be(ur,[],e?function(t){var e={color:Ut,string:Lt,number:Ot,enum:Lt,boolean:Dt,formatted:Nt,image:Kt};if("array"===t.type)return Zt(e[t.value]||jt,t.length);return e[t.type]}(e):void 0),n=r.parse(t,void 0,void 0,void 0,e&&"string"===e.type?{typeAnnotation:"coerce"}:void 0);return n?fr(new zr(n,e)):yr(r.errors)}zr.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i){return this._evaluator.globals=t,this._evaluator.feature=e,this._evaluator.featureState=r,this._evaluator.availableImages=n||null,this._evaluator.formattedSection=i,this.expression.evaluate(this._evaluator)},zr.prototype.evaluate=function(t,e,r,n,i){this._evaluator.globals=t,this._evaluator.feature=e||null,this._evaluator.featureState=r||null,this._evaluator.availableImages=n||null,this._evaluator.formattedSection=i||null;try{var a=this.expression.evaluate(this._evaluator);if(null==a)return this._defaultValue;if(this._enumValues&&!(a in this._enumValues))throw new ae("Expected value to be one of "+Object.keys(this._enumValues).map(function(t){return JSON.stringify(t)}).join(", ")+", but found "+JSON.stringify(a)+" instead.");return a}catch(t){return this._warningHistory[t.message]||(this._warningHistory[t.message]=!0,"undefined"!=typeof console&&console.warn(t.message)),this._defaultValue}};var Br=function(t,e){this.kind=t,this._styleExpression=e,this.isStateDependent="constant"!==t&&!ve(e.expression);};Br.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i)},Br.prototype.evaluate=function(t,e,r,n,i){return this._styleExpression.evaluate(t,e,r,n,i)};var Er=function(t,e,r,n){this.kind=t,this.zoomStops=r,this._styleExpression=e,this.isStateDependent="camera"!==t&&!ve(e.expression),this.interpolationType=n;};function Pr(t,e){if("error"===(t=Cr(t,e)).result)return t;var r=t.value.expression,n=me(r);if(!n&&!dr(e))return yr([new Tt("","data expressions not supported")]);var i=ge(r,["zoom"]);if(!i&&!mr(e))return yr([new Tt("","zoom expressions not supported")]);var a=function t(e){var r=null;if(e instanceof Ge)r=t(e.result);else if(e instanceof Xe)for(var n=0,i=e.args;n<i.length;n+=1){var a=i[n];if(r=t(a))break}else(e instanceof we||e instanceof Ke)&&e.input instanceof ye&&"zoom"===e.input.name&&(r=e);if(r instanceof Tt)return r;e.eachChild(function(e){var n=t(e);n instanceof Tt?r=n:!r&&n?r=new Tt("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'):r&&n&&r!==n&&(r=new Tt("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));});return r}(r);if(!a&&!i)return yr([new Tt("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);if(a instanceof Tt)return yr([a]);if(a instanceof Ke&&!vr(e))return yr([new Tt("",'"interpolate" expressions cannot be used with this property')]);if(!a)return fr(new Br(n?"constant":"source",t.value));var o=a instanceof Ke?a.interpolation:void 0;return fr(new Er(n?"camera":"composite",t.value,a.labels,o))}Er.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i)},Er.prototype.evaluate=function(t,e,r,n,i){return this._styleExpression.evaluate(t,e,r,n,i)},Er.prototype.interpolationFactor=function(t,e,r){return this.interpolationType?Ke.interpolationFactor(this.interpolationType,t,e,r):0};var Mr=function(t,e){this._parameters=t,this._specification=e,Bt(this,function t(e,r){var n,i,a,o="color"===r.type,s=e.stops&&"object"==typeof e.stops[0][0],u=s||void 0!==e.property,l=s||!u,p=e.type||(vr(r)?"exponential":"interval");if(o&&((e=Bt({},e)).stops&&(e.stops=e.stops.map(function(t){return [t[0],Yt.parse(t[1])]})),e.default?e.default=Yt.parse(e.default):e.default=Yt.parse(r.default)),e.colorSpace&&"rgb"!==e.colorSpace&&!Ne[e.colorSpace])throw new Error("Unknown color space: "+e.colorSpace);if("exponential"===p)n=kr;else if("interval"===p)n=Ar;else if("categorical"===p){n=wr,i=Object.create(null);for(var c=0,h=e.stops;c<h.length;c+=1){var f=h[c];i[f[0]]=f[1];}a=typeof e.stops[0][0];}else{if("identity"!==p)throw new Error('Unknown function type "'+p+'"');n=Sr;}if(s){for(var y={},d=[],m=0;m<e.stops.length;m++){var v=e.stops[m],g=v[0].zoom;void 0===y[g]&&(y[g]={zoom:g,type:e.type,property:e.property,default:e.default,stops:[]},d.push(g)),y[g].stops.push([v[0].value,v[1]]);}for(var x=[],b=0,_=d;b<_.length;b+=1){var w=_[b];x.push([y[w].zoom,t(y[w],r)]);}var A={name:"linear"};return {kind:"composite",interpolationType:A,interpolationFactor:Ke.interpolationFactor.bind(void 0,A),zoomStops:x.map(function(t){return t[0]}),evaluate:function(t,n){var i=t.zoom;return kr({stops:x,base:e.base},r,i).evaluate(i,n)}}}if(l){var k="exponential"===p?{name:"exponential",base:void 0!==e.base?e.base:1}:null;return {kind:"camera",interpolationType:k,interpolationFactor:Ke.interpolationFactor.bind(void 0,k),zoomStops:e.stops.map(function(t){return t[0]}),evaluate:function(t){var o=t.zoom;return n(e,r,o,i,a)}}}return {kind:"source",evaluate:function(t,o){var s=o&&o.properties?o.properties[e.property]:void 0;return void 0===s?_r(e.default,r.default):n(e,r,s,i,a)}}}(this._parameters,this._specification));};function Tr(t){var e=t.key,r=t.value,n=t.valueSpec||{},i=t.objectElementValidators||{},a=t.style,o=t.styleSpec,s=[],u=gr(r);if("object"!==u)return [new It(e,r,"object expected, "+u+" found")];for(var l in r){var p=l.split(".")[0],c=n[p]||n["*"],h=void 0;if(i[p])h=i[p];else if(n[p])h=nn;else if(i["*"])h=i["*"];else{if(!n["*"]){s.push(new It(e,r[l],'unknown property "'+l+'"'));continue}h=nn;}s=s.concat(h({key:(e?e+".":e)+l,value:r[l],valueSpec:c,style:a,styleSpec:o,object:r,objectKey:l},r));}for(var f in n)i[f]||n[f].required&&void 0===n[f].default&&void 0===r[f]&&s.push(new It(e,r,'missing required property "'+f+'"'));return s}function Vr(t){var e=t.value,r=t.valueSpec,n=t.style,i=t.styleSpec,a=t.key,o=t.arrayElementValidator||nn;if("array"!==gr(e))return [new It(a,e,"array expected, "+gr(e)+" found")];if(r.length&&e.length!==r.length)return [new It(a,e,"array length "+r.length+" expected, length "+e.length+" found")];if(r["min-length"]&&e.length<r["min-length"])return [new It(a,e,"array length at least "+r["min-length"]+" expected, length "+e.length+" found")];var s={type:r.value,values:r.values};i.$version<7&&(s.function=r.function),"object"===gr(r.value)&&(s=r.value);for(var u=[],l=0;l<e.length;l++)u=u.concat(o({array:e,arrayIndex:l,value:e[l],valueSpec:s,style:n,styleSpec:i,key:a+"["+l+"]"}));return u}function Fr(t){var e=t.key,r=t.value,n=t.valueSpec,i=gr(r);return "number"!==i?[new It(e,r,"number expected, "+i+" found")]:"minimum"in n&&r<n.minimum?[new It(e,r,r+" is less than the minimum value "+n.minimum)]:"maximum"in n&&r>n.maximum?[new It(e,r,r+" is greater than the maximum value "+n.maximum)]:[]}function Or(t){var e,r,n,i=t.valueSpec,a=Pt(t.value.type),o={},s="categorical"!==a&&void 0===t.value.property,u=!s,l="array"===gr(t.value.stops)&&"array"===gr(t.value.stops[0])&&"object"===gr(t.value.stops[0][0]),p=Tr({key:t.key,value:t.value,valueSpec:t.styleSpec.function,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{stops:function(t){if("identity"===a)return [new It(t.key,t.value,'identity function may not have a "stops" property')];var e=[],r=t.value;e=e.concat(Vr({key:t.key,value:r,valueSpec:t.valueSpec,style:t.style,styleSpec:t.styleSpec,arrayElementValidator:c})),"array"===gr(r)&&0===r.length&&e.push(new It(t.key,r,"array must have at least one stop"));return e},default:function(t){return nn({key:t.key,value:t.value,valueSpec:i,style:t.style,styleSpec:t.styleSpec})}}});return "identity"===a&&s&&p.push(new It(t.key,t.value,'missing required property "property"')),"identity"===a||t.value.stops||p.push(new It(t.key,t.value,'missing required property "stops"')),"exponential"===a&&t.valueSpec.expression&&!vr(t.valueSpec)&&p.push(new It(t.key,t.value,"exponential functions not supported")),t.styleSpec.$version>=8&&(u&&!dr(t.valueSpec)?p.push(new It(t.key,t.value,"property functions not supported")):s&&!mr(t.valueSpec)&&p.push(new It(t.key,t.value,"zoom functions not supported"))),"categorical"!==a&&!l||void 0!==t.value.property||p.push(new It(t.key,t.value,'"property" property is required')),p;function c(t){var e=[],a=t.value,s=t.key;if("array"!==gr(a))return [new It(s,a,"array expected, "+gr(a)+" found")];if(2!==a.length)return [new It(s,a,"array length 2 expected, length "+a.length+" found")];if(l){if("object"!==gr(a[0]))return [new It(s,a,"object expected, "+gr(a[0])+" found")];if(void 0===a[0].zoom)return [new It(s,a,"object stop key must have zoom")];if(void 0===a[0].value)return [new It(s,a,"object stop key must have value")];if(n&&n>Pt(a[0].zoom))return [new It(s,a[0].zoom,"stop zoom values must appear in ascending order")];Pt(a[0].zoom)!==n&&(n=Pt(a[0].zoom),r=void 0,o={}),e=e.concat(Tr({key:s+"[0]",value:a[0],valueSpec:{zoom:{}},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{zoom:Fr,value:h}}));}else e=e.concat(h({key:s+"[0]",value:a[0],valueSpec:{},style:t.style,styleSpec:t.styleSpec},a));return Ir(Mt(a[1]))?e.concat([new It(s+"[1]",a[1],"expressions are not allowed in function stops.")]):e.concat(nn({key:s+"[1]",value:a[1],valueSpec:i,style:t.style,styleSpec:t.styleSpec}))}function h(t,n){var s=gr(t.value),u=Pt(t.value),l=null!==t.value?t.value:n;if(e){if(s!==e)return [new It(t.key,l,s+" stop domain type must match previous stop domain type "+e)]}else e=s;if("number"!==s&&"string"!==s&&"boolean"!==s)return [new It(t.key,l,"stop domain value must be a number, string, or boolean")];if("number"!==s&&"categorical"!==a){var p="number expected, "+s+" found";return dr(i)&&void 0===a&&(p+='\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),[new It(t.key,l,p)]}return "categorical"!==a||"number"!==s||isFinite(u)&&Math.floor(u)===u?"categorical"!==a&&"number"===s&&void 0!==r&&u<r?[new It(t.key,l,"stop domain values must appear in ascending order")]:(r=u,"categorical"===a&&u in o?[new It(t.key,l,"stop domain values must be unique")]:(o[u]=!0,[])):[new It(t.key,l,"integer expected, found "+u)]}}function Lr(t){var e=("property"===t.expressionContext?Pr:Cr)(Mt(t.value),t.valueSpec);if("error"===e.result)return e.value.map(function(e){return new It(""+t.key+e.key,t.value,e.message)});var r=e.value.expression||e.value._styleExpression.expression;if("property"===t.expressionContext&&"text-font"===t.propertyKey&&-1!==r.possibleOutputs().indexOf(void 0))return [new It(t.key,t.value,'Invalid data expression for "'+t.propertyKey+'". Output values must be contained as literals within the expression.')];if("property"===t.expressionContext&&"layout"===t.propertyType&&!ve(r))return [new It(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];if("filter"===t.expressionContext&&!ve(r))return [new It(t.key,t.value,'"feature-state" data expressions are not supported with filters.')];if(t.expressionContext&&0===t.expressionContext.indexOf("cluster")){if(!ge(r,["zoom","feature-state"]))return [new It(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if("cluster-initial"===t.expressionContext&&!me(r))return [new It(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return []}function Dr(t){var e=t.key,r=t.value,n=t.valueSpec,i=[];return Array.isArray(n.values)?-1===n.values.indexOf(Pt(r))&&i.push(new It(e,r,"expected one of ["+n.values.join(", ")+"], "+JSON.stringify(r)+" found")):-1===Object.keys(n.values).indexOf(Pt(r))&&i.push(new It(e,r,"expected one of ["+Object.keys(n.values).join(", ")+"], "+JSON.stringify(r)+" found")),i}function Ur(t){if(!0===t||!1===t)return !0;if(!Array.isArray(t)||0===t.length)return !1;switch(t[0]){case"has":return t.length>=2&&"$id"!==t[1]&&"$type"!==t[1];case"in":case"!in":case"!has":case"none":return !1;case"==":case"!=":case">":case">=":case"<":case"<=":return 3!==t.length||Array.isArray(t[1])||Array.isArray(t[2]);case"any":case"all":for(var e=0,r=t.slice(1);e<r.length;e+=1){var n=r[e];if(!Ur(n)&&"boolean"!=typeof n)return !1}return !0;default:return !0}}Mr.deserialize=function(t){return new Mr(t._parameters,t._specification)},Mr.serialize=function(t){return {_parameters:t._parameters,_specification:t._specification}};var Rr={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function jr(t){if(null==t)return function(){return !0};Ur(t)||(t=Nr(t));var e=Cr(t,Rr);if("error"===e.result)throw new Error(e.value.map(function(t){return t.key+": "+t.message}).join(", "));return function(t,r){return e.value.evaluate(t,r)}}function qr(t,e){return t<e?-1:t>e?1:0}function Nr(t){if(!t)return !0;var e,r=t[0];return t.length<=1?"any"!==r:"=="===r?Kr(t[1],t[2],"=="):"!="===r?Gr(Kr(t[1],t[2],"==")):"<"===r||">"===r||"<="===r||">="===r?Kr(t[1],t[2],r):"any"===r?(e=t.slice(1),["any"].concat(e.map(Nr))):"all"===r?["all"].concat(t.slice(1).map(Nr)):"none"===r?["all"].concat(t.slice(1).map(Nr).map(Gr)):"in"===r?Zr(t[1],t.slice(2)):"!in"===r?Gr(Zr(t[1],t.slice(2))):"has"===r?Xr(t[1]):"!has"!==r||Gr(Xr(t[1]))}function Kr(t,e,r){switch(t){case"$type":return ["filter-type-"+r,e];case"$id":return ["filter-id-"+r,e];default:return ["filter-"+r,t,e]}}function Zr(t,e){if(0===e.length)return !1;switch(t){case"$type":return ["filter-type-in",["literal",e]];case"$id":return ["filter-id-in",["literal",e]];default:return e.length>200&&!e.some(function(t){return typeof t!=typeof e[0]})?["filter-in-large",t,["literal",e.sort(qr)]]:["filter-in-small",t,["literal",e]]}}function Xr(t){switch(t){case"$type":return !0;case"$id":return ["filter-has-id"];default:return ["filter-has",t]}}function Gr(t){return ["!",t]}function Jr(t){return Ur(Mt(t.value))?Lr(Bt({},t,{expressionContext:"filter",valueSpec:{value:"boolean"}})):function t(e){var r=e.value;var n=e.key;if("array"!==gr(r))return [new It(n,r,"array expected, "+gr(r)+" found")];var i=e.styleSpec;var a;var o=[];if(r.length<1)return [new It(n,r,"filter array must have at least 1 element")];o=o.concat(Dr({key:n+"[0]",value:r[0],valueSpec:i.filter_operator,style:e.style,styleSpec:e.styleSpec}));switch(Pt(r[0])){case"<":case"<=":case">":case">=":r.length>=2&&"$type"===Pt(r[1])&&o.push(new It(n,r,'"$type" cannot be use with operator "'+r[0]+'"'));case"==":case"!=":3!==r.length&&o.push(new It(n,r,'filter array for operator "'+r[0]+'" must have 3 elements'));case"in":case"!in":r.length>=2&&"string"!==(a=gr(r[1]))&&o.push(new It(n+"[1]",r[1],"string expected, "+a+" found"));for(var s=2;s<r.length;s++)a=gr(r[s]),"$type"===Pt(r[1])?o=o.concat(Dr({key:n+"["+s+"]",value:r[s],valueSpec:i.geometry_type,style:e.style,styleSpec:e.styleSpec})):"string"!==a&&"number"!==a&&"boolean"!==a&&o.push(new It(n+"["+s+"]",r[s],"string, number, or boolean expected, "+a+" found"));break;case"any":case"all":case"none":for(var u=1;u<r.length;u++)o=o.concat(t({key:n+"["+u+"]",value:r[u],style:e.style,styleSpec:e.styleSpec}));break;case"has":case"!has":a=gr(r[1]),2!==r.length?o.push(new It(n,r,'filter array for "'+r[0]+'" operator must have 2 elements')):"string"!==a&&o.push(new It(n+"[1]",r[1],"string expected, "+a+" found"));}return o}(t)}function Hr(t,e){var r=t.key,n=t.style,i=t.styleSpec,a=t.value,o=t.objectKey,s=i[e+"_"+t.layerType];if(!s)return [];var u=o.match(/^(.*)-transition$/);if("paint"===e&&u&&s[u[1]]&&s[u[1]].transition)return nn({key:r,value:a,valueSpec:i.transition,style:n,styleSpec:i});var l,p=t.valueSpec||s[o];if(!p)return [new It(r,a,'unknown property "'+o+'"')];if("string"===gr(a)&&dr(p)&&!p.tokens&&(l=/^{([^}]+)}$/.exec(a)))return [new It(r,a,'"'+o+'" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": '+JSON.stringify(l[1])+" }`.")];var c=[];return "symbol"===t.layerType&&("text-field"===o&&n&&!n.glyphs&&c.push(new It(r,a,'use of "text-field" requires a style "glyphs" property')),"text-font"===o&&xr(Mt(a))&&"identity"===Pt(a.type)&&c.push(new It(r,a,'"text-font" does not support identity functions'))),c.concat(nn({key:t.key,value:a,valueSpec:p,style:n,styleSpec:i,expressionContext:"property",propertyType:e,propertyKey:o}))}function Yr(t){return Hr(t,"paint")}function $r(t){return Hr(t,"layout")}function Wr(t){var e=[],r=t.value,n=t.key,i=t.style,a=t.styleSpec;r.type||r.ref||e.push(new It(n,r,'either "type" or "ref" is required'));var o,s=Pt(r.type),u=Pt(r.ref);if(r.id)for(var l=Pt(r.id),p=0;p<t.arrayIndex;p++){var c=i.layers[p];Pt(c.id)===l&&e.push(new It(n,r.id,'duplicate layer id "'+r.id+'", previously used at line '+c.id.__line__));}if("ref"in r)["type","source","source-layer","filter","layout"].forEach(function(t){t in r&&e.push(new It(n,r[t],'"'+t+'" is prohibited for ref layers'));}),i.layers.forEach(function(t){Pt(t.id)===u&&(o=t);}),o?o.ref?e.push(new It(n,r.ref,"ref cannot reference another ref layer")):s=Pt(o.type):e.push(new It(n,r.ref,'ref layer "'+u+'" not found'));else if("background"!==s)if(r.source){var h=i.sources&&i.sources[r.source],f=h&&Pt(h.type);h?"vector"===f&&"raster"===s?e.push(new It(n,r.source,'layer "'+r.id+'" requires a raster source')):"raster"===f&&"raster"!==s?e.push(new It(n,r.source,'layer "'+r.id+'" requires a vector source')):"vector"!==f||r["source-layer"]?"raster-dem"===f&&"hillshade"!==s?e.push(new It(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")):"line"!==s||!r.paint||!r.paint["line-gradient"]||"geojson"===f&&h.lineMetrics||e.push(new It(n,r,'layer "'+r.id+'" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')):e.push(new It(n,r,'layer "'+r.id+'" must specify a "source-layer"')):e.push(new It(n,r.source,'source "'+r.source+'" not found'));}else e.push(new It(n,r,'missing required property "source"'));return e=e.concat(Tr({key:n,value:r,valueSpec:a.layer,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(){return []},type:function(){return nn({key:n+".type",value:r.type,valueSpec:a.layer.type,style:t.style,styleSpec:t.styleSpec,object:r,objectKey:"type"})},filter:Jr,layout:function(t){return Tr({layer:r,key:t.key,value:t.value,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(t){return $r(Bt({layerType:s},t))}}})},paint:function(t){return Tr({layer:r,key:t.key,value:t.value,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(t){return Yr(Bt({layerType:s},t))}}})}}}))}function Qr(t){var e=t.value,r=t.key,n=t.styleSpec,i=t.style;if(!e.type)return [new It(r,e,'"type" is required')];var a,o=Pt(e.type);switch(o){case"vector":case"raster":case"raster-dem":return a=Tr({key:r,value:e,valueSpec:n["source_"+o.replace("-","_")],style:t.style,styleSpec:n});case"geojson":if(a=Tr({key:r,value:e,valueSpec:n.source_geojson,style:i,styleSpec:n}),e.cluster)for(var s in e.clusterProperties){var u=e.clusterProperties[s],l=u[0],p=u[1],c="string"==typeof l?[l,["accumulated"],["get",s]]:l;a.push.apply(a,Lr({key:r+"."+s+".map",value:p,expressionContext:"cluster-map"})),a.push.apply(a,Lr({key:r+"."+s+".reduce",value:c,expressionContext:"cluster-reduce"}));}return a;case"video":return Tr({key:r,value:e,valueSpec:n.source_video,style:i,styleSpec:n});case"image":return Tr({key:r,value:e,valueSpec:n.source_image,style:i,styleSpec:n});case"canvas":return [new It(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return Dr({key:r+".type",value:e.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]},style:i,styleSpec:n})}}function tn(t){var e=t.value,r=t.styleSpec,n=r.light,i=t.style,a=[],o=gr(e);if(void 0===e)return a;if("object"!==o)return a=a.concat([new It("light",e,"object expected, "+o+" found")]);for(var s in e){var u=s.match(/^(.*)-transition$/);a=u&&n[u[1]]&&n[u[1]].transition?a.concat(nn({key:s,value:e[s],valueSpec:r.transition,style:i,styleSpec:r})):n[s]?a.concat(nn({key:s,value:e[s],valueSpec:n[s],style:i,styleSpec:r})):a.concat([new It(s,e[s],'unknown property "'+s+'"')]);}return a}function en(t){var e=t.value,r=t.key,n=gr(e);return "string"!==n?[new It(r,e,"string expected, "+n+" found")]:[]}var rn={"*":function(){return []},array:Vr,boolean:function(t){var e=t.value,r=t.key,n=gr(e);return "boolean"!==n?[new It(r,e,"boolean expected, "+n+" found")]:[]},number:Fr,color:function(t){var e=t.key,r=t.value,n=gr(r);return "string"!==n?[new It(e,r,"color expected, "+n+" found")]:null===Ht(r)?[new It(e,r,'color expected, "'+r+'" found')]:[]},constants:Ct,enum:Dr,filter:Jr,function:Or,layer:Wr,object:Tr,source:Qr,light:tn,string:en,formatted:function(t){return 0===en(t).length?[]:Lr(t)},image:function(t){return 0===en(t).length?[]:Lr(t)}};function nn(t){var e=t.value,r=t.valueSpec,n=t.styleSpec;return r.expression&&xr(Pt(e))?Or(t):r.expression&&Ir(Mt(e))?Lr(t):r.type&&rn[r.type]?rn[r.type](t):Tr(Bt({},t,{valueSpec:r.type?n[r.type]:r}))}function an(t){var e=t.value,r=t.key,n=en(t);return n.length?n:(-1===e.indexOf("{fontstack}")&&n.push(new It(r,e,'"glyphs" url must include a "{fontstack}" token')),-1===e.indexOf("{range}")&&n.push(new It(r,e,'"glyphs" url must include a "{range}" token')),n)}function on(t,e){void 0===e&&(e=zt);var r=[];return r=r.concat(nn({key:"",value:t,valueSpec:e.$root,styleSpec:e,style:t,objectElementValidators:{glyphs:an,"*":function(){return []}}})),t.constants&&(r=r.concat(Ct({key:"constants",value:t.constants,style:t,styleSpec:e}))),sn(r)}function sn(t){return [].concat(t).sort(function(t,e){return t.line-e.line})}function un(t){return function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];return sn(t.apply(this,e))}}on.source=un(Qr),on.light=un(tn),on.layer=un(Wr),on.filter=un(Jr),on.paintProperty=un(Yr),on.layoutProperty=un($r);var ln=on,pn=ln.light,cn=ln.paintProperty,hn=ln.layoutProperty;function fn(t,e){var r=!1;if(e&&e.length)for(var n=0,i=e;n<i.length;n+=1){var a=i[n];t.fire(new kt(new Error(a.message))),r=!0;}return r}var yn=mn,dn=3;function mn(t,e,r){var n=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;var i=new Int32Array(this.arrayBuffer);t=i[0],e=i[1],r=i[2],this.d=e+2*r;for(var a=0;a<this.d*this.d;a++){var o=i[dn+a],s=i[dn+a+1];n.push(o===s?null:i.subarray(o,s));}var u=i[dn+n.length],l=i[dn+n.length+1];this.keys=i.subarray(u,l),this.bboxes=i.subarray(l),this.insert=this._insertReadonly;}else{this.d=e+2*r;for(var p=0;p<this.d*this.d;p++)n.push([]);this.keys=[],this.bboxes=[];}this.n=e,this.extent=t,this.padding=r,this.scale=e/t,this.uid=0;var c=r/e*t;this.min=-c,this.max=t+c;}mn.prototype.insert=function(t,e,r,n,i){this._forEachCell(e,r,n,i,this._insertCell,this.uid++),this.keys.push(t),this.bboxes.push(e),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i);},mn.prototype._insertReadonly=function(){throw"Cannot insert into a GridIndex created from an ArrayBuffer."},mn.prototype._insertCell=function(t,e,r,n,i,a){this.cells[i].push(a);},mn.prototype.query=function(t,e,r,n,i){var a=this.min,o=this.max;if(t<=a&&e<=a&&o<=r&&o<=n&&!i)return Array.prototype.slice.call(this.keys);var s=[];return this._forEachCell(t,e,r,n,this._queryCell,s,{},i),s},mn.prototype._queryCell=function(t,e,r,n,i,a,o,s){var u=this.cells[i];if(null!==u)for(var l=this.keys,p=this.bboxes,c=0;c<u.length;c++){var h=u[c];if(void 0===o[h]){var f=4*h;(s?s(p[f+0],p[f+1],p[f+2],p[f+3]):t<=p[f+2]&&e<=p[f+3]&&r>=p[f+0]&&n>=p[f+1])?(o[h]=!0,a.push(l[h])):o[h]=!1;}}},mn.prototype._forEachCell=function(t,e,r,n,i,a,o,s){for(var u=this._convertToCellCoord(t),l=this._convertToCellCoord(e),p=this._convertToCellCoord(r),c=this._convertToCellCoord(n),h=u;h<=p;h++)for(var f=l;f<=c;f++){var y=this.d*f+h;if((!s||s(this._convertFromCellCoord(h),this._convertFromCellCoord(f),this._convertFromCellCoord(h+1),this._convertFromCellCoord(f+1)))&&i.call(this,t,e,r,n,y,a,o,s))return}},mn.prototype._convertFromCellCoord=function(t){return (t-this.padding)/this.scale},mn.prototype._convertToCellCoord=function(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))},mn.prototype.toArrayBuffer=function(){if(this.arrayBuffer)return this.arrayBuffer;for(var t=this.cells,e=dn+this.cells.length+1+1,r=0,n=0;n<this.cells.length;n++)r+=this.cells[n].length;var i=new Int32Array(e+r+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;for(var a=e,o=0;o<t.length;o++){var s=t[o];i[dn+o]=a,i.set(s,a),a+=s.length;}return i[dn+t.length]=a,i.set(this.keys,a),a+=this.keys.length,i[dn+t.length+1]=a,i.set(this.bboxes,a),a+=this.bboxes.length,i.buffer};var vn=self.ImageData,gn={};function xn(t,e,r){void 0===r&&(r={}),Object.defineProperty(e,"_classRegistryKey",{value:t,writeable:!1}),gn[t]={klass:e,omit:r.omit||[],shallow:r.shallow||[]};}for(var bn in xn("Object",Object),yn.serialize=function(t,e){var r=t.toArrayBuffer();return e&&e.push(r),{buffer:r}},yn.deserialize=function(t){return new yn(t.buffer)},xn("Grid",yn),xn("Color",Yt),xn("Error",Error),xn("ResolvedImage",te),xn("StylePropertyFunction",Mr),xn("StyleExpression",zr,{omit:["_evaluator"]}),xn("ZoomDependentExpression",Er),xn("ZoomConstantExpression",Br),xn("CompoundExpression",ye,{omit:["_evaluate"]}),ur)ur[bn]._classRegistryKey||xn("Expression_"+bn,ur[bn]);function _n(t,e){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp)return t;if(t instanceof ArrayBuffer)return e&&e.push(t),t;if(ArrayBuffer.isView(t)){var r=t;return e&&e.push(r.buffer),r}if(t instanceof vn)return e&&e.push(t.data.buffer),t;if(Array.isArray(t)){for(var n=[],i=0,a=t;i<a.length;i+=1){var o=a[i];n.push(_n(o,e));}return n}if("object"==typeof t){var s=t.constructor,u=s._classRegistryKey;if(!u)throw new Error("can't serialize object of unregistered class");var l=s.serialize?s.serialize(t,e):{};if(!s.serialize){for(var p in t)if(t.hasOwnProperty(p)&&!(gn[u].omit.indexOf(p)>=0)){var c=t[p];l[p]=gn[u].shallow.indexOf(p)>=0?c:_n(c,e);}t instanceof Error&&(l.message=t.message);}if(l.$name)throw new Error("$name property is reserved for worker serialization logic.");return "Object"!==u&&(l.$name=u),l}throw new Error("can't serialize object of type "+typeof t)}function wn(t){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||t instanceof ArrayBuffer||ArrayBuffer.isView(t)||t instanceof vn)return t;if(Array.isArray(t))return t.map(wn);if("object"==typeof t){var e=t.$name||"Object",r=gn[e].klass;if(!r)throw new Error("can't deserialize unregistered class "+e);if(r.deserialize)return r.deserialize(t);for(var n=Object.create(r.prototype),i=0,a=Object.keys(t);i<a.length;i+=1){var o=a[i];if("$name"!==o){var s=t[o];n[o]=gn[e].shallow.indexOf(o)>=0?s:wn(s);}}return n}throw new Error("can't deserialize object of type "+typeof t)}var An=function(){this.first=!0;};An.prototype.update=function(t,e){var r=Math.floor(t);return this.first?(this.first=!1,this.lastIntegerZoom=r,this.lastIntegerZoomTime=0,this.lastZoom=t,this.lastFloorZoom=r,!0):(this.lastFloorZoom>r?(this.lastIntegerZoom=r+1,this.lastIntegerZoomTime=e):this.lastFloorZoom<r&&(this.lastIntegerZoom=r,this.lastIntegerZoomTime=e),t!==this.lastZoom&&(this.lastZoom=t,this.lastFloorZoom=r,!0))};var kn={"Latin-1 Supplement":function(t){return t>=128&&t<=255},Arabic:function(t){return t>=1536&&t<=1791},"Arabic Supplement":function(t){return t>=1872&&t<=1919},"Arabic Extended-A":function(t){return t>=2208&&t<=2303},"Hangul Jamo":function(t){return t>=4352&&t<=4607},"Unified Canadian Aboriginal Syllabics":function(t){return t>=5120&&t<=5759},Khmer:function(t){return t>=6016&&t<=6143},"Unified Canadian Aboriginal Syllabics Extended":function(t){return t>=6320&&t<=6399},"General Punctuation":function(t){return t>=8192&&t<=8303},"Letterlike Symbols":function(t){return t>=8448&&t<=8527},"Number Forms":function(t){return t>=8528&&t<=8591},"Miscellaneous Technical":function(t){return t>=8960&&t<=9215},"Control Pictures":function(t){return t>=9216&&t<=9279},"Optical Character Recognition":function(t){return t>=9280&&t<=9311},"Enclosed Alphanumerics":function(t){return t>=9312&&t<=9471},"Geometric Shapes":function(t){return t>=9632&&t<=9727},"Miscellaneous Symbols":function(t){return t>=9728&&t<=9983},"Miscellaneous Symbols and Arrows":function(t){return t>=11008&&t<=11263},"CJK Radicals Supplement":function(t){return t>=11904&&t<=12031},"Kangxi Radicals":function(t){return t>=12032&&t<=12255},"Ideographic Description Characters":function(t){return t>=12272&&t<=12287},"CJK Symbols and Punctuation":function(t){return t>=12288&&t<=12351},Hiragana:function(t){return t>=12352&&t<=12447},Katakana:function(t){return t>=12448&&t<=12543},Bopomofo:function(t){return t>=12544&&t<=12591},"Hangul Compatibility Jamo":function(t){return t>=12592&&t<=12687},Kanbun:function(t){return t>=12688&&t<=12703},"Bopomofo Extended":function(t){return t>=12704&&t<=12735},"CJK Strokes":function(t){return t>=12736&&t<=12783},"Katakana Phonetic Extensions":function(t){return t>=12784&&t<=12799},"Enclosed CJK Letters and Months":function(t){return t>=12800&&t<=13055},"CJK Compatibility":function(t){return t>=13056&&t<=13311},"CJK Unified Ideographs Extension A":function(t){return t>=13312&&t<=19903},"Yijing Hexagram Symbols":function(t){return t>=19904&&t<=19967},"CJK Unified Ideographs":function(t){return t>=19968&&t<=40959},"Yi Syllables":function(t){return t>=40960&&t<=42127},"Yi Radicals":function(t){return t>=42128&&t<=42191},"Hangul Jamo Extended-A":function(t){return t>=43360&&t<=43391},"Hangul Syllables":function(t){return t>=44032&&t<=55215},"Hangul Jamo Extended-B":function(t){return t>=55216&&t<=55295},"Private Use Area":function(t){return t>=57344&&t<=63743},"CJK Compatibility Ideographs":function(t){return t>=63744&&t<=64255},"Arabic Presentation Forms-A":function(t){return t>=64336&&t<=65023},"Vertical Forms":function(t){return t>=65040&&t<=65055},"CJK Compatibility Forms":function(t){return t>=65072&&t<=65103},"Small Form Variants":function(t){return t>=65104&&t<=65135},"Arabic Presentation Forms-B":function(t){return t>=65136&&t<=65279},"Halfwidth and Fullwidth Forms":function(t){return t>=65280&&t<=65519}};function Sn(t){for(var e=0,r=t;e<r.length;e+=1){if(In(r[e].charCodeAt(0)))return !0}return !1}function zn(t){return !kn.Arabic(t)&&(!kn["Arabic Supplement"](t)&&(!kn["Arabic Extended-A"](t)&&(!kn["Arabic Presentation Forms-A"](t)&&!kn["Arabic Presentation Forms-B"](t))))}function In(t){return 746===t||747===t||!(t<4352)&&(!!kn["Bopomofo Extended"](t)||(!!kn.Bopomofo(t)||(!(!kn["CJK Compatibility Forms"](t)||t>=65097&&t<=65103)||(!!kn["CJK Compatibility Ideographs"](t)||(!!kn["CJK Compatibility"](t)||(!!kn["CJK Radicals Supplement"](t)||(!!kn["CJK Strokes"](t)||(!(!kn["CJK Symbols and Punctuation"](t)||t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||(!!kn["CJK Unified Ideographs Extension A"](t)||(!!kn["CJK Unified Ideographs"](t)||(!!kn["Enclosed CJK Letters and Months"](t)||(!!kn["Hangul Compatibility Jamo"](t)||(!!kn["Hangul Jamo Extended-A"](t)||(!!kn["Hangul Jamo Extended-B"](t)||(!!kn["Hangul Jamo"](t)||(!!kn["Hangul Syllables"](t)||(!!kn.Hiragana(t)||(!!kn["Ideographic Description Characters"](t)||(!!kn.Kanbun(t)||(!!kn["Kangxi Radicals"](t)||(!!kn["Katakana Phonetic Extensions"](t)||(!(!kn.Katakana(t)||12540===t)||(!(!kn["Halfwidth and Fullwidth Forms"](t)||65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||(!(!kn["Small Form Variants"](t)||t>=65112&&t<=65118||t>=65123&&t<=65126)||(!!kn["Unified Canadian Aboriginal Syllabics"](t)||(!!kn["Unified Canadian Aboriginal Syllabics Extended"](t)||(!!kn["Vertical Forms"](t)||(!!kn["Yijing Hexagram Symbols"](t)||(!!kn["Yi Syllables"](t)||!!kn["Yi Radicals"](t))))))))))))))))))))))))))))))}function Cn(t){return !(In(t)||function(t){return !(!kn["Latin-1 Supplement"](t)||167!==t&&169!==t&&174!==t&&177!==t&&188!==t&&189!==t&&190!==t&&215!==t&&247!==t)||(!(!kn["General Punctuation"](t)||8214!==t&&8224!==t&&8225!==t&&8240!==t&&8241!==t&&8251!==t&&8252!==t&&8258!==t&&8263!==t&&8264!==t&&8265!==t&&8273!==t)||(!!kn["Letterlike Symbols"](t)||(!!kn["Number Forms"](t)||(!(!kn["Miscellaneous Technical"](t)||!(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||9003===t||t>=9085&&t<=9114||t>=9150&&t<=9165||9167===t||t>=9169&&t<=9179||t>=9186&&t<=9215))||(!(!kn["Control Pictures"](t)||9251===t)||(!!kn["Optical Character Recognition"](t)||(!!kn["Enclosed Alphanumerics"](t)||(!!kn["Geometric Shapes"](t)||(!(!kn["Miscellaneous Symbols"](t)||t>=9754&&t<=9759)||(!(!kn["Miscellaneous Symbols and Arrows"](t)||!(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243))||(!!kn["CJK Symbols and Punctuation"](t)||(!!kn.Katakana(t)||(!!kn["Private Use Area"](t)||(!!kn["CJK Compatibility Forms"](t)||(!!kn["Small Form Variants"](t)||(!!kn["Halfwidth and Fullwidth Forms"](t)||(8734===t||8756===t||8757===t||t>=9984&&t<=10087||t>=10102&&t<=10131||65532===t||65533===t)))))))))))))))))}(t))}function Bn(t,e){return !(!e&&(t>=1424&&t<=2303||kn["Arabic Presentation Forms-A"](t)||kn["Arabic Presentation Forms-B"](t)))&&!(t>=2304&&t<=3583||t>=3840&&t<=4255||kn.Khmer(t))}var En,Pn=!1,Mn=null,Tn=!1,Vn=new St,Fn={applyArabicShaping:null,processBidirectionalText:null,processStyledBidirectionalText:null,isLoaded:function(){return Tn||null!=Fn.applyArabicShaping}},On=function(t,e){this.zoom=t,e?(this.now=e.now,this.fadeDuration=e.fadeDuration,this.zoomHistory=e.zoomHistory,this.transition=e.transition):(this.now=0,this.fadeDuration=0,this.zoomHistory=new An,this.transition={});};On.prototype.isSupportedScript=function(t){return function(t,e){for(var r=0,n=t;r<n.length;r+=1){if(!Bn(n[r].charCodeAt(0),e))return !1}return !0}(t,Fn.isLoaded())},On.prototype.crossFadingFactor=function(){return 0===this.fadeDuration?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)},On.prototype.getCrossfadeParameters=function(){var t=this.zoom,e=t-Math.floor(t),r=this.crossFadingFactor();return t>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:e+(1-e)*r}:{fromScale:.5,toScale:1,t:1-(1-r)*e}};var Ln=function(t,e){this.property=t,this.value=e,this.expression=function(t,e){if(xr(t))return new Mr(t,e);if(Ir(t)){var r=Pr(t,e);if("error"===r.result)throw new Error(r.value.map(function(t){return t.key+": "+t.message}).join(", "));return r.value}var n=t;return "string"==typeof t&&"color"===e.type&&(n=Yt.parse(t)),{kind:"constant",evaluate:function(){return n}}}(void 0===e?t.specification.default:e,t.specification);};Ln.prototype.isDataDriven=function(){return "source"===this.expression.kind||"composite"===this.expression.kind},Ln.prototype.possiblyEvaluate=function(t,e){return this.property.possiblyEvaluate(this,t,e)};var Dn=function(t){this.property=t,this.value=new Ln(t,void 0);};Dn.prototype.transitioned=function(t,e){return new Rn(this.property,this.value,e,c({},t.transition,this.transition),t.now)},Dn.prototype.untransitioned=function(){return new Rn(this.property,this.value,null,{},0)};var Un=function(t){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues);};Un.prototype.getValue=function(t){return b(this._values[t].value.value)},Un.prototype.setValue=function(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new Dn(this._values[t].property)),this._values[t].value=new Ln(this._values[t].property,null===e?void 0:b(e));},Un.prototype.getTransition=function(t){return b(this._values[t].transition)},Un.prototype.setTransition=function(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new Dn(this._values[t].property)),this._values[t].transition=b(e)||void 0;},Un.prototype.serialize=function(){for(var t={},e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e],i=this.getValue(n);void 0!==i&&(t[n]=i);var a=this.getTransition(n);void 0!==a&&(t[n+"-transition"]=a);}return t},Un.prototype.transitioned=function(t,e){for(var r=new jn(this._properties),n=0,i=Object.keys(this._values);n<i.length;n+=1){var a=i[n];r._values[a]=this._values[a].transitioned(t,e._values[a]);}return r},Un.prototype.untransitioned=function(){for(var t=new jn(this._properties),e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e];t._values[n]=this._values[n].untransitioned();}return t};var Rn=function(t,e,r,n,i){this.property=t,this.value=e,this.begin=i+n.delay||0,this.end=this.begin+n.duration||0,t.specification.transition&&(n.delay||n.duration)&&(this.prior=r);};Rn.prototype.possiblyEvaluate=function(t,e){var r=t.now||0,n=this.value.possiblyEvaluate(t,e),i=this.prior;if(i){if(r>this.end)return this.prior=null,n;if(this.value.isDataDriven())return this.prior=null,n;if(r<this.begin)return i.possiblyEvaluate(t,e);var a=(r-this.begin)/(this.end-this.begin);return this.property.interpolate(i.possiblyEvaluate(t,e),n,function(t){if(t<=0)return 0;if(t>=1)return 1;var e=t*t,r=e*t;return 4*(t<.5?r:3*(t-e)+r-.75)}(a))}return n};var jn=function(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues);};jn.prototype.possiblyEvaluate=function(t,e){for(var r=new Kn(this._properties),n=0,i=Object.keys(this._values);n<i.length;n+=1){var a=i[n];r._values[a]=this._values[a].possiblyEvaluate(t,e);}return r},jn.prototype.hasTransition=function(){for(var t=0,e=Object.keys(this._values);t<e.length;t+=1){var r=e[t];if(this._values[r].prior)return !0}return !1};var qn=function(t){this._properties=t,this._values=Object.create(t.defaultPropertyValues);};qn.prototype.getValue=function(t){return b(this._values[t].value)},qn.prototype.setValue=function(t,e){this._values[t]=new Ln(this._values[t].property,null===e?void 0:b(e));},qn.prototype.serialize=function(){for(var t={},e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e],i=this.getValue(n);void 0!==i&&(t[n]=i);}return t},qn.prototype.possiblyEvaluate=function(t,e){for(var r=new Kn(this._properties),n=0,i=Object.keys(this._values);n<i.length;n+=1){var a=i[n];r._values[a]=this._values[a].possiblyEvaluate(t,e);}return r};var Nn=function(t,e,r){this.property=t,this.value=e,this.parameters=r;};Nn.prototype.isConstant=function(){return "constant"===this.value.kind},Nn.prototype.constantOr=function(t){return "constant"===this.value.kind?this.value.value:t},Nn.prototype.evaluate=function(t,e,r){return this.property.evaluate(this.value,this.parameters,t,e,r)};var Kn=function(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues);};Kn.prototype.get=function(t){return this._values[t]};var Zn=function(t){this.specification=t;};Zn.prototype.possiblyEvaluate=function(t,e){return t.expression.evaluate(e)},Zn.prototype.interpolate=function(t,e,r){var n=ke[this.specification.type];return n?n(t,e,r):t};var Xn=function(t,e){this.specification=t,this.overrides=e;};Xn.prototype.possiblyEvaluate=function(t,e,r){return "constant"===t.expression.kind||"camera"===t.expression.kind?new Nn(this,{kind:"constant",value:t.expression.evaluate(e,null,{},r)},e):new Nn(this,t.expression,e)},Xn.prototype.interpolate=function(t,e,r){if("constant"!==t.value.kind||"constant"!==e.value.kind)return t;if(void 0===t.value.value||void 0===e.value.value)return new Nn(this,{kind:"constant",value:void 0},t.parameters);var n=ke[this.specification.type];return n?new Nn(this,{kind:"constant",value:n(t.value.value,e.value.value,r)},t.parameters):t},Xn.prototype.evaluate=function(t,e,r,n,i){return "constant"===t.kind?t.value:t.evaluate(e,r,n,i)};var Gn=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.possiblyEvaluate=function(t,e,r){if(void 0===t.value)return new Nn(this,{kind:"constant",value:void 0},e);if("constant"===t.expression.kind){var n=t.expression.evaluate(e,null,{},r),i="image"===t.property.specification.type&&"string"!=typeof n?n.name:n,a=this._calculate(i,i,i,e);return new Nn(this,{kind:"constant",value:a},e)}if("camera"===t.expression.kind){var o=this._calculate(t.expression.evaluate({zoom:e.zoom-1}),t.expression.evaluate({zoom:e.zoom}),t.expression.evaluate({zoom:e.zoom+1}),e);return new Nn(this,{kind:"constant",value:o},e)}return new Nn(this,t.expression,e)},e.prototype.evaluate=function(t,e,r,n,i){if("source"===t.kind){var a=t.evaluate(e,r,n,i);return this._calculate(a,a,a,e)}return "composite"===t.kind?this._calculate(t.evaluate({zoom:Math.floor(e.zoom)-1},r,n),t.evaluate({zoom:Math.floor(e.zoom)},r,n),t.evaluate({zoom:Math.floor(e.zoom)+1},r,n),e):t.value},e.prototype._calculate=function(t,e,r,n){return n.zoom>n.zoomHistory.lastIntegerZoom?{from:t,to:e}:{from:r,to:e}},e.prototype.interpolate=function(t){return t},e}(Xn),Jn=function(t){this.specification=t;};Jn.prototype.possiblyEvaluate=function(t,e,r){if(void 0!==t.value){if("constant"===t.expression.kind){var n=t.expression.evaluate(e,null,{},r);return this._calculate(n,n,n,e)}return this._calculate(t.expression.evaluate(new On(Math.floor(e.zoom-1),e)),t.expression.evaluate(new On(Math.floor(e.zoom),e)),t.expression.evaluate(new On(Math.floor(e.zoom+1),e)),e)}},Jn.prototype._calculate=function(t,e,r,n){return n.zoom>n.zoomHistory.lastIntegerZoom?{from:t,to:e}:{from:r,to:e}},Jn.prototype.interpolate=function(t){return t};var Hn=function(t){this.specification=t;};Hn.prototype.possiblyEvaluate=function(t,e,r){return !!t.expression.evaluate(e,null,{},r)},Hn.prototype.interpolate=function(){return !1};var Yn=function(t){for(var e in this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[],t){var r=t[e];r.specification.overridable&&this.overridableProperties.push(e);var n=this.defaultPropertyValues[e]=new Ln(r,void 0),i=this.defaultTransitionablePropertyValues[e]=new Dn(r);this.defaultTransitioningPropertyValues[e]=i.untransitioned(),this.defaultPossiblyEvaluatedValues[e]=n.possiblyEvaluate({});}};xn("DataDrivenProperty",Xn),xn("DataConstantProperty",Zn),xn("CrossFadedDataDrivenProperty",Gn),xn("CrossFadedProperty",Jn),xn("ColorRampProperty",Hn);var $n=function(t){function e(e,r){if(t.call(this),this.id=e.id,this.type=e.type,this._featureFilter=function(){return !0},"custom"!==e.type&&(e=e,this.metadata=e.metadata,this.minzoom=e.minzoom,this.maxzoom=e.maxzoom,"background"!==e.type&&(this.source=e.source,this.sourceLayer=e["source-layer"],this.filter=e.filter),r.layout&&(this._unevaluatedLayout=new qn(r.layout)),r.paint)){for(var n in this._transitionablePaint=new Un(r.paint),e.paint)this.setPaintProperty(n,e.paint[n],{validate:!1});for(var i in e.layout)this.setLayoutProperty(i,e.layout[i],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned();}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getCrossfadeParameters=function(){return this._crossfadeParameters},e.prototype.getLayoutProperty=function(t){return "visibility"===t?this.visibility:this._unevaluatedLayout.getValue(t)},e.prototype.setLayoutProperty=function(t,e,r){if(void 0===r&&(r={}),null!=e){var n="layers."+this.id+".layout."+t;if(this._validate(hn,n,t,e,r))return}"visibility"!==t?this._unevaluatedLayout.setValue(t,e):this.visibility=e;},e.prototype.getPaintProperty=function(t){return v(t,"-transition")?this._transitionablePaint.getTransition(t.slice(0,-"-transition".length)):this._transitionablePaint.getValue(t)},e.prototype.setPaintProperty=function(t,e,r){if(void 0===r&&(r={}),null!=e){var n="layers."+this.id+".paint."+t;if(this._validate(cn,n,t,e,r))return !1}if(v(t,"-transition"))return this._transitionablePaint.setTransition(t.slice(0,-"-transition".length),e||void 0),!1;var i=this._transitionablePaint._values[t],a="cross-faded-data-driven"===i.property.specification["property-type"],o=i.value.isDataDriven(),s=i.value;this._transitionablePaint.setValue(t,e),this._handleSpecialPaintPropertyUpdate(t);var u=this._transitionablePaint._values[t].value;return u.isDataDriven()||o||a||this._handleOverridablePaintPropertyUpdate(t,s,u)},e.prototype._handleSpecialPaintPropertyUpdate=function(t){},e.prototype._handleOverridablePaintPropertyUpdate=function(t,e,r){return !1},e.prototype.isHidden=function(t){return !!(this.minzoom&&t<this.minzoom)||(!!(this.maxzoom&&t>=this.maxzoom)||"none"===this.visibility)},e.prototype.updateTransitions=function(t){this._transitioningPaint=this._transitionablePaint.transitioned(t,this._transitioningPaint);},e.prototype.hasTransition=function(){return this._transitioningPaint.hasTransition()},e.prototype.recalculate=function(t,e){t.getCrossfadeParameters&&(this._crossfadeParameters=t.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(t,e)),this.paint=this._transitioningPaint.possiblyEvaluate(t,e);},e.prototype.serialize=function(){var t={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(t.layout=t.layout||{},t.layout.visibility=this.visibility),x(t,function(t,e){return !(void 0===t||"layout"===e&&!Object.keys(t).length||"paint"===e&&!Object.keys(t).length)})},e.prototype._validate=function(t,e,r,n,i){return void 0===i&&(i={}),(!i||!1!==i.validate)&&fn(this,t.call(ln,{key:e,layerType:this.type,objectKey:r,value:n,styleSpec:zt,style:{glyphs:!0,sprite:!0}}))},e.prototype.is3D=function(){return !1},e.prototype.isTileClipped=function(){return !1},e.prototype.hasOffscreenPass=function(){return !1},e.prototype.resize=function(){},e.prototype.isStateDependent=function(){for(var t in this.paint._values){var e=this.paint.get(t);if(e instanceof Nn&&dr(e.property.specification)&&(("source"===e.value.kind||"composite"===e.value.kind)&&e.value.isStateDependent))return !0}return !1},e}(St),Wn={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Qn=function(t,e){this._structArray=t,this._pos1=e*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8;},ti=function(){this.isTransferred=!1,this.capacity=-1,this.resize(0);};function ei(t,e){void 0===e&&(e=1);var r=0,n=0;return {members:t.map(function(t){var i,a=(i=t.type,Wn[i].BYTES_PER_ELEMENT),o=r=ri(r,Math.max(e,a)),s=t.components||1;return n=Math.max(n,a),r+=a*s,{name:t.name,type:t.type,components:s,offset:o}}),size:ri(r,Math.max(n,e)),alignment:e}}function ri(t,e){return Math.ceil(t/e)*e}ti.serialize=function(t,e){return t._trim(),e&&(t.isTransferred=!0,e.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}},ti.deserialize=function(t){var e=Object.create(this.prototype);return e.arrayBuffer=t.arrayBuffer,e.length=t.length,e.capacity=t.arrayBuffer.byteLength/e.bytesPerElement,e._refreshViews(),e},ti.prototype._trim=function(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews());},ti.prototype.clear=function(){this.length=0;},ti.prototype.resize=function(t){this.reserve(t),this.length=t;},ti.prototype.reserve=function(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(5*this.capacity),128),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);var e=this.uint8;this._refreshViews(),e&&this.uint8.set(e);}},ti.prototype._refreshViews=function(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")};var ni=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.int16[n+0]=e,this.int16[n+1]=r,t},e}(ti);ni.prototype.bytesPerElement=4,xn("StructArrayLayout2i4",ni);var ii=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=4*t;return this.int16[a+0]=e,this.int16[a+1]=r,this.int16[a+2]=n,this.int16[a+3]=i,t},e}(ti);ii.prototype.bytesPerElement=8,xn("StructArrayLayout4i8",ii);var ai=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=6*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,this.int16[s+4]=a,this.int16[s+5]=o,t},e}(ti);ai.prototype.bytesPerElement=12,xn("StructArrayLayout2i4i12",ai);var oi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=4*t,u=8*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.uint8[u+4]=n,this.uint8[u+5]=i,this.uint8[u+6]=a,this.uint8[u+7]=o,t},e}(ti);oi.prototype.bytesPerElement=8,xn("StructArrayLayout2i4ub8",oi);var si=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s){var u=this.length;return this.resize(u+1),this.emplace(u,t,e,r,n,i,a,o,s)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u){var l=8*t;return this.uint16[l+0]=e,this.uint16[l+1]=r,this.uint16[l+2]=n,this.uint16[l+3]=i,this.uint16[l+4]=a,this.uint16[l+5]=o,this.uint16[l+6]=s,this.uint16[l+7]=u,t},e}(ti);si.prototype.bytesPerElement=16,xn("StructArrayLayout8ui16",si);var ui=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s){var u=this.length;return this.resize(u+1),this.emplace(u,t,e,r,n,i,a,o,s)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u){var l=8*t;return this.int16[l+0]=e,this.int16[l+1]=r,this.int16[l+2]=n,this.int16[l+3]=i,this.uint16[l+4]=a,this.uint16[l+5]=o,this.uint16[l+6]=s,this.uint16[l+7]=u,t},e}(ti);ui.prototype.bytesPerElement=16,xn("StructArrayLayout4i4ui16",ui);var li=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.float32[i+0]=e,this.float32[i+1]=r,this.float32[i+2]=n,t},e}(ti);li.prototype.bytesPerElement=12,xn("StructArrayLayout3f12",li);var pi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){var r=1*t;return this.uint32[r+0]=e,t},e}(ti);pi.prototype.bytesPerElement=4,xn("StructArrayLayout1ul4",pi);var ci=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p){var c=this.length;return this.resize(c+1),this.emplace(c,t,e,r,n,i,a,o,s,u,l,p)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c){var h=12*t,f=6*t;return this.int16[h+0]=e,this.int16[h+1]=r,this.int16[h+2]=n,this.int16[h+3]=i,this.int16[h+4]=a,this.int16[h+5]=o,this.uint32[f+3]=s,this.uint16[h+8]=u,this.uint16[h+9]=l,this.int16[h+10]=p,this.int16[h+11]=c,t},e}(ti);ci.prototype.bytesPerElement=24,xn("StructArrayLayout6i1ul2ui2i24",ci);var hi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=6*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,this.int16[s+4]=a,this.int16[s+5]=o,t},e}(ti);hi.prototype.bytesPerElement=12,xn("StructArrayLayout2i2i2i12",hi);var fi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=12*t,o=3*t;return this.uint8[a+0]=e,this.uint8[a+1]=r,this.float32[o+1]=n,this.float32[o+2]=i,t},e}(ti);fi.prototype.bytesPerElement=12,xn("StructArrayLayout2ub2f12",fi);var yi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m){var v=this.length;return this.resize(v+1),this.emplace(v,t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v){var g=24*t,x=12*t,b=48*t;return this.int16[g+0]=e,this.int16[g+1]=r,this.uint16[g+2]=n,this.uint16[g+3]=i,this.uint32[x+2]=a,this.uint32[x+3]=o,this.uint32[x+4]=s,this.uint16[g+10]=u,this.uint16[g+11]=l,this.uint16[g+12]=p,this.float32[x+7]=c,this.float32[x+8]=h,this.uint8[b+36]=f,this.uint8[b+37]=y,this.uint8[b+38]=d,this.uint32[x+10]=m,this.int16[g+22]=v,t},e}(ti);yi.prototype.bytesPerElement=48,xn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",yi);var di=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,_){var w=this.length;return this.resize(w+1),this.emplace(w,t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,_)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,_,w){var A=26*t,k=13*t;return this.int16[A+0]=e,this.int16[A+1]=r,this.int16[A+2]=n,this.int16[A+3]=i,this.int16[A+4]=a,this.int16[A+5]=o,this.int16[A+6]=s,this.uint16[A+7]=u,this.uint16[A+8]=l,this.uint16[A+9]=p,this.uint16[A+10]=c,this.uint16[A+11]=h,this.uint16[A+12]=f,this.uint16[A+13]=y,this.uint16[A+14]=d,this.uint16[A+15]=m,this.uint16[A+16]=v,this.uint16[A+17]=g,this.uint32[k+9]=x,this.float32[k+10]=b,this.float32[k+11]=_,this.float32[k+12]=w,t},e}(ti);di.prototype.bytesPerElement=52,xn("StructArrayLayout7i11ui1ul3f52",di);var mi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){var r=1*t;return this.float32[r+0]=e,t},e}(ti);mi.prototype.bytesPerElement=4,xn("StructArrayLayout1f4",mi);var vi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.int16[i+0]=e,this.int16[i+1]=r,this.int16[i+2]=n,t},e}(ti);vi.prototype.bytesPerElement=6,xn("StructArrayLayout3i6",vi);var gi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=2*t,a=4*t;return this.uint32[i+0]=e,this.uint16[a+2]=r,this.uint16[a+3]=n,t},e}(ti);gi.prototype.bytesPerElement=8,xn("StructArrayLayout1ul2ui8",gi);var xi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.uint16[i+0]=e,this.uint16[i+1]=r,this.uint16[i+2]=n,t},e}(ti);xi.prototype.bytesPerElement=6,xn("StructArrayLayout3ui6",xi);var bi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.uint16[n+0]=e,this.uint16[n+1]=r,t},e}(ti);bi.prototype.bytesPerElement=4,xn("StructArrayLayout2ui4",bi);var _i=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){var r=1*t;return this.uint16[r+0]=e,t},e}(ti);_i.prototype.bytesPerElement=2,xn("StructArrayLayout1ui2",_i);var wi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.float32[n+0]=e,this.float32[n+1]=r,t},e}(ti);wi.prototype.bytesPerElement=8,xn("StructArrayLayout2f8",wi);var Ai=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=4*t;return this.float32[a+0]=e,this.float32[a+1]=r,this.float32[a+2]=n,this.float32[a+3]=i,t},e}(ti);Ai.prototype.bytesPerElement=16,xn("StructArrayLayout4f16",Ai);var ki=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={anchorPointX:{configurable:!0},anchorPointY:{configurable:!0},x1:{configurable:!0},y1:{configurable:!0},x2:{configurable:!0},y2:{configurable:!0},featureIndex:{configurable:!0},sourceLayerIndex:{configurable:!0},bucketIndex:{configurable:!0},radius:{configurable:!0},signedDistanceFromAnchor:{configurable:!0},anchorPoint:{configurable:!0}};return r.anchorPointX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorPointX.set=function(t){this._structArray.int16[this._pos2+0]=t;},r.anchorPointY.get=function(){return this._structArray.int16[this._pos2+1]},r.anchorPointY.set=function(t){this._structArray.int16[this._pos2+1]=t;},r.x1.get=function(){return this._structArray.int16[this._pos2+2]},r.x1.set=function(t){this._structArray.int16[this._pos2+2]=t;},r.y1.get=function(){return this._structArray.int16[this._pos2+3]},r.y1.set=function(t){this._structArray.int16[this._pos2+3]=t;},r.x2.get=function(){return this._structArray.int16[this._pos2+4]},r.x2.set=function(t){this._structArray.int16[this._pos2+4]=t;},r.y2.get=function(){return this._structArray.int16[this._pos2+5]},r.y2.set=function(t){this._structArray.int16[this._pos2+5]=t;},r.featureIndex.get=function(){return this._structArray.uint32[this._pos4+3]},r.featureIndex.set=function(t){this._structArray.uint32[this._pos4+3]=t;},r.sourceLayerIndex.get=function(){return this._structArray.uint16[this._pos2+8]},r.sourceLayerIndex.set=function(t){this._structArray.uint16[this._pos2+8]=t;},r.bucketIndex.get=function(){return this._structArray.uint16[this._pos2+9]},r.bucketIndex.set=function(t){this._structArray.uint16[this._pos2+9]=t;},r.radius.get=function(){return this._structArray.int16[this._pos2+10]},r.radius.set=function(t){this._structArray.int16[this._pos2+10]=t;},r.signedDistanceFromAnchor.get=function(){return this._structArray.int16[this._pos2+11]},r.signedDistanceFromAnchor.set=function(t){this._structArray.int16[this._pos2+11]=t;},r.anchorPoint.get=function(){return new i(this.anchorPointX,this.anchorPointY)},Object.defineProperties(e.prototype,r),e}(Qn);ki.prototype.size=24;var Si=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){return new ki(this,t)},e}(ci);xn("CollisionBoxArray",Si);var zi=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={anchorX:{configurable:!0},anchorY:{configurable:!0},glyphStartIndex:{configurable:!0},numGlyphs:{configurable:!0},vertexStartIndex:{configurable:!0},lineStartIndex:{configurable:!0},lineLength:{configurable:!0},segment:{configurable:!0},lowerSize:{configurable:!0},upperSize:{configurable:!0},lineOffsetX:{configurable:!0},lineOffsetY:{configurable:!0},writingMode:{configurable:!0},placedOrientation:{configurable:!0},hidden:{configurable:!0},crossTileID:{configurable:!0},associatedIconIndex:{configurable:!0}};return r.anchorX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorX.set=function(t){this._structArray.int16[this._pos2+0]=t;},r.anchorY.get=function(){return this._structArray.int16[this._pos2+1]},r.anchorY.set=function(t){this._structArray.int16[this._pos2+1]=t;},r.glyphStartIndex.get=function(){return this._structArray.uint16[this._pos2+2]},r.glyphStartIndex.set=function(t){this._structArray.uint16[this._pos2+2]=t;},r.numGlyphs.get=function(){return this._structArray.uint16[this._pos2+3]},r.numGlyphs.set=function(t){this._structArray.uint16[this._pos2+3]=t;},r.vertexStartIndex.get=function(){return this._structArray.uint32[this._pos4+2]},r.vertexStartIndex.set=function(t){this._structArray.uint32[this._pos4+2]=t;},r.lineStartIndex.get=function(){return this._structArray.uint32[this._pos4+3]},r.lineStartIndex.set=function(t){this._structArray.uint32[this._pos4+3]=t;},r.lineLength.get=function(){return this._structArray.uint32[this._pos4+4]},r.lineLength.set=function(t){this._structArray.uint32[this._pos4+4]=t;},r.segment.get=function(){return this._structArray.uint16[this._pos2+10]},r.segment.set=function(t){this._structArray.uint16[this._pos2+10]=t;},r.lowerSize.get=function(){return this._structArray.uint16[this._pos2+11]},r.lowerSize.set=function(t){this._structArray.uint16[this._pos2+11]=t;},r.upperSize.get=function(){return this._structArray.uint16[this._pos2+12]},r.upperSize.set=function(t){this._structArray.uint16[this._pos2+12]=t;},r.lineOffsetX.get=function(){return this._structArray.float32[this._pos4+7]},r.lineOffsetX.set=function(t){this._structArray.float32[this._pos4+7]=t;},r.lineOffsetY.get=function(){return this._structArray.float32[this._pos4+8]},r.lineOffsetY.set=function(t){this._structArray.float32[this._pos4+8]=t;},r.writingMode.get=function(){return this._structArray.uint8[this._pos1+36]},r.writingMode.set=function(t){this._structArray.uint8[this._pos1+36]=t;},r.placedOrientation.get=function(){return this._structArray.uint8[this._pos1+37]},r.placedOrientation.set=function(t){this._structArray.uint8[this._pos1+37]=t;},r.hidden.get=function(){return this._structArray.uint8[this._pos1+38]},r.hidden.set=function(t){this._structArray.uint8[this._pos1+38]=t;},r.crossTileID.get=function(){return this._structArray.uint32[this._pos4+10]},r.crossTileID.set=function(t){this._structArray.uint32[this._pos4+10]=t;},r.associatedIconIndex.get=function(){return this._structArray.int16[this._pos2+22]},r.associatedIconIndex.set=function(t){this._structArray.int16[this._pos2+22]=t;},Object.defineProperties(e.prototype,r),e}(Qn);zi.prototype.size=48;var Ii=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){return new zi(this,t)},e}(yi);xn("PlacedSymbolArray",Ii);var Ci=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={anchorX:{configurable:!0},anchorY:{configurable:!0},rightJustifiedTextSymbolIndex:{configurable:!0},centerJustifiedTextSymbolIndex:{configurable:!0},leftJustifiedTextSymbolIndex:{configurable:!0},verticalPlacedTextSymbolIndex:{configurable:!0},placedIconSymbolIndex:{configurable:!0},key:{configurable:!0},textBoxStartIndex:{configurable:!0},textBoxEndIndex:{configurable:!0},verticalTextBoxStartIndex:{configurable:!0},verticalTextBoxEndIndex:{configurable:!0},iconBoxStartIndex:{configurable:!0},iconBoxEndIndex:{configurable:!0},featureIndex:{configurable:!0},numHorizontalGlyphVertices:{configurable:!0},numVerticalGlyphVertices:{configurable:!0},numIconVertices:{configurable:!0},crossTileID:{configurable:!0},textBoxScale:{configurable:!0},textOffset0:{configurable:!0},textOffset1:{configurable:!0}};return r.anchorX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorX.set=function(t){this._structArray.int16[this._pos2+0]=t;},r.anchorY.get=function(){return this._structArray.int16[this._pos2+1]},r.anchorY.set=function(t){this._structArray.int16[this._pos2+1]=t;},r.rightJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+2]},r.rightJustifiedTextSymbolIndex.set=function(t){this._structArray.int16[this._pos2+2]=t;},r.centerJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+3]},r.centerJustifiedTextSymbolIndex.set=function(t){this._structArray.int16[this._pos2+3]=t;},r.leftJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+4]},r.leftJustifiedTextSymbolIndex.set=function(t){this._structArray.int16[this._pos2+4]=t;},r.verticalPlacedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+5]},r.verticalPlacedTextSymbolIndex.set=function(t){this._structArray.int16[this._pos2+5]=t;},r.placedIconSymbolIndex.get=function(){return this._structArray.int16[this._pos2+6]},r.placedIconSymbolIndex.set=function(t){this._structArray.int16[this._pos2+6]=t;},r.key.get=function(){return this._structArray.uint16[this._pos2+7]},r.key.set=function(t){this._structArray.uint16[this._pos2+7]=t;},r.textBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+8]},r.textBoxStartIndex.set=function(t){this._structArray.uint16[this._pos2+8]=t;},r.textBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+9]},r.textBoxEndIndex.set=function(t){this._structArray.uint16[this._pos2+9]=t;},r.verticalTextBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+10]},r.verticalTextBoxStartIndex.set=function(t){this._structArray.uint16[this._pos2+10]=t;},r.verticalTextBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+11]},r.verticalTextBoxEndIndex.set=function(t){this._structArray.uint16[this._pos2+11]=t;},r.iconBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+12]},r.iconBoxStartIndex.set=function(t){this._structArray.uint16[this._pos2+12]=t;},r.iconBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+13]},r.iconBoxEndIndex.set=function(t){this._structArray.uint16[this._pos2+13]=t;},r.featureIndex.get=function(){return this._structArray.uint16[this._pos2+14]},r.featureIndex.set=function(t){this._structArray.uint16[this._pos2+14]=t;},r.numHorizontalGlyphVertices.get=function(){return this._structArray.uint16[this._pos2+15]},r.numHorizontalGlyphVertices.set=function(t){this._structArray.uint16[this._pos2+15]=t;},r.numVerticalGlyphVertices.get=function(){return this._structArray.uint16[this._pos2+16]},r.numVerticalGlyphVertices.set=function(t){this._structArray.uint16[this._pos2+16]=t;},r.numIconVertices.get=function(){return this._structArray.uint16[this._pos2+17]},r.numIconVertices.set=function(t){this._structArray.uint16[this._pos2+17]=t;},r.crossTileID.get=function(){return this._structArray.uint32[this._pos4+9]},r.crossTileID.set=function(t){this._structArray.uint32[this._pos4+9]=t;},r.textBoxScale.get=function(){return this._structArray.float32[this._pos4+10]},r.textBoxScale.set=function(t){this._structArray.float32[this._pos4+10]=t;},r.textOffset0.get=function(){return this._structArray.float32[this._pos4+11]},r.textOffset0.set=function(t){this._structArray.float32[this._pos4+11]=t;},r.textOffset1.get=function(){return this._structArray.float32[this._pos4+12]},r.textOffset1.set=function(t){this._structArray.float32[this._pos4+12]=t;},Object.defineProperties(e.prototype,r),e}(Qn);Ci.prototype.size=52;var Bi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){return new Ci(this,t)},e}(di);xn("SymbolInstanceArray",Bi);var Ei=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={offsetX:{configurable:!0}};return r.offsetX.get=function(){return this._structArray.float32[this._pos4+0]},r.offsetX.set=function(t){this._structArray.float32[this._pos4+0]=t;},Object.defineProperties(e.prototype,r),e}(Qn);Ei.prototype.size=4;var Pi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getoffsetX=function(t){return this.float32[1*t+0]},e.prototype.get=function(t){return new Ei(this,t)},e}(mi);xn("GlyphOffsetArray",Pi);var Mi=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={x:{configurable:!0},y:{configurable:!0},tileUnitDistanceFromAnchor:{configurable:!0}};return r.x.get=function(){return this._structArray.int16[this._pos2+0]},r.x.set=function(t){this._structArray.int16[this._pos2+0]=t;},r.y.get=function(){return this._structArray.int16[this._pos2+1]},r.y.set=function(t){this._structArray.int16[this._pos2+1]=t;},r.tileUnitDistanceFromAnchor.get=function(){return this._structArray.int16[this._pos2+2]},r.tileUnitDistanceFromAnchor.set=function(t){this._structArray.int16[this._pos2+2]=t;},Object.defineProperties(e.prototype,r),e}(Qn);Mi.prototype.size=6;var Ti=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getx=function(t){return this.int16[3*t+0]},e.prototype.gety=function(t){return this.int16[3*t+1]},e.prototype.gettileUnitDistanceFromAnchor=function(t){return this.int16[3*t+2]},e.prototype.get=function(t){return new Mi(this,t)},e}(vi);xn("SymbolLineVertexArray",Ti);var Vi=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={featureIndex:{configurable:!0},sourceLayerIndex:{configurable:!0},bucketIndex:{configurable:!0}};return r.featureIndex.get=function(){return this._structArray.uint32[this._pos4+0]},r.featureIndex.set=function(t){this._structArray.uint32[this._pos4+0]=t;},r.sourceLayerIndex.get=function(){return this._structArray.uint16[this._pos2+2]},r.sourceLayerIndex.set=function(t){this._structArray.uint16[this._pos2+2]=t;},r.bucketIndex.get=function(){return this._structArray.uint16[this._pos2+3]},r.bucketIndex.set=function(t){this._structArray.uint16[this._pos2+3]=t;},Object.defineProperties(e.prototype,r),e}(Qn);Vi.prototype.size=8;var Fi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){return new Vi(this,t)},e}(gi);xn("FeatureIndexArray",Fi);var Oi=ei([{name:"a_pos",components:2,type:"Int16"}],4).members,Li=function(t){void 0===t&&(t=[]),this.segments=t;};function Di(t,e){return 256*(t=l(Math.floor(t),0,255))+(e=l(Math.floor(e),0,255))}Li.prototype.prepareSegment=function(t,e,r,n){var i=this.segments[this.segments.length-1];return t>Li.MAX_VERTEX_ARRAY_LENGTH&&w("Max vertices per segment is "+Li.MAX_VERTEX_ARRAY_LENGTH+": bucket requested "+t),(!i||i.vertexLength+t>Li.MAX_VERTEX_ARRAY_LENGTH||i.sortKey!==n)&&(i={vertexOffset:e.length,primitiveOffset:r.length,vertexLength:0,primitiveLength:0},void 0!==n&&(i.sortKey=n),this.segments.push(i)),i},Li.prototype.get=function(){return this.segments},Li.prototype.destroy=function(){for(var t=0,e=this.segments;t<e.length;t+=1){var r=e[t];for(var n in r.vaos)r.vaos[n].destroy();}},Li.simpleSegment=function(t,e,r,n){return new Li([{vertexOffset:t,primitiveOffset:e,vertexLength:r,primitiveLength:n,vaos:{},sortKey:0}])},Li.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1,xn("SegmentVector",Li);var Ui=function(){this.ids=[],this.positions=[],this.indexed=!1;};function Ri(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}Ui.prototype.add=function(t,e,r,n){this.ids.push(t),this.positions.push(e,r,n);},Ui.prototype.getPositions=function(t){for(var e=0,r=this.ids.length-1;e<r;){var n=e+r>>1;this.ids[n]>=t?r=n:e=n+1;}for(var i=[];this.ids[e]===t;){var a=this.positions[3*e],o=this.positions[3*e+1],s=this.positions[3*e+2];i.push({index:a,start:o,end:s}),e++;}return i},Ui.serialize=function(t,e){var r=new Float64Array(t.ids),n=new Uint32Array(t.positions);return function t(e,r,n,i){if(n>=i)return;var a=e[n+i>>1];var o=n-1;var s=i+1;for(;;){do{o++;}while(e[o]<a);do{s--;}while(e[s]>a);if(o>=s)break;Ri(e,o,s),Ri(r,3*o,3*s),Ri(r,3*o+1,3*s+1),Ri(r,3*o+2,3*s+2);}t(e,r,n,s);t(e,r,s+1,i);}(r,n,0,r.length-1),e.push(r.buffer,n.buffer),{ids:r,positions:n}},Ui.deserialize=function(t){var e=new Ui;return e.ids=t.ids,e.positions=t.positions,e.indexed=!0,e},xn("FeaturePositionMap",Ui);var ji=function(t,e){this.gl=t.gl,this.location=e;},qi=function(t){function e(e,r){t.call(this,e,r),this.current=0;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){this.current!==t&&(this.current=t,this.gl.uniform1i(this.location,t));},e}(ji),Ni=function(t){function e(e,r){t.call(this,e,r),this.current=0;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){this.current!==t&&(this.current=t,this.gl.uniform1f(this.location,t));},e}(ji),Ki=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0];}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]||(this.current=t,this.gl.uniform2f(this.location,t[0],t[1]));},e}(ji),Zi=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0,0];}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]&&t[2]===this.current[2]||(this.current=t,this.gl.uniform3f(this.location,t[0],t[1],t[2]));},e}(ji),Xi=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0,0,0];}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]&&t[2]===this.current[2]&&t[3]===this.current[3]||(this.current=t,this.gl.uniform4f(this.location,t[0],t[1],t[2],t[3]));},e}(ji),Gi=function(t){function e(e,r){t.call(this,e,r),this.current=Yt.transparent;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){t.r===this.current.r&&t.g===this.current.g&&t.b===this.current.b&&t.a===this.current.a||(this.current=t,this.gl.uniform4f(this.location,t.r,t.g,t.b,t.a));},e}(ji),Ji=new Float32Array(16),Hi=function(t){function e(e,r){t.call(this,e,r),this.current=Ji;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){if(t[12]!==this.current[12]||t[0]!==this.current[0])return this.current=t,void this.gl.uniformMatrix4fv(this.location,!1,t);for(var e=1;e<16;e++)if(t[e]!==this.current[e]){this.current=t,this.gl.uniformMatrix4fv(this.location,!1,t);break}},e}(ji);function Yi(t){return [Di(255*t.r,255*t.g),Di(255*t.b,255*t.a)]}var $i=function(t,e,r){this.value=t,this.names=e,this.uniformNames=this.names.map(function(t){return "u_"+t}),this.type=r,this.maxValue=-1/0;};$i.prototype.defines=function(){return this.names.map(function(t){return "#define HAS_UNIFORM_u_"+t})},$i.prototype.setConstantPatternPositions=function(){},$i.prototype.populatePaintArray=function(){},$i.prototype.updatePaintArray=function(){},$i.prototype.upload=function(){},$i.prototype.destroy=function(){},$i.prototype.setUniforms=function(t,e,r,n){e.set(n.constantOr(this.value));},$i.prototype.getBinding=function(t,e){return "color"===this.type?new Gi(t,e):new Ni(t,e)},$i.serialize=function(t){var e=t.value,r=t.names,n=t.type;return {value:_n(e),names:r,type:n}},$i.deserialize=function(t){var e=t.value,r=t.names,n=t.type;return new $i(wn(e),r,n)};var Wi=function(t,e,r){this.value=t,this.names=e,this.uniformNames=this.names.map(function(t){return "u_"+t}),this.type=r,this.maxValue=-1/0,this.patternPositions={patternTo:null,patternFrom:null};};Wi.prototype.defines=function(){return this.names.map(function(t){return "#define HAS_UNIFORM_u_"+t})},Wi.prototype.populatePaintArray=function(){},Wi.prototype.updatePaintArray=function(){},Wi.prototype.upload=function(){},Wi.prototype.destroy=function(){},Wi.prototype.setConstantPatternPositions=function(t,e){this.patternPositions.patternTo=t.tlbr,this.patternPositions.patternFrom=e.tlbr;},Wi.prototype.setUniforms=function(t,e,r,n,i){var a=this.patternPositions;"u_pattern_to"===i&&a.patternTo&&e.set(a.patternTo),"u_pattern_from"===i&&a.patternFrom&&e.set(a.patternFrom);},Wi.prototype.getBinding=function(t,e){return new Xi(t,e)};var Qi=function(t,e,r,n){this.expression=t,this.names=e,this.type=r,this.uniformNames=this.names.map(function(t){return "a_"+t}),this.maxValue=-1/0,this.paintVertexAttributes=e.map(function(t){return {name:"a_"+t,type:"Float32",components:"color"===r?2:1,offset:0}}),this.paintVertexArray=new n;};Qi.prototype.defines=function(){return []},Qi.prototype.setConstantPatternPositions=function(){},Qi.prototype.populatePaintArray=function(t,e,r,n){var i=this.paintVertexArray,a=i.length;i.reserve(t);var o=this.expression.evaluate(new On(0),e,{},[],n);if("color"===this.type)for(var s=Yi(o),u=a;u<t;u++)i.emplaceBack(s[0],s[1]);else{for(var l=a;l<t;l++)i.emplaceBack(o);this.maxValue=Math.max(this.maxValue,o);}},Qi.prototype.updatePaintArray=function(t,e,r,n){var i=this.paintVertexArray,a=this.expression.evaluate({zoom:0},r,n);if("color"===this.type)for(var o=Yi(a),s=t;s<e;s++)i.emplace(s,o[0],o[1]);else{for(var u=t;u<e;u++)i.emplace(u,a);this.maxValue=Math.max(this.maxValue,a);}},Qi.prototype.upload=function(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));},Qi.prototype.destroy=function(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();},Qi.prototype.setUniforms=function(t,e){e.set(0);},Qi.prototype.getBinding=function(t,e){return new Ni(t,e)};var ta=function(t,e,r,n,i,a){this.expression=t,this.names=e,this.uniformNames=this.names.map(function(t){return "u_"+t+"_t"}),this.type=r,this.useIntegerZoom=n,this.zoom=i,this.maxValue=-1/0;var o=a;this.paintVertexAttributes=e.map(function(t){return {name:"a_"+t,type:"Float32",components:"color"===r?4:2,offset:0}}),this.paintVertexArray=new o;};ta.prototype.defines=function(){return []},ta.prototype.setConstantPatternPositions=function(){},ta.prototype.populatePaintArray=function(t,e,r,n){var i=this.paintVertexArray,a=i.length;i.reserve(t);var o=this.expression.evaluate(new On(this.zoom),e,{},[],n),s=this.expression.evaluate(new On(this.zoom+1),e,{},[],n);if("color"===this.type)for(var u=Yi(o),l=Yi(s),p=a;p<t;p++)i.emplaceBack(u[0],u[1],l[0],l[1]);else{for(var c=a;c<t;c++)i.emplaceBack(o,s);this.maxValue=Math.max(this.maxValue,o,s);}},ta.prototype.updatePaintArray=function(t,e,r,n){var i=this.paintVertexArray,a=this.expression.evaluate({zoom:this.zoom},r,n),o=this.expression.evaluate({zoom:this.zoom+1},r,n);if("color"===this.type)for(var s=Yi(a),u=Yi(o),l=t;l<e;l++)i.emplace(l,s[0],s[1],u[0],u[1]);else{for(var p=t;p<e;p++)i.emplace(p,a,o);this.maxValue=Math.max(this.maxValue,a,o);}},ta.prototype.upload=function(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));},ta.prototype.destroy=function(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();},ta.prototype.interpolationFactor=function(t){return this.useIntegerZoom?this.expression.interpolationFactor(Math.floor(t),this.zoom,this.zoom+1):this.expression.interpolationFactor(t,this.zoom,this.zoom+1)},ta.prototype.setUniforms=function(t,e,r){e.set(this.interpolationFactor(r.zoom));},ta.prototype.getBinding=function(t,e){return new Ni(t,e)};var ea=function(t,e,r,n,i,a,o){this.expression=t,this.names=e,this.type=r,this.uniformNames=this.names.map(function(t){return "u_"+t+"_t"}),this.useIntegerZoom=n,this.zoom=i,this.maxValue=-1/0,this.layerId=o,this.paintVertexAttributes=e.map(function(t){return {name:"a_"+t,type:"Uint16",components:4,offset:0}}),this.zoomInPaintVertexArray=new a,this.zoomOutPaintVertexArray=new a;};ea.prototype.defines=function(){return []},ea.prototype.setConstantPatternPositions=function(){},ea.prototype.populatePaintArray=function(t,e,r){var n=this.zoomInPaintVertexArray,i=this.zoomOutPaintVertexArray,a=this.layerId,o=n.length;if(n.reserve(t),i.reserve(t),r&&e.patterns&&e.patterns[a]){var s=e.patterns[a],u=s.min,l=s.mid,p=s.max,c=r[u],h=r[l],f=r[p];if(!c||!h||!f)return;for(var y=o;y<t;y++)n.emplaceBack(h.tl[0],h.tl[1],h.br[0],h.br[1],c.tl[0],c.tl[1],c.br[0],c.br[1]),i.emplaceBack(h.tl[0],h.tl[1],h.br[0],h.br[1],f.tl[0],f.tl[1],f.br[0],f.br[1]);}},ea.prototype.updatePaintArray=function(t,e,r,n,i){var a=this.zoomInPaintVertexArray,o=this.zoomOutPaintVertexArray,s=this.layerId;if(i&&r.patterns&&r.patterns[s]){var u=r.patterns[s],l=u.min,p=u.mid,c=u.max,h=i[l],f=i[p],y=i[c];if(!h||!f||!y)return;for(var d=t;d<e;d++)a.emplace(d,f.tl[0],f.tl[1],f.br[0],f.br[1],h.tl[0],h.tl[1],h.br[0],h.br[1]),o.emplace(d,f.tl[0],f.tl[1],f.br[0],f.br[1],y.tl[0],y.tl[1],y.br[0],y.br[1]);}},ea.prototype.upload=function(t){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=t.createVertexBuffer(this.zoomInPaintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=t.createVertexBuffer(this.zoomOutPaintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));},ea.prototype.destroy=function(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy();},ea.prototype.setUniforms=function(t,e){e.set(0);},ea.prototype.getBinding=function(t,e){return new Ni(t,e)};var ra=function(){this.binders={},this.cacheKey="",this._buffers=[],this._featureMap=new Ui,this._bufferOffset=0;};ra.createDynamic=function(t,e,r){var n=new ra,i=[];for(var a in t.paint._values)if(r(a)){var o=t.paint.get(a);if(o instanceof Nn&&dr(o.property.specification)){var s=ia(a,t.type),u=o.property.specification.type,l=o.property.useIntegerZoom;if("cross-faded"===o.property.specification["property-type"]||"cross-faded-data-driven"===o.property.specification["property-type"])if("constant"===o.value.kind)n.binders[a]=new Wi(o.value.value,s,u),i.push("/u_"+a);else{var p=aa(a,u,"source");n.binders[a]=new ea(o.value,s,u,l,e,p,t.id),i.push("/a_"+a);}else if("constant"===o.value.kind)n.binders[a]=new $i(o.value.value,s,u),i.push("/u_"+a);else if("source"===o.value.kind){var c=aa(a,u,"source");n.binders[a]=new Qi(o.value,s,u,c),i.push("/a_"+a);}else{var h=aa(a,u,"composite");n.binders[a]=new ta(o.value,s,u,l,e,h),i.push("/z_"+a);}}}return n.cacheKey=i.sort().join(""),n},ra.prototype.populatePaintArrays=function(t,e,r,n,i){for(var a in this.binders){this.binders[a].populatePaintArray(t,e,n,i);}void 0!==e.id&&this._featureMap.add(+e.id,r,this._bufferOffset,t),this._bufferOffset=t;},ra.prototype.setConstantPatternPositions=function(t,e){for(var r in this.binders){this.binders[r].setConstantPatternPositions(t,e);}},ra.prototype.updatePaintArrays=function(t,e,r,n){var i=!1;for(var a in t)for(var o=0,s=this._featureMap.getPositions(+a);o<s.length;o+=1){var u=s[o],l=e.feature(u.index);for(var p in this.binders){var c=this.binders[p];if(!(c instanceof $i||c instanceof Wi)&&!0===c.expression.isStateDependent){var h=r.paint.get(p);c.expression=h.value,c.updatePaintArray(u.start,u.end,l,t[a],n),i=!0;}}}return i},ra.prototype.defines=function(){var t=[];for(var e in this.binders)t.push.apply(t,this.binders[e].defines());return t},ra.prototype.getPaintVertexBuffers=function(){return this._buffers},ra.prototype.getUniforms=function(t,e){var r=[];for(var n in this.binders)for(var i=this.binders[n],a=0,o=i.uniformNames;a<o.length;a+=1){var s=o[a];if(e[s]){var u=i.getBinding(t,e[s]);r.push({name:s,property:n,binding:u});}}return r},ra.prototype.setUniforms=function(t,e,r,n){for(var i=0,a=e;i<a.length;i+=1){var o=a[i],s=o.name,u=o.property,l=o.binding;this.binders[u].setUniforms(t,l,n,r.get(u),s);}},ra.prototype.updatePatternPaintBuffers=function(t){var e=[];for(var r in this.binders){var n=this.binders[r];if(n instanceof ea){var i=2===t.fromScale?n.zoomInPaintVertexBuffer:n.zoomOutPaintVertexBuffer;i&&e.push(i);}else(n instanceof Qi||n instanceof ta)&&n.paintVertexBuffer&&e.push(n.paintVertexBuffer);}this._buffers=e;},ra.prototype.upload=function(t){for(var e in this.binders)this.binders[e].upload(t);var r=[];for(var n in this.binders){var i=this.binders[n];(i instanceof Qi||i instanceof ta)&&i.paintVertexBuffer&&r.push(i.paintVertexBuffer);}this._buffers=r;},ra.prototype.destroy=function(){for(var t in this.binders)this.binders[t].destroy();};var na=function(t,e,r,n){void 0===n&&(n=function(){return !0}),this.programConfigurations={};for(var i=0,a=e;i<a.length;i+=1){var o=a[i];this.programConfigurations[o.id]=ra.createDynamic(o,r,n),this.programConfigurations[o.id].layoutAttributes=t;}this.needsUpload=!1;};function ia(t,e){return {"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from"],"fill-pattern":["pattern_to","pattern_from"],"fill-extrusion-pattern":["pattern_to","pattern_from"]}[t]||[t.replace(e+"-","").replace(/-/g,"_")]}function aa(t,e,r){var n={color:{source:wi,composite:Ai},number:{source:mi,composite:wi}},i=function(t){return {"line-pattern":{source:si,composite:si},"fill-pattern":{source:si,composite:si},"fill-extrusion-pattern":{source:si,composite:si}}[t]}(t);return i&&i[r]||n[e][r]}na.prototype.populatePaintArrays=function(t,e,r,n,i){for(var a in this.programConfigurations)this.programConfigurations[a].populatePaintArrays(t,e,r,n,i);this.needsUpload=!0;},na.prototype.updatePaintArrays=function(t,e,r,n){for(var i=0,a=r;i<a.length;i+=1){var o=a[i];this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(t,e,o,n)||this.needsUpload;}},na.prototype.get=function(t){return this.programConfigurations[t]},na.prototype.upload=function(t){if(this.needsUpload){for(var e in this.programConfigurations)this.programConfigurations[e].upload(t);this.needsUpload=!1;}},na.prototype.destroy=function(){for(var t in this.programConfigurations)this.programConfigurations[t].destroy();},xn("ConstantBinder",$i),xn("CrossFadedConstantBinder",Wi),xn("SourceExpressionBinder",Qi),xn("CrossFadedCompositeBinder",ea),xn("CompositeExpressionBinder",ta),xn("ProgramConfiguration",ra,{omit:["_buffers"]}),xn("ProgramConfigurationSet",na);var oa=8192;var sa,ua=(sa=15,{min:-1*Math.pow(2,sa-1),max:Math.pow(2,sa-1)-1});function la(t){for(var e=oa/t.extent,r=t.loadGeometry(),n=0;n<r.length;n++)for(var i=r[n],a=0;a<i.length;a++){var o=i[a];o.x=Math.round(o.x*e),o.y=Math.round(o.y*e),(o.x<ua.min||o.x>ua.max||o.y<ua.min||o.y>ua.max)&&(w("Geometry exceeds allowed extent, reduce your vector tile buffer size"),o.x=l(o.x,ua.min,ua.max),o.y=l(o.y,ua.min,ua.max));}return r}function pa(t,e,r,n,i){t.emplaceBack(2*e+(n+1)/2,2*r+(i+1)/2);}var ca=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(function(t){return t.id}),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new ni,this.indexArray=new xi,this.segments=new Li,this.programConfigurations=new na(Oi,t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter(function(t){return t.isStateDependent()}).map(function(t){return t.id});};function ha(t,e){for(var r=0;r<t.length;r++)if(_a(e,t[r]))return !0;for(var n=0;n<e.length;n++)if(_a(t,e[n]))return !0;return !!ma(t,e)}function fa(t,e,r){return !!_a(t,e)||!!ga(e,t,r)}function ya(t,e){if(1===t.length)return ba(e,t[0]);for(var r=0;r<e.length;r++)for(var n=e[r],i=0;i<n.length;i++)if(_a(t,n[i]))return !0;for(var a=0;a<t.length;a++)if(ba(e,t[a]))return !0;for(var o=0;o<e.length;o++)if(ma(t,e[o]))return !0;return !1}function da(t,e,r){if(t.length>1){if(ma(t,e))return !0;for(var n=0;n<e.length;n++)if(ga(e[n],t,r))return !0}for(var i=0;i<t.length;i++)if(ga(t[i],e,r))return !0;return !1}function ma(t,e){if(0===t.length||0===e.length)return !1;for(var r=0;r<t.length-1;r++)for(var n=t[r],i=t[r+1],a=0;a<e.length-1;a++){if(va(n,i,e[a],e[a+1]))return !0}return !1}function va(t,e,r,n){return A(t,r,n)!==A(e,r,n)&&A(t,e,r)!==A(t,e,n)}function ga(t,e,r){var n=r*r;if(1===e.length)return t.distSqr(e[0])<n;for(var i=1;i<e.length;i++){if(xa(t,e[i-1],e[i])<n)return !0}return !1}function xa(t,e,r){var n=e.distSqr(r);if(0===n)return t.distSqr(e);var i=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y))/n;return i<0?t.distSqr(e):i>1?t.distSqr(r):t.distSqr(r.sub(e)._mult(i)._add(e))}function ba(t,e){for(var r,n,i,a=!1,o=0;o<t.length;o++)for(var s=0,u=(r=t[o]).length-1;s<r.length;u=s++)n=r[s],i=r[u],n.y>e.y!=i.y>e.y&&e.x<(i.x-n.x)*(e.y-n.y)/(i.y-n.y)+n.x&&(a=!a);return a}function _a(t,e){for(var r=!1,n=0,i=t.length-1;n<t.length;i=n++){var a=t[n],o=t[i];a.y>e.y!=o.y>e.y&&e.x<(o.x-a.x)*(e.y-a.y)/(o.y-a.y)+a.x&&(r=!r);}return r}function wa(t,e,r){var n=r[0],i=r[2];if(t.x<n.x&&e.x<n.x||t.x>i.x&&e.x>i.x||t.y<n.y&&e.y<n.y||t.y>i.y&&e.y>i.y)return !1;var a=A(t,e,r[0]);return a!==A(t,e,r[1])||a!==A(t,e,r[2])||a!==A(t,e,r[3])}function Aa(t,e,r){var n=e.paint.get(t).value;return "constant"===n.kind?n.value:r.programConfigurations.get(e.id).binders[t].maxValue}function ka(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function Sa(t,e,r,n,a){if(!e[0]&&!e[1])return t;var o=i.convert(e)._mult(a);"viewport"===r&&o._rotate(-n);for(var s=[],u=0;u<t.length;u++){var l=t[u];s.push(l.sub(o));}return s}ca.prototype.populate=function(t,e){var r=this.layers[0],n=[],i=null;"circle"===r.type&&(i=r.layout.get("circle-sort-key"));for(var a=0,o=t;a<o.length;a+=1){var s=o[a],u=s.feature,l=s.index,p=s.sourceLayerIndex;if(this.layers[0]._featureFilter(new On(this.zoom),u)){var c=la(u),h=i?i.evaluate(u,{}):void 0,f={id:u.id,properties:u.properties,type:u.type,sourceLayerIndex:p,index:l,geometry:c,patterns:{},sortKey:h};n.push(f);}}i&&n.sort(function(t,e){return t.sortKey-e.sortKey});for(var y=0,d=n;y<d.length;y+=1){var m=d[y],v=m,g=v.geometry,x=v.index,b=v.sourceLayerIndex,_=t[x].feature;this.addFeature(m,g,x),e.featureIndex.insert(_,g,x,b,this.index);}},ca.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},ca.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},ca.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},ca.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Oi),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},ca.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},ca.prototype.addFeature=function(t,e,r){for(var n=0,i=e;n<i.length;n+=1)for(var a=0,o=i[n];a<o.length;a+=1){var s=o[a],u=s.x,l=s.y;if(!(u<0||u>=oa||l<0||l>=oa)){var p=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),c=p.vertexLength;pa(this.layoutVertexArray,u,l,-1,-1),pa(this.layoutVertexArray,u,l,1,-1),pa(this.layoutVertexArray,u,l,1,1),pa(this.layoutVertexArray,u,l,-1,1),this.indexArray.emplaceBack(c,c+1,c+2),this.indexArray.emplaceBack(c,c+3,c+2),p.vertexLength+=4,p.primitiveLength+=2;}}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,{});},xn("CircleBucket",ca,{omit:["layers"]});var za=new Yn({"circle-sort-key":new Xn(zt.layout_circle["circle-sort-key"])}),Ia={paint:new Yn({"circle-radius":new Xn(zt.paint_circle["circle-radius"]),"circle-color":new Xn(zt.paint_circle["circle-color"]),"circle-blur":new Xn(zt.paint_circle["circle-blur"]),"circle-opacity":new Xn(zt.paint_circle["circle-opacity"]),"circle-translate":new Zn(zt.paint_circle["circle-translate"]),"circle-translate-anchor":new Zn(zt.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new Zn(zt.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new Zn(zt.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new Xn(zt.paint_circle["circle-stroke-width"]),"circle-stroke-color":new Xn(zt.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new Xn(zt.paint_circle["circle-stroke-opacity"])}),layout:za},Ca="undefined"!=typeof Float32Array?Float32Array:Array;Math.PI;var Ba,Ea;Ba=new Ca(3),Ca!=Float32Array&&(Ba[0]=0,Ba[1]=0,Ba[2]=0),Ea=Ba;function Pa(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*a+r[12]*o,t[1]=r[1]*n+r[5]*i+r[9]*a+r[13]*o,t[2]=r[2]*n+r[6]*i+r[10]*a+r[14]*o,t[3]=r[3]*n+r[7]*i+r[11]*a+r[15]*o,t}!function(){var t=function(){var t=new Ca(4);return Ca!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}();}();var Ma=function(t){function e(e){t.call(this,e,Ia);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createBucket=function(t){return new ca(t)},e.prototype.queryRadius=function(t){var e=t;return Aa("circle-radius",this,e)+Aa("circle-stroke-width",this,e)+ka(this.paint.get("circle-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,i,a,o,s){for(var u=Sa(t,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),a.angle,o),l=this.paint.get("circle-radius").evaluate(e,r)+this.paint.get("circle-stroke-width").evaluate(e,r),p="map"===this.paint.get("circle-pitch-alignment"),c=p?u:function(t,e){return t.map(function(t){return Ta(t,e)})}(u,s),h=p?l*o:l,f=0,y=n;f<y.length;f+=1)for(var d=0,m=y[f];d<m.length;d+=1){var v=m[d],g=p?v:Ta(v,s),x=h,b=Pa([],[v.x,v.y,0,1],s);if("viewport"===this.paint.get("circle-pitch-scale")&&"map"===this.paint.get("circle-pitch-alignment")?x*=b[3]/a.cameraToCenterDistance:"map"===this.paint.get("circle-pitch-scale")&&"viewport"===this.paint.get("circle-pitch-alignment")&&(x*=a.cameraToCenterDistance/b[3]),fa(c,g,x))return !0}return !1},e}($n);function Ta(t,e){var r=Pa([],[t.x,t.y,0,1],e);return new i(r[0]/r[3],r[1]/r[3])}var Va=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(ca);function Fa(t,e,r,n){var i=e.width,a=e.height;if(n){if(n instanceof Uint8ClampedArray)n=new Uint8Array(n.buffer);else if(n.length!==i*a*r)throw new RangeError("mismatched image size")}else n=new Uint8Array(i*a*r);return t.width=i,t.height=a,t.data=n,t}function Oa(t,e,r){var n=e.width,i=e.height;if(n!==t.width||i!==t.height){var a=Fa({},{width:n,height:i},r);La(t,a,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,n),height:Math.min(t.height,i)},r),t.width=n,t.height=i,t.data=a.data;}}function La(t,e,r,n,i,a){if(0===i.width||0===i.height)return e;if(i.width>t.width||i.height>t.height||r.x>t.width-i.width||r.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>e.width||i.height>e.height||n.x>e.width-i.width||n.y>e.height-i.height)throw new RangeError("out of range destination coordinates for image copy");for(var o=t.data,s=e.data,u=0;u<i.height;u++)for(var l=((r.y+u)*t.width+r.x)*a,p=((n.y+u)*e.width+n.x)*a,c=0;c<i.width*a;c++)s[p+c]=o[l+c];return e}xn("HeatmapBucket",Va,{omit:["layers"]});var Da=function(t,e){Fa(this,t,1,e);};Da.prototype.resize=function(t){Oa(this,t,1);},Da.prototype.clone=function(){return new Da({width:this.width,height:this.height},new Uint8Array(this.data))},Da.copy=function(t,e,r,n,i){La(t,e,r,n,i,1);};var Ua=function(t,e){Fa(this,t,4,e);};Ua.prototype.resize=function(t){Oa(this,t,4);},Ua.prototype.replace=function(t,e){e?this.data.set(t):t instanceof Uint8ClampedArray?this.data=new Uint8Array(t.buffer):this.data=t;},Ua.prototype.clone=function(){return new Ua({width:this.width,height:this.height},new Uint8Array(this.data))},Ua.copy=function(t,e,r,n,i){La(t,e,r,n,i,4);},xn("AlphaImage",Da),xn("RGBAImage",Ua);var Ra={paint:new Yn({"heatmap-radius":new Xn(zt.paint_heatmap["heatmap-radius"]),"heatmap-weight":new Xn(zt.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new Zn(zt.paint_heatmap["heatmap-intensity"]),"heatmap-color":new Hn(zt.paint_heatmap["heatmap-color"]),"heatmap-opacity":new Zn(zt.paint_heatmap["heatmap-opacity"])})};function ja(t,e){for(var r=new Uint8Array(1024),n={},i=0,a=0;i<256;i++,a+=4){n[e]=i/255;var o=t.evaluate(n);r[a+0]=Math.floor(255*o.r/o.a),r[a+1]=Math.floor(255*o.g/o.a),r[a+2]=Math.floor(255*o.b/o.a),r[a+3]=Math.floor(255*o.a);}return new Ua({width:256,height:1},r)}var qa=function(t){function e(e){t.call(this,e,Ra),this._updateColorRamp();}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createBucket=function(t){return new Va(t)},e.prototype._handleSpecialPaintPropertyUpdate=function(t){"heatmap-color"===t&&this._updateColorRamp();},e.prototype._updateColorRamp=function(){var t=this._transitionablePaint._values["heatmap-color"].value.expression;this.colorRamp=ja(t,"heatmapDensity"),this.colorRampTexture=null;},e.prototype.resize=function(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null);},e.prototype.queryRadius=function(){return 0},e.prototype.queryIntersectsFeature=function(){return !1},e.prototype.hasOffscreenPass=function(){return 0!==this.paint.get("heatmap-opacity")&&"none"!==this.visibility},e}($n),Na={paint:new Yn({"hillshade-illumination-direction":new Zn(zt.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new Zn(zt.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new Zn(zt.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new Zn(zt.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new Zn(zt.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new Zn(zt.paint_hillshade["hillshade-accent-color"])})},Ka=function(t){function e(e){t.call(this,e,Na);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.hasOffscreenPass=function(){return 0!==this.paint.get("hillshade-exaggeration")&&"none"!==this.visibility},e}($n),Za=ei([{name:"a_pos",components:2,type:"Int16"}],4).members,Xa=Ja,Ga=Ja;function Ja(t,e,r){r=r||2;var n,i,a,o,s,u,l,p=e&&e.length,c=p?e[0]*r:t.length,h=Ha(t,0,c,r,!0),f=[];if(!h||h.next===h.prev)return f;if(p&&(h=function(t,e,r,n){var i,a,o,s,u,l=[];for(i=0,a=e.length;i<a;i++)o=e[i]*n,s=i<a-1?e[i+1]*n:t.length,(u=Ha(t,o,s,n,!1))===u.next&&(u.steiner=!0),l.push(oo(u));for(l.sort(ro),i=0;i<l.length;i++)no(l[i],r),r=Ya(r,r.next);return r}(t,e,h,r)),t.length>80*r){n=a=t[0],i=o=t[1];for(var y=r;y<c;y+=r)(s=t[y])<n&&(n=s),(u=t[y+1])<i&&(i=u),s>a&&(a=s),u>o&&(o=u);l=0!==(l=Math.max(a-n,o-i))?1/l:0;}return $a(h,f,r,n,i,l),f}function Ha(t,e,r,n,i){var a,o;if(i===bo(t,e,r,n)>0)for(a=e;a<r;a+=n)o=vo(a,t[a],t[a+1],o);else for(a=r-n;a>=e;a-=n)o=vo(a,t[a],t[a+1],o);return o&&po(o,o.next)&&(go(o),o=o.next),o}function Ya(t,e){if(!t)return t;e||(e=t);var r,n=t;do{if(r=!1,n.steiner||!po(n,n.next)&&0!==lo(n.prev,n,n.next))n=n.next;else{if(go(n),(n=e=n.prev)===n.next)break;r=!0;}}while(r||n!==e);return e}function $a(t,e,r,n,i,a,o){if(t){!o&&a&&function(t,e,r,n){var i=t;do{null===i.z&&(i.z=ao(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){var e,r,n,i,a,o,s,u,l=1;do{for(r=t,t=null,a=null,o=0;r;){for(o++,n=r,s=0,e=0;e<l&&(s++,n=n.nextZ);e++);for(u=l;s>0||u>0&&n;)0!==s&&(0===u||!n||r.z<=n.z)?(i=r,r=r.nextZ,s--):(i=n,n=n.nextZ,u--),a?a.nextZ=i:t=i,i.prevZ=a,a=i;r=n;}a.nextZ=null,l*=2;}while(o>1)}(i);}(t,n,i,a);for(var s,u,l=t;t.prev!==t.next;)if(s=t.prev,u=t.next,a?Qa(t,n,i,a):Wa(t))e.push(s.i/r),e.push(t.i/r),e.push(u.i/r),go(t),t=u.next,l=u.next;else if((t=u)===l){o?1===o?$a(t=to(Ya(t),e,r),e,r,n,i,a,2):2===o&&eo(t,e,r,n,i,a):$a(Ya(t),e,r,n,i,a,1);break}}}function Wa(t){var e=t.prev,r=t,n=t.next;if(lo(e,r,n)>=0)return !1;for(var i=t.next.next;i!==t.prev;){if(so(e.x,e.y,r.x,r.y,n.x,n.y,i.x,i.y)&&lo(i.prev,i,i.next)>=0)return !1;i=i.next;}return !0}function Qa(t,e,r,n){var i=t.prev,a=t,o=t.next;if(lo(i,a,o)>=0)return !1;for(var s=i.x<a.x?i.x<o.x?i.x:o.x:a.x<o.x?a.x:o.x,u=i.y<a.y?i.y<o.y?i.y:o.y:a.y<o.y?a.y:o.y,l=i.x>a.x?i.x>o.x?i.x:o.x:a.x>o.x?a.x:o.x,p=i.y>a.y?i.y>o.y?i.y:o.y:a.y>o.y?a.y:o.y,c=ao(s,u,e,r,n),h=ao(l,p,e,r,n),f=t.prevZ,y=t.nextZ;f&&f.z>=c&&y&&y.z<=h;){if(f!==t.prev&&f!==t.next&&so(i.x,i.y,a.x,a.y,o.x,o.y,f.x,f.y)&&lo(f.prev,f,f.next)>=0)return !1;if(f=f.prevZ,y!==t.prev&&y!==t.next&&so(i.x,i.y,a.x,a.y,o.x,o.y,y.x,y.y)&&lo(y.prev,y,y.next)>=0)return !1;y=y.nextZ;}for(;f&&f.z>=c;){if(f!==t.prev&&f!==t.next&&so(i.x,i.y,a.x,a.y,o.x,o.y,f.x,f.y)&&lo(f.prev,f,f.next)>=0)return !1;f=f.prevZ;}for(;y&&y.z<=h;){if(y!==t.prev&&y!==t.next&&so(i.x,i.y,a.x,a.y,o.x,o.y,y.x,y.y)&&lo(y.prev,y,y.next)>=0)return !1;y=y.nextZ;}return !0}function to(t,e,r){var n=t;do{var i=n.prev,a=n.next.next;!po(i,a)&&co(i,n,n.next,a)&&yo(i,a)&&yo(a,i)&&(e.push(i.i/r),e.push(n.i/r),e.push(a.i/r),go(n),go(n.next),n=t=a),n=n.next;}while(n!==t);return Ya(n)}function eo(t,e,r,n,i,a){var o=t;do{for(var s=o.next.next;s!==o.prev;){if(o.i!==s.i&&uo(o,s)){var u=mo(o,s);return o=Ya(o,o.next),u=Ya(u,u.next),$a(o,e,r,n,i,a),void $a(u,e,r,n,i,a)}s=s.next;}o=o.next;}while(o!==t)}function ro(t,e){return t.x-e.x}function no(t,e){if(e=function(t,e){var r,n=e,i=t.x,a=t.y,o=-1/0;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){var s=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(s<=i&&s>o){if(o=s,s===i){if(a===n.y)return n;if(a===n.next.y)return n.next}r=n.x<n.next.x?n:n.next;}}n=n.next;}while(n!==e);if(!r)return null;if(i===o)return r;var u,l=r,p=r.x,c=r.y,h=1/0;n=r;do{i>=n.x&&n.x>=p&&i!==n.x&&so(a<c?i:o,a,p,c,a<c?o:i,a,n.x,n.y)&&(u=Math.abs(a-n.y)/(i-n.x),yo(n,t)&&(u<h||u===h&&(n.x>r.x||n.x===r.x&&io(r,n)))&&(r=n,h=u)),n=n.next;}while(n!==l);return r}(t,e)){var r=mo(e,t);Ya(r,r.next);}}function io(t,e){return (lo(t.prev,t,e.prev)<0||lo(e.prev,t,t.next)<0)&&(lo(t.prev,t,e.next)<0||lo(e.next,t,t.next)<0)}function ao(t,e,r,n,i){return (t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function oo(t){var e=t,r=t;do{(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;}while(e!==t);return r}function so(t,e,r,n,i,a,o,s){return (i-o)*(e-s)-(t-o)*(a-s)>=0&&(t-o)*(n-s)-(r-o)*(e-s)>=0&&(r-o)*(a-s)-(i-o)*(n-s)>=0}function uo(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&co(r,r.next,t,e))return !0;r=r.next;}while(r!==t);return !1}(t,e)&&(yo(t,e)&&yo(e,t)&&function(t,e){var r=t,n=!1,i=(t.x+e.x)/2,a=(t.y+e.y)/2;do{r.y>a!=r.next.y>a&&r.next.y!==r.y&&i<(r.next.x-r.x)*(a-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;}while(r!==t);return n}(t,e)&&(lo(t.prev,t,e.prev)||lo(t,e.prev,e))||po(t,e)&&lo(t.prev,t,t.next)>0&&lo(e.prev,e,e.next)>0)}function lo(t,e,r){return (e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function po(t,e){return t.x===e.x&&t.y===e.y}function co(t,e,r,n){var i=fo(lo(t,e,r)),a=fo(lo(t,e,n)),o=fo(lo(r,n,t)),s=fo(lo(r,n,e));return i!==a&&o!==s||(!(0!==i||!ho(t,r,e))||(!(0!==a||!ho(t,n,e))||(!(0!==o||!ho(r,t,n))||!(0!==s||!ho(r,e,n)))))}function ho(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function fo(t){return t>0?1:t<0?-1:0}function yo(t,e){return lo(t.prev,t,t.next)<0?lo(t,e,t.next)>=0&&lo(t,t.prev,e)>=0:lo(t,e,t.prev)<0||lo(t,t.next,e)<0}function mo(t,e){var r=new xo(t.i,t.x,t.y),n=new xo(e.i,e.x,e.y),i=t.next,a=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,a.next=n,n.prev=a,n}function vo(t,e,r,n){var i=new xo(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function go(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ);}function xo(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1;}function bo(t,e,r,n){for(var i=0,a=e,o=r-n;a<r;a+=n)i+=(t[o]-t[a])*(t[a+1]+t[o+1]),o=a;return i}function _o(t,e,r,n,i){!function t(e,r,n,i,a){for(;i>n;){if(i-n>600){var o=i-n+1,s=r-n+1,u=Math.log(o),l=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*l*(o-l)/o)*(s-o/2<0?-1:1),c=Math.max(n,Math.floor(r-s*l/o+p)),h=Math.min(i,Math.floor(r+(o-s)*l/o+p));t(e,r,c,h,a);}var f=e[r],y=n,d=i;for(wo(e,n,r),a(e[i],f)>0&&wo(e,n,i);y<d;){for(wo(e,y,d),y++,d--;a(e[y],f)<0;)y++;for(;a(e[d],f)>0;)d--;}0===a(e[n],f)?wo(e,n,d):wo(e,++d,i),d<=r&&(n=d+1),r<=d&&(i=d-1);}}(t,e,r||0,n||t.length-1,i||Ao);}function wo(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}function Ao(t,e){return t<e?-1:t>e?1:0}function ko(t,e){var r=t.length;if(r<=1)return [t];for(var n,i,a=[],o=0;o<r;o++){var s=k(t[o]);0!==s&&(t[o].area=Math.abs(s),void 0===i&&(i=s<0),i===s<0?(n&&a.push(n),n=[t[o]]):n.push(t[o]));}if(n&&a.push(n),e>1)for(var u=0;u<a.length;u++)a[u].length<=e||(_o(a[u],e,1,a[u].length-1,So),a[u]=a[u].slice(0,e));return a}function So(t,e){return e.area-t.area}function zo(t,e,r){for(var n=r.patternDependencies,i=!1,a=0,o=e;a<o.length;a+=1){var s=o[a].paint.get(t+"-pattern");s.isConstant()||(i=!0);var u=s.constantOr(null);u&&(i=!0,n[u.to]=!0,n[u.from]=!0);}return i}function Io(t,e,r,n,i){for(var a=i.patternDependencies,o=0,s=e;o<s.length;o+=1){var u=s[o],l=u.paint.get(t+"-pattern").value;if("constant"!==l.kind){var p=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),h=l.evaluate({zoom:n+1},r,{},i.availableImages);p=p&&p.name?p.name:p,c=c&&c.name?c.name:c,h=h&&h.name?h.name:h,a[p]=!0,a[c]=!0,a[h]=!0,r.patterns[u.id]={min:p,mid:c,max:h};}}return r}Ja.deviation=function(t,e,r,n){var i=e&&e.length,a=i?e[0]*r:t.length,o=Math.abs(bo(t,0,a,r));if(i)for(var s=0,u=e.length;s<u;s++){var l=e[s]*r,p=s<u-1?e[s+1]*r:t.length;o-=Math.abs(bo(t,l,p,r));}var c=0;for(s=0;s<n.length;s+=3){var h=n[s]*r,f=n[s+1]*r,y=n[s+2]*r;c+=Math.abs((t[h]-t[y])*(t[f+1]-t[h+1])-(t[h]-t[f])*(t[y+1]-t[h+1]));}return 0===o&&0===c?0:Math.abs((c-o)/o)},Ja.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var a=0;a<t[i].length;a++)for(var o=0;o<e;o++)r.vertices.push(t[i][a][o]);i>0&&(n+=t[i-1].length,r.holes.push(n));}return r},Xa.default=Ga;var Co=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(function(t){return t.id}),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new ni,this.indexArray=new xi,this.indexArray2=new bi,this.programConfigurations=new na(Za,t.layers,t.zoom),this.segments=new Li,this.segments2=new Li,this.stateDependentLayerIds=this.layers.filter(function(t){return t.isStateDependent()}).map(function(t){return t.id});};Co.prototype.populate=function(t,e){this.hasPattern=zo("fill",this.layers,e);for(var r=this.layers[0].layout.get("fill-sort-key"),n=[],i=0,a=t;i<a.length;i+=1){var o=a[i],s=o.feature,u=o.index,l=o.sourceLayerIndex;if(this.layers[0]._featureFilter(new On(this.zoom),s)){var p=la(s),c=r?r.evaluate(s,{},e.availableImages):void 0,h={id:s.id,properties:s.properties,type:s.type,sourceLayerIndex:l,index:u,geometry:p,patterns:{},sortKey:c};n.push(h);}}r&&n.sort(function(t,e){return t.sortKey-e.sortKey});for(var f=0,y=n;f<y.length;f+=1){var d=y[f],m=d,v=m.geometry,g=m.index,x=m.sourceLayerIndex;if(this.hasPattern){var b=Io("fill",this.layers,d,this.zoom,e);this.patternFeatures.push(b);}else this.addFeature(d,v,g,{});var _=t[g].feature;e.featureIndex.insert(_,v,g,x,this.index);}},Co.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},Co.prototype.addFeatures=function(t,e){for(var r=0,n=this.patternFeatures;r<n.length;r+=1){var i=n[r];this.addFeature(i,i.geometry,i.index,e);}},Co.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},Co.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},Co.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Za),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0;},Co.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy());},Co.prototype.addFeature=function(t,e,r,n){for(var i=0,a=ko(e,500);i<a.length;i+=1){for(var o=a[i],s=0,u=0,l=o;u<l.length;u+=1){s+=l[u].length;}for(var p=this.segments.prepareSegment(s,this.layoutVertexArray,this.indexArray),c=p.vertexLength,h=[],f=[],y=0,d=o;y<d.length;y+=1){var m=d[y];if(0!==m.length){m!==o[0]&&f.push(h.length/2);var v=this.segments2.prepareSegment(m.length,this.layoutVertexArray,this.indexArray2),g=v.vertexLength;this.layoutVertexArray.emplaceBack(m[0].x,m[0].y),this.indexArray2.emplaceBack(g+m.length-1,g),h.push(m[0].x),h.push(m[0].y);for(var x=1;x<m.length;x++)this.layoutVertexArray.emplaceBack(m[x].x,m[x].y),this.indexArray2.emplaceBack(g+x-1,g+x),h.push(m[x].x),h.push(m[x].y);v.vertexLength+=m.length,v.primitiveLength+=m.length;}}for(var b=Xa(h,f),_=0;_<b.length;_+=3)this.indexArray.emplaceBack(c+b[_],c+b[_+1],c+b[_+2]);p.vertexLength+=s,p.primitiveLength+=b.length/3;}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,n);},xn("FillBucket",Co,{omit:["layers","patternFeatures"]});var Bo=new Yn({"fill-sort-key":new Xn(zt.layout_fill["fill-sort-key"])}),Eo={paint:new Yn({"fill-antialias":new Zn(zt.paint_fill["fill-antialias"]),"fill-opacity":new Xn(zt.paint_fill["fill-opacity"]),"fill-color":new Xn(zt.paint_fill["fill-color"]),"fill-outline-color":new Xn(zt.paint_fill["fill-outline-color"]),"fill-translate":new Zn(zt.paint_fill["fill-translate"]),"fill-translate-anchor":new Zn(zt.paint_fill["fill-translate-anchor"]),"fill-pattern":new Gn(zt.paint_fill["fill-pattern"])}),layout:Bo},Po=function(t){function e(e){t.call(this,e,Eo);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.recalculate=function(e,r){t.prototype.recalculate.call(this,e,r);var n=this.paint._values["fill-outline-color"];"constant"===n.value.kind&&void 0===n.value.value&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"]);},e.prototype.createBucket=function(t){return new Co(t)},e.prototype.queryRadius=function(){return ka(this.paint.get("fill-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,i,a,o){return ya(Sa(t,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),a.angle,o),n)},e.prototype.isTileClipped=function(){return !0},e}($n),Mo=ei([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4).members,To=Vo;function Vo(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=i,t.readFields(Fo,this,e);}function Fo(t,e,r){1==t?e.id=r.readVarint():2==t?function(t,e){var r=t.readVarint()+t.pos;for(;t.pos<r;){var n=e._keys[t.readVarint()],i=e._values[t.readVarint()];e.properties[n]=i;}}(r,e):3==t?e.type=r.readVarint():4==t&&(e._geometry=r.pos);}function Oo(t){for(var e,r,n=0,i=0,a=t.length,o=a-1;i<a;o=i++)e=t[i],n+=((r=t[o]).x-e.x)*(e.y+r.y);return n}Vo.types=["Unknown","Point","LineString","Polygon"],Vo.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e,r=t.readVarint()+t.pos,n=1,a=0,o=0,s=0,u=[];t.pos<r;){if(a<=0){var l=t.readVarint();n=7&l,a=l>>3;}if(a--,1===n||2===n)o+=t.readSVarint(),s+=t.readSVarint(),1===n&&(e&&u.push(e),e=[]),e.push(new i(o,s));else{if(7!==n)throw new Error("unknown command "+n);e&&e.push(e[0].clone());}}return e&&u.push(e),u},Vo.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,a=0,o=1/0,s=-1/0,u=1/0,l=-1/0;t.pos<e;){if(n<=0){var p=t.readVarint();r=7&p,n=p>>3;}if(n--,1===r||2===r)(i+=t.readSVarint())<o&&(o=i),i>s&&(s=i),(a+=t.readSVarint())<u&&(u=a),a>l&&(l=a);else if(7!==r)throw new Error("unknown command "+r)}return [o,u,s,l]},Vo.prototype.toGeoJSON=function(t,e,r){var n,i,a=this.extent*Math.pow(2,r),o=this.extent*t,s=this.extent*e,u=this.loadGeometry(),l=Vo.types[this.type];function p(t){for(var e=0;e<t.length;e++){var r=t[e],n=180-360*(r.y+s)/a;t[e]=[360*(r.x+o)/a-180,360/Math.PI*Math.atan(Math.exp(n*Math.PI/180))-90];}}switch(this.type){case 1:var c=[];for(n=0;n<u.length;n++)c[n]=u[n][0];p(u=c);break;case 2:for(n=0;n<u.length;n++)p(u[n]);break;case 3:for(u=function(t){var e=t.length;if(e<=1)return [t];for(var r,n,i=[],a=0;a<e;a++){var o=Oo(t[a]);0!==o&&(void 0===n&&(n=o<0),n===o<0?(r&&i.push(r),r=[t[a]]):r.push(t[a]));}r&&i.push(r);return i}(u),n=0;n<u.length;n++)for(i=0;i<u[n].length;i++)p(u[n][i]);}1===u.length?u=u[0]:l="Multi"+l;var h={type:"Feature",geometry:{type:l,coordinates:u},properties:this.properties};return "id"in this&&(h.id=this.id),h};var Lo=Do;function Do(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(Uo,this,e),this.length=this._features.length;}function Uo(t,e,r){15===t?e.version=r.readVarint():1===t?e.name=r.readString():5===t?e.extent=r.readVarint():2===t?e._features.push(r.pos):3===t?e._keys.push(r.readString()):4===t&&e._values.push(function(t){var e=null,r=t.readVarint()+t.pos;for(;t.pos<r;){var n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null;}return e}(r));}function Ro(t,e,r){if(3===t){var n=new Lo(r,r.readVarint()+r.pos);n.length&&(e[n.name]=n);}}Do.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new To(this._pbf,e,this.extent,this._keys,this._values)};var jo={VectorTile:function(t,e){this.layers=t.readFields(Ro,{},e);},VectorTileFeature:To,VectorTileLayer:Lo},qo=jo.VectorTileFeature.types,No=Math.pow(2,13);function Ko(t,e,r,n,i,a,o,s){t.emplaceBack(e,r,2*Math.floor(n*No)+o,i*No*2,a*No*2,Math.round(s));}var Zo=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(function(t){return t.id}),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new ai,this.indexArray=new xi,this.programConfigurations=new na(Mo,t.layers,t.zoom),this.segments=new Li,this.stateDependentLayerIds=this.layers.filter(function(t){return t.isStateDependent()}).map(function(t){return t.id});};function Xo(t,e){return t.x===e.x&&(t.x<0||t.x>oa)||t.y===e.y&&(t.y<0||t.y>oa)}function Go(t){return t.every(function(t){return t.x<0})||t.every(function(t){return t.x>oa})||t.every(function(t){return t.y<0})||t.every(function(t){return t.y>oa})}Zo.prototype.populate=function(t,e){this.features=[],this.hasPattern=zo("fill-extrusion",this.layers,e);for(var r=0,n=t;r<n.length;r+=1){var i=n[r],a=i.feature,o=i.index,s=i.sourceLayerIndex;if(this.layers[0]._featureFilter(new On(this.zoom),a)){var u=la(a),l={sourceLayerIndex:s,index:o,geometry:u,properties:a.properties,type:a.type,patterns:{}};void 0!==a.id&&(l.id=a.id),this.hasPattern?this.features.push(Io("fill-extrusion",this.layers,l,this.zoom,e)):this.addFeature(l,u,o,{}),e.featureIndex.insert(a,u,o,s,this.index,!0);}}},Zo.prototype.addFeatures=function(t,e){for(var r=0,n=this.features;r<n.length;r+=1){var i=n[r],a=i.geometry;this.addFeature(i,a,i.index,e);}},Zo.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},Zo.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},Zo.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},Zo.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Mo),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},Zo.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},Zo.prototype.addFeature=function(t,e,r,n){for(var i=0,a=ko(e,500);i<a.length;i+=1){for(var o=a[i],s=0,u=0,l=o;u<l.length;u+=1){s+=l[u].length;}for(var p=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray),c=0,h=o;c<h.length;c+=1){var f=h[c];if(0!==f.length&&!Go(f))for(var y=0,d=0;d<f.length;d++){var m=f[d];if(d>=1){var v=f[d-1];if(!Xo(m,v)){p.vertexLength+4>Li.MAX_VERTEX_ARRAY_LENGTH&&(p=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));var g=m.sub(v)._perp()._unit(),x=v.dist(m);y+x>32768&&(y=0),Ko(this.layoutVertexArray,m.x,m.y,g.x,g.y,0,0,y),Ko(this.layoutVertexArray,m.x,m.y,g.x,g.y,0,1,y),y+=x,Ko(this.layoutVertexArray,v.x,v.y,g.x,g.y,0,0,y),Ko(this.layoutVertexArray,v.x,v.y,g.x,g.y,0,1,y);var b=p.vertexLength;this.indexArray.emplaceBack(b,b+2,b+1),this.indexArray.emplaceBack(b+1,b+2,b+3),p.vertexLength+=4,p.primitiveLength+=2;}}}}if(p.vertexLength+s>Li.MAX_VERTEX_ARRAY_LENGTH&&(p=this.segments.prepareSegment(s,this.layoutVertexArray,this.indexArray)),"Polygon"===qo[t.type]){for(var _=[],w=[],A=p.vertexLength,k=0,S=o;k<S.length;k+=1){var z=S[k];if(0!==z.length){z!==o[0]&&w.push(_.length/2);for(var I=0;I<z.length;I++){var C=z[I];Ko(this.layoutVertexArray,C.x,C.y,0,0,1,1,0),_.push(C.x),_.push(C.y);}}}for(var B=Xa(_,w),E=0;E<B.length;E+=3)this.indexArray.emplaceBack(A+B[E],A+B[E+2],A+B[E+1]);p.primitiveLength+=B.length/3,p.vertexLength+=s;}}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,n);},xn("FillExtrusionBucket",Zo,{omit:["layers","features"]});var Jo={paint:new Yn({"fill-extrusion-opacity":new Zn(zt["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new Xn(zt["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new Zn(zt["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new Zn(zt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new Gn(zt["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new Xn(zt["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new Xn(zt["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new Zn(zt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])})},Ho=function(t){function e(e){t.call(this,e,Jo);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createBucket=function(t){return new Zo(t)},e.prototype.queryRadius=function(){return ka(this.paint.get("fill-extrusion-translate"))},e.prototype.is3D=function(){return !0},e.prototype.queryIntersectsFeature=function(t,e,r,n,a,o,s,u){var l=Sa(t,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),o.angle,s),p=this.paint.get("fill-extrusion-height").evaluate(e,r),c=this.paint.get("fill-extrusion-base").evaluate(e,r),h=function(t,e,r,n){for(var a=[],o=0,s=t;o<s.length;o+=1){var u=s[o],l=[u.x,u.y,n,1];Pa(l,l,e),a.push(new i(l[0]/l[3],l[1]/l[3]));}return a}(l,u,0,0),f=function(t,e,r,n){for(var a=[],o=[],s=n[8]*e,u=n[9]*e,l=n[10]*e,p=n[11]*e,c=n[8]*r,h=n[9]*r,f=n[10]*r,y=n[11]*r,d=0,m=t;d<m.length;d+=1){for(var v=m[d],g=[],x=[],b=0,_=v;b<_.length;b+=1){var w=_[b],A=w.x,k=w.y,S=n[0]*A+n[4]*k+n[12],z=n[1]*A+n[5]*k+n[13],I=n[2]*A+n[6]*k+n[14],C=n[3]*A+n[7]*k+n[15],B=I+l,E=C+p,P=S+c,M=z+h,T=I+f,V=C+y,F=new i((S+s)/E,(z+u)/E);F.z=B/E,g.push(F);var O=new i(P/V,M/V);O.z=T/V,x.push(O);}a.push(g),o.push(x);}return [a,o]}(n,c,p,u);return function(t,e,r){var n=1/0;ya(r,e)&&(n=$o(r,e[0]));for(var i=0;i<e.length;i++)for(var a=e[i],o=t[i],s=0;s<a.length-1;s++){var u=a[s],l=a[s+1],p=o[s],c=o[s+1],h=[u,l,c,p,u];ha(r,h)&&(n=Math.min(n,$o(r,h)));}return n!==1/0&&n}(f[0],f[1],h)},e}($n);function Yo(t,e){return t.x*e.x+t.y*e.y}function $o(t,e){if(1===t.length){var r=e[0],n=e[1],i=e[3],a=t[0],o=n.sub(r),s=i.sub(r),u=a.sub(r),l=Yo(o,o),p=Yo(o,s),c=Yo(s,s),h=Yo(u,o),f=Yo(u,s),y=l*c-p*p,d=(c*h-p*f)/y,m=(l*f-p*h)/y,v=1-d-m;return r.z*v+n.z*d+i.z*m}for(var g=1/0,x=0,b=e;x<b.length;x+=1){var _=b[x];g=Math.min(g,_.z);}return g}var Wo=ei([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4).members,Qo=jo.VectorTileFeature.types,ts=Math.cos(Math.PI/180*37.5),es=Math.pow(2,14)/.5,rs=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(function(t){return t.id}),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new oi,this.indexArray=new xi,this.programConfigurations=new na(Wo,t.layers,t.zoom),this.segments=new Li,this.stateDependentLayerIds=this.layers.filter(function(t){return t.isStateDependent()}).map(function(t){return t.id});};rs.prototype.populate=function(t,e){this.hasPattern=zo("line",this.layers,e);for(var r=this.layers[0].layout.get("line-sort-key"),n=[],i=0,a=t;i<a.length;i+=1){var o=a[i],s=o.feature,u=o.index,l=o.sourceLayerIndex;if(this.layers[0]._featureFilter(new On(this.zoom),s)){var p=la(s),c=r?r.evaluate(s,{}):void 0,h={id:s.id,properties:s.properties,type:s.type,sourceLayerIndex:l,index:u,geometry:p,patterns:{},sortKey:c};n.push(h);}}r&&n.sort(function(t,e){return t.sortKey-e.sortKey});for(var f=0,y=n;f<y.length;f+=1){var d=y[f],m=d,v=m.geometry,g=m.index,x=m.sourceLayerIndex;if(this.hasPattern){var b=Io("line",this.layers,d,this.zoom,e);this.patternFeatures.push(b);}else this.addFeature(d,v,g,{});var _=t[g].feature;e.featureIndex.insert(_,v,g,x,this.index);}},rs.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},rs.prototype.addFeatures=function(t,e){for(var r=0,n=this.patternFeatures;r<n.length;r+=1){var i=n[r];this.addFeature(i,i.geometry,i.index,e);}},rs.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},rs.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},rs.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Wo),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},rs.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},rs.prototype.addFeature=function(t,e,r,n){for(var i=this.layers[0].layout,a=i.get("line-join").evaluate(t,{}),o=i.get("line-cap"),s=i.get("line-miter-limit"),u=i.get("line-round-limit"),l=0,p=e;l<p.length;l+=1){var c=p[l];this.addLine(c,t,a,o,s,u,r,n);}},rs.prototype.addLine=function(t,e,r,n,i,a,o,s){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,e.properties&&e.properties.hasOwnProperty("mapbox_clip_start")&&e.properties.hasOwnProperty("mapbox_clip_end")){this.clipStart=+e.properties.mapbox_clip_start,this.clipEnd=+e.properties.mapbox_clip_end;for(var u=0;u<t.length-1;u++)this.totalDistance+=t[u].dist(t[u+1]);}for(var l="Polygon"===Qo[e.type],p=t.length;p>=2&&t[p-1].equals(t[p-2]);)p--;for(var c=0;c<p-1&&t[c].equals(t[c+1]);)c++;if(!(p<(l?3:2))){"bevel"===r&&(i=1.05);var h,f=oa/(512*this.overscaling)*15,y=this.segments.prepareSegment(10*p,this.layoutVertexArray,this.indexArray),d=void 0,m=void 0,v=void 0,g=void 0;this.e1=this.e2=-1,l&&(h=t[p-2],g=t[c].sub(h)._unit()._perp());for(var x=c;x<p;x++)if(!(m=l&&x===p-1?t[c+1]:t[x+1])||!t[x].equals(m)){g&&(v=g),h&&(d=h),h=t[x],g=m?m.sub(h)._unit()._perp():v;var b=(v=v||g).add(g);0===b.x&&0===b.y||b._unit();var _=v.x*g.x+v.y*g.y,w=b.x*g.x+b.y*g.y,A=0!==w?1/w:1/0,k=2*Math.sqrt(2-2*w),S=w<ts&&d&&m,z=v.x*g.y-v.y*g.x>0;if(S&&x>c){var I=h.dist(d);if(I>2*f){var C=h.sub(h.sub(d)._mult(f/I)._round());this.updateDistance(d,C),this.addCurrentVertex(C,v,0,0,y),d=C;}}var B=d&&m,E=B?r:l?"butt":n;if(B&&"round"===E&&(A<a?E="miter":A<=2&&(E="fakeround")),"miter"===E&&A>i&&(E="bevel"),"bevel"===E&&(A>2&&(E="flipbevel"),A<i&&(E="miter")),d&&this.updateDistance(d,h),"miter"===E)b._mult(A),this.addCurrentVertex(h,b,0,0,y);else if("flipbevel"===E){if(A>100)b=g.mult(-1);else{var P=A*v.add(g).mag()/v.sub(g).mag();b._perp()._mult(P*(z?-1:1));}this.addCurrentVertex(h,b,0,0,y),this.addCurrentVertex(h,b.mult(-1),0,0,y);}else if("bevel"===E||"fakeround"===E){var M=-Math.sqrt(A*A-1),T=z?M:0,V=z?0:M;if(d&&this.addCurrentVertex(h,v,T,V,y),"fakeround"===E)for(var F=Math.round(180*k/Math.PI/20),O=1;O<F;O++){var L=O/F;if(.5!==L){var D=L-.5;L+=L*D*(L-1)*((1.0904+_*(_*(3.55645-1.43519*_)-3.2452))*D*D+(.848013+_*(.215638*_-1.06021)));}var U=g.sub(v)._mult(L)._add(v)._unit()._mult(z?-1:1);this.addHalfVertex(h,U.x,U.y,!1,z,0,y);}m&&this.addCurrentVertex(h,g,-T,-V,y);}else if("butt"===E)this.addCurrentVertex(h,b,0,0,y);else if("square"===E){var R=d?1:-1;this.addCurrentVertex(h,b,R,R,y);}else"round"===E&&(d&&(this.addCurrentVertex(h,v,0,0,y),this.addCurrentVertex(h,v,1,1,y,!0)),m&&(this.addCurrentVertex(h,g,-1,-1,y,!0),this.addCurrentVertex(h,g,0,0,y)));if(S&&x<p-1){var j=h.dist(m);if(j>2*f){var q=h.add(m.sub(h)._mult(f/j)._round());this.updateDistance(h,q),this.addCurrentVertex(q,g,0,0,y),h=q;}}}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,o,s);}},rs.prototype.addCurrentVertex=function(t,e,r,n,i,a){void 0===a&&(a=!1);var o=e.x+e.y*r,s=e.y-e.x*r,u=-e.x+e.y*n,l=-e.y-e.x*n;this.addHalfVertex(t,o,s,a,!1,r,i),this.addHalfVertex(t,u,l,a,!0,-n,i),this.distance>es/2&&0===this.totalDistance&&(this.distance=0,this.addCurrentVertex(t,e,r,n,i,a));},rs.prototype.addHalfVertex=function(t,e,r,n,i,a,o){var s=t.x,u=t.y,l=.5*this.scaledDistance;this.layoutVertexArray.emplaceBack((s<<1)+(n?1:0),(u<<1)+(i?1:0),Math.round(63*e)+128,Math.round(63*r)+128,1+(0===a?0:a<0?-1:1)|(63&l)<<2,l>>6);var p=o.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,p),o.primitiveLength++),i?this.e2=p:this.e1=p;},rs.prototype.updateDistance=function(t,e){this.distance+=t.dist(e),this.scaledDistance=this.totalDistance>0?(this.clipStart+(this.clipEnd-this.clipStart)*this.distance/this.totalDistance)*(es-1):this.distance;},xn("LineBucket",rs,{omit:["layers","patternFeatures"]});var ns=new Yn({"line-cap":new Zn(zt.layout_line["line-cap"]),"line-join":new Xn(zt.layout_line["line-join"]),"line-miter-limit":new Zn(zt.layout_line["line-miter-limit"]),"line-round-limit":new Zn(zt.layout_line["line-round-limit"]),"line-sort-key":new Xn(zt.layout_line["line-sort-key"])}),is={paint:new Yn({"line-opacity":new Xn(zt.paint_line["line-opacity"]),"line-color":new Xn(zt.paint_line["line-color"]),"line-translate":new Zn(zt.paint_line["line-translate"]),"line-translate-anchor":new Zn(zt.paint_line["line-translate-anchor"]),"line-width":new Xn(zt.paint_line["line-width"]),"line-gap-width":new Xn(zt.paint_line["line-gap-width"]),"line-offset":new Xn(zt.paint_line["line-offset"]),"line-blur":new Xn(zt.paint_line["line-blur"]),"line-dasharray":new Jn(zt.paint_line["line-dasharray"]),"line-pattern":new Gn(zt.paint_line["line-pattern"]),"line-gradient":new Hn(zt.paint_line["line-gradient"])}),layout:ns},as=new(function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.possiblyEvaluate=function(e,r){return r=new On(Math.floor(r.zoom),{now:r.now,fadeDuration:r.fadeDuration,zoomHistory:r.zoomHistory,transition:r.transition}),t.prototype.possiblyEvaluate.call(this,e,r)},e.prototype.evaluate=function(e,r,n,i){return r=c({},r,{zoom:Math.floor(r.zoom)}),t.prototype.evaluate.call(this,e,r,n,i)},e}(Xn))(is.paint.properties["line-width"].specification);as.useIntegerZoom=!0;var os=function(t){function e(e){t.call(this,e,is);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype._handleSpecialPaintPropertyUpdate=function(t){"line-gradient"===t&&this._updateGradient();},e.prototype._updateGradient=function(){var t=this._transitionablePaint._values["line-gradient"].value.expression;this.gradient=ja(t,"lineProgress"),this.gradientTexture=null;},e.prototype.recalculate=function(e,r){t.prototype.recalculate.call(this,e,r),this.paint._values["line-floorwidth"]=as.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,e);},e.prototype.createBucket=function(t){return new rs(t)},e.prototype.queryRadius=function(t){var e=t,r=ss(Aa("line-width",this,e),Aa("line-gap-width",this,e)),n=Aa("line-offset",this,e);return r/2+Math.abs(n)+ka(this.paint.get("line-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,a,o,s){var u=Sa(t,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),o.angle,s),l=s/2*ss(this.paint.get("line-width").evaluate(e,r),this.paint.get("line-gap-width").evaluate(e,r)),p=this.paint.get("line-offset").evaluate(e,r);return p&&(n=function(t,e){for(var r=[],n=new i(0,0),a=0;a<t.length;a++){for(var o=t[a],s=[],u=0;u<o.length;u++){var l=o[u-1],p=o[u],c=o[u+1],h=0===u?n:p.sub(l)._unit()._perp(),f=u===o.length-1?n:c.sub(p)._unit()._perp(),y=h._add(f)._unit(),d=y.x*f.x+y.y*f.y;y._mult(1/d),s.push(y._mult(e)._add(p));}r.push(s);}return r}(n,p*s)),function(t,e,r){for(var n=0;n<e.length;n++){var i=e[n];if(t.length>=3)for(var a=0;a<i.length;a++)if(_a(t,i[a]))return !0;if(da(t,i,r))return !0}return !1}(u,n,l)},e.prototype.isTileClipped=function(){return !0},e}($n);function ss(t,e){return e>0?e+2*t:t}var us=ei([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"}]),ls=ei([{name:"a_projected_pos",components:3,type:"Float32"}],4),ps=(ei([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),ei([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}])),cs=(ei([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"},{type:"Int16",name:"radius"},{type:"Int16",name:"signedDistanceFromAnchor"}]),ei([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4)),hs=ei([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4);ei([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),ei([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",components:2,name:"textOffset"}]),ei([{type:"Float32",name:"offsetX"}]),ei([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]);function fs(t,e,r){return t.sections.forEach(function(t){t.text=function(t,e,r){var n=e.layout.get("text-transform").evaluate(r,{});return "uppercase"===n?t=t.toLocaleUpperCase():"lowercase"===n&&(t=t.toLocaleLowerCase()),Fn.applyArabicShaping&&(t=Fn.applyArabicShaping(t)),t}(t.text,e,r);}),t}var ys={"!":"︕","#":"＃",$:"＄","%":"％","&":"＆","(":"︵",")":"︶","*":"＊","+":"＋",",":"︐","-":"︲",".":"・","/":"／",":":"︓",";":"︔","<":"︿","=":"＝",">":"﹀","?":"︖","@":"＠","[":"﹇","\\":"＼","]":"﹈","^":"＾",_:"︳","`":"｀","{":"︷","|":"―","}":"︸","~":"～","¢":"￠","£":"￡","¥":"￥","¦":"￤","¬":"￢","¯":"￣","–":"︲","—":"︱","‘":"﹃","’":"﹄","“":"﹁","”":"﹂","…":"︙","‧":"・","₩":"￦","、":"︑","。":"︒","〈":"︿","〉":"﹀","《":"︽","》":"︾","「":"﹁","」":"﹂","『":"﹃","』":"﹄","【":"︻","】":"︼","〔":"︹","〕":"︺","〖":"︗","〗":"︘","！":"︕","（":"︵","）":"︶","，":"︐","－":"︲","．":"・","：":"︓","；":"︔","＜":"︿","＞":"﹀","？":"︖","［":"﹇","］":"﹈","＿":"︳","｛":"︷","｜":"―","｝":"︸","｟":"︵","｠":"︶","｡":"︒","｢":"﹁","｣":"﹂"};var ds=24,ms={horizontal:1,vertical:2,horizontalOnly:3},vs=function(){this.text="",this.sectionIndex=[],this.sections=[];};function gs(t,e,r,n,i,a,o,s,u,l,p,c){var h,f=vs.fromFeature(t,r);l===ms.vertical&&f.verticalizePunctuation();var y=Fn.processBidirectionalText,d=Fn.processStyledBidirectionalText;if(y&&1===f.sections.length){h=[];for(var m=0,v=y(f.toString(),ks(f,s,n,e,c));m<v.length;m+=1){var g=v[m],x=new vs;x.text=g,x.sections=f.sections;for(var b=0;b<g.length;b++)x.sectionIndex.push(0);h.push(x);}}else if(d){h=[];for(var _=0,w=d(f.text,f.sectionIndex,ks(f,s,n,e,c));_<w.length;_+=1){var A=w[_],k=new vs;k.text=A[0],k.sectionIndex=A[1],k.sections=f.sections,h.push(k);}}else h=function(t,e){for(var r=[],n=t.text,i=0,a=0,o=e;a<o.length;a+=1){var s=o[a];r.push(t.substring(i,s)),i=s;}return i<n.length&&r.push(t.substring(i,n.length)),r}(f,ks(f,s,n,e,c));var S=[],z={positionedGlyphs:S,text:f.toString(),top:u[1],bottom:u[1],left:u[0],right:u[0],writingMode:l,lineCount:h.length,yOffset:-17};return function(t,e,r,n,i,a,o,s,u){for(var l=0,p=t.yOffset,c=0,h=t.positionedGlyphs,f="right"===a?1:"left"===a?0:.5,y=0,d=r;y<d.length;y+=1){var m=d[y];m.trim();var v=m.getMaxScale();if(m.length()){for(var g=h.length,x=0;x<m.length();x++){var b=m.getSection(x),_=m.getSectionIndex(x),w=m.getCharCode(x),A=24*(v-b.scale),k=e[b.fontStack],S=k&&k[w];S&&(o===ms.horizontal||!u&&!In(w)||u&&(xs[w]||(I=w,kn.Arabic(I)||kn["Arabic Supplement"](I)||kn["Arabic Extended-A"](I)||kn["Arabic Presentation Forms-A"](I)||kn["Arabic Presentation Forms-B"](I)))?(h.push({glyph:w,x:l,y:p+A,vertical:!1,scale:b.scale,fontStack:b.fontStack,sectionIndex:_}),l+=S.metrics.advance*b.scale+s):(h.push({glyph:w,x:l,y:p+A,vertical:!0,scale:b.scale,fontStack:b.fontStack,sectionIndex:_}),l+=ds*b.scale+s));}if(h.length!==g){var z=l-s;c=Math.max(z,c),zs(h,e,g,h.length-1,f);}l=0,p+=n*v;}else p+=n;}var I;var C=Ss(i),B=C.horizontalAlign,E=C.verticalAlign;!function(t,e,r,n,i,a,o){for(var s=(e-r)*i,u=(-n*o+.5)*a,l=0;l<t.length;l++)t[l].x+=s,t[l].y+=u;}(h,f,B,E,c,n,r.length);var P=p-t.yOffset;t.top+=-E*P,t.bottom=t.top+P,t.left+=-B*c,t.right=t.left+c;}(z,e,h,i,a,o,l,s,p),!!S.length&&z}vs.fromFeature=function(t,e){for(var r=new vs,n=0;n<t.sections.length;n++){var i=t.sections[n];r.sections.push({scale:i.scale||1,fontStack:i.fontStack||e}),r.text+=i.text;for(var a=0;a<i.text.length;a++)r.sectionIndex.push(n);}return r},vs.prototype.length=function(){return this.text.length},vs.prototype.getSection=function(t){return this.sections[this.sectionIndex[t]]},vs.prototype.getSectionIndex=function(t){return this.sectionIndex[t]},vs.prototype.getCharCode=function(t){return this.text.charCodeAt(t)},vs.prototype.verticalizePunctuation=function(){this.text=function(t){for(var e="",r=0;r<t.length;r++){var n=t.charCodeAt(r+1)||null,i=t.charCodeAt(r-1)||null;(!n||!Cn(n)||ys[t[r+1]])&&(!i||!Cn(i)||ys[t[r-1]])&&ys[t[r]]?e+=ys[t[r]]:e+=t[r];}return e}(this.text);},vs.prototype.trim=function(){for(var t=0,e=0;e<this.text.length&&xs[this.text.charCodeAt(e)];e++)t++;for(var r=this.text.length,n=this.text.length-1;n>=0&&n>=t&&xs[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(t,r),this.sectionIndex=this.sectionIndex.slice(t,r);},vs.prototype.substring=function(t,e){var r=new vs;return r.text=this.text.substring(t,e),r.sectionIndex=this.sectionIndex.slice(t,e),r.sections=this.sections,r},vs.prototype.toString=function(){return this.text},vs.prototype.getMaxScale=function(){var t=this;return this.sectionIndex.reduce(function(e,r){return Math.max(e,t.sections[r].scale)},0)};var xs={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},bs={};function _s(t,e,r,n){var i=Math.pow(t-e,2);return n?t<e?i/2:2*i:i+Math.abs(r)*r}function ws(t,e,r){var n=0;return 10===t&&(n-=1e4),r&&(n+=150),40!==t&&65288!==t||(n+=50),41!==e&&65289!==e||(n+=50),n}function As(t,e,r,n,i,a){for(var o=null,s=_s(e,r,i,a),u=0,l=n;u<l.length;u+=1){var p=l[u],c=_s(e-p.x,r,i,a)+p.badness;c<=s&&(o=p,s=c);}return {index:t,x:e,priorBreak:o,badness:s}}function ks(t,e,r,n,i){if("point"!==i)return [];if(!t)return [];for(var a,o=[],s=function(t,e,r,n){for(var i=0,a=0;a<t.length();a++){var o=t.getSection(a),s=n[o.fontStack],u=s&&s[t.getCharCode(a)];u&&(i+=u.metrics.advance*o.scale+e);}return i/Math.max(1,Math.ceil(i/r))}(t,e,r,n),u=t.text.indexOf("​")>=0,l=0,p=0;p<t.length();p++){var c=t.getSection(p),h=t.getCharCode(p),f=n[c.fontStack],y=f&&f[h];if(y&&!xs[h]&&(l+=y.metrics.advance*c.scale+e),p<t.length()-1){var d=!!(!((a=h)<11904)&&(kn["Bopomofo Extended"](a)||kn.Bopomofo(a)||kn["CJK Compatibility Forms"](a)||kn["CJK Compatibility Ideographs"](a)||kn["CJK Compatibility"](a)||kn["CJK Radicals Supplement"](a)||kn["CJK Strokes"](a)||kn["CJK Symbols and Punctuation"](a)||kn["CJK Unified Ideographs Extension A"](a)||kn["CJK Unified Ideographs"](a)||kn["Enclosed CJK Letters and Months"](a)||kn["Halfwidth and Fullwidth Forms"](a)||kn.Hiragana(a)||kn["Ideographic Description Characters"](a)||kn["Kangxi Radicals"](a)||kn["Katakana Phonetic Extensions"](a)||kn.Katakana(a)||kn["Vertical Forms"](a)||kn["Yi Radicals"](a)||kn["Yi Syllables"](a)));(bs[h]||d)&&o.push(As(p+1,l,s,o,ws(h,t.getCharCode(p+1),d&&u),!1));}}return function t(e){return e?t(e.priorBreak).concat(e.index):[]}(As(t.length(),l,s,o,0,!0))}function Ss(t){var e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=1;break;case"left":case"top-left":case"bottom-left":e=0;}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;}return {horizontalAlign:e,verticalAlign:r}}function zs(t,e,r,n,i){if(i){var a=t[n],o=e[a.fontStack],s=o&&o[a.glyph];if(s)for(var u=s.metrics.advance*a.scale,l=(t[n].x+u)*i,p=r;p<=n;p++)t[p].x-=l;}}bs[10]=!0,bs[32]=!0,bs[38]=!0,bs[40]=!0,bs[41]=!0,bs[43]=!0,bs[45]=!0,bs[47]=!0,bs[173]=!0,bs[183]=!0,bs[8203]=!0,bs[8208]=!0,bs[8211]=!0,bs[8231]=!0;var Is=function(t){function e(e,r,n,i){t.call(this,e,r),this.angle=n,void 0!==i&&(this.segment=i);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.clone=function(){return new e(this.x,this.y,this.angle,this.segment)},e}(i);xn("Anchor",Is);var Cs=256;function Bs(t,e){var r=e.expression;if("constant"===r.kind)return {kind:"constant",layoutSize:r.evaluate(new On(t+1))};if("source"===r.kind)return {kind:"source"};for(var n=r.zoomStops,i=r.interpolationType,a=0;a<n.length&&n[a]<=t;)a++;for(var o=a=Math.max(0,a-1);o<n.length&&n[o]<t+1;)o++;o=Math.min(n.length-1,o);var s=n[a],u=n[o];return "composite"===r.kind?{kind:"composite",minZoom:s,maxZoom:u,interpolationType:i}:{kind:"camera",minZoom:s,maxZoom:u,minSize:r.evaluate(new On(s)),maxSize:r.evaluate(new On(u)),interpolationType:i}}function Es(t,e,r){var n=e.uSize,i=e.uSizeT,a=r.lowerSize,o=r.upperSize;return "source"===t.kind?a/Cs:"composite"===t.kind?Ae(a/Cs,o/Cs,i):n}function Ps(t,e){var r=0,n=0;if("constant"===t.kind)n=t.layoutSize;else if("source"!==t.kind){var i=t.interpolationType,a=t.minZoom,o=t.maxZoom,s=i?l(Ke.interpolationFactor(i,e,a,o),0,1):0;"camera"===t.kind?n=Ae(t.minSize,t.maxSize,s):r=s;}return {uSizeT:r,uSize:n}}var Ms=Object.freeze({getSizeData:Bs,evaluateSizeForFeature:Es,evaluateSizeForZoom:Ps,SIZE_PACK_FACTOR:Cs}),Ts=jo.VectorTileFeature.types,Vs=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function Fs(t,e,r,n,i,a,o,s){t.emplaceBack(e,r,Math.round(32*n),Math.round(32*i),a,o,s?s[0]:0,s?s[1]:0);}function Os(t,e,r){t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r);}var Ls=function(t){this.layoutVertexArray=new ui,this.indexArray=new xi,this.programConfigurations=t,this.segments=new Li,this.dynamicLayoutVertexArray=new li,this.opacityVertexArray=new pi,this.placedSymbolArray=new Ii;};Ls.prototype.upload=function(t,e,r,n){r&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,us.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,e),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,ls.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,Vs,!0),this.opacityVertexBuffer.itemSize=1),(r||n)&&this.programConfigurations.upload(t);},Ls.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy());},xn("SymbolBuffers",Ls);var Ds=function(t,e,r){this.layoutVertexArray=new t,this.layoutAttributes=e,this.indexArray=new r,this.segments=new Li,this.collisionVertexArray=new fi;};Ds.prototype.upload=function(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,ps.members,!0);},Ds.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy());},xn("CollisionBuffers",Ds);var Us=function(t){this.collisionBoxArray=t.collisionBoxArray,this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(function(t){return t.id}),this.index=t.index,this.pixelRatio=t.pixelRatio,this.sourceLayerIndex=t.sourceLayerIndex,this.hasPattern=!1,this.hasPaintOverrides=!1;var e=this.layers[0]._unevaluatedLayout._values;this.textSizeData=Bs(this.zoom,e["text-size"]),this.iconSizeData=Bs(this.zoom,e["icon-size"]);var r=this.layers[0].layout,n=r.get("symbol-sort-key"),i=r.get("symbol-z-order");this.sortFeaturesByKey="viewport-y"!==i&&void 0!==n.constantOr(1);var a="viewport-y"===i||"auto"===i&&!this.sortFeaturesByKey;this.sortFeaturesByY=a&&(r.get("text-allow-overlap")||r.get("icon-allow-overlap")||r.get("text-ignore-placement")||r.get("icon-ignore-placement")),"point"===r.get("symbol-placement")&&(this.writingModes=r.get("text-writing-mode").map(function(t){return ms[t]})),this.stateDependentLayerIds=this.layers.filter(function(t){return t.isStateDependent()}).map(function(t){return t.id}),this.sourceID=t.sourceID;};Us.prototype.createArrays=function(){var t=this.layers[0].layout;this.hasPaintOverrides=Ns.hasPaintOverrides(t),this.text=new Ls(new na(us.members,this.layers,this.zoom,function(t){return /^text/.test(t)})),this.icon=new Ls(new na(us.members,this.layers,this.zoom,function(t){return /^icon/.test(t)})),this.textCollisionBox=new Ds(hi,cs.members,bi),this.iconCollisionBox=new Ds(hi,cs.members,bi),this.textCollisionCircle=new Ds(hi,hs.members,xi),this.iconCollisionCircle=new Ds(hi,hs.members,xi),this.glyphOffsetArray=new Pi,this.lineVertexArray=new Ti,this.symbolInstances=new Bi;},Us.prototype.calculateGlyphDependencies=function(t,e,r,n,i){for(var a=0;a<t.length;a++)if(e[t.charCodeAt(a)]=!0,(r||n)&&i){var o=ys[t.charAt(a)];o&&(e[o.charCodeAt(0)]=!0);}},Us.prototype.populate=function(t,e){var r=this.layers[0],n=r.layout,i=n.get("text-font"),a=n.get("text-field"),o=n.get("icon-image"),s=("constant"!==a.value.kind||a.value.value.toString().length>0)&&("constant"!==i.value.kind||i.value.value.length>0),u=("constant"!==o.value.kind||!!o.value.value)&&Object.keys(o.parameters).length>0,l=n.get("symbol-sort-key");if(this.features=[],s||u){for(var p=e.iconDependencies,c=e.glyphDependencies,h=e.availableImages,f=new On(this.zoom),y=0,d=t;y<d.length;y+=1){var m=d[y],v=m.feature,g=m.index,x=m.sourceLayerIndex;if(r._featureFilter(f,v)){var b=void 0;if(s){var _=r.getValueAndResolveTokens("text-field",v,h);b=fs(_ instanceof Qt?_:Qt.fromString(_),r,v);}var w=void 0;if(u){var A=r.getValueAndResolveTokens("icon-image",v,h);w=A instanceof te?A:A&&"string"!=typeof A?te.fromString(A):te.fromString({name:A,available:!1});}if(b||w){var k=this.sortFeaturesByKey?l.evaluate(v,{}):void 0,S={text:b,icon:w,index:g,sourceLayerIndex:x,geometry:la(v),properties:v.properties,type:Ts[v.type],sortKey:k};if(void 0!==v.id&&(S.id=v.id),this.features.push(S),w&&(p[w.name]=!0),b){var z=i.evaluate(v,{}).join(","),I="map"===n.get("text-rotation-alignment")&&"point"!==n.get("symbol-placement");this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(ms.vertical)>=0;for(var C=0,B=b.sections;C<B.length;C+=1){var E=B[C],P=Sn(b.toString()),M=E.fontStack||z,T=c[M]=c[M]||{};this.calculateGlyphDependencies(E.text,T,I,this.allowVerticalPlacement,P);}}}}}"line"===n.get("symbol-placement")&&(this.features=function(t){var e={},r={},n=[],i=0;function a(e){n.push(t[e]),i++;}function o(t,e,i){var a=r[t];return delete r[t],r[e]=a,n[a].geometry[0].pop(),n[a].geometry[0]=n[a].geometry[0].concat(i[0]),a}function s(t,r,i){var a=e[r];return delete e[r],e[t]=a,n[a].geometry[0].shift(),n[a].geometry[0]=i[0].concat(n[a].geometry[0]),a}function u(t,e,r){var n=r?e[0][e[0].length-1]:e[0][0];return t+":"+n.x+":"+n.y}for(var l=0;l<t.length;l++){var p=t[l],c=p.geometry,h=p.text?p.text.toString():null;if(h){var f=u(h,c),y=u(h,c,!0);if(f in r&&y in e&&r[f]!==e[y]){var d=s(f,y,c),m=o(f,y,n[d].geometry);delete e[f],delete r[y],r[u(h,n[m].geometry,!0)]=m,n[d].geometry=null;}else f in r?o(f,y,c):y in e?s(f,y,c):(a(l),e[f]=i-1,r[y]=i-1);}else a(l);}return n.filter(function(t){return t.geometry})}(this.features)),this.sortFeaturesByKey&&this.features.sort(function(t,e){return t.sortKey-e.sortKey});}},Us.prototype.update=function(t,e,r){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(t,e,this.layers,r),this.icon.programConfigurations.updatePaintArrays(t,e,this.layers,r));},Us.prototype.isEmpty=function(){return 0===this.symbolInstances.length},Us.prototype.uploadPending=function(){return !this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload},Us.prototype.upload=function(t){this.uploaded||(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t),this.textCollisionCircle.upload(t),this.iconCollisionCircle.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0;},Us.prototype.destroy=function(){this.text.destroy(),this.icon.destroy(),this.textCollisionBox.destroy(),this.iconCollisionBox.destroy(),this.textCollisionCircle.destroy(),this.iconCollisionCircle.destroy();},Us.prototype.addToLineVertexArray=function(t,e){var r=this.lineVertexArray.length;if(void 0!==t.segment){for(var n=t.dist(e[t.segment+1]),i=t.dist(e[t.segment]),a={},o=t.segment+1;o<e.length;o++)a[o]={x:e[o].x,y:e[o].y,tileUnitDistanceFromAnchor:n},o<e.length-1&&(n+=e[o+1].dist(e[o]));for(var s=t.segment||0;s>=0;s--)a[s]={x:e[s].x,y:e[s].y,tileUnitDistanceFromAnchor:i},s>0&&(i+=e[s-1].dist(e[s]));for(var u=0;u<e.length;u++){var l=a[u];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor);}}return {lineStartIndex:r,lineLength:this.lineVertexArray.length-r}},Us.prototype.addSymbols=function(t,e,r,n,i,a,o,s,u,l,p){var c=this,h=t.indexArray,f=t.layoutVertexArray,y=t.dynamicLayoutVertexArray,d=t.segments.prepareSegment(4*e.length,t.layoutVertexArray,t.indexArray,a.sortKey),m=this.glyphOffsetArray.length,v=d.vertexLength,g=this.allowVerticalPlacement&&o===ms.vertical?Math.PI/2:0,x=function(t){var e=t.tl,n=t.tr,i=t.bl,a=t.br,o=t.tex,u=d.vertexLength,l=t.glyphOffset[1];Fs(f,s.x,s.y,e.x,l+e.y,o.x,o.y,r),Fs(f,s.x,s.y,n.x,l+n.y,o.x+o.w,o.y,r),Fs(f,s.x,s.y,i.x,l+i.y,o.x,o.y+o.h,r),Fs(f,s.x,s.y,a.x,l+a.y,o.x+o.w,o.y+o.h,r),Os(y,s,g),h.emplaceBack(u,u+1,u+2),h.emplaceBack(u+1,u+2,u+3),d.vertexLength+=4,d.primitiveLength+=2,c.glyphOffsetArray.emplaceBack(t.glyphOffset[0]);};if(a.text&&a.text.sections){var b=a.text.sections;if(this.hasPaintOverrides){for(var _,w=function(e,r){void 0===_||_===e&&!r||t.programConfigurations.populatePaintArrays(t.layoutVertexArray.length,a,a.index,{},b[_]),_=e;},A=0,k=e;A<k.length;A+=1){var S=k[A];w(S.sectionIndex,!1),x(S);}w(_,!0);}else{for(var z=0,I=e;z<I.length;z+=1){x(I[z]);}t.programConfigurations.populatePaintArrays(t.layoutVertexArray.length,a,a.index,{},b[0]);}}else{for(var C=0,B=e;C<B.length;C+=1){x(B[C]);}t.programConfigurations.populatePaintArrays(t.layoutVertexArray.length,a,a.index,{});}t.placedSymbolArray.emplaceBack(s.x,s.y,m,this.glyphOffsetArray.length-m,v,u,l,s.segment,r?r[0]:0,r?r[1]:0,n[0],n[1],o,0,!1,0,p);},Us.prototype._addCollisionDebugVertex=function(t,e,r,n,i,a){return e.emplaceBack(0,0),t.emplaceBack(r.x,r.y,n,i,Math.round(a.x),Math.round(a.y))},Us.prototype.addCollisionDebugVertices=function(t,e,r,n,a,o,s,u){var l=a.segments.prepareSegment(4,a.layoutVertexArray,a.indexArray),p=l.vertexLength,c=a.layoutVertexArray,h=a.collisionVertexArray,f=s.anchorX,y=s.anchorY;if(this._addCollisionDebugVertex(c,h,o,f,y,new i(t,e)),this._addCollisionDebugVertex(c,h,o,f,y,new i(r,e)),this._addCollisionDebugVertex(c,h,o,f,y,new i(r,n)),this._addCollisionDebugVertex(c,h,o,f,y,new i(t,n)),l.vertexLength+=4,u){var d=a.indexArray;d.emplaceBack(p,p+1,p+2),d.emplaceBack(p,p+2,p+3),l.primitiveLength+=2;}else{var m=a.indexArray;m.emplaceBack(p,p+1),m.emplaceBack(p+1,p+2),m.emplaceBack(p+2,p+3),m.emplaceBack(p+3,p),l.primitiveLength+=4;}},Us.prototype.addDebugCollisionBoxes=function(t,e,r,n){for(var i=t;i<e;i++){var a=this.collisionBoxArray.get(i),o=a.x1,s=a.y1,u=a.x2,l=a.y2,p=a.radius>0;this.addCollisionDebugVertices(o,s,u,l,p?n?this.textCollisionCircle:this.iconCollisionCircle:n?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,r,p);}},Us.prototype.generateCollisionDebugBuffers=function(){for(var t=0;t<this.symbolInstances.length;t++){var e=this.symbolInstances.get(t);this.addDebugCollisionBoxes(e.textBoxStartIndex,e.textBoxEndIndex,e,!0),this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex,e.verticalTextBoxEndIndex,e,!0),this.addDebugCollisionBoxes(e.iconBoxStartIndex,e.iconBoxEndIndex,e,!1);}},Us.prototype._deserializeCollisionBoxesForSymbol=function(t,e,r,n,i,a,o){for(var s={},u=e;u<r;u++){var l=t.get(u);if(0===l.radius){s.textBox={x1:l.x1,y1:l.y1,x2:l.x2,y2:l.y2,anchorPointX:l.anchorPointX,anchorPointY:l.anchorPointY},s.textFeatureIndex=l.featureIndex;break}s.textCircles||(s.textCircles=[],s.textFeatureIndex=l.featureIndex);s.textCircles.push(l.anchorPointX,l.anchorPointY,l.radius,l.signedDistanceFromAnchor,1);}for(var p=n;p<i;p++){var c=t.get(p);if(0===c.radius){s.verticalTextBox={x1:c.x1,y1:c.y1,x2:c.x2,y2:c.y2,anchorPointX:c.anchorPointX,anchorPointY:c.anchorPointY},s.verticalTextFeatureIndex=c.featureIndex;break}}for(var h=a;h<o;h++){var f=t.get(h);if(0===f.radius){s.iconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},s.iconFeatureIndex=f.featureIndex;break}}return s},Us.prototype.deserializeCollisionBoxes=function(t){this.collisionArrays=[];for(var e=0;e<this.symbolInstances.length;e++){var r=this.symbolInstances.get(e);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,r.textBoxStartIndex,r.textBoxEndIndex,r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r.iconBoxStartIndex,r.iconBoxEndIndex));}},Us.prototype.hasTextData=function(){return this.text.segments.get().length>0},Us.prototype.hasIconData=function(){return this.icon.segments.get().length>0},Us.prototype.hasTextCollisionBoxData=function(){return this.textCollisionBox.segments.get().length>0},Us.prototype.hasIconCollisionBoxData=function(){return this.iconCollisionBox.segments.get().length>0},Us.prototype.hasTextCollisionCircleData=function(){return this.textCollisionCircle.segments.get().length>0},Us.prototype.hasIconCollisionCircleData=function(){return this.iconCollisionCircle.segments.get().length>0},Us.prototype.addIndicesForPlacedTextSymbol=function(t){for(var e=this.text.placedSymbolArray.get(t),r=e.vertexStartIndex+4*e.numGlyphs,n=e.vertexStartIndex;n<r;n+=4)this.text.indexArray.emplaceBack(n,n+1,n+2),this.text.indexArray.emplaceBack(n+1,n+2,n+3);},Us.prototype.getSortedSymbolIndexes=function(t){if(this.sortedAngle===t&&void 0!==this.symbolInstanceIndexes)return this.symbolInstanceIndexes;for(var e=Math.sin(t),r=Math.cos(t),n=[],i=[],a=[],o=0;o<this.symbolInstances.length;++o){a.push(o);var s=this.symbolInstances.get(o);n.push(0|Math.round(e*s.anchorX+r*s.anchorY)),i.push(s.featureIndex);}return a.sort(function(t,e){return n[t]-n[e]||i[e]-i[t]}),a},Us.prototype.sortFeatures=function(t){var e=this;if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(var r=0,n=this.symbolInstanceIndexes;r<n.length;r+=1){var i=n[r],a=this.symbolInstances.get(i);this.featureSortOrder.push(a.featureIndex),[a.rightJustifiedTextSymbolIndex,a.centerJustifiedTextSymbolIndex,a.leftJustifiedTextSymbolIndex].forEach(function(t,r,n){t>=0&&n.indexOf(t)===r&&e.addIndicesForPlacedTextSymbol(t);}),a.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedTextSymbol(a.verticalPlacedTextSymbolIndex);var o=this.icon.placedSymbolArray.get(i);if(o.numGlyphs){var s=o.vertexStartIndex;this.icon.indexArray.emplaceBack(s,s+1,s+2),this.icon.indexArray.emplaceBack(s+1,s+2,s+3);}}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray);}},xn("SymbolBucket",Us,{omit:["layers","collisionBoxArray","features","compareText"]}),Us.MAX_GLYPHS=65535,Us.addDynamicAttributes=Os;var Rs=new Yn({"symbol-placement":new Zn(zt.layout_symbol["symbol-placement"]),"symbol-spacing":new Zn(zt.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new Zn(zt.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new Xn(zt.layout_symbol["symbol-sort-key"]),"symbol-z-order":new Zn(zt.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new Zn(zt.layout_symbol["icon-allow-overlap"]),"icon-ignore-placement":new Zn(zt.layout_symbol["icon-ignore-placement"]),"icon-optional":new Zn(zt.layout_symbol["icon-optional"]),"icon-rotation-alignment":new Zn(zt.layout_symbol["icon-rotation-alignment"]),"icon-size":new Xn(zt.layout_symbol["icon-size"]),"icon-text-fit":new Zn(zt.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new Zn(zt.layout_symbol["icon-text-fit-padding"]),"icon-image":new Xn(zt.layout_symbol["icon-image"]),"icon-rotate":new Xn(zt.layout_symbol["icon-rotate"]),"icon-padding":new Zn(zt.layout_symbol["icon-padding"]),"icon-keep-upright":new Zn(zt.layout_symbol["icon-keep-upright"]),"icon-offset":new Xn(zt.layout_symbol["icon-offset"]),"icon-anchor":new Xn(zt.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new Zn(zt.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new Zn(zt.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new Zn(zt.layout_symbol["text-rotation-alignment"]),"text-field":new Xn(zt.layout_symbol["text-field"]),"text-font":new Xn(zt.layout_symbol["text-font"]),"text-size":new Xn(zt.layout_symbol["text-size"]),"text-max-width":new Xn(zt.layout_symbol["text-max-width"]),"text-line-height":new Zn(zt.layout_symbol["text-line-height"]),"text-letter-spacing":new Xn(zt.layout_symbol["text-letter-spacing"]),"text-justify":new Xn(zt.layout_symbol["text-justify"]),"text-radial-offset":new Xn(zt.layout_symbol["text-radial-offset"]),"text-variable-anchor":new Zn(zt.layout_symbol["text-variable-anchor"]),"text-anchor":new Xn(zt.layout_symbol["text-anchor"]),"text-max-angle":new Zn(zt.layout_symbol["text-max-angle"]),"text-writing-mode":new Zn(zt.layout_symbol["text-writing-mode"]),"text-rotate":new Xn(zt.layout_symbol["text-rotate"]),"text-padding":new Zn(zt.layout_symbol["text-padding"]),"text-keep-upright":new Zn(zt.layout_symbol["text-keep-upright"]),"text-transform":new Xn(zt.layout_symbol["text-transform"]),"text-offset":new Xn(zt.layout_symbol["text-offset"]),"text-allow-overlap":new Zn(zt.layout_symbol["text-allow-overlap"]),"text-ignore-placement":new Zn(zt.layout_symbol["text-ignore-placement"]),"text-optional":new Zn(zt.layout_symbol["text-optional"])}),js={paint:new Yn({"icon-opacity":new Xn(zt.paint_symbol["icon-opacity"]),"icon-color":new Xn(zt.paint_symbol["icon-color"]),"icon-halo-color":new Xn(zt.paint_symbol["icon-halo-color"]),"icon-halo-width":new Xn(zt.paint_symbol["icon-halo-width"]),"icon-halo-blur":new Xn(zt.paint_symbol["icon-halo-blur"]),"icon-translate":new Zn(zt.paint_symbol["icon-translate"]),"icon-translate-anchor":new Zn(zt.paint_symbol["icon-translate-anchor"]),"text-opacity":new Xn(zt.paint_symbol["text-opacity"]),"text-color":new Xn(zt.paint_symbol["text-color"],{runtimeType:Ut,getOverride:function(t){return t.textColor},hasOverride:function(t){return !!t.textColor}}),"text-halo-color":new Xn(zt.paint_symbol["text-halo-color"]),"text-halo-width":new Xn(zt.paint_symbol["text-halo-width"]),"text-halo-blur":new Xn(zt.paint_symbol["text-halo-blur"]),"text-translate":new Zn(zt.paint_symbol["text-translate"]),"text-translate-anchor":new Zn(zt.paint_symbol["text-translate-anchor"])}),layout:Rs},qs=function(t){this.type=t.property.overrides?t.property.overrides.runtimeType:Ft,this.defaultValue=t;};qs.prototype.evaluate=function(t){if(t.formattedSection){var e=this.defaultValue.property.overrides;if(e&&e.hasOverride(t.formattedSection))return e.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default},qs.prototype.eachChild=function(t){this.defaultValue.isConstant()||t(this.defaultValue.value._styleExpression.expression);},qs.prototype.possibleOutputs=function(){return [void 0]},qs.prototype.serialize=function(){return null},xn("FormatSectionOverride",qs,{omit:["defaultValue"]});var Ns=function(t){function e(e){t.call(this,e,js);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.recalculate=function(e,r){if(t.prototype.recalculate.call(this,e,r),"auto"===this.layout.get("icon-rotation-alignment")&&("point"!==this.layout.get("symbol-placement")?this.layout._values["icon-rotation-alignment"]="map":this.layout._values["icon-rotation-alignment"]="viewport"),"auto"===this.layout.get("text-rotation-alignment")&&("point"!==this.layout.get("symbol-placement")?this.layout._values["text-rotation-alignment"]="map":this.layout._values["text-rotation-alignment"]="viewport"),"auto"===this.layout.get("text-pitch-alignment")&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")),"auto"===this.layout.get("icon-pitch-alignment")&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),"point"===this.layout.get("symbol-placement")){var n=this.layout.get("text-writing-mode");if(n){for(var i=[],a=0,o=n;a<o.length;a+=1){var s=o[a];i.indexOf(s)<0&&i.push(s);}this.layout._values["text-writing-mode"]=i;}else this.layout._values["text-writing-mode"]=["horizontal"];}this._setPaintOverrides();},e.prototype.getValueAndResolveTokens=function(t,e,r){var n=this.layout.get(t).evaluate(e,{},r),i=this._unevaluatedLayout._values[t];return i.isDataDriven()||Ir(i.value)||!n?n:function(t,e){return e.replace(/{([^{}]+)}/g,function(e,r){return r in t?String(t[r]):""})}(e.properties,n)},e.prototype.createBucket=function(t){return new Us(t)},e.prototype.queryRadius=function(){return 0},e.prototype.queryIntersectsFeature=function(){return !1},e.prototype._setPaintOverrides=function(){for(var t=0,r=js.paint.overridableProperties;t<r.length;t+=1){var n=r[t];if(e.hasPaintOverride(this.layout,n)){var i=this.paint.get(n),a=new qs(i),o=new zr(a,i.property.specification),s=null;s="constant"===i.value.kind||"source"===i.value.kind?new Br("source",o):new Er("composite",o,i.value.zoomStops,i.value._interpolationType),this.paint._values[n]=new Nn(i.property,s,i.parameters);}}},e.prototype._handleOverridablePaintPropertyUpdate=function(t,r,n){return !(!this.layout||r.isDataDriven()||n.isDataDriven())&&e.hasPaintOverride(this.layout,t)},e.hasPaintOverride=function(t,e){var r=t.get("text-field"),n=js.paint.properties[e],i=!1,a=function(t){for(var e=0,r=t;e<r.length;e+=1){var a=r[e];if(n.overrides&&n.overrides.hasOverride(a))return void(i=!0)}};if("constant"===r.value.kind&&r.value.value instanceof Qt)a(r.value.value.sections);else if("source"===r.value.kind){var o=function(t){if(!i)if(t instanceof ie&&re(t.value)===Nt){var e=t.value;a(e.sections);}else t instanceof ue?a(t.sections):t.eachChild(o);},s=r.value;s._styleExpression&&o(s._styleExpression.expression);}return i},e.hasPaintOverrides=function(t){for(var r=0,n=js.paint.overridableProperties;r<n.length;r+=1){var i=n[r];if(e.hasPaintOverride(t,i))return !0}return !1},e}($n),Ks={paint:new Yn({"background-color":new Zn(zt.paint_background["background-color"]),"background-pattern":new Jn(zt.paint_background["background-pattern"]),"background-opacity":new Zn(zt.paint_background["background-opacity"])})},Zs=function(t){function e(e){t.call(this,e,Ks);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}($n),Xs={paint:new Yn({"raster-opacity":new Zn(zt.paint_raster["raster-opacity"]),"raster-hue-rotate":new Zn(zt.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new Zn(zt.paint_raster["raster-brightness-min"]),"raster-brightness-max":new Zn(zt.paint_raster["raster-brightness-max"]),"raster-saturation":new Zn(zt.paint_raster["raster-saturation"]),"raster-contrast":new Zn(zt.paint_raster["raster-contrast"]),"raster-resampling":new Zn(zt.paint_raster["raster-resampling"]),"raster-fade-duration":new Zn(zt.paint_raster["raster-fade-duration"])})},Gs=function(t){function e(e){t.call(this,e,Xs);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}($n);var Js=function(t){function e(e){t.call(this,e,{}),this.implementation=e;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.is3D=function(){return "3d"===this.implementation.renderingMode},e.prototype.hasOffscreenPass=function(){return void 0!==this.implementation.prerender},e.prototype.recalculate=function(){},e.prototype.updateTransitions=function(){},e.prototype.hasTransition=function(){},e.prototype.serialize=function(){},e.prototype.onAdd=function(t){this.implementation.onAdd&&this.implementation.onAdd(t,t.painter.context.gl);},e.prototype.onRemove=function(t){this.implementation.onRemove&&this.implementation.onRemove(t,t.painter.context.gl);},e}($n),Hs={circle:Ma,heatmap:qa,hillshade:Ka,fill:Po,"fill-extrusion":Ho,line:os,symbol:Ns,background:Zs,raster:Gs};function Ys(t){for(var e=0,r=0,n=0,i=t;n<i.length;n+=1){var a=i[n];e+=a.w*a.h,r=Math.max(r,a.w);}t.sort(function(t,e){return e.h-t.h});for(var o=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),r),h:1/0}],s=0,u=0,l=0,p=t;l<p.length;l+=1)for(var c=p[l],h=o.length-1;h>=0;h--){var f=o[h];if(!(c.w>f.w||c.h>f.h)){if(c.x=f.x,c.y=f.y,u=Math.max(u,c.y+c.h),s=Math.max(s,c.x+c.w),c.w===f.w&&c.h===f.h){var y=o.pop();h<o.length&&(o[h]=y);}else c.h===f.h?(f.x+=c.w,f.w-=c.w):c.w===f.w?(f.y+=c.h,f.h-=c.h):(o.push({x:f.x+c.w,y:f.y,w:f.w-c.w,h:c.h}),f.y+=c.h,f.h-=c.h);break}}return {w:s,h:u,fill:e/(s*u)||0}}var $s=function(t,e){var r=e.pixelRatio,n=e.version;this.paddedRect=t,this.pixelRatio=r,this.version=n;},Ws={tl:{configurable:!0},br:{configurable:!0},tlbr:{configurable:!0},displaySize:{configurable:!0}};Ws.tl.get=function(){return [this.paddedRect.x+1,this.paddedRect.y+1]},Ws.br.get=function(){return [this.paddedRect.x+this.paddedRect.w-1,this.paddedRect.y+this.paddedRect.h-1]},Ws.tlbr.get=function(){return this.tl.concat(this.br)},Ws.displaySize.get=function(){return [(this.paddedRect.w-2)/this.pixelRatio,(this.paddedRect.h-2)/this.pixelRatio]},Object.defineProperties($s.prototype,Ws);var Qs=function(t,e){var r={},n={};this.haveRenderCallbacks=[];var i=[];this.addImages(t,r,i),this.addImages(e,n,i);var a=Ys(i),o=a.w,s=a.h,u=new Ua({width:o||1,height:s||1});for(var l in t){var p=t[l],c=r[l].paddedRect;Ua.copy(p.data,u,{x:0,y:0},{x:c.x+1,y:c.y+1},p.data);}for(var h in e){var f=e[h],y=n[h].paddedRect,d=y.x+1,m=y.y+1,v=f.data.width,g=f.data.height;Ua.copy(f.data,u,{x:0,y:0},{x:d,y:m},f.data),Ua.copy(f.data,u,{x:0,y:g-1},{x:d,y:m-1},{width:v,height:1}),Ua.copy(f.data,u,{x:0,y:0},{x:d,y:m+g},{width:v,height:1}),Ua.copy(f.data,u,{x:v-1,y:0},{x:d-1,y:m},{width:1,height:g}),Ua.copy(f.data,u,{x:0,y:0},{x:d+v,y:m},{width:1,height:g});}this.image=u,this.iconPositions=r,this.patternPositions=n;};Qs.prototype.addImages=function(t,e,r){for(var n in t){var i=t[n],a={x:0,y:0,w:i.data.width+2,h:i.data.height+2};r.push(a),e[n]=new $s(a,i),i.hasRenderCallback&&this.haveRenderCallbacks.push(n);}},Qs.prototype.patchUpdatedImages=function(t,e){for(var r in t.dispatchRenderCallbacks(this.haveRenderCallbacks),t.updatedImages)this.patchUpdatedImage(this.iconPositions[r],t.getImage(r),e),this.patchUpdatedImage(this.patternPositions[r],t.getImage(r),e);},Qs.prototype.patchUpdatedImage=function(t,e,r){if(t&&e&&t.version!==e.version){t.version=e.version;var n=t.tl,i=n[0],a=n[1];r.update(e.data,void 0,{x:i,y:a});}},xn("ImagePosition",$s),xn("ImageAtlas",Qs);var tu=self.HTMLImageElement,eu=self.HTMLCanvasElement,ru=self.HTMLVideoElement,nu=self.ImageData,iu=function(t,e,r,n){this.context=t,this.format=r,this.texture=t.gl.createTexture(),this.update(e,n);};iu.prototype.update=function(t,e,r){var n=t.width,i=t.height,a=!(this.size&&this.size[0]===n&&this.size[1]===i||r),o=this.context,s=o.gl;if(this.useMipmap=Boolean(e&&e.useMipmap),s.bindTexture(s.TEXTURE_2D,this.texture),o.pixelStoreUnpackFlipY.set(!1),o.pixelStoreUnpack.set(1),o.pixelStoreUnpackPremultiplyAlpha.set(this.format===s.RGBA&&(!e||!1!==e.premultiply)),a)this.size=[n,i],t instanceof tu||t instanceof eu||t instanceof ru||t instanceof nu?s.texImage2D(s.TEXTURE_2D,0,this.format,this.format,s.UNSIGNED_BYTE,t):s.texImage2D(s.TEXTURE_2D,0,this.format,n,i,0,this.format,s.UNSIGNED_BYTE,t.data);else{var u=r||{x:0,y:0},l=u.x,p=u.y;t instanceof tu||t instanceof eu||t instanceof ru||t instanceof nu?s.texSubImage2D(s.TEXTURE_2D,0,l,p,s.RGBA,s.UNSIGNED_BYTE,t):s.texSubImage2D(s.TEXTURE_2D,0,l,p,n,i,s.RGBA,s.UNSIGNED_BYTE,t.data);}this.useMipmap&&this.isSizePowerOfTwo()&&s.generateMipmap(s.TEXTURE_2D);},iu.prototype.bind=function(t,e,r){var n=this.context.gl;n.bindTexture(n.TEXTURE_2D,this.texture),r!==n.LINEAR_MIPMAP_NEAREST||this.isSizePowerOfTwo()||(r=n.LINEAR),t!==this.filter&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,r||t),this.filter=t),e!==this.wrap&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,e),this.wrap=e);},iu.prototype.isSizePowerOfTwo=function(){return this.size[0]===this.size[1]&&Math.log(this.size[0])/Math.LN2%1==0},iu.prototype.destroy=function(){this.context.gl.deleteTexture(this.texture),this.texture=null;};var au=function(t,e,r,n,i){var a,o,s=8*i-n-1,u=(1<<s)-1,l=u>>1,p=-7,c=r?i-1:0,h=r?-1:1,f=t[e+c];for(c+=h,a=f&(1<<-p)-1,f>>=-p,p+=s;p>0;a=256*a+t[e+c],c+=h,p-=8);for(o=a&(1<<-p)-1,a>>=-p,p+=n;p>0;o=256*o+t[e+c],c+=h,p-=8);if(0===a)a=1-l;else{if(a===u)return o?NaN:1/0*(f?-1:1);o+=Math.pow(2,n),a-=l;}return (f?-1:1)*o*Math.pow(2,a-n)},ou=function(t,e,r,n,i,a){var o,s,u,l=8*a-i-1,p=(1<<l)-1,c=p>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:a-1,y=n?1:-1,d=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=p):(o=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-o))<1&&(o--,u*=2),(e+=o+c>=1?h/u:h*Math.pow(2,1-c))*u>=2&&(o++,u/=2),o+c>=p?(s=0,o=p):o+c>=1?(s=(e*u-1)*Math.pow(2,i),o+=c):(s=e*Math.pow(2,c-1)*Math.pow(2,i),o=0));i>=8;t[r+f]=255&s,f+=y,s/=256,i-=8);for(o=o<<i|s,l+=i;l>0;t[r+f]=255&o,f+=y,o/=256,l-=8);t[r+f-y]|=128*d;},su=uu;function uu(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length;}uu.Varint=0,uu.Fixed64=1,uu.Bytes=2,uu.Fixed32=5;function lu(t){return t.type===uu.Bytes?t.readVarint()+t.pos:t.pos+1}function pu(t,e,r){return r?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function cu(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(7*Math.LN2));r.realloc(n);for(var i=r.pos-1;i>=t;i--)r.buf[i+n]=r.buf[i];}function hu(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r]);}function fu(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r]);}function yu(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r]);}function du(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r]);}function mu(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r]);}function vu(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r]);}function gu(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r]);}function xu(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r]);}function bu(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r]);}function _u(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function wu(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24;}function Au(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}uu.prototype={destroy:function(){this.buf=null;},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,a=this.pos;this.type=7&n,t(i,e,this),this.pos===a&&this.skip(n);}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=_u(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=Au(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=_u(this.buf,this.pos)+4294967296*_u(this.buf,this.pos+4);return this.pos+=8,t},readSFixed64:function(){var t=_u(this.buf,this.pos)+4294967296*Au(this.buf,this.pos+4);return this.pos+=8,t},readFloat:function(){var t=au(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=au(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e,r,n=this.buf;return e=127&(r=n[this.pos++]),r<128?e:(e|=(127&(r=n[this.pos++]))<<7,r<128?e:(e|=(127&(r=n[this.pos++]))<<14,r<128?e:(e|=(127&(r=n[this.pos++]))<<21,r<128?e:function(t,e,r){var n,i,a=r.buf;if(i=a[r.pos++],n=(112&i)>>4,i<128)return pu(t,n,e);if(i=a[r.pos++],n|=(127&i)<<3,i<128)return pu(t,n,e);if(i=a[r.pos++],n|=(127&i)<<10,i<128)return pu(t,n,e);if(i=a[r.pos++],n|=(127&i)<<17,i<128)return pu(t,n,e);if(i=a[r.pos++],n|=(127&i)<<24,i<128)return pu(t,n,e);if(i=a[r.pos++],n|=(1&i)<<31,i<128)return pu(t,n,e);throw new Error("Expected varint not more than 10 bytes")}(e|=(15&(r=n[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,e=function(t,e,r){var n="",i=e;for(;i<r;){var a,o,s,u=t[i],l=null,p=u>239?4:u>223?3:u>191?2:1;if(i+p>r)break;1===p?u<128&&(l=u):2===p?128==(192&(a=t[i+1]))&&(l=(31&u)<<6|63&a)<=127&&(l=null):3===p?(a=t[i+1],o=t[i+2],128==(192&a)&&128==(192&o)&&((l=(15&u)<<12|(63&a)<<6|63&o)<=2047||l>=55296&&l<=57343)&&(l=null)):4===p&&(a=t[i+1],o=t[i+2],s=t[i+3],128==(192&a)&&128==(192&o)&&128==(192&s)&&((l=(15&u)<<18|(63&a)<<12|(63&o)<<6|63&s)<=65535||l>=1114112)&&(l=null)),null===l?(l=65533,p=1):l>65535&&(l-=65536,n+=String.fromCharCode(l>>>10&1023|55296),l=56320|1023&l),n+=String.fromCharCode(l),i+=p;}return n}(this.buf,this.pos,t);return this.pos=t,e},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==uu.Bytes)return t.push(this.readVarint(e));var r=lu(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==uu.Bytes)return t.push(this.readSVarint());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==uu.Bytes)return t.push(this.readBoolean());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==uu.Bytes)return t.push(this.readFloat());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==uu.Bytes)return t.push(this.readDouble());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==uu.Bytes)return t.push(this.readFixed32());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==uu.Bytes)return t.push(this.readSFixed32());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==uu.Bytes)return t.push(this.readFixed64());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==uu.Bytes)return t.push(this.readSFixed64());var e=lu(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=7&t;if(e===uu.Varint)for(;this.buf[this.pos++]>127;);else if(e===uu.Bytes)this.pos=this.readVarint()+this.pos;else if(e===uu.Fixed32)this.pos+=4;else{if(e!==uu.Fixed64)throw new Error("Unimplemented type: "+e);this.pos+=8;}},writeTag:function(t,e){this.writeVarint(t<<3|e);},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e;}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),wu(this.buf,t,this.pos),this.pos+=4;},writeSFixed32:function(t){this.realloc(4),wu(this.buf,t,this.pos),this.pos+=4;},writeFixed64:function(t){this.realloc(8),wu(this.buf,-1&t,this.pos),wu(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8;},writeSFixed64:function(t){this.realloc(8),wu(this.buf,-1&t,this.pos),wu(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8;},writeVarint:function(t){(t=+t||0)>268435455||t<0?function(t,e){var r,n;t>=0?(r=t%4294967296|0,n=t/4294967296|0):(n=~(-t/4294967296),4294967295^(r=~(-t%4294967296))?r=r+1|0:(r=0,n=n+1|0));if(t>=0x10000000000000000||t<-0x10000000000000000)throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10),function(t,e,r){r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos]=127&t;}(r,0,e),function(t,e){var r=(7&t)<<4;if(e.buf[e.pos++]|=r|((t>>>=3)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;e.buf[e.pos++]=127&t;}(n,e);}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))));},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t);},writeBoolean:function(t){this.writeVarint(Boolean(t));},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var e=this.pos;this.pos=function(t,e,r){for(var n,i,a=0;a<e.length;a++){if((n=e.charCodeAt(a))>55295&&n<57344){if(!i){n>56319||a+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):i=n;continue}if(n<56320){t[r++]=239,t[r++]=191,t[r++]=189,i=n;continue}n=i-55296<<10|n-56320|65536,i=null;}else i&&(t[r++]=239,t[r++]=191,t[r++]=189,i=null);n<128?t[r++]=n:(n<2048?t[r++]=n>>6|192:(n<65536?t[r++]=n>>12|224:(t[r++]=n>>18|240,t[r++]=n>>12&63|128),t[r++]=n>>6&63|128),t[r++]=63&n|128);}return r}(this.buf,t,this.pos);var r=this.pos-e;r>=128&&cu(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r;},writeFloat:function(t){this.realloc(4),ou(this.buf,t,this.pos,!0,23,4),this.pos+=4;},writeDouble:function(t){this.realloc(8),ou(this.buf,t,this.pos,!0,52,8),this.pos+=8;},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r];},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&cu(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n;},writeMessage:function(t,e,r){this.writeTag(t,uu.Bytes),this.writeRawMessage(e,r);},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,hu,e);},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,fu,e);},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,mu,e);},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,yu,e);},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,du,e);},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,vu,e);},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,gu,e);},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,xu,e);},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,bu,e);},writeBytesField:function(t,e){this.writeTag(t,uu.Bytes),this.writeBytes(e);},writeFixed32Field:function(t,e){this.writeTag(t,uu.Fixed32),this.writeFixed32(e);},writeSFixed32Field:function(t,e){this.writeTag(t,uu.Fixed32),this.writeSFixed32(e);},writeFixed64Field:function(t,e){this.writeTag(t,uu.Fixed64),this.writeFixed64(e);},writeSFixed64Field:function(t,e){this.writeTag(t,uu.Fixed64),this.writeSFixed64(e);},writeVarintField:function(t,e){this.writeTag(t,uu.Varint),this.writeVarint(e);},writeSVarintField:function(t,e){this.writeTag(t,uu.Varint),this.writeSVarint(e);},writeStringField:function(t,e){this.writeTag(t,uu.Bytes),this.writeString(e);},writeFloatField:function(t,e){this.writeTag(t,uu.Fixed32),this.writeFloat(e);},writeDoubleField:function(t,e){this.writeTag(t,uu.Fixed64),this.writeDouble(e);},writeBooleanField:function(t,e){this.writeVarintField(t,Boolean(e));}};var ku=3;function Su(t,e,r){1===t&&r.readMessage(zu,e);}function zu(t,e,r){if(3===t){var n=r.readMessage(Iu,{}),i=n.id,a=n.bitmap,o=n.width,s=n.height,u=n.left,l=n.top,p=n.advance;e.push({id:i,bitmap:new Da({width:o+2*ku,height:s+2*ku},a),metrics:{width:o,height:s,left:u,top:l,advance:p}});}}function Iu(t,e,r){1===t?e.id=r.readVarint():2===t?e.bitmap=r.readBytes():3===t?e.width=r.readVarint():4===t?e.height=r.readVarint():5===t?e.left=r.readSVarint():6===t?e.top=r.readSVarint():7===t&&(e.advance=r.readVarint());}var Cu=ku,Bu=function(t){var e=this;this._callback=t,this._triggered=!1,"undefined"!=typeof MessageChannel&&(this._channel=new MessageChannel,this._channel.port2.onmessage=function(){e._triggered=!1,e._callback();});};Bu.prototype.trigger=function(){var t=this;this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout(function(){t._triggered=!1,t._callback();},0));};var Eu=function(t,e,r){this.target=t,this.parent=e,this.mapId=r,this.callbacks={},this.tasks={},this.taskQueue=[],this.cancelCallbacks={},m(["receive","process"],this),this.invoker=new Bu(this.process),this.target.addEventListener("message",this.receive,!1);};function Pu(t,e,r){var n=2*Math.PI*6378137/256/Math.pow(2,r);return [t*n-2*Math.PI*6378137/2,e*n-2*Math.PI*6378137/2]}Eu.prototype.send=function(t,e,r,n){var i=this,a=Math.round(1e18*Math.random()).toString(36).substring(0,10);r&&(this.callbacks[a]=r);var o=[];return this.target.postMessage({id:a,type:t,hasCallback:!!r,targetMapId:n,sourceMapId:this.mapId,data:_n(e,o)},o),{cancel:function(){r&&delete i.callbacks[a],i.target.postMessage({id:a,type:"<cancel>",targetMapId:n,sourceMapId:i.mapId});}}},Eu.prototype.receive=function(t){var e=t.data,r=e.id;if(r&&(!e.targetMapId||this.mapId===e.targetMapId))if("<cancel>"===e.type){delete this.tasks[r];var n=this.cancelCallbacks[r];delete this.cancelCallbacks[r],n&&n();}else this.tasks[r]=e,this.taskQueue.push(r),this.invoker.trigger();},Eu.prototype.process=function(){var t=this;if(this.taskQueue.length){var e=this.taskQueue.shift(),r=this.tasks[e];if(delete this.tasks[e],this.taskQueue.length&&this.invoker.trigger(),r)if("<response>"===r.type){var n=this.callbacks[e];delete this.callbacks[e],n&&(r.error?n(wn(r.error)):n(null,wn(r.data)));}else{var i=!1,a=r.hasCallback?function(r,n){i=!0,delete t.cancelCallbacks[e];var a=[];t.target.postMessage({id:e,type:"<response>",sourceMapId:t.mapId,error:r?_n(r):null,data:_n(n,a)},a);}:function(t){i=!0;},o=null,s=wn(r.data);if(this.parent[r.type])o=this.parent[r.type](r.sourceMapId,s,a);else if(this.parent.getWorkerSource){var u=r.type.split(".");o=this.parent.getWorkerSource(r.sourceMapId,u[0],s.source)[u[1]](s,a);}else a(new Error("Could not find function "+r.type));!i&&o&&o.cancel&&(this.cancelCallbacks[e]=o.cancel);}}},Eu.prototype.remove=function(){this.target.removeEventListener("message",this.receive,!1);};var Mu=function(t,e){t&&(e?this.setSouthWest(t).setNorthEast(e):4===t.length?this.setSouthWest([t[0],t[1]]).setNorthEast([t[2],t[3]]):this.setSouthWest(t[0]).setNorthEast(t[1]));};Mu.prototype.setNorthEast=function(t){return this._ne=t instanceof Tu?new Tu(t.lng,t.lat):Tu.convert(t),this},Mu.prototype.setSouthWest=function(t){return this._sw=t instanceof Tu?new Tu(t.lng,t.lat):Tu.convert(t),this},Mu.prototype.extend=function(t){var e,r,n=this._sw,i=this._ne;if(t instanceof Tu)e=t,r=t;else{if(!(t instanceof Mu))return Array.isArray(t)?t.every(Array.isArray)?this.extend(Mu.convert(t)):this.extend(Tu.convert(t)):this;if(e=t._sw,r=t._ne,!e||!r)return this}return n||i?(n.lng=Math.min(e.lng,n.lng),n.lat=Math.min(e.lat,n.lat),i.lng=Math.max(r.lng,i.lng),i.lat=Math.max(r.lat,i.lat)):(this._sw=new Tu(e.lng,e.lat),this._ne=new Tu(r.lng,r.lat)),this},Mu.prototype.getCenter=function(){return new Tu((this._sw.lng+this._ne.lng)/2,(this._sw.lat+this._ne.lat)/2)},Mu.prototype.getSouthWest=function(){return this._sw},Mu.prototype.getNorthEast=function(){return this._ne},Mu.prototype.getNorthWest=function(){return new Tu(this.getWest(),this.getNorth())},Mu.prototype.getSouthEast=function(){return new Tu(this.getEast(),this.getSouth())},Mu.prototype.getWest=function(){return this._sw.lng},Mu.prototype.getSouth=function(){return this._sw.lat},Mu.prototype.getEast=function(){return this._ne.lng},Mu.prototype.getNorth=function(){return this._ne.lat},Mu.prototype.toArray=function(){return [this._sw.toArray(),this._ne.toArray()]},Mu.prototype.toString=function(){return "LngLatBounds("+this._sw.toString()+", "+this._ne.toString()+")"},Mu.prototype.isEmpty=function(){return !(this._sw&&this._ne)},Mu.convert=function(t){return !t||t instanceof Mu?t:new Mu(t)};var Tu=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid LngLat object: ("+t+", "+e+")");if(this.lng=+t,this.lat=+e,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")};Tu.prototype.wrap=function(){return new Tu(p(this.lng,-180,180),this.lat)},Tu.prototype.toArray=function(){return [this.lng,this.lat]},Tu.prototype.toString=function(){return "LngLat("+this.lng+", "+this.lat+")"},Tu.prototype.toBounds=function(t){void 0===t&&(t=0);var e=360*t/40075017,r=e/Math.cos(Math.PI/180*this.lat);return new Mu(new Tu(this.lng-r,this.lat-e),new Tu(this.lng+r,this.lat+e))},Tu.convert=function(t){if(t instanceof Tu)return t;if(Array.isArray(t)&&(2===t.length||3===t.length))return new Tu(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&"object"==typeof t&&null!==t)return new Tu(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")};var Vu=2*Math.PI*6378137;function Fu(t){return Vu*Math.cos(t*Math.PI/180)}function Ou(t){return (180+t)/360}function Lu(t){return (180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function Du(t,e){return t/Fu(e)}function Uu(t){var e=180-360*t;return 360/Math.PI*Math.atan(Math.exp(e*Math.PI/180))-90}var Ru=function(t,e,r){void 0===r&&(r=0),this.x=+t,this.y=+e,this.z=+r;};Ru.fromLngLat=function(t,e){void 0===e&&(e=0);var r=Tu.convert(t);return new Ru(Ou(r.lng),Lu(r.lat),Du(e,r.lat))},Ru.prototype.toLngLat=function(){return new Tu(360*this.x-180,Uu(this.y))},Ru.prototype.toAltitude=function(){return t=this.z,e=this.y,t*Fu(Uu(e));var t,e;},Ru.prototype.meterInMercatorCoordinateUnits=function(){return 1/Vu*(t=Uu(this.y),1/Math.cos(t*Math.PI/180));var t;};var ju=function(t,e,r){this.z=t,this.x=e,this.y=r,this.key=Ku(0,t,e,r);};ju.prototype.equals=function(t){return this.z===t.z&&this.x===t.x&&this.y===t.y},ju.prototype.url=function(t,e){var r,n,i,a,o,s=(r=this.x,n=this.y,i=this.z,a=Pu(256*r,256*(n=Math.pow(2,i)-n-1),i),o=Pu(256*(r+1),256*(n+1),i),a[0]+","+a[1]+","+o[0]+","+o[1]),u=function(t,e,r){for(var n,i="",a=t;a>0;a--)i+=(e&(n=1<<a-1)?1:0)+(r&n?2:0);return i}(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace("{prefix}",(this.x%16).toString(16)+(this.y%16).toString(16)).replace("{z}",String(this.z)).replace("{x}",String(this.x)).replace("{y}",String("tms"===e?Math.pow(2,this.z)-this.y-1:this.y)).replace("{quadkey}",u).replace("{bbox-epsg-3857}",s)},ju.prototype.getTilePoint=function(t){var e=Math.pow(2,this.z);return new i((t.x*e-this.x)*oa,(t.y*e-this.y)*oa)};var qu=function(t,e){this.wrap=t,this.canonical=e,this.key=Ku(t,e.z,e.x,e.y);},Nu=function(t,e,r,n,i){this.overscaledZ=t,this.wrap=e,this.canonical=new ju(r,+n,+i),this.key=Ku(e,t,n,i);};function Ku(t,e,r,n){(t*=2)<0&&(t=-1*t-1);var i=1<<e;return 32*(i*i*t+i*n+r)+e}Nu.prototype.equals=function(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)},Nu.prototype.scaledTo=function(t){var e=this.canonical.z-t;return t>this.canonical.z?new Nu(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new Nu(t,this.wrap,t,this.canonical.x>>e,this.canonical.y>>e)},Nu.prototype.isChildOf=function(t){if(t.wrap!==this.wrap)return !1;var e=this.canonical.z-t.canonical.z;return 0===t.overscaledZ||t.overscaledZ<this.overscaledZ&&t.canonical.x===this.canonical.x>>e&&t.canonical.y===this.canonical.y>>e},Nu.prototype.children=function(t){if(this.overscaledZ>=t)return [new Nu(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];var e=this.canonical.z+1,r=2*this.canonical.x,n=2*this.canonical.y;return [new Nu(e,this.wrap,e,r,n),new Nu(e,this.wrap,e,r+1,n),new Nu(e,this.wrap,e,r,n+1),new Nu(e,this.wrap,e,r+1,n+1)]},Nu.prototype.isLessThan=function(t){return this.wrap<t.wrap||!(this.wrap>t.wrap)&&(this.overscaledZ<t.overscaledZ||!(this.overscaledZ>t.overscaledZ)&&(this.canonical.x<t.canonical.x||!(this.canonical.x>t.canonical.x)&&this.canonical.y<t.canonical.y))},Nu.prototype.wrapped=function(){return new Nu(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)},Nu.prototype.unwrapTo=function(t){return new Nu(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)},Nu.prototype.overscaleFactor=function(){return Math.pow(2,this.overscaledZ-this.canonical.z)},Nu.prototype.toUnwrapped=function(){return new qu(this.wrap,this.canonical)},Nu.prototype.toString=function(){return this.overscaledZ+"/"+this.canonical.x+"/"+this.canonical.y},Nu.prototype.getTilePoint=function(t){return this.canonical.getTilePoint(new Ru(t.x-this.wrap,t.y))},xn("CanonicalTileID",ju),xn("OverscaledTileID",Nu,{omit:["posMatrix"]});var Zu=function(t,e,r){if(this.uid=t,e.height!==e.width)throw new RangeError("DEM tiles must be square");if(r&&"mapbox"!==r&&"terrarium"!==r)return w('"'+r+'" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');this.stride=e.height;var n=this.dim=e.height-2;this.data=new Uint32Array(e.data.buffer),this.encoding=r||"mapbox";for(var i=0;i<n;i++)this.data[this._idx(-1,i)]=this.data[this._idx(0,i)],this.data[this._idx(n,i)]=this.data[this._idx(n-1,i)],this.data[this._idx(i,-1)]=this.data[this._idx(i,0)],this.data[this._idx(i,n)]=this.data[this._idx(i,n-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(n,-1)]=this.data[this._idx(n-1,0)],this.data[this._idx(-1,n)]=this.data[this._idx(0,n-1)],this.data[this._idx(n,n)]=this.data[this._idx(n-1,n-1)];};Zu.prototype.get=function(t,e){var r=new Uint8Array(this.data.buffer),n=4*this._idx(t,e);return ("terrarium"===this.encoding?this._unpackTerrarium:this._unpackMapbox)(r[n],r[n+1],r[n+2])},Zu.prototype.getUnpackVector=function(){return "terrarium"===this.encoding?[256,1,1/256,32768]:[6553.6,25.6,.1,1e4]},Zu.prototype._idx=function(t,e){if(t<-1||t>=this.dim+1||e<-1||e>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return (e+1)*this.stride+(t+1)},Zu.prototype._unpackMapbox=function(t,e,r){return (256*t*256+256*e+r)/10-1e4},Zu.prototype._unpackTerrarium=function(t,e,r){return 256*t+e+r/256-32768},Zu.prototype.getPixels=function(){return new Ua({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))},Zu.prototype.backfillBorder=function(t,e,r){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");var n=e*this.dim,i=e*this.dim+this.dim,a=r*this.dim,o=r*this.dim+this.dim;switch(e){case-1:n=i-1;break;case 1:i=n+1;}switch(r){case-1:a=o-1;break;case 1:o=a+1;}for(var s=-e*this.dim,u=-r*this.dim,l=a;l<o;l++)for(var p=n;p<i;p++)this.data[this._idx(p,l)]=t.data[this._idx(p+s,l+u)];},xn("DEMData",Zu);var Xu=ei([{name:"a_pos",type:"Int16",components:2},{name:"a_texture_pos",type:"Int16",components:2}]);var Gu=function(t){this._stringToNumber={},this._numberToString=[];for(var e=0;e<t.length;e++){var r=t[e];this._stringToNumber[r]=e,this._numberToString[e]=r;}};Gu.prototype.encode=function(t){return this._stringToNumber[t]},Gu.prototype.decode=function(t){return this._numberToString[t]};var Ju=function(t,e,r,n){this.type="Feature",this._vectorTileFeature=t,t._z=e,t._x=r,t._y=n,this.properties=t.properties,null!=t.id&&(this.id=t.id);},Hu={geometry:{configurable:!0}};Hu.geometry.get=function(){return void 0===this._geometry&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry},Hu.geometry.set=function(t){this._geometry=t;},Ju.prototype.toJSON=function(){var t={geometry:this.geometry};for(var e in this)"_geometry"!==e&&"_vectorTileFeature"!==e&&(t[e]=this[e]);return t},Object.defineProperties(Ju.prototype,Hu);var Yu=function(){this.state={},this.stateChanges={},this.deletedStates={};};Yu.prototype.updateState=function(t,e,r){var n=String(e);if(this.stateChanges[t]=this.stateChanges[t]||{},this.stateChanges[t][n]=this.stateChanges[t][n]||{},c(this.stateChanges[t][n],r),null===this.deletedStates[t])for(var i in this.deletedStates[t]={},this.state[t])i!==n&&(this.deletedStates[t][i]=null);else if(this.deletedStates[t]&&null===this.deletedStates[t][n])for(var a in this.deletedStates[t][n]={},this.state[t][n])r[a]||(this.deletedStates[t][n][a]=null);else for(var o in r){this.deletedStates[t]&&this.deletedStates[t][n]&&null===this.deletedStates[t][n][o]&&delete this.deletedStates[t][n][o];}},Yu.prototype.removeFeatureState=function(t,e,r){if(!(null===this.deletedStates[t])){var n=String(e);if(this.deletedStates[t]=this.deletedStates[t]||{},r&&void 0!==e&&e>=0)null!==this.deletedStates[t][n]&&(this.deletedStates[t][n]=this.deletedStates[t][n]||{},this.deletedStates[t][n][r]=null);else if(void 0!==e&&e>=0){if(this.stateChanges[t]&&this.stateChanges[t][n])for(r in this.deletedStates[t][n]={},this.stateChanges[t][n])this.deletedStates[t][n][r]=null;else this.deletedStates[t][n]=null;}else this.deletedStates[t]=null;}},Yu.prototype.getState=function(t,e){var r=String(e),n=this.state[t]||{},i=this.stateChanges[t]||{},a=c({},n[r],i[r]);if(null===this.deletedStates[t])return {};if(this.deletedStates[t]){var o=this.deletedStates[t][e];if(null===o)return {};for(var s in o)delete a[s];}return a},Yu.prototype.initializeTileState=function(t,e){t.setFeatureState(this.state,e);},Yu.prototype.coalesceChanges=function(t,e){var r={};for(var n in this.stateChanges){this.state[n]=this.state[n]||{};var i={};for(var a in this.stateChanges[n])this.state[n][a]||(this.state[n][a]={}),c(this.state[n][a],this.stateChanges[n][a]),i[a]=this.state[n][a];r[n]=i;}for(var o in this.deletedStates){this.state[o]=this.state[o]||{};var s={};if(null===this.deletedStates[o])for(var u in this.state[o])s[u]={},this.state[o][u]={};else for(var l in this.deletedStates[o]){if(null===this.deletedStates[o][l])this.state[o][l]={};else for(var p=0,h=Object.keys(this.deletedStates[o][l]);p<h.length;p+=1){var f=h[p];delete this.state[o][l][f];}s[l]=this.state[o][l];}r[o]=r[o]||{},c(r[o],s);}if(this.stateChanges={},this.deletedStates={},0!==Object.keys(r).length)for(var y in t){t[y].setFeatureState(r,e);}};var $u=function(t,e,r){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=e||new yn(oa,16,0),this.grid3D=new yn(oa,16,0),this.featureIndexArray=r||new Fi;};function Wu(t){for(var e=1/0,r=1/0,n=-1/0,i=-1/0,a=0,o=t;a<o.length;a+=1){var s=o[a];e=Math.min(e,s.x),r=Math.min(r,s.y),n=Math.max(n,s.x),i=Math.max(i,s.y);}return {minX:e,minY:r,maxX:n,maxY:i}}function Qu(t,e){return e-t}$u.prototype.insert=function(t,e,r,n,i,a){var o=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(r,n,i);for(var s=a?this.grid3D:this.grid,u=0;u<e.length;u++){for(var l=e[u],p=[1/0,1/0,-1/0,-1/0],c=0;c<l.length;c++){var h=l[c];p[0]=Math.min(p[0],h.x),p[1]=Math.min(p[1],h.y),p[2]=Math.max(p[2],h.x),p[3]=Math.max(p[3],h.y);}p[0]<oa&&p[1]<oa&&p[2]>=0&&p[3]>=0&&s.insert(o,p[0],p[1],p[2],p[3]);}},$u.prototype.loadVTLayers=function(){return this.vtLayers||(this.vtLayers=new jo.VectorTile(new su(this.rawTileData)).layers,this.sourceLayerCoder=new Gu(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers},$u.prototype.query=function(t,e,r){var n=this;this.loadVTLayers();for(var a=t.params||{},o=oa/t.tileSize/t.scale,s=jr(a.filter),u=t.queryGeometry,l=t.queryPadding*o,p=Wu(u),c=this.grid.query(p.minX-l,p.minY-l,p.maxX+l,p.maxY+l),h=Wu(t.cameraQueryGeometry),f=this.grid3D.query(h.minX-l,h.minY-l,h.maxX+l,h.maxY+l,function(e,r,n,a){return function(t,e,r,n,a){for(var o=0,s=t;o<s.length;o+=1){var u=s[o];if(e<=u.x&&r<=u.y&&n>=u.x&&a>=u.y)return !0}var l=[new i(e,r),new i(e,a),new i(n,a),new i(n,r)];if(t.length>2)for(var p=0,c=l;p<c.length;p+=1){if(_a(t,c[p]))return !0}for(var h=0;h<t.length-1;h++){if(wa(t[h],t[h+1],l))return !0}return !1}(t.cameraQueryGeometry,e-l,r-l,n+l,a+l)}),y=0,d=f;y<d.length;y+=1){var m=d[y];c.push(m);}c.sort(Qu);for(var v,g={},x=function(i){var l=c[i];if(l!==v){v=l;var p=n.featureIndexArray.get(l),h=null;n.loadMatchingFeature(g,p.bucketIndex,p.sourceLayerIndex,p.featureIndex,s,a.layers,e,function(e,i){h||(h=la(e));var a={};return e.id&&(a=r.getState(i.sourceLayer||"_geojsonTileLayer",e.id)),i.queryIntersectsFeature(u,e,a,h,n.z,t.transform,o,t.pixelPosMatrix)});}},b=0;b<c.length;b++)x(b);return g},$u.prototype.loadMatchingFeature=function(t,e,r,n,i,a,o,s){var u=this.bucketLayerIDs[e];if(!a||function(t,e){for(var r=0;r<t.length;r++)if(e.indexOf(t[r])>=0)return !0;return !1}(a,u)){var l=this.sourceLayerCoder.decode(r),p=this.vtLayers[l].feature(n);if(i(new On(this.tileID.overscaledZ),p))for(var c=0;c<u.length;c++){var h=u[c];if(!(a&&a.indexOf(h)<0)){var f=o[h];if(f){var y=!s||s(p,f);if(y){var d=new Ju(p,this.z,this.x,this.y);d.layer=f.serialize();var m=t[h];void 0===m&&(m=t[h]=[]),m.push({featureIndex:n,feature:d,intersectionZ:y});}}}}}},$u.prototype.lookupSymbolFeatures=function(t,e,r,n,i,a){var o={};this.loadVTLayers();for(var s=jr(n),u=0,l=t;u<l.length;u+=1){var p=l[u];this.loadMatchingFeature(o,e,r,p,s,i,a);}return o},$u.prototype.hasLayer=function(t){for(var e=0,r=this.bucketLayerIDs;e<r.length;e+=1)for(var n=0,i=r[e];n<i.length;n+=1){if(t===i[n])return !0}return !1},xn("FeatureIndex",$u,{omit:["rawTileData","sourceLayerCoder"]});var tl=function(t,e){this.tileID=t,this.uid=f(),this.uses=0,this.tileSize=e,this.buckets={},this.expirationTime=null,this.queryPadding=0,this.hasSymbolBuckets=!1,this.expiredRequestCount=0,this.state="loading";};tl.prototype.registerFadeDuration=function(t){var e=t+this.timeAdded;e<V.now()||this.fadeEndTime&&e<this.fadeEndTime||(this.fadeEndTime=e);},tl.prototype.wasRequested=function(){return "errored"===this.state||"loaded"===this.state||"reloading"===this.state},tl.prototype.loadVectorData=function(t,e,r){if(this.hasData()&&this.unloadVectorData(),this.state="loaded",t){for(var n in t.featureIndex&&(this.latestFeatureIndex=t.featureIndex,t.rawTileData?(this.latestRawTileData=t.rawTileData,this.latestFeatureIndex.rawTileData=t.rawTileData):this.latestRawTileData&&(this.latestFeatureIndex.rawTileData=this.latestRawTileData)),this.collisionBoxArray=t.collisionBoxArray,this.buckets=function(t,e){var r={};if(!e)return r;for(var n=function(){var t=a[i],n=t.layerIds.map(function(t){return e.getLayer(t)}).filter(Boolean);if(0!==n.length){t.layers=n,t.stateDependentLayerIds&&(t.stateDependentLayers=t.stateDependentLayerIds.map(function(t){return n.filter(function(e){return e.id===t})[0]}));for(var o=0,s=n;o<s.length;o+=1){var u=s[o];r[u.id]=t;}}},i=0,a=t;i<a.length;i+=1)n();return r}(t.buckets,e.style),this.hasSymbolBuckets=!1,this.buckets){var i=this.buckets[n];if(i instanceof Us){if(this.hasSymbolBuckets=!0,!r)break;i.justReloaded=!0;}}for(var a in this.queryPadding=0,this.buckets){var o=this.buckets[a];this.queryPadding=Math.max(this.queryPadding,e.style.getLayer(a).queryRadius(o));}t.imageAtlas&&(this.imageAtlas=t.imageAtlas),t.glyphAtlasImage&&(this.glyphAtlasImage=t.glyphAtlasImage);}else this.collisionBoxArray=new Si;},tl.prototype.unloadVectorData=function(){for(var t in this.buckets)this.buckets[t].destroy();this.buckets={},this.imageAtlasTexture&&this.imageAtlasTexture.destroy(),this.imageAtlas&&(this.imageAtlas=null),this.glyphAtlasTexture&&this.glyphAtlasTexture.destroy(),this.latestFeatureIndex=null,this.state="unloaded";},tl.prototype.unloadDEMData=function(){this.dem=null,this.neighboringTiles=null,this.state="unloaded";},tl.prototype.getBucket=function(t){return this.buckets[t.id]},tl.prototype.upload=function(t){for(var e in this.buckets){var r=this.buckets[e];r.uploadPending()&&r.upload(t);}var n=t.gl;this.imageAtlas&&!this.imageAtlas.uploaded&&(this.imageAtlasTexture=new iu(t,this.imageAtlas.image,n.RGBA),this.imageAtlas.uploaded=!0),this.glyphAtlasImage&&(this.glyphAtlasTexture=new iu(t,this.glyphAtlasImage,n.ALPHA),this.glyphAtlasImage=null);},tl.prototype.prepare=function(t){this.imageAtlas&&this.imageAtlas.patchUpdatedImages(t,this.imageAtlasTexture);},tl.prototype.queryRenderedFeatures=function(t,e,r,n,i,a,o,s,u){return this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData?this.latestFeatureIndex.query({queryGeometry:r,cameraQueryGeometry:n,scale:i,tileSize:this.tileSize,pixelPosMatrix:u,transform:o,params:a,queryPadding:this.queryPadding*s},t,e):{}},tl.prototype.querySourceFeatures=function(t,e){if(this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData){var r=this.latestFeatureIndex.loadVTLayers(),n=e?e.sourceLayer:"",i=r._geojsonTileLayer||r[n];if(i)for(var a=jr(e&&e.filter),o=this.tileID.canonical,s=o.z,u=o.x,l=o.y,p={z:s,x:u,y:l},c=0;c<i.length;c++){var h=i.feature(c);if(a(new On(this.tileID.overscaledZ),h)){var f=new Ju(h,s,u,l);f.tile=p,t.push(f);}}}},tl.prototype.clearMask=function(){this.segments&&(this.segments.destroy(),delete this.segments),this.maskedBoundsBuffer&&(this.maskedBoundsBuffer.destroy(),delete this.maskedBoundsBuffer),this.maskedIndexBuffer&&(this.maskedIndexBuffer.destroy(),delete this.maskedIndexBuffer);},tl.prototype.setMask=function(t,e){if(!o(this.mask,t)&&(this.mask=t,this.clearMask(),!o(t,{0:!0}))){var r=new ii,n=new xi;this.segments=new Li,this.segments.prepareSegment(0,r,n);for(var a=Object.keys(t),s=0;s<a.length;s++){var u=t[+a[s]],l=oa>>u.z,p=new i(u.x*l,u.y*l),c=new i(p.x+l,p.y+l),h=this.segments.prepareSegment(4,r,n);r.emplaceBack(p.x,p.y,p.x,p.y),r.emplaceBack(c.x,p.y,c.x,p.y),r.emplaceBack(p.x,c.y,p.x,c.y),r.emplaceBack(c.x,c.y,c.x,c.y);var f=h.vertexLength;n.emplaceBack(f,f+1,f+2),n.emplaceBack(f+1,f+2,f+3),h.vertexLength+=4,h.primitiveLength+=2;}this.maskedBoundsBuffer=e.createVertexBuffer(r,Xu.members),this.maskedIndexBuffer=e.createIndexBuffer(n);}},tl.prototype.hasData=function(){return "loaded"===this.state||"reloading"===this.state||"expired"===this.state},tl.prototype.patternsLoaded=function(){return this.imageAtlas&&!!Object.keys(this.imageAtlas.patternPositions).length},tl.prototype.setExpiryData=function(t){var e=this.expirationTime;if(t.cacheControl){var r=S(t.cacheControl);r["max-age"]&&(this.expirationTime=Date.now()+1e3*r["max-age"]);}else t.expires&&(this.expirationTime=new Date(t.expires).getTime());if(this.expirationTime){var n=Date.now(),i=!1;if(this.expirationTime>n)i=!1;else if(e)if(this.expirationTime<e)i=!0;else{var a=this.expirationTime-e;a?this.expirationTime=n+Math.max(a,3e4):i=!0;}else i=!0;i?(this.expiredRequestCount++,this.state="expired"):this.expiredRequestCount=0;}},tl.prototype.getExpiryTimeout=function(){if(this.expirationTime)return this.expiredRequestCount?1e3*(1<<Math.min(this.expiredRequestCount-1,31)):Math.min(this.expirationTime-(new Date).getTime(),Math.pow(2,31)-1)},tl.prototype.setFeatureState=function(t,e){if(this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData&&0!==Object.keys(t).length){var r=this.latestFeatureIndex.loadVTLayers();for(var n in this.buckets){var i=this.buckets[n],a=i.layers[0].sourceLayer||"_geojsonTileLayer",o=r[a],s=t[a];o&&s&&0!==Object.keys(s).length&&(i.update(s,o,this.imageAtlas&&this.imageAtlas.patternPositions||{}),e&&e.style&&(this.queryPadding=Math.max(this.queryPadding,e.style.getLayer(n).queryRadius(i))));}}},tl.prototype.holdingForFade=function(){return void 0!==this.symbolFadeHoldUntil},tl.prototype.symbolFadeFinished=function(){return !this.symbolFadeHoldUntil||this.symbolFadeHoldUntil<V.now()},tl.prototype.clearFadeHold=function(){this.symbolFadeHoldUntil=void 0;},tl.prototype.setHoldDuration=function(t){this.symbolFadeHoldUntil=V.now()+t;};function el(t,e,r,n,i){if(void 0===e.segment)return !0;for(var a=e,o=e.segment+1,s=0;s>-r/2;){if(--o<0)return !1;s-=t[o].dist(a),a=t[o];}s+=t[o].dist(t[o+1]),o++;for(var u=[],l=0;s<r/2;){var p=t[o-1],c=t[o],h=t[o+1];if(!h)return !1;var f=p.angleTo(c)-c.angleTo(h);for(f=Math.abs((f+3*Math.PI)%(2*Math.PI)-Math.PI),u.push({distance:s,angleDelta:f}),l+=f;s-u[0].distance>n;)l-=u.shift().angleDelta;if(l>i)return !1;o++,s+=c.dist(h);}return !0}function rl(t){for(var e=0,r=0;r<t.length-1;r++)e+=t[r].dist(t[r+1]);return e}function nl(t,e,r){return t?.6*e*r:0}function il(t,e){return Math.max(t?t.right-t.left:0,e?e.right-e.left:0)}function al(t,e,r,n,i,a){for(var o=nl(r,i,a),s=il(r,n)*a,u=0,l=rl(t)/2,p=0;p<t.length-1;p++){var c=t[p],h=t[p+1],f=c.dist(h);if(u+f>l){var y=(l-u)/f,d=Ae(c.x,h.x,y),m=Ae(c.y,h.y,y),v=new Is(d,m,h.angleTo(c),p);return v._round(),!o||el(t,v,s,o,e)?v:void 0}u+=f;}}function ol(t,e,r,n,i,a,o,s,u){var l=nl(n,a,o),p=il(n,i),c=p*o,h=0===t[0].x||t[0].x===u||0===t[0].y||t[0].y===u;return e-c<e/4&&(e=c+e/4),function t(e,r,n,i,a,o,s,u,l){var p=o/2;var c=rl(e);var h=0,f=r-n;var y=[];for(var d=0;d<e.length-1;d++){for(var m=e[d],v=e[d+1],g=m.dist(v),x=v.angleTo(m);f+n<h+g;){var b=((f+=n)-h)/g,_=Ae(m.x,v.x,b),w=Ae(m.y,v.y,b);if(_>=0&&_<l&&w>=0&&w<l&&f-p>=0&&f+p<=c){var A=new Is(_,w,x,d);A._round(),i&&!el(e,A,o,i,a)||y.push(A);}}h+=g;}u||y.length||s||(y=t(e,h/2,n,i,a,o,s,!0,l));return y}(t,h?e/2*s%e:(p/2+2*a)*o*s%e,e,l,r,c,h,!1,u)}var sl=function(t,e,r,n,a,o,s,u,l,p,c,h){var f=s.top*u-l,y=s.bottom*u+l,d=s.left*u-l,m=s.right*u+l;if(this.boxStartIndex=t.length,p){var v=y-f,g=m-d;v>0&&(v=Math.max(10*u,v),this._addLineCollisionCircles(t,e,r,r.segment,g,v,n,a,o,c));}else{if(h){var x=new i(d,f),b=new i(m,f),_=new i(d,y),w=new i(m,y),A=h*Math.PI/180;x._rotate(A),b._rotate(A),_._rotate(A),w._rotate(A),d=Math.min(x.x,b.x,_.x,w.x),m=Math.max(x.x,b.x,_.x,w.x),f=Math.min(x.y,b.y,_.y,w.y),y=Math.max(x.y,b.y,_.y,w.y);}t.emplaceBack(r.x,r.y,d,f,m,y,n,a,o,0,0);}this.boxEndIndex=t.length;};sl.prototype._addLineCollisionCircles=function(t,e,r,n,i,a,o,s,u,l){var p=a/2,c=Math.floor(i/p)||1,h=1+.4*Math.log(l)/Math.LN2,f=Math.floor(c*h/2),y=-a/2,d=r,m=n+1,v=y,g=-i/2,x=g-i/4;do{if(--m<0){if(v>g)return;m=0;break}v-=e[m].dist(d),d=e[m];}while(v>x);for(var b=e[m].dist(e[m+1]),_=-f;_<c+f;_++){var w=_*p,A=g+w;if(w<0&&(A+=w),w>i&&(A+=w-i),!(A<v)){for(;v+b<A;){if(v+=b,++m+1>=e.length)return;b=e[m].dist(e[m+1]);}var k=A-v,S=e[m],z=e[m+1].sub(S)._unit()._mult(k)._add(S)._round(),I=Math.abs(A-y)<p?0:.8*(A-y);t.emplaceBack(z.x,z.y,-a/2,-a/2,a/2,a/2,o,s,u,a/2,I);}}};var ul=function(t,e){if(void 0===t&&(t=[]),void 0===e&&(e=ll),this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(var r=(this.length>>1)-1;r>=0;r--)this._down(r);};function ll(t,e){return t<e?-1:t>e?1:0}function pl(t,e,r){void 0===e&&(e=1),void 0===r&&(r=!1);for(var n=1/0,a=1/0,o=-1/0,s=-1/0,u=t[0],l=0;l<u.length;l++){var p=u[l];(!l||p.x<n)&&(n=p.x),(!l||p.y<a)&&(a=p.y),(!l||p.x>o)&&(o=p.x),(!l||p.y>s)&&(s=p.y);}var c=o-n,h=s-a,f=Math.min(c,h),y=f/2,d=new ul([],cl);if(0===f)return new i(n,a);for(var m=n;m<o;m+=f)for(var v=a;v<s;v+=f)d.push(new hl(m+y,v+y,y,t));for(var g=function(t){for(var e=0,r=0,n=0,i=t[0],a=0,o=i.length,s=o-1;a<o;s=a++){var u=i[a],l=i[s],p=u.x*l.y-l.x*u.y;r+=(u.x+l.x)*p,n+=(u.y+l.y)*p,e+=3*p;}return new hl(r/e,n/e,0,t)}(t),x=d.length;d.length;){var b=d.pop();(b.d>g.d||!g.d)&&(g=b,r&&console.log("found best %d after %d probes",Math.round(1e4*b.d)/1e4,x)),b.max-g.d<=e||(y=b.h/2,d.push(new hl(b.p.x-y,b.p.y-y,y,t)),d.push(new hl(b.p.x+y,b.p.y-y,y,t)),d.push(new hl(b.p.x-y,b.p.y+y,y,t)),d.push(new hl(b.p.x+y,b.p.y+y,y,t)),x+=4);}return r&&(console.log("num probes: "+x),console.log("best distance: "+g.d)),g.p}function cl(t,e){return e.max-t.max}function hl(t,e,r,n){this.p=new i(t,e),this.h=r,this.d=function(t,e){for(var r=!1,n=1/0,i=0;i<e.length;i++)for(var a=e[i],o=0,s=a.length,u=s-1;o<s;u=o++){var l=a[o],p=a[u];l.y>t.y!=p.y>t.y&&t.x<(p.x-l.x)*(t.y-l.y)/(p.y-l.y)+l.x&&(r=!r),n=Math.min(n,xa(t,l,p));}return (r?1:-1)*Math.sqrt(n)}(this.p,n),this.max=this.d+this.h*Math.SQRT2;}ul.prototype.push=function(t){this.data.push(t),this.length++,this._up(this.length-1);},ul.prototype.pop=function(){if(0!==this.length){var t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}},ul.prototype.peek=function(){return this.data[0]},ul.prototype._up=function(t){for(var e=this.data,r=this.compare,n=e[t];t>0;){var i=t-1>>1,a=e[i];if(r(n,a)>=0)break;e[t]=a,t=i;}e[t]=n;},ul.prototype._down=function(t){for(var e=this.data,r=this.compare,n=this.length>>1,i=e[t];t<n;){var a=1+(t<<1),o=e[a],s=a+1;if(s<this.length&&r(e[s],o)<0&&(a=s,o=e[s]),r(o,i)>=0)break;e[t]=o,t=a;}e[t]=i;};var fl=e(function(t){t.exports=function(t,e){var r,n,i,a,o,s,u,l;for(r=3&t.length,n=t.length-r,i=e,o=3432918353,s=461845907,l=0;l<n;)u=255&t.charCodeAt(l)|(255&t.charCodeAt(++l))<<8|(255&t.charCodeAt(++l))<<16|(255&t.charCodeAt(++l))<<24,++l,i=27492+(65535&(a=5*(65535&(i=(i^=u=(65535&(u=(u=(65535&u)*o+(((u>>>16)*o&65535)<<16)&4294967295)<<15|u>>>17))*s+(((u>>>16)*s&65535)<<16)&4294967295)<<13|i>>>19))+((5*(i>>>16)&65535)<<16)&4294967295))+((58964+(a>>>16)&65535)<<16);switch(u=0,r){case 3:u^=(255&t.charCodeAt(l+2))<<16;case 2:u^=(255&t.charCodeAt(l+1))<<8;case 1:i^=u=(65535&(u=(u=(65535&(u^=255&t.charCodeAt(l)))*o+(((u>>>16)*o&65535)<<16)&4294967295)<<15|u>>>17))*s+(((u>>>16)*s&65535)<<16)&4294967295;}return i^=t.length,i=2246822507*(65535&(i^=i>>>16))+((2246822507*(i>>>16)&65535)<<16)&4294967295,i=3266489909*(65535&(i^=i>>>13))+((3266489909*(i>>>16)&65535)<<16)&4294967295,(i^=i>>>16)>>>0};}),yl=e(function(t){t.exports=function(t,e){for(var r,n=t.length,i=e^n,a=0;n>=4;)r=1540483477*(65535&(r=255&t.charCodeAt(a)|(255&t.charCodeAt(++a))<<8|(255&t.charCodeAt(++a))<<16|(255&t.charCodeAt(++a))<<24))+((1540483477*(r>>>16)&65535)<<16),i=1540483477*(65535&i)+((1540483477*(i>>>16)&65535)<<16)^(r=1540483477*(65535&(r^=r>>>24))+((1540483477*(r>>>16)&65535)<<16)),n-=4,++a;switch(n){case 3:i^=(255&t.charCodeAt(a+2))<<16;case 2:i^=(255&t.charCodeAt(a+1))<<8;case 1:i=1540483477*(65535&(i^=255&t.charCodeAt(a)))+((1540483477*(i>>>16)&65535)<<16);}return i=1540483477*(65535&(i^=i>>>13))+((1540483477*(i>>>16)&65535)<<16),(i^=i>>>15)>>>0};}),dl=fl,ml=fl,vl=yl;dl.murmur3=ml,dl.murmur2=vl;var gl=7,xl=Number.POSITIVE_INFINITY;function bl(t,e){return e[1]!==xl?function(t,e,r){var n=0,i=0;switch(e=Math.abs(e),r=Math.abs(r),t){case"top-right":case"top-left":case"top":i=r-gl;break;case"bottom-right":case"bottom-left":case"bottom":i=-r+gl;}switch(t){case"top-right":case"bottom-right":case"right":n=-e;break;case"top-left":case"bottom-left":case"left":n=e;}return [n,i]}(t,e[0],e[1]):function(t,e){var r=0,n=0;e<0&&(e=0);var i=e/Math.sqrt(2);switch(t){case"top-right":case"top-left":n=i-gl;break;case"bottom-right":case"bottom-left":n=-i+gl;break;case"bottom":n=-e+gl;break;case"top":n=e-gl;}switch(t){case"top-right":case"bottom-right":r=-i;break;case"top-left":case"bottom-left":r=i;break;case"left":r=e;break;case"right":r=-e;}return [r,n]}(t,e[0])}function _l(t){switch(t){case"right":case"top-right":case"bottom-right":return "right";case"left":case"top-left":case"bottom-left":return "left"}return "center"}var wl=65535;function Al(t,e,r,n,a,o,s,u,l,p,c,h,f,y){var d=function(t,e,r,n,a,o,s,u){for(var l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,p=e.positionedGlyphs,c=[],h=0;h<p.length;h++){var f=p[h],y=s[f.fontStack],d=y&&y[f.glyph];if(d){var m=d.rect;if(m){var v=Cu+1,g=d.metrics.advance*f.scale/2,x=a?[f.x+g,f.y]:[0,0],b=a?[0,0]:[f.x+g+r[0],f.y+r[1]],_=(a||u)&&f.vertical,w=[0,0];_&&(w=b,b=[0,0]);var A=(d.metrics.left-v)*f.scale-g+b[0],k=(-d.metrics.top-v)*f.scale+b[1],S=A+m.w*f.scale,z=k+m.h*f.scale,I=new i(A,k),C=new i(S,k),B=new i(A,z),E=new i(S,z);if(_){var P=new i(-g,g-e.yOffset),M=-Math.PI/2,T=ds/2-g,V=new i(5-e.yOffset-T,0),F=new(Function.prototype.bind.apply(i,[null].concat(w)));I._rotateAround(M,P)._add(V)._add(F),C._rotateAround(M,P)._add(V)._add(F),B._rotateAround(M,P)._add(V)._add(F),E._rotateAround(M,P)._add(V)._add(F);}if(l){var O=Math.sin(l),L=Math.cos(l),D=[L,-O,O,L];I._matMult(D),C._matMult(D),B._matMult(D),E._matMult(D);}c.push({tl:I,tr:C,bl:B,br:E,tex:m,writingMode:e.writingMode,glyphOffset:x,sectionIndex:f.sectionIndex});}}}return c}(0,r,s,n,a,o,h,t.allowVerticalPlacement),m=t.textSizeData,v=null;"source"===m.kind?(v=[Cs*n.layout.get("text-size").evaluate(o,{})])[0]>wl&&w(t.layerIds[0]+': Value for "text-size" is >= 256. Reduce your "text-size".'):"composite"===m.kind&&((v=[Cs*y.compositeTextSizes[0].evaluate(o,{}),Cs*y.compositeTextSizes[1].evaluate(o,{})])[0]>wl||v[1]>wl)&&w(t.layerIds[0]+': Value for "text-size" is >= 256. Reduce your "text-size".'),t.addSymbols(t.text,d,v,s,a,o,l,e,u.lineStartIndex,u.lineLength,f);for(var g=0,x=p;g<x.length;g+=1){c[x[g]]=t.text.placedSymbolArray.length-1;}return 4*d.length}function kl(t,e,r,n){var i=t.compareText;if(e in i){for(var a=i[e],o=a.length-1;o>=0;o--)if(n.dist(a[o])<r)return !0}else i[e]=[];return i[e].push(n),!1}t.Actor=Eu,t.AlphaImage=Da,t.CanonicalTileID=ju,t.CollisionBoxArray=Si,t.Color=Yt,t.DEMData=Zu,t.DataConstantProperty=Zn,t.DictionaryCoder=Gu,t.EXTENT=oa,t.ErrorEvent=kt,t.EvaluationParameters=On,t.Event=At,t.Evented=St,t.FeatureIndex=$u,t.FillBucket=Co,t.FillExtrusionBucket=Zo,t.ImageAtlas=Qs,t.ImagePosition=$s,t.LineBucket=rs,t.LngLat=Tu,t.LngLatBounds=Mu,t.MercatorCoordinate=Ru,t.ONE_EM=ds,t.OverscaledTileID=Nu,t.Point=i,t.Point$1=i,t.ProgramConfiguration=ra,t.Properties=Yn,t.Protobuf=su,t.RGBAImage=Ua,t.RequestManager=j,t.ResourceType=pt,t.SegmentVector=Li,t.SourceFeatureState=Yu,t.StructArrayLayout1ui2=_i,t.StructArrayLayout2i4=ni,t.StructArrayLayout2ui4=bi,t.StructArrayLayout3ui6=xi,t.StructArrayLayout4i8=ii,t.SymbolBucket=Us,t.Texture=iu,t.Tile=tl,t.Transitionable=Un,t.Uniform1f=Ni,t.Uniform1i=qi,t.Uniform2f=Ki,t.Uniform3f=Zi,t.Uniform4f=Xi,t.UniformColor=Gi,t.UniformMatrix4f=Hi,t.UnwrappedTileID=qu,t.ValidationError=It,t.WritingMode=ms,t.ZoomHistory=An,t.addDynamicAttributes=Os,t.asyncAll=function(t,e,r){if(!t.length)return r(null,[]);var n=t.length,i=new Array(t.length),a=null;t.forEach(function(t,o){e(t,function(t,e){t&&(a=t),i[o]=e,0==--n&&r(a,i);});});},t.bezier=s,t.bindAll=m,t.browser=V,t.cacheEntryPossiblyAdded=function(t){++lt>it&&(t.getActor().send("enforceCacheSizeLimit",nt),lt=0);},t.clamp=l,t.clearTileCache=function(t){var e=self.caches.delete(rt);t&&e.catch(t).then(function(){return t()});},t.clone=function(t){var e=new Ca(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},t.clone$1=b,t.config=F,t.create=function(){var t=new Ca(16);return Ca!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},t.create$1=function(){var t=new Ca(9);return Ca!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t},t.create$2=function(){var t=new Ca(4);return Ca!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t},t.createCommonjsModule=e,t.createExpression=Cr,t.createLayout=ei,t.createStyleLayer=function(t){return "custom"===t.type?new Js(t):new Hs[t.type](t)},t.deepEqual=o,t.ease=u,t.emitValidationErrors=fn,t.endsWith=v,t.enforceCacheSizeLimit=function(t){self.caches&&self.caches.open(rt).then(function(e){e.keys().then(function(r){for(var n=0;n<r.length-t;n++)e.delete(r[n]);});});},t.evaluateSizeForFeature=Es,t.evaluateSizeForZoom=Ps,t.evaluateVariableOffset=bl,t.evented=Vn,t.extend=c,t.featureFilter=jr,t.filterObject=x,t.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=-r,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},t.getAnchorAlignment=Ss,t.getAnchorJustification=_l,t.getArrayBuffer=mt,t.getImage=bt,t.getJSON=function(t,e){return dt(c(t,{type:"json"}),e)},t.getReferrer=ft,t.getVideo=function(t,e){var r,n,i=self.document.createElement("video");i.muted=!0,i.onloadstart=function(){e(null,i);};for(var a=0;a<t.length;a++){var o=self.document.createElement("source");r=t[a],n=void 0,(n=self.document.createElement("a")).href=r,(n.protocol!==self.document.location.protocol||n.host!==self.document.location.host)&&(i.crossOrigin="Anonymous"),o.src=t[a],i.appendChild(o);}return {cancel:function(){}}},t.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},t.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],o=e[4],s=e[5],u=e[6],l=e[7],p=e[8],c=e[9],h=e[10],f=e[11],y=e[12],d=e[13],m=e[14],v=e[15],g=r*s-n*o,x=r*u-i*o,b=r*l-a*o,_=n*u-i*s,w=n*l-a*s,A=i*l-a*u,k=p*d-c*y,S=p*m-h*y,z=p*v-f*y,I=c*m-h*d,C=c*v-f*d,B=h*v-f*m,E=g*B-x*C+b*I+_*z-w*S+A*k;return E?(E=1/E,t[0]=(s*B-u*C+l*I)*E,t[1]=(i*C-n*B-a*I)*E,t[2]=(d*A-m*w+v*_)*E,t[3]=(h*w-c*A-f*_)*E,t[4]=(u*z-o*B-l*S)*E,t[5]=(r*B-i*z+a*S)*E,t[6]=(m*b-y*A-v*x)*E,t[7]=(p*A-h*b+f*x)*E,t[8]=(o*C-s*z+l*k)*E,t[9]=(n*z-r*C-a*k)*E,t[10]=(y*w-d*b+v*g)*E,t[11]=(c*b-p*w-f*g)*E,t[12]=(s*S-o*I-u*k)*E,t[13]=(r*I-n*S+i*k)*E,t[14]=(d*x-y*_-m*g)*E,t[15]=(p*_-c*x+h*g)*E,t):null},t.isChar=kn,t.isMapboxURL=q,t.keysDifference=function(t,e){var r=[];for(var n in t)n in e||r.push(n);return r},t.makeRequest=dt,t.mapObject=g,t.mercatorXfromLng=Ou,t.mercatorYfromLat=Lu,t.mercatorZfromAltitude=Du,t.multiply=function(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],l=e[6],p=e[7],c=e[8],h=e[9],f=e[10],y=e[11],d=e[12],m=e[13],v=e[14],g=e[15],x=r[0],b=r[1],_=r[2],w=r[3];return t[0]=x*n+b*s+_*c+w*d,t[1]=x*i+b*u+_*h+w*m,t[2]=x*a+b*l+_*f+w*v,t[3]=x*o+b*p+_*y+w*g,x=r[4],b=r[5],_=r[6],w=r[7],t[4]=x*n+b*s+_*c+w*d,t[5]=x*i+b*u+_*h+w*m,t[6]=x*a+b*l+_*f+w*v,t[7]=x*o+b*p+_*y+w*g,x=r[8],b=r[9],_=r[10],w=r[11],t[8]=x*n+b*s+_*c+w*d,t[9]=x*i+b*u+_*h+w*m,t[10]=x*a+b*l+_*f+w*v,t[11]=x*o+b*p+_*y+w*g,x=r[12],b=r[13],_=r[14],w=r[15],t[12]=x*n+b*s+_*c+w*d,t[13]=x*i+b*u+_*h+w*m,t[14]=x*a+b*l+_*f+w*v,t[15]=x*o+b*p+_*y+w*g,t},t.mvt=jo,t.number=Ae,t.ortho=function(t,e,r,n,i,a,o){var s=1/(e-r),u=1/(n-i),l=1/(a-o);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*l,t[11]=0,t[12]=(e+r)*s,t[13]=(i+n)*u,t[14]=(o+a)*l,t[15]=1,t},t.parseGlyphPBF=function(t){return new su(t).readFields(Su,[])},t.pbf=su,t.performSymbolLayout=function(t,e,r,n,a,o){t.createArrays();var s=512*t.overscaling;t.tilePixelRatio=oa/s,t.compareText={},t.iconsNeedLinear=!1;var u=t.layers[0].layout,l=t.layers[0]._unevaluatedLayout._values,p={};if("composite"===t.textSizeData.kind){var c=t.textSizeData,h=c.minZoom,f=c.maxZoom;p.compositeTextSizes=[l["text-size"].possiblyEvaluate(new On(h)),l["text-size"].possiblyEvaluate(new On(f))];}if("composite"===t.iconSizeData.kind){var y=t.iconSizeData,d=y.minZoom,m=y.maxZoom;p.compositeIconSizes=[l["icon-size"].possiblyEvaluate(new On(d)),l["icon-size"].possiblyEvaluate(new On(m))];}p.layoutTextSize=l["text-size"].possiblyEvaluate(new On(t.zoom+1)),p.layoutIconSize=l["icon-size"].possiblyEvaluate(new On(t.zoom+1)),p.textMaxSize=l["text-size"].possiblyEvaluate(new On(18));for(var v=u.get("text-line-height")*ds,g="map"===u.get("text-rotation-alignment")&&"point"!==u.get("symbol-placement"),x=u.get("text-keep-upright"),b=function(){var o=A[_],s=u.get("text-font").evaluate(o,{}).join(","),l=r,c={horizontal:{},vertical:void 0},h=o.text,f=[0,0];if(h){var y=h.toString(),d=u.get("text-letter-spacing").evaluate(o,{})*ds,m=function(t){for(var e=0,r=t;e<r.length;e+=1){if(!zn(r[e].charCodeAt(0)))return !1}return !0}(y)?d:0,b=u.get("text-anchor").evaluate(o,{}),k=u.get("text-variable-anchor");if(!k){var S=u.get("text-radial-offset").evaluate(o,{});f=S?bl(b,[S*ds,xl]):u.get("text-offset").evaluate(o,{}).map(function(t){return t*ds});}var z=g?"center":u.get("text-justify").evaluate(o,{}),I=u.get("symbol-placement"),C="point"===I?u.get("text-max-width").evaluate(o,{})*ds:0,B=function(){t.allowVerticalPlacement&&Sn(y)&&(c.vertical=gs(h,e,s,C,v,b,"left",m,f,ms.vertical,!0,I));};if(!g&&k){for(var E="auto"===z?k.map(function(t){return _l(t)}):[z],P=!1,M=0;M<E.length;M++){var T=E[M];if(!c.horizontal[T])if(P)c.horizontal[T]=c.horizontal[0];else{var V=gs(h,e,s,C,v,"center",T,m,f,ms.horizontal,!1,I);V&&(c.horizontal[T]=V,P=1===V.lineCount);}}B();}else{"auto"===z&&(z=_l(b));var F=gs(h,e,s,C,v,b,z,m,f,ms.horizontal,!1,I);F&&(c.horizontal[z]=F),B(),Sn(y)&&g&&x&&(c.vertical=gs(h,e,s,C,v,b,z,m,f,ms.vertical,!1,I));}}var O=void 0;if(o.icon&&o.icon.name){var L=n[o.icon.name];L&&(O=function(t,e,r){var n=Ss(r),i=n.horizontalAlign,a=n.verticalAlign,o=e[0],s=e[1],u=o-t.displaySize[0]*i,l=u+t.displaySize[0],p=s-t.displaySize[1]*a;return {image:t,top:p,bottom:p+t.displaySize[1],left:u,right:l}}(a[o.icon.name],u.get("icon-offset").evaluate(o,{}),u.get("icon-anchor").evaluate(o,{})),void 0===t.sdfIcons?t.sdfIcons=L.sdf:t.sdfIcons!==L.sdf&&w("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),L.pixelRatio!==t.pixelRatio?t.iconsNeedLinear=!0:0!==u.get("icon-rotate").constantOr(1)&&(t.iconsNeedLinear=!0));}(Object.keys(c.horizontal).length||O)&&function(t,e,r,n,a,o,s){var u=o.layoutTextSize.evaluate(e,{}),l=o.layoutIconSize.evaluate(e,{}),p=o.textMaxSize.evaluate(e,{});void 0===p&&(p=u);var c=t.layers[0].layout,h=c.get("icon-offset").evaluate(e,{}),f=function(t){for(var e in t)return t[e];return null}(r.horizontal),y=u/24,d=t.tilePixelRatio*y,m=t.tilePixelRatio*p/24,v=t.tilePixelRatio*l,g=t.tilePixelRatio*c.get("symbol-spacing"),x=c.get("text-padding")*t.tilePixelRatio,b=c.get("icon-padding")*t.tilePixelRatio,_=c.get("text-max-angle")/180*Math.PI,A="map"===c.get("text-rotation-alignment")&&"point"!==c.get("symbol-placement"),k="map"===c.get("icon-rotation-alignment")&&"point"!==c.get("symbol-placement"),S=c.get("symbol-placement"),z=g/2,I=c.get("icon-text-fit");n&&"none"!==I&&f&&(n=function(t,e,r,n,i,a){var o,s,u,l,p=t.image,c=e.left*a,h=e.right*a;"width"===r||"both"===r?(l=i[0]+c-n[3],s=i[0]+h+n[1]):s=(l=i[0]+(c+h-p.displaySize[0])/2)+p.displaySize[0];var f=e.top*a,y=e.bottom*a;return "height"===r||"both"===r?(o=i[1]+f-n[0],u=i[1]+y+n[2]):u=(o=i[1]+(f+y-p.displaySize[1])/2)+p.displaySize[1],{image:p,top:o,right:s,bottom:u,left:l}}(n,f,I,c.get("icon-text-fit-padding"),h,y));var C=function(u,l){l.x<0||l.x>=oa||l.y<0||l.y>=oa||function(t,e,r,n,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,_){var A,k,S,z,I=t.addToLineVertexArray(e,r),C=0,B=0,E=0,P=-1,M={},T=dl(""),V=0,F=0;void 0===o._unevaluatedLayout.getValue("text-radial-offset")?(A=o.layout.get("text-offset").evaluate(x,{}).map(function(t){return t*ds}),V=A[0],F=A[1]):(V=o.layout.get("text-radial-offset").evaluate(x,{})*ds,F=xl);if(t.allowVerticalPlacement&&n.vertical){var O=o.layout.get("text-rotate").evaluate(x,{})+90,L=n.vertical;z=new sl(s,r,e,u,l,p,L,c,h,f,t.overscaling,O);}if(a){var D=o.layout.get("icon-rotate").evaluate(x,{}),U=function(t,e){var r=t.image,n=t.right-t.left,a=(n*r.paddedRect.w/(r.paddedRect.w-2)-n)/2,o=t.left-a,s=t.right+a,u=t.bottom-t.top,l=(u*r.paddedRect.h/(r.paddedRect.h-2)-u)/2,p=t.top-l,c=t.bottom+l,h=new i(o,p),f=new i(s,p),y=new i(s,c),d=new i(o,c),m=e*Math.PI/180;if(m){var v=Math.sin(m),g=Math.cos(m),x=[g,-v,v,g];h._matMult(x),f._matMult(x),d._matMult(x),y._matMult(x);}return [{tl:h,tr:f,bl:d,br:y,tex:r.paddedRect,writingMode:void 0,glyphOffset:[0,0],sectionIndex:0}]}(a,D);S=new sl(s,r,e,u,l,p,a,d,m,!1,t.overscaling,D),C=4*U.length;var R=t.iconSizeData,j=null;"source"===R.kind?(j=[Cs*o.layout.get("icon-size").evaluate(x,{})])[0]>wl&&w(t.layerIds[0]+': Value for "icon-size" is >= 256. Reduce your "icon-size".'):"composite"===R.kind&&((j=[Cs*_.compositeIconSizes[0].evaluate(x,{}),Cs*_.compositeIconSizes[1].evaluate(x,{})])[0]>wl||j[1]>wl)&&w(t.layerIds[0]+': Value for "icon-size" is >= 256. Reduce your "icon-size".'),t.addSymbols(t.icon,U,j,g,v,x,!1,e,I.lineStartIndex,I.lineLength,-1),P=t.icon.placedSymbolArray.length-1;}for(var q in n.horizontal){var N=n.horizontal[q];if(!k){T=dl(N.text);var K=o.layout.get("text-rotate").evaluate(x,{});k=new sl(s,r,e,u,l,p,N,c,h,f,t.overscaling,K);}var Z=1===N.lineCount;if(B+=Al(t,e,N,o,f,x,y,I,n.vertical?ms.horizontal:ms.horizontalOnly,Z?Object.keys(n.horizontal):[q],M,b,P,_),Z)break}n.vertical&&(E+=Al(t,e,n.vertical,o,f,x,y,I,ms.vertical,["vertical"],M,b,P,_));var X=k?k.boxStartIndex:t.collisionBoxArray.length,G=k?k.boxEndIndex:t.collisionBoxArray.length,J=z?z.boxStartIndex:t.collisionBoxArray.length,H=z?z.boxEndIndex:t.collisionBoxArray.length,Y=S?S.boxStartIndex:t.collisionBoxArray.length,$=S?S.boxEndIndex:t.collisionBoxArray.length;t.glyphOffsetArray.length>=Us.MAX_GLYPHS&&w("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907");t.symbolInstances.emplaceBack(e.x,e.y,M.right>=0?M.right:-1,M.center>=0?M.center:-1,M.left>=0?M.left:-1,M.vertical||-1,P,T,X,G,J,H,Y,$,u,B,E,C,0,c,V,F);}(t,l,u,r,n,t.layers[0],t.collisionBoxArray,e.index,e.sourceLayerIndex,t.index,d,x,A,s,v,b,k,h,e,a,o);};if("line"===S)for(var B=0,E=function(t,e,r,n,a){for(var o=[],s=0;s<t.length;s++)for(var u=t[s],l=void 0,p=0;p<u.length-1;p++){var c=u[p],h=u[p+1];c.x<e&&h.x<e||(c.x<e?c=new i(e,c.y+(h.y-c.y)*((e-c.x)/(h.x-c.x)))._round():h.x<e&&(h=new i(e,c.y+(h.y-c.y)*((e-c.x)/(h.x-c.x)))._round()),c.y<r&&h.y<r||(c.y<r?c=new i(c.x+(h.x-c.x)*((r-c.y)/(h.y-c.y)),r)._round():h.y<r&&(h=new i(c.x+(h.x-c.x)*((r-c.y)/(h.y-c.y)),r)._round()),c.x>=n&&h.x>=n||(c.x>=n?c=new i(n,c.y+(h.y-c.y)*((n-c.x)/(h.x-c.x)))._round():h.x>=n&&(h=new i(n,c.y+(h.y-c.y)*((n-c.x)/(h.x-c.x)))._round()),c.y>=a&&h.y>=a||(c.y>=a?c=new i(c.x+(h.x-c.x)*((a-c.y)/(h.y-c.y)),a)._round():h.y>=a&&(h=new i(c.x+(h.x-c.x)*((a-c.y)/(h.y-c.y)),a)._round()),l&&c.equals(l[l.length-1])||(l=[c],o.push(l)),l.push(h)))));}return o}(e.geometry,0,0,oa,oa);B<E.length;B+=1)for(var P=E[B],M=ol(P,g,_,r.vertical||f,n,24,m,t.overscaling,oa),T=0,V=M;T<V.length;T+=1){var F=V[T],O=f;O&&kl(t,O.text,z,F)||C(P,F);}else if("line-center"===S)for(var L=0,D=e.geometry;L<D.length;L+=1){var U=D[L];if(U.length>1){var R=al(U,_,r.vertical||f,n,24,m);R&&C(U,R);}}else if("Polygon"===e.type)for(var j=0,q=ko(e.geometry,0);j<q.length;j+=1){var N=q[j],K=pl(N,16);C(N[0],new Is(K.x,K.y,0));}else if("LineString"===e.type)for(var Z=0,X=e.geometry;Z<X.length;Z+=1){var G=X[Z];C(G,new Is(G[0].x,G[0].y,0));}else if("Point"===e.type)for(var J=0,H=e.geometry;J<H.length;J+=1)for(var Y=H[J],$=0,W=Y;$<W.length;$+=1){var Q=W[$];C([Q],new Is(Q.x,Q.y,0));}}(t,o,c,O,l,p,f);},_=0,A=t.features;_<A.length;_+=1)b();o&&t.generateCollisionDebugBuffers();},t.perspective=function(t,e,r,n,i){var a,o=1/Math.tan(e/2);return t[0]=o/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(a=1/(n-i),t[10]=(i+n)*a,t[14]=2*i*n*a):(t[10]=-1,t[14]=-2*n),t},t.pick=function(t,e){for(var r={},n=0;n<e.length;n++){var i=e[n];i in t&&(r[i]=t[i]);}return r},t.plugin=Fn,t.polygonIntersectsPolygon=ha,t.postMapLoadEvent=et,t.postTurnstileEvent=Q,t.potpack=Ys,t.rasterBoundsAttributes=Xu,t.refProperties=["type","source","source-layer","minzoom","maxzoom","filter","layout"],t.register=xn,t.registerForPluginAvailability=function(t){return Mn?t({pluginURL:Mn,completionCallback:En}):Vn.once("pluginAvailable",t),t},t.rotate=function(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3],s=Math.sin(r),u=Math.cos(r);return t[0]=n*u+a*s,t[1]=i*u+o*s,t[2]=n*-s+a*u,t[3]=i*-s+o*u,t},t.rotateX=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[4],o=e[5],s=e[6],u=e[7],l=e[8],p=e[9],c=e[10],h=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=a*i+l*n,t[5]=o*i+p*n,t[6]=s*i+c*n,t[7]=u*i+h*n,t[8]=l*i-a*n,t[9]=p*i-o*n,t[10]=c*i-s*n,t[11]=h*i-u*n,t},t.rotateZ=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[0],o=e[1],s=e[2],u=e[3],l=e[4],p=e[5],c=e[6],h=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=a*i+l*n,t[1]=o*i+p*n,t[2]=s*i+c*n,t[3]=u*i+h*n,t[4]=l*i-a*n,t[5]=p*i-o*n,t[6]=c*i-s*n,t[7]=h*i-u*n,t},t.scale=function(t,e,r){var n=r[0],i=r[1],a=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*a,t[9]=e[9]*a,t[10]=e[10]*a,t[11]=e[11]*a,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},t.setCacheLimits=function(t,e){nt=t,it=e;},t.setRTLTextPlugin=function(t,e){if(Pn)throw new Error("setRTLTextPlugin cannot be called multiple times.");Pn=!0,Mn=V.resolveURL(t),En=function(t){t?(Pn=!1,Mn=null,e&&e(t)):Tn=!0;},Vn.fire(new At("pluginAvailable",{pluginURL:Mn,completionCallback:En}));},t.sphericalToCartesian=function(t){var e=t[0],r=t[1],n=t[2];return r+=90,r*=Math.PI/180,n*=Math.PI/180,{x:e*Math.cos(r)*Math.sin(n),y:e*Math.sin(r)*Math.sin(n),z:e*Math.cos(n)}},t.styleSpec=zt,t.symbolSize=Ms,t.transformMat3=function(t,e,r){var n=e[0],i=e[1],a=e[2];return t[0]=n*r[0]+i*r[3]+a*r[6],t[1]=n*r[1]+i*r[4]+a*r[7],t[2]=n*r[2]+i*r[5]+a*r[8],t},t.transformMat4=Pa,t.translate=function(t,e,r){var n,i,a,o,s,u,l,p,c,h,f,y,d=r[0],m=r[1],v=r[2];return e===t?(t[12]=e[0]*d+e[4]*m+e[8]*v+e[12],t[13]=e[1]*d+e[5]*m+e[9]*v+e[13],t[14]=e[2]*d+e[6]*m+e[10]*v+e[14],t[15]=e[3]*d+e[7]*m+e[11]*v+e[15]):(n=e[0],i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],l=e[6],p=e[7],c=e[8],h=e[9],f=e[10],y=e[11],t[0]=n,t[1]=i,t[2]=a,t[3]=o,t[4]=s,t[5]=u,t[6]=l,t[7]=p,t[8]=c,t[9]=h,t[10]=f,t[11]=y,t[12]=n*d+s*m+c*v+e[12],t[13]=i*d+u*m+h*v+e[13],t[14]=a*d+l*m+f*v+e[14],t[15]=o*d+p*m+y*v+e[15]),t},t.uniqueId=f,t.validateCustomStyleLayer=function(t){var e=[],r=t.id;return void 0===r&&e.push({message:"layers."+r+': missing required property "id"'}),void 0===t.render&&e.push({message:"layers."+r+': missing required method "render"'}),t.renderingMode&&"2d"!==t.renderingMode&&"3d"!==t.renderingMode&&e.push({message:"layers."+r+': property "renderingMode" must be either "2d" or "3d"'}),e},t.validateLight=pn,t.validateStyle=ln,t.values=function(t){var e=[];for(var r in t)e.push(t[r]);return e},t.vectorTile=jo,t.version="1.4.1",t.warnOnce=w,t.webpSupported=O,t.window=self,t.wrap=p;});

	define(["./shared"],function(e){function t(e){var r=typeof e;if("number"===r||"boolean"===r||"string"===r||null==e)return JSON.stringify(e);if(Array.isArray(e)){for(var i="[",o=0,n=e;o<n.length;o+=1){i+=t(n[o])+",";}return i+"]"}for(var a=Object.keys(e).sort(),s="{",l=0;l<a.length;l++)s+=JSON.stringify(a[l])+":"+t(e[a[l]])+",";return s+"}"}function r(r){for(var i="",o=0,n=e.refProperties;o<n.length;o+=1){i+="/"+t(r[n[o]]);}return i}var i=function(e){this.keyCache={},e&&this.replace(e);};i.prototype.replace=function(e){this._layerConfigs={},this._layers={},this.update(e,[]);},i.prototype.update=function(t,i){for(var o=this,n=0,a=t;n<a.length;n+=1){var s=a[n];this._layerConfigs[s.id]=s;var l=this._layers[s.id]=e.createStyleLayer(s);l._featureFilter=e.featureFilter(l.filter),this.keyCache[s.id]&&delete this.keyCache[s.id];}for(var u=0,h=i;u<h.length;u+=1){var c=h[u];delete this.keyCache[c],delete this._layerConfigs[c],delete this._layers[c];}this.familiesBySource={};for(var p=0,f=function(e,t){for(var i={},o=0;o<e.length;o++){var n=t&&t[e[o].id]||r(e[o]);t&&(t[e[o].id]=n);var a=i[n];a||(a=i[n]=[]),a.push(e[o]);}var s=[];for(var l in i)s.push(i[l]);return s}(e.values(this._layerConfigs),this.keyCache);p<f.length;p+=1){var d=f[p].map(function(e){return o._layers[e.id]}),g=d[0];if("none"!==g.visibility){var m=g.source||"",v=this.familiesBySource[m];v||(v=this.familiesBySource[m]={});var y=g.sourceLayer||"_geojsonTileLayer",x=v[y];x||(x=v[y]=[]),x.push(d);}}};var o=function(t){var r={},i=[];for(var o in t){var n=t[o],a=r[o]={};for(var s in n){var l=n[+s];if(l&&0!==l.bitmap.width&&0!==l.bitmap.height){var u={x:0,y:0,w:l.bitmap.width+2,h:l.bitmap.height+2};i.push(u),a[s]={rect:u,metrics:l.metrics};}}}var h=e.potpack(i),c=h.w,p=h.h,f=new e.AlphaImage({width:c||1,height:p||1});for(var d in t){var g=t[d];for(var m in g){var v=g[+m];if(v&&0!==v.bitmap.width&&0!==v.bitmap.height){var y=r[d][m].rect;e.AlphaImage.copy(v.bitmap,f,{x:0,y:0},{x:y.x+1,y:y.y+1},v.bitmap);}}}this.image=f,this.positions=r;};e.register("GlyphAtlas",o);var n=function(t){this.tileID=new e.OverscaledTileID(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.uid=t.uid,this.zoom=t.zoom,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.returnDependencies=!!t.returnDependencies;};function a(t,r,i){for(var o=new e.EvaluationParameters(r),n=0,a=t;n<a.length;n+=1){a[n].recalculate(o,i);}}n.prototype.parse=function(t,r,i,n,s){var l=this;this.status="parsing",this.data=t,this.collisionBoxArray=new e.CollisionBoxArray;var u=new e.DictionaryCoder(Object.keys(t.layers).sort()),h=new e.FeatureIndex(this.tileID);h.bucketLayerIDs=[];var c,p,f,d,g={},m={featureIndex:h,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:i},v=r.familiesBySource[this.source];for(var y in v){var x=t.layers[y];if(x){1===x.version&&e.warnOnce('Vector tile source "'+this.source+'" layer "'+y+'" does not use vector tile spec v2 and therefore may have some rendering errors.');for(var w=u.encode(y),S=[],M=0;M<x.length;M++){var b=x.feature(M);S.push({feature:b,index:M,sourceLayerIndex:w});}for(var k=0,I=v[y];k<I.length;k+=1){var _=I[k],P=_[0];if(!(P.minzoom&&this.zoom<Math.floor(P.minzoom)))if(!(P.maxzoom&&this.zoom>=P.maxzoom))if("none"!==P.visibility)a(_,this.zoom,i),(g[P.id]=P.createBucket({index:h.bucketLayerIDs.length,layers:_,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:w,sourceID:this.source})).populate(S,m),h.bucketLayerIDs.push(_.map(function(e){return e.id}));}}}var T=e.mapObject(m.glyphDependencies,function(e){return Object.keys(e).map(Number)});Object.keys(T).length?n.send("getGlyphs",{uid:this.uid,stacks:T},function(e,t){c||(c=e,p=t,C.call(l));}):p={};var L=Object.keys(m.iconDependencies);L.length?n.send("getImages",{icons:L},function(e,t){c||(c=e,f=t,C.call(l));}):f={};var D=Object.keys(m.patternDependencies);function C(){if(c)return s(c);if(p&&f&&d){var t=new o(p),r=new e.ImageAtlas(f,d);for(var n in g){var l=g[n];l instanceof e.SymbolBucket?(a(l.layers,this.zoom,i),e.performSymbolLayout(l,p,t.positions,f,r.iconPositions,this.showCollisionBoxes)):l.hasPattern&&(l instanceof e.LineBucket||l instanceof e.FillBucket||l instanceof e.FillExtrusionBucket)&&(a(l.layers,this.zoom,i),l.addFeatures(m,r.patternPositions));}this.status="done",s(null,{buckets:e.values(g).filter(function(e){return !e.isEmpty()}),featureIndex:h,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:t.image,imageAtlas:r,glyphMap:this.returnDependencies?p:null,iconMap:this.returnDependencies?f:null,glyphPositions:this.returnDependencies?t.positions:null});}}D.length?n.send("getImages",{icons:D},function(e,t){c||(c=e,d=t,C.call(l));}):d={},C.call(this);};var s="undefined"!=typeof performance,l={getEntriesByName:function(e){return !!(s&&performance&&performance.getEntriesByName)&&performance.getEntriesByName(e)},mark:function(e){return !!(s&&performance&&performance.mark)&&performance.mark(e)},measure:function(e,t,r){return !!(s&&performance&&performance.measure)&&performance.measure(e,t,r)},clearMarks:function(e){return !!(s&&performance&&performance.clearMarks)&&performance.clearMarks(e)},clearMeasures:function(e){return !!(s&&performance&&performance.clearMeasures)&&performance.clearMeasures(e)}},u=function(e){this._marks={start:[e.url,"start"].join("#"),end:[e.url,"end"].join("#"),measure:e.url.toString()},l.mark(this._marks.start);};function h(t,r){var i=e.getArrayBuffer(t.request,function(t,i,o,n){t?r(t):i&&r(null,{vectorTile:new e.vectorTile.VectorTile(new e.pbf(i)),rawData:i,cacheControl:o,expires:n});});return function(){i.cancel(),r();}}u.prototype.finish=function(){l.mark(this._marks.end);var e=l.getEntriesByName(this._marks.measure);return 0===e.length&&(l.measure(this._marks.measure,this._marks.start,this._marks.end),e=l.getEntriesByName(this._marks.measure),l.clearMarks(this._marks.start),l.clearMarks(this._marks.end),l.clearMeasures(this._marks.measure)),e},l.Performance=u;var c=function(e,t,r,i){this.actor=e,this.layerIndex=t,this.availableImages=r,this.loadVectorData=i||h,this.loading={},this.loaded={};};c.prototype.loadTile=function(t,r){var i=this,o=t.uid;this.loading||(this.loading={});var a=!!(t&&t.request&&t.request.collectResourceTiming)&&new l.Performance(t.request),s=this.loading[o]=new n(t);s.abort=this.loadVectorData(t,function(t,n){if(delete i.loading[o],t||!n)return s.status="done",i.loaded[o]=s,r(t);var l=n.rawData,u={};n.expires&&(u.expires=n.expires),n.cacheControl&&(u.cacheControl=n.cacheControl);var h={};if(a){var c=a.finish();c&&(h.resourceTiming=JSON.parse(JSON.stringify(c)));}s.vectorTile=n.vectorTile,s.parse(n.vectorTile,i.layerIndex,i.availableImages,i.actor,function(t,i){if(t||!i)return r(t);r(null,e.extend({rawTileData:l.slice(0)},i,u,h));}),i.loaded=i.loaded||{},i.loaded[o]=s;});},c.prototype.reloadTile=function(e,t){var r=this,i=this.loaded,o=e.uid,n=this;if(i&&i[o]){var a=i[o];a.showCollisionBoxes=e.showCollisionBoxes;var s=function(e,i){var o=a.reloadCallback;o&&(delete a.reloadCallback,a.parse(a.vectorTile,n.layerIndex,r.availableImages,n.actor,o)),t(e,i);};"parsing"===a.status?a.reloadCallback=s:"done"===a.status&&(a.vectorTile?a.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor,s):s());}},c.prototype.abortTile=function(e,t){var r=this.loading,i=e.uid;r&&r[i]&&r[i].abort&&(r[i].abort(),delete r[i]),t();},c.prototype.removeTile=function(e,t){var r=this.loaded,i=e.uid;r&&r[i]&&delete r[i],t();};var p=function(){this.loaded={};};p.prototype.loadTile=function(t,r){var i=t.uid,o=t.encoding,n=t.rawImageData,a=new e.DEMData(i,n,o);this.loaded=this.loaded||{},this.loaded[i]=a,r(null,a);},p.prototype.removeTile=function(e){var t=this.loaded,r=e.uid;t&&t[r]&&delete t[r];};var f={RADIUS:6378137,FLATTENING:1/298.257223563,POLAR_RADIUS:6356752.3142};function d(e){var t=0;if(e&&e.length>0){t+=Math.abs(g(e[0]));for(var r=1;r<e.length;r++)t-=Math.abs(g(e[r]));}return t}function g(e){var t,r,i,o,n,a,s=0,l=e.length;if(l>2){for(a=0;a<l;a++)a===l-2?(i=l-2,o=l-1,n=0):a===l-1?(i=l-1,o=0,n=1):(i=a,o=a+1,n=a+2),t=e[i],r=e[o],s+=(m(e[n][0])-m(t[0]))*Math.sin(m(r[1]));s=s*f.RADIUS*f.RADIUS/2;}return s}function m(e){return e*Math.PI/180}var v={geometry:function e(t){var r,i=0;switch(t.type){case"Polygon":return d(t.coordinates);case"MultiPolygon":for(r=0;r<t.coordinates.length;r++)i+=d(t.coordinates[r]);return i;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0;case"GeometryCollection":for(r=0;r<t.geometries.length;r++)i+=e(t.geometries[r]);return i}},ring:g},y=function e(t,r){switch(t&&t.type||null){case"FeatureCollection":return t.features=t.features.map(x(e,r)),t;case"GeometryCollection":return t.geometries=t.geometries.map(x(e,r)),t;case"Feature":return t.geometry=e(t.geometry,r),t;case"Polygon":case"MultiPolygon":return function(e,t){"Polygon"===e.type?e.coordinates=w(e.coordinates,t):"MultiPolygon"===e.type&&(e.coordinates=e.coordinates.map(x(w,t)));return e}(t,r);default:return t}};function x(e,t){return function(r){return e(r,t)}}function w(e,t){t=!!t,e[0]=S(e[0],t);for(var r=1;r<e.length;r++)e[r]=S(e[r],!t);return e}function S(e,t){return function(e){return v.ring(e)>=0}(e)===t?e:e.reverse()}var M=e.vectorTile.VectorTileFeature.prototype.toGeoJSON,b=function(t){this._feature=t,this.extent=e.EXTENT,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10));};b.prototype.loadGeometry=function(){if(1===this._feature.type){for(var t=[],r=0,i=this._feature.geometry;r<i.length;r+=1){var o=i[r];t.push([new e.Point$1(o[0],o[1])]);}return t}for(var n=[],a=0,s=this._feature.geometry;a<s.length;a+=1){for(var l=[],u=0,h=s[a];u<h.length;u+=1){var c=h[u];l.push(new e.Point$1(c[0],c[1]));}n.push(l);}return n},b.prototype.toGeoJSON=function(e,t,r){return M.call(this,e,t,r)};var k=function(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=e.EXTENT,this.length=t.length,this._features=t;};k.prototype.feature=function(e){return new b(this._features[e])};var I=e.vectorTile.VectorTileFeature,_=P;function P(e,t){this.options=t||{},this.features=e,this.length=e.length;}function T(e,t){this.id="number"==typeof e.id?e.id:void 0,this.type=e.type,this.rawGeometry=1===e.type?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096;}P.prototype.feature=function(e){return new T(this.features[e],this.options.extent)},T.prototype.loadGeometry=function(){var t=this.rawGeometry;this.geometry=[];for(var r=0;r<t.length;r++){for(var i=t[r],o=[],n=0;n<i.length;n++)o.push(new e.Point$1(i[n][0],i[n][1]));this.geometry.push(o);}return this.geometry},T.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-1/0,i=1/0,o=-1/0,n=0;n<e.length;n++)for(var a=e[n],s=0;s<a.length;s++){var l=a[s];t=Math.min(t,l.x),r=Math.max(r,l.x),i=Math.min(i,l.y),o=Math.max(o,l.y);}return [t,i,r,o]},T.prototype.toGeoJSON=I.prototype.toGeoJSON;var L=O,D=O,C=function(e,t){t=t||{};var r={};for(var i in e)r[i]=new _(e[i].features,t),r[i].name=i,r[i].version=t.version,r[i].extent=t.extent;return O({layers:r})},z=_;function O(t){var r=new e.pbf;return function(e,t){for(var r in e.layers)t.writeMessage(3,E,e.layers[r]);}(t,r),r.finish()}function E(e,t){var r;t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var i={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<e.length;r++)i.feature=e.feature(r),t.writeMessage(2,N,i);var o=i.keys;for(r=0;r<o.length;r++)t.writeStringField(3,o[r]);var n=i.values;for(r=0;r<n.length;r++)t.writeMessage(4,G,n[r]);}function N(e,t){var r=e.feature;void 0!==r.id&&t.writeVarintField(1,r.id),t.writeMessage(2,F,e),t.writeVarintField(3,r.type),t.writeMessage(4,J,r);}function F(e,t){var r=e.feature,i=e.keys,o=e.values,n=e.keycache,a=e.valuecache;for(var s in r.properties){var l=n[s];void 0===l&&(i.push(s),l=i.length-1,n[s]=l),t.writeVarint(l);var u=r.properties[s],h=typeof u;"string"!==h&&"boolean"!==h&&"number"!==h&&(u=JSON.stringify(u));var c=h+":"+u,p=a[c];void 0===p&&(o.push(u),p=o.length-1,a[c]=p),t.writeVarint(p);}}function A(e,t){return (t<<3)+(7&e)}function B(e){return e<<1^e>>31}function J(e,t){for(var r=e.loadGeometry(),i=e.type,o=0,n=0,a=r.length,s=0;s<a;s++){var l=r[s],u=1;1===i&&(u=l.length),t.writeVarint(A(1,u));for(var h=3===i?l.length-1:l.length,c=0;c<h;c++){1===c&&1!==i&&t.writeVarint(A(2,h-1));var p=l[c].x-o,f=l[c].y-n;t.writeVarint(B(p)),t.writeVarint(B(f)),o+=p,n+=f;}3===i&&t.writeVarint(A(7,1));}}function G(e,t){var r=typeof e;"string"===r?t.writeStringField(1,e):"boolean"===r?t.writeBooleanField(7,e):"number"===r&&(e%1!=0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e));}function Z(e,t,r,i,o,n){if(!(o-i<=r)){var a=i+o>>1;!function e(t,r,i,o,n,a){for(;n>o;){if(n-o>600){var s=n-o+1,l=i-o+1,u=Math.log(s),h=.5*Math.exp(2*u/3),c=.5*Math.sqrt(u*h*(s-h)/s)*(l-s/2<0?-1:1),p=Math.max(o,Math.floor(i-l*h/s+c)),f=Math.min(n,Math.floor(i+(s-l)*h/s+c));e(t,r,i,p,f,a);}var d=r[2*i+a],g=o,m=n;for(j(t,r,o,i),r[2*n+a]>d&&j(t,r,o,n);g<m;){for(j(t,r,g,m),g++,m--;r[2*g+a]<d;)g++;for(;r[2*m+a]>d;)m--;}r[2*o+a]===d?j(t,r,o,m):j(t,r,++m,n),m<=i&&(o=m+1),i<=m&&(n=m-1);}}(e,t,a,i,o,n%2),Z(e,t,r,i,a-1,n+1),Z(e,t,r,a+1,o,n+1);}}function j(e,t,r,i){Y(e,r,i),Y(t,2*r,2*i),Y(t,2*r+1,2*i+1);}function Y(e,t,r){var i=e[t];e[t]=e[r],e[r]=i;}function V(e,t,r,i){var o=e-r,n=t-i;return o*o+n*n}L.fromVectorTileJs=D,L.fromGeojsonVt=C,L.GeoJSONWrapper=z;var X=function(e){return e[0]},W=function(e){return e[1]},R=function(e,t,r,i,o){void 0===t&&(t=X),void 0===r&&(r=W),void 0===i&&(i=64),void 0===o&&(o=Float64Array),this.nodeSize=i,this.points=e;for(var n=e.length<65536?Uint16Array:Uint32Array,a=this.ids=new n(e.length),s=this.coords=new o(2*e.length),l=0;l<e.length;l++)a[l]=l,s[2*l]=t(e[l]),s[2*l+1]=r(e[l]);Z(a,s,i,0,a.length-1,0);};R.prototype.range=function(e,t,r,i){return function(e,t,r,i,o,n,a){for(var s,l,u=[0,e.length-1,0],h=[];u.length;){var c=u.pop(),p=u.pop(),f=u.pop();if(p-f<=a)for(var d=f;d<=p;d++)s=t[2*d],l=t[2*d+1],s>=r&&s<=o&&l>=i&&l<=n&&h.push(e[d]);else{var g=Math.floor((f+p)/2);s=t[2*g],l=t[2*g+1],s>=r&&s<=o&&l>=i&&l<=n&&h.push(e[g]);var m=(c+1)%2;(0===c?r<=s:i<=l)&&(u.push(f),u.push(g-1),u.push(m)),(0===c?o>=s:n>=l)&&(u.push(g+1),u.push(p),u.push(m));}}return h}(this.ids,this.coords,e,t,r,i,this.nodeSize)},R.prototype.within=function(e,t,r){return function(e,t,r,i,o,n){for(var a=[0,e.length-1,0],s=[],l=o*o;a.length;){var u=a.pop(),h=a.pop(),c=a.pop();if(h-c<=n)for(var p=c;p<=h;p++)V(t[2*p],t[2*p+1],r,i)<=l&&s.push(e[p]);else{var f=Math.floor((c+h)/2),d=t[2*f],g=t[2*f+1];V(d,g,r,i)<=l&&s.push(e[f]);var m=(u+1)%2;(0===u?r-o<=d:i-o<=g)&&(a.push(c),a.push(f-1),a.push(m)),(0===u?r+o>=d:i+o>=g)&&(a.push(f+1),a.push(h),a.push(m));}}return s}(this.ids,this.coords,e,t,r,this.nodeSize)};var q={minZoom:0,maxZoom:16,radius:40,extent:512,nodeSize:64,log:!1,reduce:null,map:function(e){return e}},U=function(e){this.options=re(Object.create(q),e),this.trees=new Array(this.options.maxZoom+1);};function $(e,t,r,i,o){return {x:e,y:t,zoom:1/0,id:r,parentId:-1,numPoints:i,properties:o}}function H(e,t){var r=e.geometry.coordinates,i=r[0],o=r[1];return {x:ee(i),y:te(o),zoom:1/0,index:t,parentId:-1}}function K(e){return {type:"Feature",id:e.id,properties:Q(e),geometry:{type:"Point",coordinates:[(i=e.x,360*(i-.5)),(t=e.y,r=(180-360*t)*Math.PI/180,360*Math.atan(Math.exp(r))/Math.PI-90)]}};var t,r,i;}function Q(e){var t=e.numPoints,r=t>=1e4?Math.round(t/1e3)+"k":t>=1e3?Math.round(t/100)/10+"k":t;return re(re({},e.properties),{cluster:!0,cluster_id:e.id,point_count:t,point_count_abbreviated:r})}function ee(e){return e/360+.5}function te(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function re(e,t){for(var r in t)e[r]=t[r];return e}function ie(e){return e.x}function oe(e){return e.y}function ne(e,t,r,i,o,n){var a=o-r,s=n-i;if(0!==a||0!==s){var l=((e-r)*a+(t-i)*s)/(a*a+s*s);l>1?(r=o,i=n):l>0&&(r+=a*l,i+=s*l);}return (a=e-r)*a+(s=t-i)*s}function ae(e,t,r,i){var o={id:void 0===e?null:e,type:t,geometry:r,tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return function(e){var t=e.geometry,r=e.type;if("Point"===r||"MultiPoint"===r||"LineString"===r)se(e,t);else if("Polygon"===r||"MultiLineString"===r)for(var i=0;i<t.length;i++)se(e,t[i]);else if("MultiPolygon"===r)for(i=0;i<t.length;i++)for(var o=0;o<t[i].length;o++)se(e,t[i][o]);}(o),o}function se(e,t){for(var r=0;r<t.length;r+=3)e.minX=Math.min(e.minX,t[r]),e.minY=Math.min(e.minY,t[r+1]),e.maxX=Math.max(e.maxX,t[r]),e.maxY=Math.max(e.maxY,t[r+1]);}function le(e,t,r,i){if(t.geometry){var o=t.geometry.coordinates,n=t.geometry.type,a=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),s=[],l=t.id;if(r.promoteId?l=t.properties[r.promoteId]:r.generateId&&(l=i||0),"Point"===n)ue(o,s);else if("MultiPoint"===n)for(var u=0;u<o.length;u++)ue(o[u],s);else if("LineString"===n)he(o,s,a,!1);else if("MultiLineString"===n){if(r.lineMetrics){for(u=0;u<o.length;u++)s=[],he(o[u],s,a,!1),e.push(ae(l,"LineString",s,t.properties));return}ce(o,s,a,!1);}else if("Polygon"===n)ce(o,s,a,!0);else{if("MultiPolygon"!==n){if("GeometryCollection"===n){for(u=0;u<t.geometry.geometries.length;u++)le(e,{id:l,geometry:t.geometry.geometries[u],properties:t.properties},r,i);return}throw new Error("Input data is not a valid GeoJSON object.")}for(u=0;u<o.length;u++){var h=[];ce(o[u],h,a,!0),s.push(h);}}e.push(ae(l,n,s,t.properties));}}function ue(e,t){t.push(pe(e[0])),t.push(fe(e[1])),t.push(0);}function he(e,t,r,i){for(var o,n,a=0,s=0;s<e.length;s++){var l=pe(e[s][0]),u=fe(e[s][1]);t.push(l),t.push(u),t.push(0),s>0&&(a+=i?(o*u-l*n)/2:Math.sqrt(Math.pow(l-o,2)+Math.pow(u-n,2))),o=l,n=u;}var h=t.length-3;t[2]=1,function e(t,r,i,o){for(var n,a=o,s=i-r>>1,l=i-r,u=t[r],h=t[r+1],c=t[i],p=t[i+1],f=r+3;f<i;f+=3){var d=ne(t[f],t[f+1],u,h,c,p);if(d>a)n=f,a=d;else if(d===a){var g=Math.abs(f-s);g<l&&(n=f,l=g);}}a>o&&(n-r>3&&e(t,r,n,o),t[n+2]=a,i-n>3&&e(t,n,i,o));}(t,0,h,r),t[h+2]=1,t.size=Math.abs(a),t.start=0,t.end=t.size;}function ce(e,t,r,i){for(var o=0;o<e.length;o++){var n=[];he(e[o],n,r,i),t.push(n);}}function pe(e){return e/360+.5}function fe(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function de(e,t,r,i,o,n,a,s){if(i/=t,n>=(r/=t)&&a<i)return e;if(a<r||n>=i)return null;for(var l=[],u=0;u<e.length;u++){var h=e[u],c=h.geometry,p=h.type,f=0===o?h.minX:h.minY,d=0===o?h.maxX:h.maxY;if(f>=r&&d<i)l.push(h);else if(!(d<r||f>=i)){var g=[];if("Point"===p||"MultiPoint"===p)ge(c,g,r,i,o);else if("LineString"===p)me(c,g,r,i,o,!1,s.lineMetrics);else if("MultiLineString"===p)ye(c,g,r,i,o,!1);else if("Polygon"===p)ye(c,g,r,i,o,!0);else if("MultiPolygon"===p)for(var m=0;m<c.length;m++){var v=[];ye(c[m],v,r,i,o,!0),v.length&&g.push(v);}if(g.length){if(s.lineMetrics&&"LineString"===p){for(m=0;m<g.length;m++)l.push(ae(h.id,p,g[m],h.tags));continue}"LineString"!==p&&"MultiLineString"!==p||(1===g.length?(p="LineString",g=g[0]):p="MultiLineString"),"Point"!==p&&"MultiPoint"!==p||(p=3===g.length?"Point":"MultiPoint"),l.push(ae(h.id,p,g,h.tags));}}}return l.length?l:null}function ge(e,t,r,i,o){for(var n=0;n<e.length;n+=3){var a=e[n+o];a>=r&&a<=i&&(t.push(e[n]),t.push(e[n+1]),t.push(e[n+2]));}}function me(e,t,r,i,o,n,a){for(var s,l,u=ve(e),h=0===o?we:Se,c=e.start,p=0;p<e.length-3;p+=3){var f=e[p],d=e[p+1],g=e[p+2],m=e[p+3],v=e[p+4],y=0===o?f:d,x=0===o?m:v,w=!1;a&&(s=Math.sqrt(Math.pow(f-m,2)+Math.pow(d-v,2))),y<r?x>r&&(l=h(u,f,d,m,v,r),a&&(u.start=c+s*l)):y>i?x<i&&(l=h(u,f,d,m,v,i),a&&(u.start=c+s*l)):xe(u,f,d,g),x<r&&y>=r&&(l=h(u,f,d,m,v,r),w=!0),x>i&&y<=i&&(l=h(u,f,d,m,v,i),w=!0),!n&&w&&(a&&(u.end=c+s*l),t.push(u),u=ve(e)),a&&(c+=s);}var S=e.length-3;f=e[S],d=e[S+1],g=e[S+2],(y=0===o?f:d)>=r&&y<=i&&xe(u,f,d,g),S=u.length-3,n&&S>=3&&(u[S]!==u[0]||u[S+1]!==u[1])&&xe(u,u[0],u[1],u[2]),u.length&&t.push(u);}function ve(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function ye(e,t,r,i,o,n){for(var a=0;a<e.length;a++)me(e[a],t,r,i,o,n,!1);}function xe(e,t,r,i){e.push(t),e.push(r),e.push(i);}function we(e,t,r,i,o,n){var a=(n-t)/(i-t);return e.push(n),e.push(r+(o-r)*a),e.push(1),a}function Se(e,t,r,i,o,n){var a=(n-r)/(o-r);return e.push(t+(i-t)*a),e.push(n),e.push(1),a}function Me(e,t){for(var r=[],i=0;i<e.length;i++){var o,n=e[i],a=n.type;if("Point"===a||"MultiPoint"===a||"LineString"===a)o=be(n.geometry,t);else if("MultiLineString"===a||"Polygon"===a){o=[];for(var s=0;s<n.geometry.length;s++)o.push(be(n.geometry[s],t));}else if("MultiPolygon"===a)for(o=[],s=0;s<n.geometry.length;s++){for(var l=[],u=0;u<n.geometry[s].length;u++)l.push(be(n.geometry[s][u],t));o.push(l);}r.push(ae(n.id,a,o,n.tags));}return r}function be(e,t){var r=[];r.size=e.size,void 0!==e.start&&(r.start=e.start,r.end=e.end);for(var i=0;i<e.length;i+=3)r.push(e[i]+t,e[i+1],e[i+2]);return r}function ke(e,t){if(e.transformed)return e;var r,i,o,n=1<<e.z,a=e.x,s=e.y;for(r=0;r<e.features.length;r++){var l=e.features[r],u=l.geometry,h=l.type;if(l.geometry=[],1===h)for(i=0;i<u.length;i+=2)l.geometry.push(Ie(u[i],u[i+1],t,n,a,s));else for(i=0;i<u.length;i++){var c=[];for(o=0;o<u[i].length;o+=2)c.push(Ie(u[i][o],u[i][o+1],t,n,a,s));l.geometry.push(c);}}return e.transformed=!0,e}function Ie(e,t,r,i,o,n){return [Math.round(r*(e*i-o)),Math.round(r*(t*i-n))]}function _e(e,t,r,i,o){for(var n=t===o.maxZoom?0:o.tolerance/((1<<t)*o.extent),a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:i,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},s=0;s<e.length;s++){a.numFeatures++,Pe(a,e[s],n,o);var l=e[s].minX,u=e[s].minY,h=e[s].maxX,c=e[s].maxY;l<a.minX&&(a.minX=l),u<a.minY&&(a.minY=u),h>a.maxX&&(a.maxX=h),c>a.maxY&&(a.maxY=c);}return a}function Pe(e,t,r,i){var o=t.geometry,n=t.type,a=[];if("Point"===n||"MultiPoint"===n)for(var s=0;s<o.length;s+=3)a.push(o[s]),a.push(o[s+1]),e.numPoints++,e.numSimplified++;else if("LineString"===n)Te(a,o,e,r,!1,!1);else if("MultiLineString"===n||"Polygon"===n)for(s=0;s<o.length;s++)Te(a,o[s],e,r,"Polygon"===n,0===s);else if("MultiPolygon"===n)for(var l=0;l<o.length;l++){var u=o[l];for(s=0;s<u.length;s++)Te(a,u[s],e,r,!0,0===s);}if(a.length){var h=t.tags||null;if("LineString"===n&&i.lineMetrics){for(var c in h={},t.tags)h[c]=t.tags[c];h.mapbox_clip_start=o.start/o.size,h.mapbox_clip_end=o.end/o.size;}var p={geometry:a,type:"Polygon"===n||"MultiPolygon"===n?3:"LineString"===n||"MultiLineString"===n?2:1,tags:h};null!==t.id&&(p.id=t.id),e.features.push(p);}}function Te(e,t,r,i,o,n){var a=i*i;if(i>0&&t.size<(o?a:i))r.numPoints+=t.length/3;else{for(var s=[],l=0;l<t.length;l+=3)(0===i||t[l+2]>a)&&(r.numSimplified++,s.push(t[l]),s.push(t[l+1])),r.numPoints++;o&&function(e,t){for(var r=0,i=0,o=e.length,n=o-2;i<o;n=i,i+=2)r+=(e[i]-e[n])*(e[i+1]+e[n+1]);if(r>0===t)for(i=0,o=e.length;i<o/2;i+=2){var a=e[i],s=e[i+1];e[i]=e[o-2-i],e[i+1]=e[o-1-i],e[o-2-i]=a,e[o-1-i]=s;}}(s,n),e.push(s);}}function Le(e,t){var r=(t=this.options=function(e,t){for(var r in t)e[r]=t[r];return e}(Object.create(this.options),t)).debug;if(r&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var i=function(e,t){var r=[];if("FeatureCollection"===e.type)for(var i=0;i<e.features.length;i++)le(r,e.features[i],t,i);else"Feature"===e.type?le(r,e,t):le(r,{geometry:e},t);return r}(e,t);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),(i=function(e,t){var r=t.buffer/t.extent,i=e,o=de(e,1,-1-r,r,0,-1,2,t),n=de(e,1,1-r,2+r,0,-1,2,t);return (o||n)&&(i=de(e,1,-r,1+r,0,-1,2,t)||[],o&&(i=Me(o,1).concat(i)),n&&(i=i.concat(Me(n,-1)))),i}(i,t)).length&&this.splitTile(i,0,0,0),r&&(i.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)));}function De(e,t,r){return 32*((1<<e)*r+t)+e}function Ce(e,t){var r=e.tileID.canonical;if(!this._geoJSONIndex)return t(null,null);var i=this._geoJSONIndex.getTile(r.z,r.x,r.y);if(!i)return t(null,null);var o=new k(i.features),n=L(o);0===n.byteOffset&&n.byteLength===n.buffer.byteLength||(n=new Uint8Array(n)),t(null,{vectorTile:o,rawData:n.buffer});}U.prototype.load=function(e){var t=this.options,r=t.log,i=t.minZoom,o=t.maxZoom,n=t.nodeSize;r&&console.time("total time");var a="prepare "+e.length+" points";r&&console.time(a),this.points=e;for(var s=[],l=0;l<e.length;l++)e[l].geometry&&s.push(H(e[l],l));this.trees[o+1]=new R(s,ie,oe,n,Float32Array),r&&console.timeEnd(a);for(var u=o;u>=i;u--){var h=+Date.now();s=this._cluster(s,u),this.trees[u]=new R(s,ie,oe,n,Float32Array),r&&console.log("z%d: %d clusters in %dms",u,s.length,+Date.now()-h);}return r&&console.timeEnd("total time"),this},U.prototype.getClusters=function(e,t){var r=((e[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,e[1])),o=180===e[2]?180:((e[2]+180)%360+360)%360-180,n=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)r=-180,o=180;else if(r>o){var a=this.getClusters([r,i,180,n],t),s=this.getClusters([-180,i,o,n],t);return a.concat(s)}for(var l=this.trees[this._limitZoom(t)],u=[],h=0,c=l.range(ee(r),te(n),ee(o),te(i));h<c.length;h+=1){var p=c[h],f=l.points[p];u.push(f.numPoints?K(f):this.points[f.index]);}return u},U.prototype.getChildren=function(e){var t=e>>5,r=e%32,i="No cluster with the specified id.",o=this.trees[r];if(!o)throw new Error(i);var n=o.points[t];if(!n)throw new Error(i);for(var a=this.options.radius/(this.options.extent*Math.pow(2,r-1)),s=[],l=0,u=o.within(n.x,n.y,a);l<u.length;l+=1){var h=u[l],c=o.points[h];c.parentId===e&&s.push(c.numPoints?K(c):this.points[c.index]);}if(0===s.length)throw new Error(i);return s},U.prototype.getLeaves=function(e,t,r){t=t||10,r=r||0;var i=[];return this._appendLeaves(i,e,t,r,0),i},U.prototype.getTile=function(e,t,r){var i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),n=this.options,a=n.extent,s=n.radius/a,l=(r-s)/o,u=(r+1+s)/o,h={features:[]};return this._addTileFeatures(i.range((t-s)/o,l,(t+1+s)/o,u),i.points,t,r,o,h),0===t&&this._addTileFeatures(i.range(1-s/o,l,1,u),i.points,o,r,o,h),t===o-1&&this._addTileFeatures(i.range(0,l,s/o,u),i.points,-1,r,o,h),h.features.length?h:null},U.prototype.getClusterExpansionZoom=function(e){for(var t=e%32-1;t<=this.options.maxZoom;){var r=this.getChildren(e);if(t++,1!==r.length)break;e=r[0].properties.cluster_id;}return t},U.prototype._appendLeaves=function(e,t,r,i,o){for(var n=0,a=this.getChildren(t);n<a.length;n+=1){var s=a[n],l=s.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(e,l.cluster_id,r,i,o):o<i?o++:e.push(s),e.length===r)break}return o},U.prototype._addTileFeatures=function(e,t,r,i,o,n){for(var a=0,s=e;a<s.length;a+=1){var l=t[s[a]],u={type:1,geometry:[[Math.round(this.options.extent*(l.x*o-r)),Math.round(this.options.extent*(l.y*o-i))]],tags:l.numPoints?Q(l):this.points[l.index].properties},h=l.numPoints?l.id:this.points[l.index].id;void 0!==h&&(u.id=h),n.features.push(u);}},U.prototype._limitZoom=function(e){return Math.max(this.options.minZoom,Math.min(e,this.options.maxZoom+1))},U.prototype._cluster=function(e,t){for(var r=[],i=this.options,o=i.radius,n=i.extent,a=i.reduce,s=o/(n*Math.pow(2,t)),l=0;l<e.length;l++){var u=e[l];if(!(u.zoom<=t)){u.zoom=t;for(var h=this.trees[t+1],c=h.within(u.x,u.y,s),p=u.numPoints||1,f=u.x*p,d=u.y*p,g=a&&p>1?this._map(u,!0):null,m=(l<<5)+(t+1),v=0,y=c;v<y.length;v+=1){var x=y[v],w=h.points[x];if(!(w.zoom<=t)){w.zoom=t;var S=w.numPoints||1;f+=w.x*S,d+=w.y*S,p+=S,w.parentId=m,a&&(g||(g=this._map(u,!0)),a(g,this._map(w)));}}1===p?r.push(u):(u.parentId=m,r.push($(f/p,d/p,m,p,g)));}}return r},U.prototype._map=function(e,t){if(e.numPoints)return t?re({},e.properties):e.properties;var r=this.points[e.index].properties,i=this.options.map(r);return t&&i===r?re({},i):i},Le.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0},Le.prototype.splitTile=function(e,t,r,i,o,n,a){for(var s=[e,t,r,i],l=this.options,u=l.debug;s.length;){i=s.pop(),r=s.pop(),t=s.pop(),e=s.pop();var h=1<<t,c=De(t,r,i),p=this.tiles[c];if(!p&&(u>1&&console.time("creation"),p=this.tiles[c]=_e(e,t,r,i,l),this.tileCoords.push({z:t,x:r,y:i}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,r,i,p.numFeatures,p.numPoints,p.numSimplified),console.timeEnd("creation"));var f="z"+t;this.stats[f]=(this.stats[f]||0)+1,this.total++;}if(p.source=e,o){if(t===l.maxZoom||t===o)continue;var d=1<<o-t;if(r!==Math.floor(n/d)||i!==Math.floor(a/d))continue}else if(t===l.indexMaxZoom||p.numPoints<=l.indexMaxPoints)continue;if(p.source=null,0!==e.length){u>1&&console.time("clipping");var g,m,v,y,x,w,S=.5*l.buffer/l.extent,M=.5-S,b=.5+S,k=1+S;g=m=v=y=null,x=de(e,h,r-S,r+b,0,p.minX,p.maxX,l),w=de(e,h,r+M,r+k,0,p.minX,p.maxX,l),e=null,x&&(g=de(x,h,i-S,i+b,1,p.minY,p.maxY,l),m=de(x,h,i+M,i+k,1,p.minY,p.maxY,l),x=null),w&&(v=de(w,h,i-S,i+b,1,p.minY,p.maxY,l),y=de(w,h,i+M,i+k,1,p.minY,p.maxY,l),w=null),u>1&&console.timeEnd("clipping"),s.push(g||[],t+1,2*r,2*i),s.push(m||[],t+1,2*r,2*i+1),s.push(v||[],t+1,2*r+1,2*i),s.push(y||[],t+1,2*r+1,2*i+1);}}},Le.prototype.getTile=function(e,t,r){var i=this.options,o=i.extent,n=i.debug;if(e<0||e>24)return null;var a=1<<e,s=De(e,t=(t%a+a)%a,r);if(this.tiles[s])return ke(this.tiles[s],o);n>1&&console.log("drilling down to z%d-%d-%d",e,t,r);for(var l,u=e,h=t,c=r;!l&&u>0;)u--,h=Math.floor(h/2),c=Math.floor(c/2),l=this.tiles[De(u,h,c)];return l&&l.source?(n>1&&console.log("found parent tile z%d-%d-%d",u,h,c),n>1&&console.time("drilling down"),this.splitTile(l.source,u,h,c,e,t,r),n>1&&console.timeEnd("drilling down"),this.tiles[s]?ke(this.tiles[s],o):null):null};var ze=function(t){function r(e,r,i,o){t.call(this,e,r,i,Ce),o&&(this.loadGeoJSON=o);}return t&&(r.__proto__=t),r.prototype=Object.create(t&&t.prototype),r.prototype.constructor=r,r.prototype.loadData=function(e,t){this._pendingCallback&&this._pendingCallback(null,{abandoned:!0}),this._pendingCallback=t,this._pendingLoadDataParams=e,this._state&&"Idle"!==this._state?this._state="NeedsLoadData":(this._state="Coalescing",this._loadData());},r.prototype._loadData=function(){var t=this;if(this._pendingCallback&&this._pendingLoadDataParams){var r=this._pendingCallback,i=this._pendingLoadDataParams;delete this._pendingCallback,delete this._pendingLoadDataParams;var o=!!(i&&i.request&&i.request.collectResourceTiming)&&new l.Performance(i.request);this.loadGeoJSON(i,function(n,a){if(n||!a)return r(n);if("object"!=typeof a)return r(new Error("Input data given to '"+i.source+"' is not a valid GeoJSON object."));y(a,!0);try{t._geoJSONIndex=i.cluster?new U(function(t){var r=t.superclusterOptions,i=t.clusterProperties;if(!i||!r)return r;for(var o={},n={},a={accumulated:null,zoom:0},s={properties:null},l=Object.keys(i),u=0,h=l;u<h.length;u+=1){var c=h[u],p=i[c],f=p[0],d=p[1],g=e.createExpression(d),m=e.createExpression("string"==typeof f?[f,["accumulated"],["get",c]]:f);o[c]=g.value,n[c]=m.value;}return r.map=function(e){s.properties=e;for(var t={},r=0,i=l;r<i.length;r+=1){var n=i[r];t[n]=o[n].evaluate(a,s);}return t},r.reduce=function(e,t){s.properties=t;for(var r=0,i=l;r<i.length;r+=1){var o=i[r];a.accumulated=e[o],e[o]=n[o].evaluate(a,s);}},r}(i)).load(a.features):function(e,t){return new Le(e,t)}(a,i.geojsonVtOptions);}catch(n){return r(n)}t.loaded={};var s={};if(o){var l=o.finish();l&&(s.resourceTiming={},s.resourceTiming[i.source]=JSON.parse(JSON.stringify(l)));}r(null,s);});}},r.prototype.coalesce=function(){"Coalescing"===this._state?this._state="Idle":"NeedsLoadData"===this._state&&(this._state="Coalescing",this._loadData());},r.prototype.reloadTile=function(e,r){var i=this.loaded,o=e.uid;return i&&i[o]?t.prototype.reloadTile.call(this,e,r):this.loadTile(e,r)},r.prototype.loadGeoJSON=function(t,r){if(t.request)e.getJSON(t.request,r);else{if("string"!=typeof t.data)return r(new Error("Input data given to '"+t.source+"' is not a valid GeoJSON object."));try{return r(null,JSON.parse(t.data))}catch(e){return r(new Error("Input data given to '"+t.source+"' is not a valid GeoJSON object."))}}},r.prototype.removeSource=function(e,t){this._pendingCallback&&this._pendingCallback(null,{abandoned:!0}),t();},r.prototype.getClusterExpansionZoom=function(e,t){t(null,this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));},r.prototype.getClusterChildren=function(e,t){t(null,this._geoJSONIndex.getChildren(e.clusterId));},r.prototype.getClusterLeaves=function(e,t){t(null,this._geoJSONIndex.getLeaves(e.clusterId,e.limit,e.offset));},r}(c);var Oe=function(t){var r=this;this.self=t,this.actor=new e.Actor(t,this),this.layerIndexes={},this.availableImages={},this.workerSourceTypes={vector:c,geojson:ze},this.workerSources={},this.demWorkerSources={},this.self.registerWorkerSource=function(e,t){if(r.workerSourceTypes[e])throw new Error('Worker source with name "'+e+'" already registered.');r.workerSourceTypes[e]=t;},this.self.registerRTLTextPlugin=function(t){if(e.plugin.isLoaded())throw new Error("RTL text plugin already registered.");e.plugin.applyArabicShaping=t.applyArabicShaping,e.plugin.processBidirectionalText=t.processBidirectionalText,e.plugin.processStyledBidirectionalText=t.processStyledBidirectionalText;};};return Oe.prototype.setReferrer=function(e,t){this.referrer=t;},Oe.prototype.setImages=function(e,t,r){this.availableImages[e]=t,r();},Oe.prototype.setLayers=function(e,t,r){this.getLayerIndex(e).replace(t),r();},Oe.prototype.updateLayers=function(e,t,r){this.getLayerIndex(e).update(t.layers,t.removedIds),r();},Oe.prototype.loadTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).loadTile(t,r);},Oe.prototype.loadDEMTile=function(e,t,r){this.getDEMWorkerSource(e,t.source).loadTile(t,r);},Oe.prototype.reloadTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).reloadTile(t,r);},Oe.prototype.abortTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).abortTile(t,r);},Oe.prototype.removeTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).removeTile(t,r);},Oe.prototype.removeDEMTile=function(e,t){this.getDEMWorkerSource(e,t.source).removeTile(t);},Oe.prototype.removeSource=function(e,t,r){if(this.workerSources[e]&&this.workerSources[e][t.type]&&this.workerSources[e][t.type][t.source]){var i=this.workerSources[e][t.type][t.source];delete this.workerSources[e][t.type][t.source],void 0!==i.removeSource?i.removeSource(t,r):r();}},Oe.prototype.loadWorkerSource=function(e,t,r){try{this.self.importScripts(t.url),r();}catch(e){r(e.toString());}},Oe.prototype.loadRTLTextPlugin=function(t,r,i){try{e.plugin.isLoaded()||(this.self.importScripts(r),i(e.plugin.isLoaded()?null:new Error("RTL Text Plugin failed to import scripts from "+r)));}catch(e){i(e.toString());}},Oe.prototype.getAvailableImages=function(e){var t=this.availableImages[e];return t||(t=[]),t},Oe.prototype.getLayerIndex=function(e){var t=this.layerIndexes[e];return t||(t=this.layerIndexes[e]=new i),t},Oe.prototype.getWorkerSource=function(e,t,r){var i=this;if(this.workerSources[e]||(this.workerSources[e]={}),this.workerSources[e][t]||(this.workerSources[e][t]={}),!this.workerSources[e][t][r]){var o={send:function(t,r,o){i.actor.send(t,r,o,e);}};this.workerSources[e][t][r]=new this.workerSourceTypes[t](o,this.getLayerIndex(e),this.getAvailableImages(e));}return this.workerSources[e][t][r]},Oe.prototype.getDEMWorkerSource=function(e,t){return this.demWorkerSources[e]||(this.demWorkerSources[e]={}),this.demWorkerSources[e][t]||(this.demWorkerSources[e][t]=new p),this.demWorkerSources[e][t]},Oe.prototype.enforceCacheSizeLimit=function(t,r){e.enforceCacheSizeLimit(r);},"undefined"!=typeof WorkerGlobalScope&&void 0!==e.window&&e.window instanceof WorkerGlobalScope&&(e.window.worker=new Oe(e.window)),Oe});

	define(["./shared"],function(t){var e=t.createCommonjsModule(function(t){function e(t){return !!("undefined"!=typeof window&&"undefined"!=typeof document&&Array.prototype&&Array.prototype.every&&Array.prototype.filter&&Array.prototype.forEach&&Array.prototype.indexOf&&Array.prototype.lastIndexOf&&Array.prototype.map&&Array.prototype.some&&Array.prototype.reduce&&Array.prototype.reduceRight&&Array.isArray&&Function.prototype&&Function.prototype.bind&&Object.keys&&Object.create&&Object.getPrototypeOf&&Object.getOwnPropertyNames&&Object.isSealed&&Object.isFrozen&&Object.isExtensible&&Object.getOwnPropertyDescriptor&&Object.defineProperty&&Object.defineProperties&&Object.seal&&Object.freeze&&Object.preventExtensions&&"JSON"in window&&"parse"in JSON&&"stringify"in JSON&&function(){if(!("Worker"in window&&"Blob"in window&&"URL"in window))return !1;var t,e,i=new Blob([""],{type:"text/javascript"}),o=URL.createObjectURL(i);try{e=new Worker(o),t=!0;}catch(e){t=!1;}e&&e.terminate();return URL.revokeObjectURL(o),t}()&&"Uint8ClampedArray"in window&&ArrayBuffer.isView&&function(t){void 0===i[t]&&(i[t]=function(t){var i=document.createElement("canvas"),o=Object.create(e.webGLContextAttributes);return o.failIfMajorPerformanceCaveat=t,i.probablySupportsContext?i.probablySupportsContext("webgl",o)||i.probablySupportsContext("experimental-webgl",o):i.supportsContext?i.supportsContext("webgl",o)||i.supportsContext("experimental-webgl",o):i.getContext("webgl",o)||i.getContext("experimental-webgl",o)}(t));return i[t]}(t&&t.failIfMajorPerformanceCaveat))}t.exports?t.exports=e:window&&(window.mapboxgl=window.mapboxgl||{},window.mapboxgl.supported=e);var i={};e.webGLContextAttributes={antialias:!1,alpha:!0,stencil:!0,depth:!0};}),i={create:function(e,i,o){var r=t.window.document.createElement(e);return void 0!==i&&(r.className=i),o&&o.appendChild(r),r},createNS:function(e,i){return t.window.document.createElementNS(e,i)}},o=t.window.document.documentElement.style;function r(t){if(!o)return t[0];for(var e=0;e<t.length;e++)if(t[e]in o)return t[e];return t[0]}var a,n=r(["userSelect","MozUserSelect","WebkitUserSelect","msUserSelect"]);i.disableDrag=function(){o&&n&&(a=o[n],o[n]="none");},i.enableDrag=function(){o&&n&&(o[n]=a);};var s=r(["transform","WebkitTransform"]);i.setTransform=function(t,e){t.style[s]=e;};var l=!1;try{var c=Object.defineProperty({},"passive",{get:function(){l=!0;}});t.window.addEventListener("test",c,c),t.window.removeEventListener("test",c,c);}catch(t){l=!1;}i.addEventListener=function(t,e,i,o){void 0===o&&(o={}),"passive"in o&&l?t.addEventListener(e,i,o):t.addEventListener(e,i,o.capture);},i.removeEventListener=function(t,e,i,o){void 0===o&&(o={}),"passive"in o&&l?t.removeEventListener(e,i,o):t.removeEventListener(e,i,o.capture);};var u=function(e){e.preventDefault(),e.stopPropagation(),t.window.removeEventListener("click",u,!0);};function h(t){var e=t.userImage;if(e&&e.render&&e.render())return t.data.replace(new Uint8Array(e.data.buffer)),!0;return !1}i.suppressClick=function(){t.window.addEventListener("click",u,!0),t.window.setTimeout(function(){t.window.removeEventListener("click",u,!0);},0);},i.mousePos=function(e,i){var o=e.getBoundingClientRect(),r=t.window.TouchEvent&&i instanceof t.window.TouchEvent?i.touches[0]:i;return new t.Point(r.clientX-o.left-e.clientLeft,r.clientY-o.top-e.clientTop)},i.touchPos=function(e,i){for(var o=e.getBoundingClientRect(),r=[],a="touchend"===i.type?i.changedTouches:i.touches,n=0;n<a.length;n++)r.push(new t.Point(a[n].clientX-o.left-e.clientLeft,a[n].clientY-o.top-e.clientTop));return r},i.mouseButton=function(e){return void 0!==t.window.InstallTrigger&&2===e.button&&e.ctrlKey&&t.window.navigator.platform.toUpperCase().indexOf("MAC")>=0?0:e.button},i.remove=function(t){t.parentNode&&t.parentNode.removeChild(t);};var p=function(e){function i(){e.call(this),this.images={},this.updatedImages={},this.callbackDispatchedThisFrame={},this.loaded=!1,this.requestors=[],this.patterns={},this.atlasImage=new t.RGBAImage({width:1,height:1}),this.dirty=!0;}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.isLoaded=function(){return this.loaded},i.prototype.setLoaded=function(t){if(this.loaded!==t&&(this.loaded=t,t)){for(var e=0,i=this.requestors;e<i.length;e+=1){var o=i[e],r=o.ids,a=o.callback;this._notify(r,a);}this.requestors=[];}},i.prototype.getImage=function(t){return this.images[t]},i.prototype.addImage=function(t,e){this.images[t]=e;},i.prototype.updateImage=function(t,e){var i=this.images[t];e.version=i.version+1,this.images[t]=e,this.updatedImages[t]=!0;},i.prototype.removeImage=function(t){var e=this.images[t];delete this.images[t],delete this.patterns[t],e.userImage&&e.userImage.onRemove&&e.userImage.onRemove();},i.prototype.listImages=function(){return Object.keys(this.images)},i.prototype.getImages=function(t,e){var i=!0;if(!this.isLoaded())for(var o=0,r=t;o<r.length;o+=1){var a=r[o];this.images[a]||(i=!1);}this.isLoaded()||i?this._notify(t,e):this.requestors.push({ids:t,callback:e});},i.prototype._notify=function(e,i){for(var o={},r=0,a=e;r<a.length;r+=1){var n=a[r];this.images[n]||this.fire(new t.Event("styleimagemissing",{id:n}));var s=this.images[n];s?o[n]={data:s.data.clone(),pixelRatio:s.pixelRatio,sdf:s.sdf,version:s.version,hasRenderCallback:Boolean(s.userImage&&s.userImage.render)}:t.warnOnce('Image "'+n+'" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');}i(null,o);},i.prototype.getPixelSize=function(){var t=this.atlasImage;return {width:t.width,height:t.height}},i.prototype.getPattern=function(e){var i=this.patterns[e],o=this.getImage(e);if(!o)return null;if(i&&i.position.version===o.version)return i.position;if(i)i.position.version=o.version;else{var r={w:o.data.width+2,h:o.data.height+2,x:0,y:0},a=new t.ImagePosition(r,o);this.patterns[e]={bin:r,position:a};}return this._updatePatternAtlas(),this.patterns[e].position},i.prototype.bind=function(e){var i=e.gl;this.atlasTexture?this.dirty&&(this.atlasTexture.update(this.atlasImage),this.dirty=!1):this.atlasTexture=new t.Texture(e,this.atlasImage,i.RGBA),this.atlasTexture.bind(i.LINEAR,i.CLAMP_TO_EDGE);},i.prototype._updatePatternAtlas=function(){var e=[];for(var i in this.patterns)e.push(this.patterns[i].bin);var o=t.potpack(e),r=o.w,a=o.h,n=this.atlasImage;for(var s in n.resize({width:r||1,height:a||1}),this.patterns){var l=this.patterns[s].bin,c=l.x+1,u=l.y+1,h=this.images[s].data,p=h.width,d=h.height;t.RGBAImage.copy(h,n,{x:0,y:0},{x:c,y:u},{width:p,height:d}),t.RGBAImage.copy(h,n,{x:0,y:d-1},{x:c,y:u-1},{width:p,height:1}),t.RGBAImage.copy(h,n,{x:0,y:0},{x:c,y:u+d},{width:p,height:1}),t.RGBAImage.copy(h,n,{x:p-1,y:0},{x:c-1,y:u},{width:1,height:d}),t.RGBAImage.copy(h,n,{x:0,y:0},{x:c+p,y:u},{width:1,height:d});}this.dirty=!0;},i.prototype.beginFrame=function(){this.callbackDispatchedThisFrame={};},i.prototype.dispatchRenderCallbacks=function(t){for(var e=0,i=t;e<i.length;e+=1){var o=i[e];if(!this.callbackDispatchedThisFrame[o]){this.callbackDispatchedThisFrame[o]=!0;var r=this.images[o];h(r)&&this.updateImage(o,r);}}},i}(t.Evented);var d=m,_=m,f=1e20;function m(t,e,i,o,r,a){this.fontSize=t||24,this.buffer=void 0===e?3:e,this.cutoff=o||.25,this.fontFamily=r||"sans-serif",this.fontWeight=a||"normal",this.radius=i||8;var n=this.size=this.fontSize+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=n,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(n*n),this.gridInner=new Float64Array(n*n),this.f=new Float64Array(n),this.d=new Float64Array(n),this.z=new Float64Array(n+1),this.v=new Int16Array(n),this.middle=Math.round(n/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1));}function g(t,e,i,o,r,a,n){for(var s=0;s<e;s++){for(var l=0;l<i;l++)o[l]=t[l*e+s];for(v(o,r,a,n,i),l=0;l<i;l++)t[l*e+s]=r[l];}for(l=0;l<i;l++){for(s=0;s<e;s++)o[s]=t[l*e+s];for(v(o,r,a,n,e),s=0;s<e;s++)t[l*e+s]=Math.sqrt(r[s]);}}function v(t,e,i,o,r){i[0]=0,o[0]=-f,o[1]=+f;for(var a=1,n=0;a<r;a++){for(var s=(t[a]+a*a-(t[i[n]]+i[n]*i[n]))/(2*a-2*i[n]);s<=o[n];)n--,s=(t[a]+a*a-(t[i[n]]+i[n]*i[n]))/(2*a-2*i[n]);i[++n]=a,o[n]=s,o[n+1]=+f;}for(a=0,n=0;a<r;a++){for(;o[n+1]<a;)n++;e[a]=(a-i[n])*(a-i[n])+t[i[n]];}}m.prototype.draw=function(t){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.fillText(t,this.buffer,this.middle);for(var e=this.ctx.getImageData(0,0,this.size,this.size),i=new Uint8ClampedArray(this.size*this.size),o=0;o<this.size*this.size;o++){var r=e.data[4*o+3]/255;this.gridOuter[o]=1===r?0:0===r?f:Math.pow(Math.max(0,.5-r),2),this.gridInner[o]=1===r?f:0===r?0:Math.pow(Math.max(0,r-.5),2);}for(g(this.gridOuter,this.size,this.size,this.f,this.d,this.v,this.z),g(this.gridInner,this.size,this.size,this.f,this.d,this.v,this.z),o=0;o<this.size*this.size;o++){var a=this.gridOuter[o]-this.gridInner[o];i[o]=Math.max(0,Math.min(255,Math.round(255-255*(a/this.radius+this.cutoff))));}return i},d.default=_;var y=function(t,e){this.requestManager=t,this.localIdeographFontFamily=e,this.entries={};};y.prototype.setURL=function(t){this.url=t;},y.prototype.getGlyphs=function(e,i){var o=this,r=[];for(var a in e)for(var n=0,s=e[a];n<s.length;n+=1){var l=s[n];r.push({stack:a,id:l});}t.asyncAll(r,function(t,e){var i=t.stack,r=t.id,a=o.entries[i];a||(a=o.entries[i]={glyphs:{},requests:{}});var n=a.glyphs[r];if(void 0===n){if(n=o._tinySDF(a,i,r))return a.glyphs[r]=n,void e(null,{stack:i,id:r,glyph:n});var s=Math.floor(r/256);if(256*s>65535)e(new Error("glyphs > 65535 not supported"));else{var l=a.requests[s];l||(l=a.requests[s]=[],y.loadGlyphRange(i,s,o.url,o.requestManager,function(t,e){if(e)for(var i in e)o._doesCharSupportLocalGlyph(+i)||(a.glyphs[+i]=e[+i]);for(var r=0,n=l;r<n.length;r+=1){(0, n[r])(t,e);}delete a.requests[s];})),l.push(function(t,o){t?e(t):o&&e(null,{stack:i,id:r,glyph:o[r]||null});});}}else e(null,{stack:i,id:r,glyph:n});},function(t,e){if(t)i(t);else if(e){for(var o={},r=0,a=e;r<a.length;r+=1){var n=a[r],s=n.stack,l=n.id,c=n.glyph;(o[s]||(o[s]={}))[l]=c&&{id:c.id,bitmap:c.bitmap.clone(),metrics:c.metrics};}i(null,o);}});},y.prototype._doesCharSupportLocalGlyph=function(e){return !!this.localIdeographFontFamily&&(t.isChar["CJK Unified Ideographs"](e)||t.isChar["Hangul Syllables"](e)||t.isChar.Hiragana(e)||t.isChar.Katakana(e))},y.prototype._tinySDF=function(e,i,o){var r=this.localIdeographFontFamily;if(r&&this._doesCharSupportLocalGlyph(o)){var a=e.tinySDF;if(!a){var n="400";/bold/i.test(i)?n="900":/medium/i.test(i)?n="500":/light/i.test(i)&&(n="200"),a=e.tinySDF=new y.TinySDF(24,3,8,.25,r,n);}return {id:o,bitmap:new t.AlphaImage({width:30,height:30},a.draw(String.fromCharCode(o))),metrics:{width:24,height:24,left:0,top:-8,advance:24}}}},y.loadGlyphRange=function(e,i,o,r,a){var n=256*i,s=n+255,l=r.transformRequest(r.normalizeGlyphsURL(o).replace("{fontstack}",e).replace("{range}",n+"-"+s),t.ResourceType.Glyphs);t.getArrayBuffer(l,function(e,i){if(e)a(e);else if(i){for(var o={},r=0,n=t.parseGlyphPBF(i);r<n.length;r+=1){var s=n[r];o[s.id]=s;}a(null,o);}});},y.TinySDF=d;var x=function(){this.specification=t.styleSpec.light.position;};x.prototype.possiblyEvaluate=function(e,i){return t.sphericalToCartesian(e.expression.evaluate(i))},x.prototype.interpolate=function(e,i,o){return {x:t.number(e.x,i.x,o),y:t.number(e.y,i.y,o),z:t.number(e.z,i.z,o)}};var b=new t.Properties({anchor:new t.DataConstantProperty(t.styleSpec.light.anchor),position:new x,color:new t.DataConstantProperty(t.styleSpec.light.color),intensity:new t.DataConstantProperty(t.styleSpec.light.intensity)}),w=function(e){function i(i){e.call(this),this._transitionable=new t.Transitionable(b),this.setLight(i),this._transitioning=this._transitionable.untransitioned();}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.getLight=function(){return this._transitionable.serialize()},i.prototype.setLight=function(e,i){if(void 0===i&&(i={}),!this._validate(t.validateLight,e,i))for(var o in e){var r=e[o];t.endsWith(o,"-transition")?this._transitionable.setTransition(o.slice(0,-"-transition".length),r):this._transitionable.setValue(o,r);}},i.prototype.updateTransitions=function(t){this._transitioning=this._transitionable.transitioned(t,this._transitioning);},i.prototype.hasTransition=function(){return this._transitioning.hasTransition()},i.prototype.recalculate=function(t){this.properties=this._transitioning.possiblyEvaluate(t);},i.prototype._validate=function(e,i,o){return (!o||!1!==o.validate)&&t.emitValidationErrors(this,e.call(t.validateStyle,t.extend({value:i,style:{glyphs:!0,sprite:!0},styleSpec:t.styleSpec})))},i}(t.Evented),E=function(t,e){this.width=t,this.height=e,this.nextRow=0,this.bytes=4,this.data=new Uint8Array(this.width*this.height*this.bytes),this.positions={};};E.prototype.getDash=function(t,e){var i=t.join(",")+String(e);return this.positions[i]||(this.positions[i]=this.addDash(t,e)),this.positions[i]},E.prototype.addDash=function(e,i){var o=i?7:0,r=2*o+1;if(this.nextRow+r>this.height)return t.warnOnce("LineAtlas out of space"),null;for(var a=0,n=0;n<e.length;n++)a+=e[n];for(var s=this.width/a,l=s/2,c=e.length%2==1,u=-o;u<=o;u++)for(var h=this.nextRow+o+u,p=this.width*h,d=c?-e[e.length-1]:0,_=e[0],f=1,m=0;m<this.width;m++){for(;_<m/s;)d=_,_+=e[f],c&&f===e.length-1&&(_+=e[0]),f++;var g=Math.abs(m-d*s),v=Math.abs(m-_*s),y=Math.min(g,v),x=f%2==1,b=void 0;if(i){var w=o?u/o*(l+1):0;if(x){var E=l-Math.abs(w);b=Math.sqrt(y*y+E*E);}else b=l-Math.sqrt(y*y+w*w);}else b=(x?1:-1)*y;this.data[3+4*(p+m)]=Math.max(0,Math.min(255,b+128));}var T={y:(this.nextRow+o+.5)/this.height,height:2*o/this.height,width:a};return this.nextRow+=r,this.dirty=!0,T},E.prototype.bind=function(t){var e=t.gl;this.texture?(e.bindTexture(e.TEXTURE_2D,this.texture),this.dirty&&(this.dirty=!1,e.texSubImage2D(e.TEXTURE_2D,0,0,0,this.width,this.height,e.RGBA,e.UNSIGNED_BYTE,this.data))):(this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.width,this.height,0,e.RGBA,e.UNSIGNED_BYTE,this.data));};var T=function e(i,o){this.workerPool=i,this.actors=[],this.currentActor=0,this.id=t.uniqueId();for(var r=this.workerPool.acquire(this.id),a=0;a<r.length;a++){var n=r[a],s=new e.Actor(n,o,this.id);s.name="Worker "+a,this.actors.push(s);}};function I(e,i,o){var r=function(r,a){if(r)return o(r);if(a){var n=t.pick(t.extend(a,e),["tiles","minzoom","maxzoom","attribution","mapbox_logo","bounds","scheme","tileSize","encoding"]);a.vector_layers&&(n.vectorLayers=a.vector_layers,n.vectorLayerIds=n.vectorLayers.map(function(t){return t.id})),e.url&&(n.tiles=i.canonicalizeTileset(n,e.url)),o(null,n);}};return e.url?t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url),t.ResourceType.Source),r):t.browser.frame(function(){return r(null,e)})}T.prototype.broadcast=function(e,i,o){o=o||function(){},t.asyncAll(this.actors,function(t,o){t.send(e,i,o);},o);},T.prototype.getActor=function(){return this.currentActor=(this.currentActor+1)%this.actors.length,this.actors[this.currentActor]},T.prototype.remove=function(){this.actors.forEach(function(t){t.remove();}),this.actors=[],this.workerPool.release(this.id);},T.Actor=t.Actor;var C=function(e,i,o){this.bounds=t.LngLatBounds.convert(this.validateBounds(e)),this.minzoom=i||0,this.maxzoom=o||24;};C.prototype.validateBounds=function(t){return Array.isArray(t)&&4===t.length?[Math.max(-180,t[0]),Math.max(-90,t[1]),Math.min(180,t[2]),Math.min(90,t[3])]:[-180,-90,180,90]},C.prototype.contains=function(e){var i=Math.pow(2,e.z),o=Math.floor(t.mercatorXfromLng(this.bounds.getWest())*i),r=Math.floor(t.mercatorYfromLat(this.bounds.getNorth())*i),a=Math.ceil(t.mercatorXfromLng(this.bounds.getEast())*i),n=Math.ceil(t.mercatorYfromLat(this.bounds.getSouth())*i);return e.x>=o&&e.x<a&&e.y>=r&&e.y<n};var S=function(e){function i(i,o,r,a){if(e.call(this),this.id=i,this.dispatcher=r,this.type="vector",this.minzoom=0,this.maxzoom=22,this.scheme="xyz",this.tileSize=512,this.reparseOverscaled=!0,this.isTileClipped=!0,this._loaded=!1,t.extend(this,t.pick(o,["url","scheme","tileSize"])),this._options=t.extend({type:"vector"},o),this._collectResourceTiming=o.collectResourceTiming,512!==this.tileSize)throw new Error("vector tile sources must have a tileSize of 512");this.setEventedParent(a);}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this._tileJSONRequest=I(this._options,this.map._requestManager,function(i,o){e._tileJSONRequest=null,e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(t.extend(e,o),o.bounds&&(e.tileBounds=new C(o.bounds,e.minzoom,e.maxzoom)),t.postTurnstileEvent(o.tiles,e.map._requestManager._customAccessToken),t.postMapLoadEvent(o.tiles,e.map._getMapId(),e.map._requestManager._skuToken,e.map._requestManager._customAccessToken),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})));});},i.prototype.loaded=function(){return this._loaded},i.prototype.hasTile=function(t){return !this.tileBounds||this.tileBounds.contains(t.canonical)},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.onRemove=function(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);},i.prototype.serialize=function(){return t.extend({},this._options)},i.prototype.loadTile=function(e,i){var o=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme),this.url,null),r={request:this.map._requestManager.transformRequest(o,t.ResourceType.Tile),uid:e.uid,tileID:e.tileID,zoom:e.tileID.overscaledZ,tileSize:this.tileSize*e.tileID.overscaleFactor(),type:this.type,source:this.id,pixelRatio:t.browser.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes};function a(o,r){return delete e.request,e.aborted?i(null):o&&404!==o.status?i(o):(r&&r.resourceTiming&&(e.resourceTiming=r.resourceTiming),this.map._refreshExpiredTiles&&r&&e.setExpiryData(r),e.loadVectorData(r,this.map.painter),t.cacheEntryPossiblyAdded(this.dispatcher),i(null),void(e.reloadCallback&&(this.loadTile(e,e.reloadCallback),e.reloadCallback=null)))}r.request.collectResourceTiming=this._collectResourceTiming,e.actor&&"expired"!==e.state?"loading"===e.state?e.reloadCallback=i:e.request=e.actor.send("reloadTile",r,a.bind(this)):(e.actor=this.dispatcher.getActor(),e.request=e.actor.send("loadTile",r,a.bind(this)));},i.prototype.abortTile=function(t){t.request&&(t.request.cancel(),delete t.request),t.actor&&t.actor.send("abortTile",{uid:t.uid,type:this.type,source:this.id},void 0);},i.prototype.unloadTile=function(t){t.unloadVectorData(),t.actor&&t.actor.send("removeTile",{uid:t.uid,type:this.type,source:this.id},void 0);},i.prototype.hasTransition=function(){return !1},i}(t.Evented),P=function(e){function i(i,o,r,a){e.call(this),this.id=i,this.dispatcher=r,this.setEventedParent(a),this.type="raster",this.minzoom=0,this.maxzoom=22,this.roundZoom=!0,this.scheme="xyz",this.tileSize=512,this._loaded=!1,this._options=t.extend({type:"raster"},o),t.extend(this,t.pick(o,["url","scheme","tileSize"]));}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this._tileJSONRequest=I(this._options,this.map._requestManager,function(i,o){e._tileJSONRequest=null,e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(t.extend(e,o),o.bounds&&(e.tileBounds=new C(o.bounds,e.minzoom,e.maxzoom)),t.postTurnstileEvent(o.tiles),t.postMapLoadEvent(o.tiles,e.map._getMapId(),e.map._requestManager._skuToken),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})));});},i.prototype.loaded=function(){return this._loaded},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.onRemove=function(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);},i.prototype.serialize=function(){return t.extend({},this._options)},i.prototype.hasTile=function(t){return !this.tileBounds||this.tileBounds.contains(t.canonical)},i.prototype.loadTile=function(e,i){var o=this,r=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme),this.url,this.tileSize);e.request=t.getImage(this.map._requestManager.transformRequest(r,t.ResourceType.Tile),function(r,a){if(delete e.request,e.aborted)e.state="unloaded",i(null);else if(r)e.state="errored",i(r);else if(a){o.map._refreshExpiredTiles&&e.setExpiryData(a),delete a.cacheControl,delete a.expires;var n=o.map.painter.context,s=n.gl;e.texture=o.map.painter.getTileTexture(a.width),e.texture?e.texture.update(a,{useMipmap:!0}):(e.texture=new t.Texture(n,a,s.RGBA,{useMipmap:!0}),e.texture.bind(s.LINEAR,s.CLAMP_TO_EDGE,s.LINEAR_MIPMAP_NEAREST),n.extTextureFilterAnisotropic&&s.texParameterf(s.TEXTURE_2D,n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,n.extTextureFilterAnisotropicMax)),e.state="loaded",t.cacheEntryPossiblyAdded(o.dispatcher),i(null);}});},i.prototype.abortTile=function(t,e){t.request&&(t.request.cancel(),delete t.request),e();},i.prototype.unloadTile=function(t,e){t.texture&&this.map.painter.saveTileTexture(t.texture),e();},i.prototype.hasTransition=function(){return !1},i}(t.Evented),z=function(e){function i(i,o,r,a){e.call(this,i,o,r,a),this.type="raster-dem",this.maxzoom=22,this._options=t.extend({type:"raster-dem"},o),this.encoding=o.encoding||"mapbox";}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.serialize=function(){return {type:"raster-dem",url:this.url,tileSize:this.tileSize,tiles:this.tiles,bounds:this.bounds,encoding:this.encoding}},i.prototype.loadTile=function(e,i){var o=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme),this.url,this.tileSize);e.request=t.getImage(this.map._requestManager.transformRequest(o,t.ResourceType.Tile),function(o,r){if(delete e.request,e.aborted)e.state="unloaded",i(null);else if(o)e.state="errored",i(o);else if(r){this.map._refreshExpiredTiles&&e.setExpiryData(r),delete r.cacheControl,delete r.expires;var a=t.browser.getImageData(r,1),n={uid:e.uid,coord:e.tileID,source:this.id,rawImageData:a,encoding:this.encoding};e.actor&&"expired"!==e.state||(e.actor=this.dispatcher.getActor(),e.actor.send("loadDEMTile",n,function(t,o){t&&(e.state="errored",i(t));o&&(e.dem=o,e.needsHillshadePrepare=!0,e.state="loaded",i(null));}.bind(this)));}}.bind(this)),e.neighboringTiles=this._getNeighboringTiles(e.tileID);},i.prototype._getNeighboringTiles=function(e){var i=e.canonical,o=Math.pow(2,i.z),r=(i.x-1+o)%o,a=0===i.x?e.wrap-1:e.wrap,n=(i.x+1+o)%o,s=i.x+1===o?e.wrap+1:e.wrap,l={};return l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y).key]={backfilled:!1},i.y>0&&(l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y-1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y-1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y-1).key]={backfilled:!1}),i.y+1<o&&(l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y+1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y+1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y+1).key]={backfilled:!1}),l},i.prototype.unloadTile=function(t){t.demTexture&&this.map.painter.saveTileTexture(t.demTexture),t.fbo&&(t.fbo.destroy(),delete t.fbo),t.dem&&delete t.dem,delete t.neighboringTiles,t.state="unloaded",t.actor&&t.actor.send("removeDEMTile",{uid:t.uid,source:this.id});},i}(P),L=function(e){function i(i,o,r,a){e.call(this),this.id=i,this.type="geojson",this.minzoom=0,this.maxzoom=18,this.tileSize=512,this.isTileClipped=!0,this.reparseOverscaled=!0,this._removed=!1,this._loaded=!1,this.actor=r.getActor(),this.setEventedParent(a),this._data=o.data,this._options=t.extend({},o),this._collectResourceTiming=o.collectResourceTiming,this._resourceTiming=[],void 0!==o.maxzoom&&(this.maxzoom=o.maxzoom),o.type&&(this.type=o.type),o.attribution&&(this.attribution=o.attribution);var n=t.EXTENT/this.tileSize;this.workerOptions=t.extend({source:this.id,cluster:o.cluster||!1,geojsonVtOptions:{buffer:(void 0!==o.buffer?o.buffer:128)*n,tolerance:(void 0!==o.tolerance?o.tolerance:.375)*n,extent:t.EXTENT,maxZoom:this.maxzoom,lineMetrics:o.lineMetrics||!1,generateId:o.generateId||!1},superclusterOptions:{maxZoom:void 0!==o.clusterMaxZoom?Math.min(o.clusterMaxZoom,this.maxzoom-1):this.maxzoom-1,extent:t.EXTENT,radius:(o.clusterRadius||50)*n,log:!1},clusterProperties:o.clusterProperties},o.workerOptions);}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.load=function(){var e=this;this.fire(new t.Event("dataloading",{dataType:"source"})),this._updateWorkerData(function(i){if(i)e.fire(new t.ErrorEvent(i));else{var o={dataType:"source",sourceDataType:"metadata"};e._collectResourceTiming&&e._resourceTiming&&e._resourceTiming.length>0&&(o.resourceTiming=e._resourceTiming,e._resourceTiming=[]),e.fire(new t.Event("data",o));}});},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.setData=function(e){var i=this;return this._data=e,this.fire(new t.Event("dataloading",{dataType:"source"})),this._updateWorkerData(function(e){if(e)i.fire(new t.ErrorEvent(e));else{var o={dataType:"source",sourceDataType:"content"};i._collectResourceTiming&&i._resourceTiming&&i._resourceTiming.length>0&&(o.resourceTiming=i._resourceTiming,i._resourceTiming=[]),i.fire(new t.Event("data",o));}}),this},i.prototype.getClusterExpansionZoom=function(t,e){return this.actor.send("geojson.getClusterExpansionZoom",{clusterId:t,source:this.id},e),this},i.prototype.getClusterChildren=function(t,e){return this.actor.send("geojson.getClusterChildren",{clusterId:t,source:this.id},e),this},i.prototype.getClusterLeaves=function(t,e,i,o){return this.actor.send("geojson.getClusterLeaves",{source:this.id,clusterId:t,limit:e,offset:i},o),this},i.prototype._updateWorkerData=function(e){var i=this;this._loaded=!1;var o=t.extend({},this.workerOptions),r=this._data;"string"==typeof r?(o.request=this.map._requestManager.transformRequest(t.browser.resolveURL(r),t.ResourceType.Source),o.request.collectResourceTiming=this._collectResourceTiming):o.data=JSON.stringify(r),this.actor.send(this.type+".loadData",o,function(t,r){i._removed||r&&r.abandoned||(i._loaded=!0,r&&r.resourceTiming&&r.resourceTiming[i.id]&&(i._resourceTiming=r.resourceTiming[i.id].slice(0)),i.actor.send(i.type+".coalesce",{source:o.source},null),e(t));});},i.prototype.loaded=function(){return this._loaded},i.prototype.loadTile=function(e,i){var o=this,r=e.actor?"reloadTile":"loadTile";e.actor=this.actor;var a={type:this.type,uid:e.uid,tileID:e.tileID,zoom:e.tileID.overscaledZ,maxZoom:this.maxzoom,tileSize:this.tileSize,source:this.id,pixelRatio:t.browser.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes};e.request=this.actor.send(r,a,function(t,a){return delete e.request,e.unloadVectorData(),e.aborted?i(null):t?i(t):(e.loadVectorData(a,o.map.painter,"reloadTile"===r),i(null))});},i.prototype.abortTile=function(t){t.request&&(t.request.cancel(),delete t.request),t.aborted=!0;},i.prototype.unloadTile=function(t){t.unloadVectorData(),this.actor.send("removeTile",{uid:t.uid,type:this.type,source:this.id});},i.prototype.onRemove=function(){this._removed=!0,this.actor.send("removeSource",{type:this.type,source:this.id});},i.prototype.serialize=function(){return t.extend({},this._options,{type:this.type,data:this._data})},i.prototype.hasTransition=function(){return !1},i}(t.Evented),D=function(e){function i(t,i,o,r){e.call(this),this.id=t,this.dispatcher=o,this.coordinates=i.coordinates,this.type="image",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this.tiles={},this._loaded=!1,this.setEventedParent(r),this.options=i;}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.load=function(e,i){var o=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this.url=this.options.url,t.getImage(this.map._requestManager.transformRequest(this.url,t.ResourceType.Image),function(r,a){o._loaded=!0,r?o.fire(new t.ErrorEvent(r)):a&&(o.image=a,e&&(o.coordinates=e),i&&i(),o._finishLoading());});},i.prototype.loaded=function(){return this._loaded},i.prototype.updateImage=function(t){var e=this;return this.image&&t.url?(this.options.url=t.url,this.load(t.coordinates,function(){e.texture=null;}),this):this},i.prototype._finishLoading=function(){this.map&&(this.setCoordinates(this.coordinates),this.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})));},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.setCoordinates=function(e){var i=this;this.coordinates=e;var o=e.map(t.MercatorCoordinate.fromLngLat);this.tileID=function(e){for(var i=1/0,o=1/0,r=-1/0,a=-1/0,n=0,s=e;n<s.length;n+=1){var l=s[n];i=Math.min(i,l.x),o=Math.min(o,l.y),r=Math.max(r,l.x),a=Math.max(a,l.y);}var c=r-i,u=a-o,h=Math.max(c,u),p=Math.max(0,Math.floor(-Math.log(h)/Math.LN2)),d=Math.pow(2,p);return new t.CanonicalTileID(p,Math.floor((i+r)/2*d),Math.floor((o+a)/2*d))}(o),this.minzoom=this.maxzoom=this.tileID.z;var r=o.map(function(t){return i.tileID.getTilePoint(t)._round()});return this._boundsArray=new t.StructArrayLayout4i8,this._boundsArray.emplaceBack(r[0].x,r[0].y,0,0),this._boundsArray.emplaceBack(r[1].x,r[1].y,t.EXTENT,0),this._boundsArray.emplaceBack(r[3].x,r[3].y,0,t.EXTENT),this._boundsArray.emplaceBack(r[2].x,r[2].y,t.EXTENT,t.EXTENT),this.boundsBuffer&&(this.boundsBuffer.destroy(),delete this.boundsBuffer),this.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})),this},i.prototype.prepare=function(){if(0!==Object.keys(this.tiles).length&&this.image){var e=this.map.painter.context,i=e.gl;for(var o in this.boundsBuffer||(this.boundsBuffer=e.createVertexBuffer(this._boundsArray,t.rasterBoundsAttributes.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture||(this.texture=new t.Texture(e,this.image,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE)),this.tiles){var r=this.tiles[o];"loaded"!==r.state&&(r.state="loaded",r.texture=this.texture);}}},i.prototype.loadTile=function(t,e){this.tileID&&this.tileID.equals(t.tileID.canonical)?(this.tiles[String(t.tileID.wrap)]=t,t.buckets={},e(null)):(t.state="errored",e(null));},i.prototype.serialize=function(){return {type:"image",url:this.options.url,coordinates:this.coordinates}},i.prototype.hasTransition=function(){return !1},i}(t.Evented);var M=function(e){function i(t,i,o,r){e.call(this,t,i,o,r),this.roundZoom=!0,this.type="video",this.options=i;}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1;var i=this.options;this.urls=[];for(var o=0,r=i.urls;o<r.length;o+=1){var a=r[o];this.urls.push(this.map._requestManager.transformRequest(a,t.ResourceType.Source).url);}t.getVideo(this.urls,function(i,o){e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(e.video=o,e.video.loop=!0,e.video.addEventListener("playing",function(){e.map.triggerRepaint();}),e.map&&e.video.play(),e._finishLoading());});},i.prototype.pause=function(){this.video&&this.video.pause();},i.prototype.play=function(){this.video&&this.video.play();},i.prototype.seek=function(e){if(this.video){var i=this.video.seekable;e<i.start(0)||e>i.end(0)?this.fire(new t.ErrorEvent(new t.ValidationError("Playback for this video can be set only between the "+i.start(0)+" and "+i.end(0)+"-second mark."))):this.video.currentTime=e;}},i.prototype.getVideo=function(){return this.video},i.prototype.onAdd=function(t){this.map||(this.map=t,this.load(),this.video&&(this.video.play(),this.setCoordinates(this.coordinates)));},i.prototype.prepare=function(){if(!(0===Object.keys(this.tiles).length||this.video.readyState<2)){var e=this.map.painter.context,i=e.gl;for(var o in this.boundsBuffer||(this.boundsBuffer=e.createVertexBuffer(this._boundsArray,t.rasterBoundsAttributes.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture?this.video.paused||(this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE),i.texSubImage2D(i.TEXTURE_2D,0,0,0,i.RGBA,i.UNSIGNED_BYTE,this.video)):(this.texture=new t.Texture(e,this.video,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE)),this.tiles){var r=this.tiles[o];"loaded"!==r.state&&(r.state="loaded",r.texture=this.texture);}}},i.prototype.serialize=function(){return {type:"video",urls:this.urls,coordinates:this.coordinates}},i.prototype.hasTransition=function(){return this.video&&!this.video.paused},i}(D),R=function(e){function i(i,o,r,a){e.call(this,i,o,r,a),o.coordinates?Array.isArray(o.coordinates)&&4===o.coordinates.length&&!o.coordinates.some(function(t){return !Array.isArray(t)||2!==t.length||t.some(function(t){return "number"!=typeof t})})||this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))):this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'missing required property "coordinates"'))),o.animate&&"boolean"!=typeof o.animate&&this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'optional "animate" property must be a boolean value'))),o.canvas?"string"==typeof o.canvas||o.canvas instanceof t.window.HTMLCanvasElement||this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))):this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'missing required property "canvas"'))),this.options=o,this.animate=void 0===o.animate||o.animate;}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.load=function(){this._loaded=!0,this.canvas||(this.canvas=this.options.canvas instanceof t.window.HTMLCanvasElement?this.options.canvas:t.window.document.getElementById(this.options.canvas)),this.width=this.canvas.width,this.height=this.canvas.height,this._hasInvalidDimensions()?this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))):(this.play=function(){this._playing=!0,this.map.triggerRepaint();},this.pause=function(){this._playing&&(this.prepare(),this._playing=!1);},this._finishLoading());},i.prototype.getCanvas=function(){return this.canvas},i.prototype.onAdd=function(t){this.map=t,this.load(),this.canvas&&this.animate&&this.play();},i.prototype.onRemove=function(){this.pause();},i.prototype.prepare=function(){var e=!1;if(this.canvas.width!==this.width&&(this.width=this.canvas.width,e=!0),this.canvas.height!==this.height&&(this.height=this.canvas.height,e=!0),!this._hasInvalidDimensions()&&0!==Object.keys(this.tiles).length){var i=this.map.painter.context,o=i.gl;for(var r in this.boundsBuffer||(this.boundsBuffer=i.createVertexBuffer(this._boundsArray,t.rasterBoundsAttributes.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture?(e||this._playing)&&this.texture.update(this.canvas,{premultiply:!0}):this.texture=new t.Texture(i,this.canvas,o.RGBA,{premultiply:!0}),this.tiles){var a=this.tiles[r];"loaded"!==a.state&&(a.state="loaded",a.texture=this.texture);}}},i.prototype.serialize=function(){return {type:"canvas",coordinates:this.coordinates}},i.prototype.hasTransition=function(){return this._playing},i.prototype._hasInvalidDimensions=function(){for(var t=0,e=[this.canvas.width,this.canvas.height];t<e.length;t+=1){var i=e[t];if(isNaN(i)||i<=0)return !0}return !1},i}(D),A={vector:S,raster:P,"raster-dem":z,geojson:L,video:M,image:D,canvas:R},k=function(e,i,o,r){var a=new A[i.type](e,i,o,r);if(a.id!==e)throw new Error("Expected Source id to be "+e+" instead of "+a.id);return t.bindAll(["load","abort","unload","serialize","prepare"],a),a};function B(e,i){var o=t.identity([]);return t.translate(o,o,[1,1,0]),t.scale(o,o,[.5*e.width,.5*e.height,1]),t.multiply(o,o,e.calculatePosMatrix(i.toUnwrapped()))}function O(t,e,i,o,r){var a=function(t,e,i){if(t)for(var o=0,r=t;o<r.length;o+=1){var a=e[r[o]];if(a&&a.source===i&&"fill-extrusion"===a.type)return !0}else for(var n in e){var s=e[n];if(s.source===i&&"fill-extrusion"===s.type)return !0}return !1}(o&&o.layers,e,t.id),n=r.maxPitchScaleFactor(),s=t.tilesIn(i,n,a);s.sort(F);for(var l=[],c=0,u=s;c<u.length;c+=1){var h=u[c];l.push({wrappedTileID:h.tileID.wrapped().key,queryResults:h.tile.queryRenderedFeatures(e,t._state,h.queryGeometry,h.cameraQueryGeometry,h.scale,o,r,n,B(t.transform,h.tileID))});}var p=function(t){for(var e={},i={},o=0,r=t;o<r.length;o+=1){var a=r[o],n=a.queryResults,s=a.wrappedTileID,l=i[s]=i[s]||{};for(var c in n)for(var u=n[c],h=l[c]=l[c]||{},p=e[c]=e[c]||[],d=0,_=u;d<_.length;d+=1){var f=_[d];h[f.featureIndex]||(h[f.featureIndex]=!0,p.push(f));}}return e}(l);for(var d in p)p[d].forEach(function(e){var i=e.feature,o=t.getFeatureState(i.layer["source-layer"],i.id);i.source=i.layer.source,i.layer["source-layer"]&&(i.sourceLayer=i.layer["source-layer"]),i.state=o;});return p}function F(t,e){var i=t.tileID,o=e.tileID;return i.overscaledZ-o.overscaledZ||i.canonical.y-o.canonical.y||i.wrap-o.wrap||i.canonical.x-o.canonical.x}var U=function(t,e){this.max=t,this.onRemove=e,this.reset();};U.prototype.reset=function(){for(var t in this.data)for(var e=0,i=this.data[t];e<i.length;e+=1){var o=i[e];o.timeout&&clearTimeout(o.timeout),this.onRemove(o.value);}return this.data={},this.order=[],this},U.prototype.add=function(t,e,i){var o=this,r=t.wrapped().key;void 0===this.data[r]&&(this.data[r]=[]);var a={value:e,timeout:void 0};if(void 0!==i&&(a.timeout=setTimeout(function(){o.remove(t,a);},i)),this.data[r].push(a),this.order.push(r),this.order.length>this.max){var n=this._getAndRemoveByKey(this.order[0]);n&&this.onRemove(n);}return this},U.prototype.has=function(t){return t.wrapped().key in this.data},U.prototype.getAndRemove=function(t){return this.has(t)?this._getAndRemoveByKey(t.wrapped().key):null},U.prototype._getAndRemoveByKey=function(t){var e=this.data[t].shift();return e.timeout&&clearTimeout(e.timeout),0===this.data[t].length&&delete this.data[t],this.order.splice(this.order.indexOf(t),1),e.value},U.prototype.get=function(t){return this.has(t)?this.data[t.wrapped().key][0].value:null},U.prototype.remove=function(t,e){if(!this.has(t))return this;var i=t.wrapped().key,o=void 0===e?0:this.data[i].indexOf(e),r=this.data[i][o];return this.data[i].splice(o,1),r.timeout&&clearTimeout(r.timeout),0===this.data[i].length&&delete this.data[i],this.onRemove(r.value),this.order.splice(this.order.indexOf(i),1),this},U.prototype.setMaxSize=function(t){for(this.max=t;this.order.length>this.max;){var e=this._getAndRemoveByKey(this.order[0]);e&&this.onRemove(e);}return this};var N=function(t,e,i){this.context=t;var o=t.gl;this.buffer=o.createBuffer(),this.dynamicDraw=Boolean(i),this.context.unbindVAO(),t.bindElementBuffer.set(this.buffer),o.bufferData(o.ELEMENT_ARRAY_BUFFER,e.arrayBuffer,this.dynamicDraw?o.DYNAMIC_DRAW:o.STATIC_DRAW),this.dynamicDraw||delete e.arrayBuffer;};N.prototype.bind=function(){this.context.bindElementBuffer.set(this.buffer);},N.prototype.updateData=function(t){var e=this.context.gl;this.context.unbindVAO(),this.bind(),e.bufferSubData(e.ELEMENT_ARRAY_BUFFER,0,t.arrayBuffer);},N.prototype.destroy=function(){var t=this.context.gl;this.buffer&&(t.deleteBuffer(this.buffer),delete this.buffer);};var Z={Int8:"BYTE",Uint8:"UNSIGNED_BYTE",Int16:"SHORT",Uint16:"UNSIGNED_SHORT",Int32:"INT",Uint32:"UNSIGNED_INT",Float32:"FLOAT"},V=function(t,e,i,o){this.length=e.length,this.attributes=i,this.itemSize=e.bytesPerElement,this.dynamicDraw=o,this.context=t;var r=t.gl;this.buffer=r.createBuffer(),t.bindVertexBuffer.set(this.buffer),r.bufferData(r.ARRAY_BUFFER,e.arrayBuffer,this.dynamicDraw?r.DYNAMIC_DRAW:r.STATIC_DRAW),this.dynamicDraw||delete e.arrayBuffer;};V.prototype.bind=function(){this.context.bindVertexBuffer.set(this.buffer);},V.prototype.updateData=function(t){var e=this.context.gl;this.bind(),e.bufferSubData(e.ARRAY_BUFFER,0,t.arrayBuffer);},V.prototype.enableAttributes=function(t,e){for(var i=0;i<this.attributes.length;i++){var o=this.attributes[i],r=e.attributes[o.name];void 0!==r&&t.enableVertexAttribArray(r);}},V.prototype.setVertexAttribPointers=function(t,e,i){for(var o=0;o<this.attributes.length;o++){var r=this.attributes[o],a=e.attributes[r.name];void 0!==a&&t.vertexAttribPointer(a,r.components,t[Z[r.type]],!1,this.itemSize,r.offset+this.itemSize*(i||0));}},V.prototype.destroy=function(){var t=this.context.gl;this.buffer&&(t.deleteBuffer(this.buffer),delete this.buffer);};var q=function(t){this.gl=t.gl,this.default=this.getDefault(),this.current=this.default,this.dirty=!1;};q.prototype.get=function(){return this.current},q.prototype.set=function(t){},q.prototype.getDefault=function(){return this.default},q.prototype.setDefault=function(){this.set(this.default);};var j=function(e){function i(){e.apply(this,arguments);}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.getDefault=function(){return t.Color.transparent},i.prototype.set=function(t){var e=this.current;(t.r!==e.r||t.g!==e.g||t.b!==e.b||t.a!==e.a||this.dirty)&&(this.gl.clearColor(t.r,t.g,t.b,t.a),this.current=t,this.dirty=!1);},i}(q),G=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return 1},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.clearDepth(t),this.current=t,this.dirty=!1);},e}(q),W=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return 0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.clearStencil(t),this.current=t,this.dirty=!1);},e}(q),X=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return [!0,!0,!0,!0]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||t[3]!==e[3]||this.dirty)&&(this.gl.colorMask(t[0],t[1],t[2],t[3]),this.current=t,this.dirty=!1);},e}(q),H=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return !0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.depthMask(t),this.current=t,this.dirty=!1);},e}(q),K=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return 255},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.stencilMask(t),this.current=t,this.dirty=!1);},e}(q),J=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return {func:this.gl.ALWAYS,ref:0,mask:255}},e.prototype.set=function(t){var e=this.current;(t.func!==e.func||t.ref!==e.ref||t.mask!==e.mask||this.dirty)&&(this.gl.stencilFunc(t.func,t.ref,t.mask),this.current=t,this.dirty=!1);},e}(q),Y=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [t.KEEP,t.KEEP,t.KEEP]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||this.dirty)&&(this.gl.stencilOp(t[0],t[1],t[2]),this.current=t,this.dirty=!1);},e}(q),Q=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.STENCIL_TEST):e.disable(e.STENCIL_TEST),this.current=t,this.dirty=!1;}},e}(q),$=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return [0,1]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||this.dirty)&&(this.gl.depthRange(t[0],t[1]),this.current=t,this.dirty=!1);},e}(q),tt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.DEPTH_TEST):e.disable(e.DEPTH_TEST),this.current=t,this.dirty=!1;}},e}(q),et=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return this.gl.LESS},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.depthFunc(t),this.current=t,this.dirty=!1);},e}(q),it=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.BLEND):e.disable(e.BLEND),this.current=t,this.dirty=!1;}},e}(q),ot=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [t.ONE,t.ZERO]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||this.dirty)&&(this.gl.blendFunc(t[0],t[1]),this.current=t,this.dirty=!1);},e}(q),rt=function(e){function i(){e.apply(this,arguments);}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.getDefault=function(){return t.Color.transparent},i.prototype.set=function(t){var e=this.current;(t.r!==e.r||t.g!==e.g||t.b!==e.b||t.a!==e.a||this.dirty)&&(this.gl.blendColor(t.r,t.g,t.b,t.a),this.current=t,this.dirty=!1);},i}(q),at=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return this.gl.FUNC_ADD},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.blendEquation(t),this.current=t,this.dirty=!1);},e}(q),nt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.CULL_FACE):e.disable(e.CULL_FACE),this.current=t,this.dirty=!1;}},e}(q),st=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return this.gl.BACK},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.cullFace(t),this.current=t,this.dirty=!1);},e}(q),lt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return this.gl.CCW},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.frontFace(t),this.current=t,this.dirty=!1);},e}(q),ct=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.useProgram(t),this.current=t,this.dirty=!1);},e}(q),ut=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return this.gl.TEXTURE0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.activeTexture(t),this.current=t,this.dirty=!1);},e}(q),ht=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [0,0,t.drawingBufferWidth,t.drawingBufferHeight]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||t[3]!==e[3]||this.dirty)&&(this.gl.viewport(t[0],t[1],t[2],t[3]),this.current=t,this.dirty=!1);},e}(q),pt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,t),this.current=t,this.dirty=!1;}},e}(q),dt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindRenderbuffer(e.RENDERBUFFER,t),this.current=t,this.dirty=!1;}},e}(q),_t=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindTexture(e.TEXTURE_2D,t),this.current=t,this.dirty=!1;}},e}(q),ft=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindBuffer(e.ARRAY_BUFFER,t),this.current=t,this.dirty=!1;}},e}(q),mt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){var e=this.gl;e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),this.current=t,this.dirty=!1;},e}(q),gt=function(t){function e(e){t.call(this,e),this.vao=e.extVertexArrayObject;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){this.vao&&(t!==this.current||this.dirty)&&(this.vao.bindVertexArrayOES(t),this.current=t,this.dirty=!1);},e}(q),vt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return 4},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_ALIGNMENT,t),this.current=t,this.dirty=!1;}},e}(q),yt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t),this.current=t,this.dirty=!1;}},e}(q),xt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,t),this.current=t,this.dirty=!1;}},e}(q),bt=function(t){function e(e,i){t.call(this,e),this.context=e,this.parent=i;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDefault=function(){return null},e}(q),wt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setDirty=function(){this.dirty=!0;},e.prototype.set=function(t){if(t!==this.current||this.dirty){this.context.bindFramebuffer.set(this.parent);var e=this.gl;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),this.current=t,this.dirty=!1;}},e}(bt),Et=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.set=function(t){if(t!==this.current||this.dirty){this.context.bindFramebuffer.set(this.parent);var e=this.gl;e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,t),this.current=t,this.dirty=!1;}},e}(bt),Tt=function(t,e,i){this.context=t,this.width=e,this.height=i;var o=t.gl,r=this.framebuffer=o.createFramebuffer();this.colorAttachment=new wt(t,r),this.depthAttachment=new Et(t,r);};Tt.prototype.destroy=function(){var t=this.context.gl,e=this.colorAttachment.get();e&&t.deleteTexture(e);var i=this.depthAttachment.get();i&&t.deleteRenderbuffer(i),t.deleteFramebuffer(this.framebuffer);};var It=function(t,e,i){this.func=t,this.mask=e,this.range=i;};It.ReadOnly=!1,It.ReadWrite=!0,It.disabled=new It(519,It.ReadOnly,[0,1]);var Ct=function(t,e,i,o,r,a){this.test=t,this.ref=e,this.mask=i,this.fail=o,this.depthFail=r,this.pass=a;};Ct.disabled=new Ct({func:519,mask:0},0,0,7680,7680,7680);var St=function(t,e,i){this.blendFunction=t,this.blendColor=e,this.mask=i;};St.Replace=[1,0],St.disabled=new St(St.Replace,t.Color.transparent,[!1,!1,!1,!1]),St.unblended=new St(St.Replace,t.Color.transparent,[!0,!0,!0,!0]),St.alphaBlended=new St([1,771],t.Color.transparent,[!0,!0,!0,!0]);var Pt=function(t,e,i){this.enable=t,this.mode=e,this.frontFace=i;};Pt.disabled=new Pt(!1,1029,2305),Pt.backCCW=new Pt(!0,1029,2305);var zt=function(t){this.gl=t,this.extVertexArrayObject=this.gl.getExtension("OES_vertex_array_object"),this.clearColor=new j(this),this.clearDepth=new G(this),this.clearStencil=new W(this),this.colorMask=new X(this),this.depthMask=new H(this),this.stencilMask=new K(this),this.stencilFunc=new J(this),this.stencilOp=new Y(this),this.stencilTest=new Q(this),this.depthRange=new $(this),this.depthTest=new tt(this),this.depthFunc=new et(this),this.blend=new it(this),this.blendFunc=new ot(this),this.blendColor=new rt(this),this.blendEquation=new at(this),this.cullFace=new nt(this),this.cullFaceSide=new st(this),this.frontFace=new lt(this),this.program=new ct(this),this.activeTexture=new ut(this),this.viewport=new ht(this),this.bindFramebuffer=new pt(this),this.bindRenderbuffer=new dt(this),this.bindTexture=new _t(this),this.bindVertexBuffer=new ft(this),this.bindElementBuffer=new mt(this),this.bindVertexArrayOES=this.extVertexArrayObject&&new gt(this),this.pixelStoreUnpack=new vt(this),this.pixelStoreUnpackPremultiplyAlpha=new yt(this),this.pixelStoreUnpackFlipY=new xt(this),this.extTextureFilterAnisotropic=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.extTextureFilterAnisotropic&&(this.extTextureFilterAnisotropicMax=t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),this.extTextureHalfFloat=t.getExtension("OES_texture_half_float"),this.extTextureHalfFloat&&t.getExtension("OES_texture_half_float_linear");};zt.prototype.setDefault=function(){this.unbindVAO(),this.clearColor.setDefault(),this.clearDepth.setDefault(),this.clearStencil.setDefault(),this.colorMask.setDefault(),this.depthMask.setDefault(),this.stencilMask.setDefault(),this.stencilFunc.setDefault(),this.stencilOp.setDefault(),this.stencilTest.setDefault(),this.depthRange.setDefault(),this.depthTest.setDefault(),this.depthFunc.setDefault(),this.blend.setDefault(),this.blendFunc.setDefault(),this.blendColor.setDefault(),this.blendEquation.setDefault(),this.cullFace.setDefault(),this.cullFaceSide.setDefault(),this.frontFace.setDefault(),this.program.setDefault(),this.activeTexture.setDefault(),this.bindFramebuffer.setDefault(),this.pixelStoreUnpack.setDefault(),this.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.pixelStoreUnpackFlipY.setDefault();},zt.prototype.setDirty=function(){this.clearColor.dirty=!0,this.clearDepth.dirty=!0,this.clearStencil.dirty=!0,this.colorMask.dirty=!0,this.depthMask.dirty=!0,this.stencilMask.dirty=!0,this.stencilFunc.dirty=!0,this.stencilOp.dirty=!0,this.stencilTest.dirty=!0,this.depthRange.dirty=!0,this.depthTest.dirty=!0,this.depthFunc.dirty=!0,this.blend.dirty=!0,this.blendFunc.dirty=!0,this.blendColor.dirty=!0,this.blendEquation.dirty=!0,this.cullFace.dirty=!0,this.cullFaceSide.dirty=!0,this.frontFace.dirty=!0,this.program.dirty=!0,this.activeTexture.dirty=!0,this.viewport.dirty=!0,this.bindFramebuffer.dirty=!0,this.bindRenderbuffer.dirty=!0,this.bindTexture.dirty=!0,this.bindVertexBuffer.dirty=!0,this.bindElementBuffer.dirty=!0,this.extVertexArrayObject&&(this.bindVertexArrayOES.dirty=!0),this.pixelStoreUnpack.dirty=!0,this.pixelStoreUnpackPremultiplyAlpha.dirty=!0,this.pixelStoreUnpackFlipY.dirty=!0;},zt.prototype.createIndexBuffer=function(t,e){return new N(this,t,e)},zt.prototype.createVertexBuffer=function(t,e,i){return new V(this,t,e,i)},zt.prototype.createRenderbuffer=function(t,e,i){var o=this.gl,r=o.createRenderbuffer();return this.bindRenderbuffer.set(r),o.renderbufferStorage(o.RENDERBUFFER,t,e,i),this.bindRenderbuffer.set(null),r},zt.prototype.createFramebuffer=function(t,e){return new Tt(this,t,e)},zt.prototype.clear=function(t){var e=t.color,i=t.depth,o=this.gl,r=0;e&&(r|=o.COLOR_BUFFER_BIT,this.clearColor.set(e),this.colorMask.set([!0,!0,!0,!0])),void 0!==i&&(r|=o.DEPTH_BUFFER_BIT,this.depthRange.set([0,1]),this.clearDepth.set(i),this.depthMask.set(!0)),o.clear(r);},zt.prototype.setCullFace=function(t){!1===t.enable?this.cullFace.set(!1):(this.cullFace.set(!0),this.cullFaceSide.set(t.mode),this.frontFace.set(t.frontFace));},zt.prototype.setDepthMode=function(t){t.func!==this.gl.ALWAYS||t.mask?(this.depthTest.set(!0),this.depthFunc.set(t.func),this.depthMask.set(t.mask),this.depthRange.set(t.range)):this.depthTest.set(!1);},zt.prototype.setStencilMode=function(t){t.test.func!==this.gl.ALWAYS||t.mask?(this.stencilTest.set(!0),this.stencilMask.set(t.mask),this.stencilOp.set([t.fail,t.depthFail,t.pass]),this.stencilFunc.set({func:t.test.func,ref:t.ref,mask:t.test.mask})):this.stencilTest.set(!1);},zt.prototype.setColorMode=function(e){t.deepEqual(e.blendFunction,St.Replace)?this.blend.set(!1):(this.blend.set(!0),this.blendFunc.set(e.blendFunction),this.blendColor.set(e.blendColor)),this.colorMask.set(e.mask);},zt.prototype.unbindVAO=function(){this.extVertexArrayObject&&this.bindVertexArrayOES.set(null);};var Lt=function(e){function i(i,o,r){var a=this;e.call(this),this.id=i,this.dispatcher=r,this.on("data",function(t){"source"===t.dataType&&"metadata"===t.sourceDataType&&(a._sourceLoaded=!0),a._sourceLoaded&&!a._paused&&"source"===t.dataType&&"content"===t.sourceDataType&&(a.reload(),a.transform&&a.update(a.transform));}),this.on("error",function(){a._sourceErrored=!0;}),this._source=k(i,o,r,this),this._tiles={},this._cache=new U(0,this._unloadTile.bind(this)),this._timers={},this._cacheTimers={},this._maxTileCacheSize=null,this._coveredTiles={},this._state=new t.SourceFeatureState;}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.onAdd=function(t){this.map=t,this._maxTileCacheSize=t?t._maxTileCacheSize:null,this._source&&this._source.onAdd&&this._source.onAdd(t);},i.prototype.onRemove=function(t){this._source&&this._source.onRemove&&this._source.onRemove(t);},i.prototype.loaded=function(){if(this._sourceErrored)return !0;if(!this._sourceLoaded)return !1;if(!this._source.loaded())return !1;for(var t in this._tiles){var e=this._tiles[t];if("loaded"!==e.state&&"errored"!==e.state)return !1}return !0},i.prototype.getSource=function(){return this._source},i.prototype.pause=function(){this._paused=!0;},i.prototype.resume=function(){if(this._paused){var t=this._shouldReloadOnResume;this._paused=!1,this._shouldReloadOnResume=!1,t&&this.reload(),this.transform&&this.update(this.transform);}},i.prototype._loadTile=function(t,e){return this._source.loadTile(t,e)},i.prototype._unloadTile=function(t){if(this._source.unloadTile)return this._source.unloadTile(t,function(){})},i.prototype._abortTile=function(t){if(this._source.abortTile)return this._source.abortTile(t,function(){})},i.prototype.serialize=function(){return this._source.serialize()},i.prototype.prepare=function(t){for(var e in this._source.prepare&&this._source.prepare(),this._state.coalesceChanges(this._tiles,this.map?this.map.painter:null),this._tiles){var i=this._tiles[e];i.upload(t),i.prepare(this.map.style.imageManager);}},i.prototype.getIds=function(){return Object.keys(this._tiles).map(Number).sort(Dt)},i.prototype.getRenderableIds=function(e){var i=this,o=[];for(var r in this._tiles)this._isIdRenderable(+r,e)&&o.push(+r);return e?o.sort(function(e,o){var r=i._tiles[e].tileID,a=i._tiles[o].tileID,n=new t.Point(r.canonical.x,r.canonical.y)._rotate(i.transform.angle),s=new t.Point(a.canonical.x,a.canonical.y)._rotate(i.transform.angle);return r.overscaledZ-a.overscaledZ||s.y-n.y||s.x-n.x}):o.sort(Dt)},i.prototype.hasRenderableParent=function(t){var e=this.findLoadedParent(t,0);return !!e&&this._isIdRenderable(e.tileID.key)},i.prototype._isIdRenderable=function(t,e){return this._tiles[t]&&this._tiles[t].hasData()&&!this._coveredTiles[t]&&(e||!this._tiles[t].holdingForFade())},i.prototype.reload=function(){if(this._paused)this._shouldReloadOnResume=!0;else for(var t in this._cache.reset(),this._tiles)"errored"!==this._tiles[t].state&&this._reloadTile(t,"reloading");},i.prototype._reloadTile=function(t,e){var i=this._tiles[t];i&&("loading"!==i.state&&(i.state=e),this._loadTile(i,this._tileLoaded.bind(this,i,t,e)));},i.prototype._tileLoaded=function(e,i,o,r){if(r)return e.state="errored",void(404!==r.status?this._source.fire(new t.ErrorEvent(r,{tile:e})):this.update(this.transform));e.timeAdded=t.browser.now(),"expired"===o&&(e.refreshedUponExpiration=!0),this._setTileReloadTimer(i,e),"raster-dem"===this.getSource().type&&e.dem&&this._backfillDEM(e),this._state.initializeTileState(e,this.map?this.map.painter:null),this._source.fire(new t.Event("data",{dataType:"source",tile:e,coord:e.tileID}));},i.prototype._backfillDEM=function(t){for(var e=this.getRenderableIds(),i=0;i<e.length;i++){var o=e[i];if(t.neighboringTiles&&t.neighboringTiles[o]){var r=this.getTileByID(o);a(t,r),a(r,t);}}function a(t,e){t.needsHillshadePrepare=!0;var i=e.tileID.canonical.x-t.tileID.canonical.x,o=e.tileID.canonical.y-t.tileID.canonical.y,r=Math.pow(2,t.tileID.canonical.z),a=e.tileID.key;0===i&&0===o||Math.abs(o)>1||(Math.abs(i)>1&&(1===Math.abs(i+r)?i+=r:1===Math.abs(i-r)&&(i-=r)),e.dem&&t.dem&&(t.dem.backfillBorder(e.dem,i,o),t.neighboringTiles&&t.neighboringTiles[a]&&(t.neighboringTiles[a].backfilled=!0)));}},i.prototype.getTile=function(t){return this.getTileByID(t.key)},i.prototype.getTileByID=function(t){return this._tiles[t]},i.prototype.getZoom=function(t){return t.zoom+t.scaleZoom(t.tileSize/this._source.tileSize)},i.prototype._retainLoadedChildren=function(t,e,i,o){for(var r in this._tiles){var a=this._tiles[r];if(!(o[r]||!a.hasData()||a.tileID.overscaledZ<=e||a.tileID.overscaledZ>i)){for(var n=a.tileID;a&&a.tileID.overscaledZ>e+1;){var s=a.tileID.scaledTo(a.tileID.overscaledZ-1);(a=this._tiles[s.key])&&a.hasData()&&(n=s);}for(var l=n;l.overscaledZ>e;)if(t[(l=l.scaledTo(l.overscaledZ-1)).key]){o[n.key]=n;break}}}},i.prototype.findLoadedParent=function(t,e){for(var i=t.overscaledZ-1;i>=e;i--){var o=t.scaledTo(i);if(!o)return;var r=String(o.key),a=this._tiles[r];if(a&&a.hasData())return a;if(this._cache.has(o))return this._cache.get(o)}},i.prototype.updateCacheSize=function(t){var e=(Math.ceil(t.width/this._source.tileSize)+1)*(Math.ceil(t.height/this._source.tileSize)+1),i=Math.floor(5*e),o="number"==typeof this._maxTileCacheSize?Math.min(this._maxTileCacheSize,i):i;this._cache.setMaxSize(o);},i.prototype.handleWrapJump=function(t){var e=(t-(void 0===this._prevLng?t:this._prevLng))/360,i=Math.round(e);if(this._prevLng=t,i){var o={};for(var r in this._tiles){var a=this._tiles[r];a.tileID=a.tileID.unwrapTo(a.tileID.wrap+i),o[a.tileID.key]=a;}for(var n in this._tiles=o,this._timers)clearTimeout(this._timers[n]),delete this._timers[n];for(var s in this._tiles){var l=this._tiles[s];this._setTileReloadTimer(s,l);}}},i.prototype.update=function(e){var o=this;if(this.transform=e,this._sourceLoaded&&!this._paused){var r;this.updateCacheSize(e),this.handleWrapJump(this.transform.center.lng),this._coveredTiles={},this.used?this._source.tileID?r=e.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(e){return new t.OverscaledTileID(e.canonical.z,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y)}):(r=e.coveringTiles({tileSize:this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom,reparseOverscaled:this._source.reparseOverscaled}),this._source.hasTile&&(r=r.filter(function(t){return o._source.hasTile(t)}))):r=[];var a=(this._source.roundZoom?Math.round:Math.floor)(this.getZoom(e)),n=Math.max(a-i.maxOverzooming,this._source.minzoom),s=Math.max(a+i.maxUnderzooming,this._source.minzoom),l=this._updateRetainedTiles(r,a);if(Mt(this._source.type)){for(var c={},u={},h=0,p=Object.keys(l);h<p.length;h+=1){var d=p[h],_=l[d],f=this._tiles[d];if(f&&!(f.fadeEndTime&&f.fadeEndTime<=t.browser.now())){var m=this.findLoadedParent(_,n);m&&(this._addTile(m.tileID),c[m.tileID.key]=m.tileID),u[d]=_;}}for(var g in this._retainLoadedChildren(u,a,s,l),c)l[g]||(this._coveredTiles[g]=!0,l[g]=c[g]);}for(var v in l)this._tiles[v].clearFadeHold();for(var y=0,x=t.keysDifference(this._tiles,l);y<x.length;y+=1){var b=x[y],w=this._tiles[b];w.hasSymbolBuckets&&!w.holdingForFade()?w.setHoldDuration(this.map._fadeDuration):w.hasSymbolBuckets&&!w.symbolFadeFinished()||this._removeTile(b);}}},i.prototype.releaseSymbolFadeTiles=function(){for(var t in this._tiles)this._tiles[t].holdingForFade()&&this._removeTile(t);},i.prototype._updateRetainedTiles=function(t,e){for(var o={},r={},a=Math.max(e-i.maxOverzooming,this._source.minzoom),n=Math.max(e+i.maxUnderzooming,this._source.minzoom),s={},l=0,c=t;l<c.length;l+=1){var u=c[l],h=this._addTile(u);o[u.key]=u,h.hasData()||e<this._source.maxzoom&&(s[u.key]=u);}this._retainLoadedChildren(s,e,n,o);for(var p=0,d=t;p<d.length;p+=1){var _=d[p],f=this._tiles[_.key];if(!f.hasData()){if(e+1>this._source.maxzoom){var m=_.children(this._source.maxzoom)[0],g=this.getTile(m);if(g&&g.hasData()){o[m.key]=m;continue}}else{var v=_.children(this._source.maxzoom);if(o[v[0].key]&&o[v[1].key]&&o[v[2].key]&&o[v[3].key])continue}for(var y=f.wasRequested(),x=_.overscaledZ-1;x>=a;--x){var b=_.scaledTo(x);if(r[b.key])break;if(r[b.key]=!0,!(f=this.getTile(b))&&y&&(f=this._addTile(b)),f&&(o[b.key]=b,y=f.wasRequested(),f.hasData()))break}}}return o},i.prototype._addTile=function(e){var i=this._tiles[e.key];if(i)return i;(i=this._cache.getAndRemove(e))&&(this._setTileReloadTimer(e.key,i),i.tileID=e,this._state.initializeTileState(i,this.map?this.map.painter:null),this._cacheTimers[e.key]&&(clearTimeout(this._cacheTimers[e.key]),delete this._cacheTimers[e.key],this._setTileReloadTimer(e.key,i)));var o=Boolean(i);return o||(i=new t.Tile(e,this._source.tileSize*e.overscaleFactor()),this._loadTile(i,this._tileLoaded.bind(this,i,e.key,i.state))),i?(i.uses++,this._tiles[e.key]=i,o||this._source.fire(new t.Event("dataloading",{tile:i,coord:i.tileID,dataType:"source"})),i):null},i.prototype._setTileReloadTimer=function(t,e){var i=this;t in this._timers&&(clearTimeout(this._timers[t]),delete this._timers[t]);var o=e.getExpiryTimeout();o&&(this._timers[t]=setTimeout(function(){i._reloadTile(t,"expired"),delete i._timers[t];},o));},i.prototype._removeTile=function(t){var e=this._tiles[t];e&&(e.uses--,delete this._tiles[t],this._timers[t]&&(clearTimeout(this._timers[t]),delete this._timers[t]),e.uses>0||(e.hasData()&&"reloading"!==e.state?this._cache.add(e.tileID,e,e.getExpiryTimeout()):(e.aborted=!0,this._abortTile(e),this._unloadTile(e))));},i.prototype.clearTiles=function(){for(var t in this._shouldReloadOnResume=!1,this._paused=!1,this._tiles)this._removeTile(t);this._cache.reset();},i.prototype.tilesIn=function(e,i,o){var r=this,a=[],n=this.transform;if(!n)return a;for(var s=o?n.getCameraQueryGeometry(e):e,l=e.map(function(t){return n.pointCoordinate(t)}),c=s.map(function(t){return n.pointCoordinate(t)}),u=this.getIds(),h=1/0,p=1/0,d=-1/0,_=-1/0,f=0,m=c;f<m.length;f+=1){var g=m[f];h=Math.min(h,g.x),p=Math.min(p,g.y),d=Math.max(d,g.x),_=Math.max(_,g.y);}for(var v=function(e){var o=r._tiles[u[e]];if(!o.holdingForFade()){var s=o.tileID,f=Math.pow(2,n.zoom-o.tileID.overscaledZ),m=i*o.queryPadding*t.EXTENT/o.tileSize/f,g=[s.getTilePoint(new t.MercatorCoordinate(h,p)),s.getTilePoint(new t.MercatorCoordinate(d,_))];if(g[0].x-m<t.EXTENT&&g[0].y-m<t.EXTENT&&g[1].x+m>=0&&g[1].y+m>=0){var v=l.map(function(t){return s.getTilePoint(t)}),y=c.map(function(t){return s.getTilePoint(t)});a.push({tile:o,tileID:s,queryGeometry:v,cameraQueryGeometry:y,scale:f});}}},y=0;y<u.length;y++)v(y);return a},i.prototype.getVisibleCoordinates=function(t){for(var e=this,i=this.getRenderableIds(t).map(function(t){return e._tiles[t].tileID}),o=0,r=i;o<r.length;o+=1){var a=r[o];a.posMatrix=this.transform.calculatePosMatrix(a.toUnwrapped());}return i},i.prototype.hasTransition=function(){if(this._source.hasTransition())return !0;if(Mt(this._source.type))for(var e in this._tiles){var i=this._tiles[e];if(void 0!==i.fadeEndTime&&i.fadeEndTime>=t.browser.now())return !0}return !1},i.prototype.setFeatureState=function(t,e,i){t=t||"_geojsonTileLayer",this._state.updateState(t,e,i);},i.prototype.removeFeatureState=function(t,e,i){t=t||"_geojsonTileLayer",this._state.removeFeatureState(t,e,i);},i.prototype.getFeatureState=function(t,e){return t=t||"_geojsonTileLayer",this._state.getState(t,e)},i}(t.Evented);function Dt(t,e){return t%32-e%32||e-t}function Mt(t){return "raster"===t||"image"===t||"video"===t}function Rt(){return new t.window.Worker(or.workerUrl)}Lt.maxOverzooming=10,Lt.maxUnderzooming=3;var At=function(){this.active={};};At.prototype.acquire=function(t){if(!this.workers)for(this.workers=[];this.workers.length<At.workerCount;)this.workers.push(new Rt);return this.active[t]=!0,this.workers.slice()},At.prototype.release=function(t){delete this.active[t],0===Object.keys(this.active).length&&(this.workers.forEach(function(t){t.terminate();}),this.workers=null);};var kt,Bt=Math.floor(t.browser.hardwareConcurrency/2);function Ot(e,i){var o={};for(var r in e)"ref"!==r&&(o[r]=e[r]);return t.refProperties.forEach(function(t){t in i&&(o[t]=i[t]);}),o}function Ft(t){t=t.slice();for(var e=Object.create(null),i=0;i<t.length;i++)e[t[i].id]=t[i];for(var o=0;o<t.length;o++)"ref"in t[o]&&(t[o]=Ot(t[o],e[t[o].ref]));return t}At.workerCount=Math.max(Math.min(Bt,6),1);var Ut={setStyle:"setStyle",addLayer:"addLayer",removeLayer:"removeLayer",setPaintProperty:"setPaintProperty",setLayoutProperty:"setLayoutProperty",setFilter:"setFilter",addSource:"addSource",removeSource:"removeSource",setGeoJSONSourceData:"setGeoJSONSourceData",setLayerZoomRange:"setLayerZoomRange",setLayerProperty:"setLayerProperty",setCenter:"setCenter",setZoom:"setZoom",setBearing:"setBearing",setPitch:"setPitch",setSprite:"setSprite",setGlyphs:"setGlyphs",setTransition:"setTransition",setLight:"setLight"};function Nt(t,e,i){i.push({command:Ut.addSource,args:[t,e[t]]});}function Zt(t,e,i){e.push({command:Ut.removeSource,args:[t]}),i[t]=!0;}function Vt(t,e,i,o){Zt(t,i,o),Nt(t,e,i);}function qt(e,i,o){var r;for(r in e[o])if(e[o].hasOwnProperty(r)&&"data"!==r&&!t.deepEqual(e[o][r],i[o][r]))return !1;for(r in i[o])if(i[o].hasOwnProperty(r)&&"data"!==r&&!t.deepEqual(e[o][r],i[o][r]))return !1;return !0}function jt(e,i,o,r,a,n){var s;for(s in i=i||{},e=e||{})e.hasOwnProperty(s)&&(t.deepEqual(e[s],i[s])||o.push({command:n,args:[r,s,i[s],a]}));for(s in i)i.hasOwnProperty(s)&&!e.hasOwnProperty(s)&&(t.deepEqual(e[s],i[s])||o.push({command:n,args:[r,s,i[s],a]}));}function Gt(t){return t.id}function Wt(t,e){return t[e.id]=e,t}function Xt(e,i){if(!e)return [{command:Ut.setStyle,args:[i]}];var o=[];try{if(!t.deepEqual(e.version,i.version))return [{command:Ut.setStyle,args:[i]}];t.deepEqual(e.center,i.center)||o.push({command:Ut.setCenter,args:[i.center]}),t.deepEqual(e.zoom,i.zoom)||o.push({command:Ut.setZoom,args:[i.zoom]}),t.deepEqual(e.bearing,i.bearing)||o.push({command:Ut.setBearing,args:[i.bearing]}),t.deepEqual(e.pitch,i.pitch)||o.push({command:Ut.setPitch,args:[i.pitch]}),t.deepEqual(e.sprite,i.sprite)||o.push({command:Ut.setSprite,args:[i.sprite]}),t.deepEqual(e.glyphs,i.glyphs)||o.push({command:Ut.setGlyphs,args:[i.glyphs]}),t.deepEqual(e.transition,i.transition)||o.push({command:Ut.setTransition,args:[i.transition]}),t.deepEqual(e.light,i.light)||o.push({command:Ut.setLight,args:[i.light]});var r={},a=[];!function(e,i,o,r){var a;for(a in i=i||{},e=e||{})e.hasOwnProperty(a)&&(i.hasOwnProperty(a)||Zt(a,o,r));for(a in i)i.hasOwnProperty(a)&&(e.hasOwnProperty(a)?t.deepEqual(e[a],i[a])||("geojson"===e[a].type&&"geojson"===i[a].type&&qt(e,i,a)?o.push({command:Ut.setGeoJSONSourceData,args:[a,i[a].data]}):Vt(a,i,o,r)):Nt(a,i,o));}(e.sources,i.sources,a,r);var n=[];e.layers&&e.layers.forEach(function(t){r[t.source]?o.push({command:Ut.removeLayer,args:[t.id]}):n.push(t);}),o=o.concat(a),function(e,i,o){i=i||[];var r,a,n,s,l,c,u,h=(e=e||[]).map(Gt),p=i.map(Gt),d=e.reduce(Wt,{}),_=i.reduce(Wt,{}),f=h.slice(),m=Object.create(null);for(r=0,a=0;r<h.length;r++)n=h[r],_.hasOwnProperty(n)?a++:(o.push({command:Ut.removeLayer,args:[n]}),f.splice(f.indexOf(n,a),1));for(r=0,a=0;r<p.length;r++)n=p[p.length-1-r],f[f.length-1-r]!==n&&(d.hasOwnProperty(n)?(o.push({command:Ut.removeLayer,args:[n]}),f.splice(f.lastIndexOf(n,f.length-a),1)):a++,c=f[f.length-r],o.push({command:Ut.addLayer,args:[_[n],c]}),f.splice(f.length-r,0,n),m[n]=!0);for(r=0;r<p.length;r++)if(s=d[n=p[r]],l=_[n],!m[n]&&!t.deepEqual(s,l))if(t.deepEqual(s.source,l.source)&&t.deepEqual(s["source-layer"],l["source-layer"])&&t.deepEqual(s.type,l.type)){for(u in jt(s.layout,l.layout,o,n,null,Ut.setLayoutProperty),jt(s.paint,l.paint,o,n,null,Ut.setPaintProperty),t.deepEqual(s.filter,l.filter)||o.push({command:Ut.setFilter,args:[n,l.filter]}),t.deepEqual(s.minzoom,l.minzoom)&&t.deepEqual(s.maxzoom,l.maxzoom)||o.push({command:Ut.setLayerZoomRange,args:[n,l.minzoom,l.maxzoom]}),s)s.hasOwnProperty(u)&&"layout"!==u&&"paint"!==u&&"filter"!==u&&"metadata"!==u&&"minzoom"!==u&&"maxzoom"!==u&&(0===u.indexOf("paint.")?jt(s[u],l[u],o,n,u.slice(6),Ut.setPaintProperty):t.deepEqual(s[u],l[u])||o.push({command:Ut.setLayerProperty,args:[n,u,l[u]]}));for(u in l)l.hasOwnProperty(u)&&!s.hasOwnProperty(u)&&"layout"!==u&&"paint"!==u&&"filter"!==u&&"metadata"!==u&&"minzoom"!==u&&"maxzoom"!==u&&(0===u.indexOf("paint.")?jt(s[u],l[u],o,n,u.slice(6),Ut.setPaintProperty):t.deepEqual(s[u],l[u])||o.push({command:Ut.setLayerProperty,args:[n,u,l[u]]}));}else o.push({command:Ut.removeLayer,args:[n]}),c=f[f.lastIndexOf(n)+1],o.push({command:Ut.addLayer,args:[l,c]});}(n,i.layers,o);}catch(t){console.warn("Unable to compute style diff:",t),o=[{command:Ut.setStyle,args:[i]}];}return o}var Ht=function(t,e,i){var o=this.boxCells=[],r=this.circleCells=[];this.xCellCount=Math.ceil(t/i),this.yCellCount=Math.ceil(e/i);for(var a=0;a<this.xCellCount*this.yCellCount;a++)o.push([]),r.push([]);this.circleKeys=[],this.boxKeys=[],this.bboxes=[],this.circles=[],this.width=t,this.height=e,this.xScale=this.xCellCount/t,this.yScale=this.yCellCount/e,this.boxUid=0,this.circleUid=0;};function Kt(e,i,o,r,a){var n=t.create();return i?(t.scale(n,n,[1/a,1/a,1]),o||t.rotateZ(n,n,r.angle)):t.multiply(n,r.labelPlaneMatrix,e),n}function Jt(e,i,o,r,a){if(i){var n=t.clone(e);return t.scale(n,n,[a,a,1]),o||t.rotateZ(n,n,-r.angle),n}return r.glCoordMatrix}function Yt(e,i){var o=[e.x,e.y,0,1];se(o,o,i);var r=o[3];return {point:new t.Point(o[0]/r,o[1]/r),signedDistanceFromCamera:r}}function Qt(t,e){var i=t[0]/t[3],o=t[1]/t[3];return i>=-e[0]&&i<=e[0]&&o>=-e[1]&&o<=e[1]}function $t(e,i,o,r,a,n,s,l){var c=r?e.textSizeData:e.iconSizeData,u=t.evaluateSizeForZoom(c,o.transform.zoom),h=[256/o.width*2+1,256/o.height*2+1],p=r?e.text.dynamicLayoutVertexArray:e.icon.dynamicLayoutVertexArray;p.clear();for(var d=e.lineVertexArray,_=r?e.text.placedSymbolArray:e.icon.placedSymbolArray,f=o.transform.width/o.transform.height,m=!1,g=0;g<_.length;g++){var v=_.get(g);if(v.hidden||v.writingMode===t.WritingMode.vertical&&!m)ne(v.numGlyphs,p);else{m=!1;var y=[v.anchorX,v.anchorY,0,1];if(t.transformMat4(y,y,i),Qt(y,h)){var x=.5+y[3]/o.transform.cameraToCenterDistance*.5,b=t.evaluateSizeForFeature(c,u,v),w=s?b*x:b/x,E=new t.Point(v.anchorX,v.anchorY),T=Yt(E,a).point,I={},C=ie(v,w,!1,l,i,a,n,e.glyphOffsetArray,d,p,T,E,I,f);m=C.useVertical,(C.notEnoughRoom||m||C.needsFlipping&&ie(v,w,!0,l,i,a,n,e.glyphOffsetArray,d,p,T,E,I,f).notEnoughRoom)&&ne(v.numGlyphs,p);}else ne(v.numGlyphs,p);}}r?e.text.dynamicLayoutVertexBuffer.updateData(p):e.icon.dynamicLayoutVertexBuffer.updateData(p);}function te(t,e,i,o,r,a,n,s,l,c,u,h){var p=s.glyphStartIndex+s.numGlyphs,d=s.lineStartIndex,_=s.lineStartIndex+s.lineLength,f=e.getoffsetX(s.glyphStartIndex),m=e.getoffsetX(p-1),g=re(t*f,i,o,r,a,n,s.segment,d,_,l,c,u,h);if(!g)return null;var v=re(t*m,i,o,r,a,n,s.segment,d,_,l,c,u,h);return v?{first:g,last:v}:null}function ee(e,i,o,r){if(e===t.WritingMode.horizontal&&Math.abs(o.y-i.y)>Math.abs(o.x-i.x)*r)return {useVertical:!0};return (e===t.WritingMode.vertical?i.y<o.y:i.x>o.x)?{needsFlipping:!0}:null}function ie(e,i,o,r,a,n,s,l,c,u,h,p,d,_){var f,m=i/24,g=e.lineOffsetX*m,v=e.lineOffsetY*m;if(e.numGlyphs>1){var y=e.glyphStartIndex+e.numGlyphs,x=e.lineStartIndex,b=e.lineStartIndex+e.lineLength,w=te(m,l,g,v,o,h,p,e,c,n,d,!1);if(!w)return {notEnoughRoom:!0};var E=Yt(w.first.point,s).point,T=Yt(w.last.point,s).point;if(r&&!o){var I=ee(e.writingMode,E,T,_);if(I)return I}f=[w.first];for(var C=e.glyphStartIndex+1;C<y-1;C++)f.push(re(m*l.getoffsetX(C),g,v,o,h,p,e.segment,x,b,c,n,d,!1));f.push(w.last);}else{if(r&&!o){var S=Yt(p,a).point,P=e.lineStartIndex+e.segment+1,z=new t.Point(c.getx(P),c.gety(P)),L=Yt(z,a),D=L.signedDistanceFromCamera>0?L.point:oe(p,z,S,1,a),M=ee(e.writingMode,S,D,_);if(M)return M}var R=re(m*l.getoffsetX(e.glyphStartIndex),g,v,o,h,p,e.segment,e.lineStartIndex,e.lineStartIndex+e.lineLength,c,n,d,!1);if(!R)return {notEnoughRoom:!0};f=[R];}for(var A=0,k=f;A<k.length;A+=1){var B=k[A];t.addDynamicAttributes(u,B.point,B.angle);}return {}}function oe(t,e,i,o,r){var a=Yt(t.add(t.sub(e)._unit()),r).point,n=i.sub(a);return i.add(n._mult(o/n.mag()))}function re(e,i,o,r,a,n,s,l,c,u,h,p,d){var _=r?e-i:e+i,f=_>0?1:-1,m=0;r&&(f*=-1,m=Math.PI),f<0&&(m+=Math.PI);for(var g=f>0?l+s:l+s+1,v=g,y=a,x=a,b=0,w=0,E=Math.abs(_);b+w<=E;){if((g+=f)<l||g>=c)return null;if(x=y,void 0===(y=p[g])){var T=new t.Point(u.getx(g),u.gety(g)),I=Yt(T,h);if(I.signedDistanceFromCamera>0)y=p[g]=I.point;else{var C=g-f;y=oe(0===b?n:new t.Point(u.getx(C),u.gety(C)),T,x,E-b+1,h);}}b+=w,w=x.dist(y);}var S=(E-b)/w,P=y.sub(x),z=P.mult(S)._add(x);return z._add(P._unit()._perp()._mult(o*f)),{point:z,angle:m+Math.atan2(y.y-x.y,y.x-x.x),tileDistance:d?{prevTileDistance:g-f===v?0:u.gettileUnitDistanceFromAnchor(g-f),lastSegmentViewportDistance:E-b}:null}}Ht.prototype.keysLength=function(){return this.boxKeys.length+this.circleKeys.length},Ht.prototype.insert=function(t,e,i,o,r){this._forEachCell(e,i,o,r,this._insertBoxCell,this.boxUid++),this.boxKeys.push(t),this.bboxes.push(e),this.bboxes.push(i),this.bboxes.push(o),this.bboxes.push(r);},Ht.prototype.insertCircle=function(t,e,i,o){this._forEachCell(e-o,i-o,e+o,i+o,this._insertCircleCell,this.circleUid++),this.circleKeys.push(t),this.circles.push(e),this.circles.push(i),this.circles.push(o);},Ht.prototype._insertBoxCell=function(t,e,i,o,r,a){this.boxCells[r].push(a);},Ht.prototype._insertCircleCell=function(t,e,i,o,r,a){this.circleCells[r].push(a);},Ht.prototype._query=function(t,e,i,o,r,a){if(i<0||t>this.width||o<0||e>this.height)return !r&&[];var n=[];if(t<=0&&e<=0&&this.width<=i&&this.height<=o){if(r)return !0;for(var s=0;s<this.boxKeys.length;s++)n.push({key:this.boxKeys[s],x1:this.bboxes[4*s],y1:this.bboxes[4*s+1],x2:this.bboxes[4*s+2],y2:this.bboxes[4*s+3]});for(var l=0;l<this.circleKeys.length;l++){var c=this.circles[3*l],u=this.circles[3*l+1],h=this.circles[3*l+2];n.push({key:this.circleKeys[l],x1:c-h,y1:u-h,x2:c+h,y2:u+h});}return a?n.filter(a):n}var p={hitTest:r,seenUids:{box:{},circle:{}}};return this._forEachCell(t,e,i,o,this._queryCell,n,p,a),r?n.length>0:n},Ht.prototype._queryCircle=function(t,e,i,o,r){var a=t-i,n=t+i,s=e-i,l=e+i;if(n<0||a>this.width||l<0||s>this.height)return !o&&[];var c=[],u={hitTest:o,circle:{x:t,y:e,radius:i},seenUids:{box:{},circle:{}}};return this._forEachCell(a,s,n,l,this._queryCellCircle,c,u,r),o?c.length>0:c},Ht.prototype.query=function(t,e,i,o,r){return this._query(t,e,i,o,!1,r)},Ht.prototype.hitTest=function(t,e,i,o,r){return this._query(t,e,i,o,!0,r)},Ht.prototype.hitTestCircle=function(t,e,i,o){return this._queryCircle(t,e,i,!0,o)},Ht.prototype._queryCell=function(t,e,i,o,r,a,n,s){var l=n.seenUids,c=this.boxCells[r];if(null!==c)for(var u=this.bboxes,h=0,p=c;h<p.length;h+=1){var d=p[h];if(!l.box[d]){l.box[d]=!0;var _=4*d;if(t<=u[_+2]&&e<=u[_+3]&&i>=u[_+0]&&o>=u[_+1]&&(!s||s(this.boxKeys[d]))){if(n.hitTest)return a.push(!0),!0;a.push({key:this.boxKeys[d],x1:u[_],y1:u[_+1],x2:u[_+2],y2:u[_+3]});}}}var f=this.circleCells[r];if(null!==f)for(var m=this.circles,g=0,v=f;g<v.length;g+=1){var y=v[g];if(!l.circle[y]){l.circle[y]=!0;var x=3*y;if(this._circleAndRectCollide(m[x],m[x+1],m[x+2],t,e,i,o)&&(!s||s(this.circleKeys[y]))){if(n.hitTest)return a.push(!0),!0;var b=m[x],w=m[x+1],E=m[x+2];a.push({key:this.circleKeys[y],x1:b-E,y1:w-E,x2:b+E,y2:w+E});}}}},Ht.prototype._queryCellCircle=function(t,e,i,o,r,a,n,s){var l=n.circle,c=n.seenUids,u=this.boxCells[r];if(null!==u)for(var h=this.bboxes,p=0,d=u;p<d.length;p+=1){var _=d[p];if(!c.box[_]){c.box[_]=!0;var f=4*_;if(this._circleAndRectCollide(l.x,l.y,l.radius,h[f+0],h[f+1],h[f+2],h[f+3])&&(!s||s(this.boxKeys[_])))return a.push(!0),!0}}var m=this.circleCells[r];if(null!==m)for(var g=this.circles,v=0,y=m;v<y.length;v+=1){var x=y[v];if(!c.circle[x]){c.circle[x]=!0;var b=3*x;if(this._circlesCollide(g[b],g[b+1],g[b+2],l.x,l.y,l.radius)&&(!s||s(this.circleKeys[x])))return a.push(!0),!0}}},Ht.prototype._forEachCell=function(t,e,i,o,r,a,n,s){for(var l=this._convertToXCellCoord(t),c=this._convertToYCellCoord(e),u=this._convertToXCellCoord(i),h=this._convertToYCellCoord(o),p=l;p<=u;p++)for(var d=c;d<=h;d++){var _=this.xCellCount*d+p;if(r.call(this,t,e,i,o,_,a,n,s))return}},Ht.prototype._convertToXCellCoord=function(t){return Math.max(0,Math.min(this.xCellCount-1,Math.floor(t*this.xScale)))},Ht.prototype._convertToYCellCoord=function(t){return Math.max(0,Math.min(this.yCellCount-1,Math.floor(t*this.yScale)))},Ht.prototype._circlesCollide=function(t,e,i,o,r,a){var n=o-t,s=r-e,l=i+a;return l*l>n*n+s*s},Ht.prototype._circleAndRectCollide=function(t,e,i,o,r,a,n){var s=(a-o)/2,l=Math.abs(t-(o+s));if(l>s+i)return !1;var c=(n-r)/2,u=Math.abs(e-(r+c));if(u>c+i)return !1;if(l<=s||u<=c)return !0;var h=l-s,p=u-c;return h*h+p*p<=i*i};var ae=new Float32Array([-1/0,-1/0,0,-1/0,-1/0,0,-1/0,-1/0,0,-1/0,-1/0,0]);function ne(t,e){for(var i=0;i<t;i++){var o=e.length;e.resize(o+4),e.float32.set(ae,3*o);}}function se(t,e,i){var o=e[0],r=e[1];return t[0]=i[0]*o+i[4]*r+i[12],t[1]=i[1]*o+i[5]*r+i[13],t[3]=i[3]*o+i[7]*r+i[15],t}var le=function(t,e,i){void 0===e&&(e=new Ht(t.width+200,t.height+200,25)),void 0===i&&(i=new Ht(t.width+200,t.height+200,25)),this.transform=t,this.grid=e,this.ignoredGrid=i,this.pitchfactor=Math.cos(t._pitch)*t.cameraToCenterDistance,this.screenRightBoundary=t.width+100,this.screenBottomBoundary=t.height+100,this.gridRightBoundary=t.width+200,this.gridBottomBoundary=t.height+200;};function ce(t,e,i){t[e+4]=i?1:0;}function ue(e,i,o){return i*(t.EXTENT/(e.tileSize*Math.pow(2,o-e.tileID.overscaledZ)))}le.prototype.placeCollisionBox=function(t,e,i,o,r){var a=this.projectAndGetPerspectiveRatio(o,t.anchorPointX,t.anchorPointY),n=i*a.perspectiveRatio,s=t.x1*n+a.point.x,l=t.y1*n+a.point.y,c=t.x2*n+a.point.x,u=t.y2*n+a.point.y;return !this.isInsideGrid(s,l,c,u)||!e&&this.grid.hitTest(s,l,c,u,r)?{box:[],offscreen:!1}:{box:[s,l,c,u],offscreen:this.isOffscreen(s,l,c,u)}},le.prototype.approximateTileDistance=function(t,e,i,o,r){var a=r?1:o/this.pitchfactor,n=t.lastSegmentViewportDistance*i;return t.prevTileDistance+n+(a-1)*n*Math.abs(Math.sin(e))},le.prototype.placeCollisionCircles=function(e,i,o,r,a,n,s,l,c,u,h,p,d){var _=[],f=this.projectAnchor(c,a.anchorX,a.anchorY),m=l/24,g=a.lineOffsetX*l,v=a.lineOffsetY*l,y=new t.Point(a.anchorX,a.anchorY),x=te(m,s,g,v,!1,Yt(y,u).point,y,a,n,u,{},!0),b=!1,w=!1,E=!0,T=f.perspectiveRatio*r,I=1/(r*o),C=0,S=0;x&&(C=this.approximateTileDistance(x.first.tileDistance,x.first.angle,I,f.cameraDistance,p),S=this.approximateTileDistance(x.last.tileDistance,x.last.angle,I,f.cameraDistance,p));for(var P=0;P<e.length;P+=5){var z=e[P],L=e[P+1],D=e[P+2],M=e[P+3];if(!x||M<-C||M>S)ce(e,P,!1);else{var R=this.projectPoint(c,z,L),A=D*T;if(_.length>0){var k=R.x-_[_.length-4],B=R.y-_[_.length-3];if(A*A*2>k*k+B*B)if(P+8<e.length){var O=e[P+8];if(O>-C&&O<S){ce(e,P,!1);continue}}}var F=P/5;_.push(R.x,R.y,A,F),ce(e,P,!0);var U=R.x-A,N=R.y-A,Z=R.x+A,V=R.y+A;if(E=E&&this.isOffscreen(U,N,Z,V),w=w||this.isInsideGrid(U,N,Z,V),!i&&this.grid.hitTestCircle(R.x,R.y,A,d)){if(!h)return {circles:[],offscreen:!1};b=!0;}}}return {circles:b||!w?[]:_,offscreen:E}},le.prototype.queryRenderedSymbols=function(e){if(0===e.length||0===this.grid.keysLength()&&0===this.ignoredGrid.keysLength())return {};for(var i=[],o=1/0,r=1/0,a=-1/0,n=-1/0,s=0,l=e;s<l.length;s+=1){var c=l[s],u=new t.Point(c.x+100,c.y+100);o=Math.min(o,u.x),r=Math.min(r,u.y),a=Math.max(a,u.x),n=Math.max(n,u.y),i.push(u);}for(var h={},p={},d=0,_=this.grid.query(o,r,a,n).concat(this.ignoredGrid.query(o,r,a,n));d<_.length;d+=1){var f=_[d],m=f.key;if(void 0===h[m.bucketInstanceId]&&(h[m.bucketInstanceId]={}),!h[m.bucketInstanceId][m.featureIndex]){var g=[new t.Point(f.x1,f.y1),new t.Point(f.x2,f.y1),new t.Point(f.x2,f.y2),new t.Point(f.x1,f.y2)];t.polygonIntersectsPolygon(i,g)&&(h[m.bucketInstanceId][m.featureIndex]=!0,void 0===p[m.bucketInstanceId]&&(p[m.bucketInstanceId]=[]),p[m.bucketInstanceId].push(m.featureIndex));}}return p},le.prototype.insertCollisionBox=function(t,e,i,o,r){var a={bucketInstanceId:i,featureIndex:o,collisionGroupID:r};(e?this.ignoredGrid:this.grid).insert(a,t[0],t[1],t[2],t[3]);},le.prototype.insertCollisionCircles=function(t,e,i,o,r){for(var a=e?this.ignoredGrid:this.grid,n={bucketInstanceId:i,featureIndex:o,collisionGroupID:r},s=0;s<t.length;s+=4)a.insertCircle(n,t[s],t[s+1],t[s+2]);},le.prototype.projectAnchor=function(t,e,i){var o=[e,i,0,1];return se(o,o,t),{perspectiveRatio:.5+this.transform.cameraToCenterDistance/o[3]*.5,cameraDistance:o[3]}},le.prototype.projectPoint=function(e,i,o){var r=[i,o,0,1];return se(r,r,e),new t.Point((r[0]/r[3]+1)/2*this.transform.width+100,(-r[1]/r[3]+1)/2*this.transform.height+100)},le.prototype.projectAndGetPerspectiveRatio=function(e,i,o){var r=[i,o,0,1];return se(r,r,e),{point:new t.Point((r[0]/r[3]+1)/2*this.transform.width+100,(-r[1]/r[3]+1)/2*this.transform.height+100),perspectiveRatio:.5+this.transform.cameraToCenterDistance/r[3]*.5}},le.prototype.isOffscreen=function(t,e,i,o){return i<100||t>=this.screenRightBoundary||o<100||e>this.screenBottomBoundary},le.prototype.isInsideGrid=function(t,e,i,o){return i>=0&&t<this.gridRightBoundary&&o>=0&&e<this.gridBottomBoundary};var he=function(t,e,i,o){this.opacity=t?Math.max(0,Math.min(1,t.opacity+(t.placed?e:-e))):o&&i?1:0,this.placed=i;};he.prototype.isHidden=function(){return 0===this.opacity&&!this.placed};var pe=function(t,e,i,o,r){this.text=new he(t?t.text:null,e,i,r),this.icon=new he(t?t.icon:null,e,o,r);};pe.prototype.isHidden=function(){return this.text.isHidden()&&this.icon.isHidden()};var de=function(t,e,i){this.text=t,this.icon=e,this.skipFade=i;},_e=function(t,e,i,o,r){this.bucketInstanceId=t,this.featureIndex=e,this.sourceLayerIndex=i,this.bucketIndex=o,this.tileID=r;},fe=function(t){this.crossSourceCollisions=t,this.maxGroupID=0,this.collisionGroups={};};function me(e,i,o,r,a){var n=t.getAnchorAlignment(e),s=-(n.horizontalAlign-.5)*i,l=-(n.verticalAlign-.5)*o,c=t.evaluateVariableOffset(e,r);return new t.Point(s+c[0]*a,l+c[1]*a)}function ge(e,i,o,r,a,n){var s=e.x1,l=e.x2,c=e.y1,u=e.y2,h=e.anchorPointX,p=e.anchorPointY,d=new t.Point(i,o);return r&&d._rotate(a?n:-n),{x1:s+d.x,y1:c+d.y,x2:l+d.x,y2:u+d.y,anchorPointX:h,anchorPointY:p}}fe.prototype.get=function(t){if(this.crossSourceCollisions)return {ID:0,predicate:null};if(!this.collisionGroups[t]){var e=++this.maxGroupID;this.collisionGroups[t]={ID:e,predicate:function(t){return t.collisionGroupID===e}};}return this.collisionGroups[t]};var ve=function(t,e,i,o){this.transform=t.clone(),this.collisionIndex=new le(this.transform),this.placements={},this.opacities={},this.variableOffsets={},this.stale=!1,this.commitTime=0,this.fadeDuration=e,this.retainedQueryData={},this.collisionGroups=new fe(i),this.prevPlacement=o,o&&(o.prevPlacement=void 0),this.placedOrientations={};};function ye(t,e,i,o,r){t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0);}ve.prototype.placeLayerTile=function(e,i,o,r){var a=i.getBucket(e),n=i.latestFeatureIndex;if(a&&n&&e.id===a.layerIds[0]){var s=i.collisionBoxArray,l=a.layers[0].layout,c=Math.pow(2,this.transform.zoom-i.tileID.overscaledZ),u=i.tileSize/t.EXTENT,h=this.transform.calculatePosMatrix(i.tileID.toUnwrapped()),p=Kt(h,"map"===l.get("text-pitch-alignment"),"map"===l.get("text-rotation-alignment"),this.transform,ue(i,1,this.transform.zoom)),d=Kt(h,"map"===l.get("icon-pitch-alignment"),"map"===l.get("icon-rotation-alignment"),this.transform,ue(i,1,this.transform.zoom));this.retainedQueryData[a.bucketInstanceId]=new _e(a.bucketInstanceId,n,a.sourceLayerIndex,a.index,i.tileID),this.placeLayerBucket(a,h,p,d,c,u,o,i.holdingForFade(),r,s);}},ve.prototype.attemptAnchorPlacement=function(t,e,i,o,r,a,n,s,l,c,u,h,p,d){var _,f=[h.textOffset0,h.textOffset1],m=me(t,i,o,f,r),g=this.collisionIndex.placeCollisionBox(ge(e,m.x,m.y,a,n,this.transform.angle),u,s,l,c.predicate);if(g.box.length>0)return this.prevPlacement&&this.prevPlacement.variableOffsets[h.crossTileID]&&this.prevPlacement.placements[h.crossTileID]&&this.prevPlacement.placements[h.crossTileID].text&&(_=this.prevPlacement.variableOffsets[h.crossTileID].anchor),this.variableOffsets[h.crossTileID]={textOffset:f,width:i,height:o,anchor:t,textBoxScale:r,prevAnchor:_},this.markUsedJustification(p,t,h,d),p.allowVerticalPlacement&&(this.markUsedOrientation(p,d,h),this.placedOrientations[h.crossTileID]=d),{shift:m,placedGlyphBoxes:g}},ve.prototype.placeLayerBucket=function(e,i,o,r,a,n,s,l,c,u){var h=this,p=e.layers[0].layout,d=t.evaluateSizeForZoom(e.textSizeData,this.transform.zoom),_=p.get("text-optional"),f=p.get("icon-optional"),m=p.get("text-allow-overlap"),g=p.get("icon-allow-overlap"),v=m&&(g||!e.hasIconData()||f),y=g&&(m||!e.hasTextData()||_),x=this.collisionGroups.get(e.sourceID),b="map"===p.get("text-rotation-alignment"),w="map"===p.get("text-pitch-alignment"),E="none"!==p.get("icon-text-fit"),T="viewport-y"===p.get("symbol-z-order");!e.collisionArrays&&u&&e.deserializeCollisionBoxes(u);var I=function(r,u){if(!c[r.crossTileID])if(l)h.placements[r.crossTileID]=new de(!1,!1,!1);else{var g,T=!1,I=!1,C=!0,S=null,P={box:null,offscreen:null},z={box:null,offscreen:null},L=null,D=null,M=0,R=0,A=0;u.textFeatureIndex&&(M=u.textFeatureIndex),u.verticalTextFeatureIndex&&(R=u.verticalTextFeatureIndex);var k=u.textBox;if(k){var B=function(i){var o=t.WritingMode.horizontal;if(e.allowVerticalPlacement&&!i&&h.prevPlacement){var a=h.prevPlacement.placedOrientations[r.crossTileID];a&&(h.placedOrientations[r.crossTileID]=a,o=a,h.markUsedOrientation(e,o,r));}return o},O=function(i,o){if(e.allowVerticalPlacement&&r.numVerticalGlyphVertices>0&&u.verticalTextBox)for(var a=0,n=e.writingModes;a<n.length;a+=1){if(n[a]===t.WritingMode.vertical?(P=o(),z=P):P=i(),P&&P.box&&P.box.length)break}else P=i();};if(p.get("text-variable-anchor")){var F=p.get("text-variable-anchor");if(h.prevPlacement&&h.prevPlacement.variableOffsets[r.crossTileID]){var U=h.prevPlacement.variableOffsets[r.crossTileID];F.indexOf(U.anchor)>0&&(F=F.filter(function(t){return t!==U.anchor})).unshift(U.anchor);}var N=function(t,o){for(var a=t.x2-t.x1,s=t.y2-t.y1,l=r.textBoxScale,c={box:[],offscreen:!1},u=m?2*F.length:F.length,p=0;p<u;++p){var d=F[p%F.length],_=p>=F.length,f=h.attemptAnchorPlacement(d,t,a,s,l,b,w,n,i,x,_,r,e,o);if(f&&(c=f.placedGlyphBoxes)&&c.box&&c.box.length){T=!0,S=f.shift;break}}return c};O(function(){return N(k,t.WritingMode.horizontal)},function(){var i=u.verticalTextBox,o=P&&P.box&&P.box.length;return e.allowVerticalPlacement&&!o&&r.numVerticalGlyphVertices>0&&i?N(i,t.WritingMode.vertical):{box:null,offscreen:null}}),P&&(T=P.box,C=P.offscreen);var Z=B(P&&P.box);if(!T&&h.prevPlacement){var V=h.prevPlacement.variableOffsets[r.crossTileID];V&&(h.variableOffsets[r.crossTileID]=V,h.markUsedJustification(e,V.anchor,r,Z));}}else{var q=function(t,o){var a=h.collisionIndex.placeCollisionBox(t,p.get("text-allow-overlap"),n,i,x.predicate);return a&&a.box&&a.box.length&&(h.markUsedOrientation(e,o,r),h.placedOrientations[r.crossTileID]=o),a};O(function(){return q(k,t.WritingMode.horizontal)},function(){var i=u.verticalTextBox;return e.allowVerticalPlacement&&r.numVerticalGlyphVertices>0&&i?q(i,t.WritingMode.vertical):{box:null,offscreen:null}}),B(P&&P.box&&P.box.length);}}T=(g=P)&&g.box&&g.box.length>0,C=g&&g.offscreen;var j=u.textCircles;if(j){var G=e.text.placedSymbolArray.get(r.centerJustifiedTextSymbolIndex),W=t.evaluateSizeForFeature(e.textSizeData,d,G);L=h.collisionIndex.placeCollisionCircles(j,p.get("text-allow-overlap"),a,n,G,e.lineVertexArray,e.glyphOffsetArray,W,i,o,s,w,x.predicate),T=p.get("text-allow-overlap")||L.circles.length>0,C=C&&L.offscreen;}if(u.iconFeatureIndex&&(A=u.iconFeatureIndex),u.iconBox){var X=E&&S?ge(u.iconBox,S.x,S.y,b,w,h.transform.angle):u.iconBox;I=(D=h.collisionIndex.placeCollisionBox(X,p.get("icon-allow-overlap"),n,i,x.predicate)).box.length>0,C=C&&D.offscreen;}var H=_||0===r.numHorizontalGlyphVertices&&0===r.numVerticalGlyphVertices,K=f||0===r.numIconVertices;H||K?K?H||(I=I&&T):T=I&&T:I=T=I&&T,T&&g&&g.box&&(z&&z.box&&R?h.collisionIndex.insertCollisionBox(g.box,p.get("text-ignore-placement"),e.bucketInstanceId,R,x.ID):h.collisionIndex.insertCollisionBox(g.box,p.get("text-ignore-placement"),e.bucketInstanceId,M,x.ID)),I&&D&&h.collisionIndex.insertCollisionBox(D.box,p.get("icon-ignore-placement"),e.bucketInstanceId,A,x.ID),T&&L&&h.collisionIndex.insertCollisionCircles(L.circles,p.get("text-ignore-placement"),e.bucketInstanceId,M,x.ID),h.placements[r.crossTileID]=new de(T||v,I||y,C||e.justReloaded),c[r.crossTileID]=!0;}};if(T)for(var C=e.getSortedSymbolIndexes(this.transform.angle),S=C.length-1;S>=0;--S){var P=C[S];I(e.symbolInstances.get(P),e.collisionArrays[P]);}else for(var z=0;z<e.symbolInstances.length;++z)I(e.symbolInstances.get(z),e.collisionArrays[z]);e.justReloaded=!1;},ve.prototype.markUsedJustification=function(e,i,o,r){var a,n={left:o.leftJustifiedTextSymbolIndex,center:o.centerJustifiedTextSymbolIndex,right:o.rightJustifiedTextSymbolIndex};a=r===t.WritingMode.vertical?o.verticalPlacedTextSymbolIndex:n[t.getAnchorJustification(i)];for(var s=0,l=[o.leftJustifiedTextSymbolIndex,o.centerJustifiedTextSymbolIndex,o.rightJustifiedTextSymbolIndex,o.verticalPlacedTextSymbolIndex];s<l.length;s+=1){var c=l[s];c>=0&&(e.text.placedSymbolArray.get(c).crossTileID=a>=0&&c!==a?0:o.crossTileID);}},ve.prototype.markUsedOrientation=function(e,i,o){for(var r=i===t.WritingMode.horizontal||i===t.WritingMode.horizontalOnly?i:0,a=i===t.WritingMode.vertical?i:0,n=0,s=[o.leftJustifiedTextSymbolIndex,o.centerJustifiedTextSymbolIndex,o.rightJustifiedTextSymbolIndex];n<s.length;n+=1){var l=s[n];e.text.placedSymbolArray.get(l).placedOrientation=r;}o.verticalPlacedTextSymbolIndex&&(e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation=a);},ve.prototype.commit=function(t){this.commitTime=t;var e=this.prevPlacement,i=!1,o=e&&0!==this.fadeDuration?(this.commitTime-e.commitTime)/this.fadeDuration:1,r=e?e.opacities:{},a=e?e.variableOffsets:{},n=e?e.placedOrientations:{};for(var s in this.placements){var l=this.placements[s],c=r[s];c?(this.opacities[s]=new pe(c,o,l.text,l.icon),i=i||l.text!==c.text.placed||l.icon!==c.icon.placed):(this.opacities[s]=new pe(null,o,l.text,l.icon,l.skipFade),i=i||l.text||l.icon);}for(var u in r){var h=r[u];if(!this.opacities[u]){var p=new pe(h,o,!1,!1);p.isHidden()||(this.opacities[u]=p,i=i||h.text.placed||h.icon.placed);}}for(var d in a)this.variableOffsets[d]||!this.opacities[d]||this.opacities[d].isHidden()||(this.variableOffsets[d]=a[d]);for(var _ in n)this.placedOrientations[_]||!this.opacities[_]||this.opacities[_].isHidden()||(this.placedOrientations[_]=n[_]);i?this.lastPlacementChangeTime=t:"number"!=typeof this.lastPlacementChangeTime&&(this.lastPlacementChangeTime=e?e.lastPlacementChangeTime:t);},ve.prototype.updateLayerOpacities=function(t,e){for(var i={},o=0,r=e;o<r.length;o+=1){var a=r[o],n=a.getBucket(t);n&&a.latestFeatureIndex&&t.id===n.layerIds[0]&&this.updateBucketOpacities(n,i,a.collisionBoxArray);}},ve.prototype.updateBucketOpacities=function(e,i,o){e.hasTextData()&&e.text.opacityVertexArray.clear(),e.hasIconData()&&e.icon.opacityVertexArray.clear(),e.hasIconCollisionBoxData()&&e.iconCollisionBox.collisionVertexArray.clear(),e.hasTextCollisionBoxData()&&e.textCollisionBox.collisionVertexArray.clear(),e.hasIconCollisionCircleData()&&e.iconCollisionCircle.collisionVertexArray.clear(),e.hasTextCollisionCircleData()&&e.textCollisionCircle.collisionVertexArray.clear();var r=e.layers[0].layout,a=new pe(null,0,!1,!1,!0),n=r.get("text-allow-overlap"),s=r.get("icon-allow-overlap"),l=r.get("text-variable-anchor"),c="map"===r.get("text-rotation-alignment"),u="map"===r.get("text-pitch-alignment"),h="none"!==r.get("icon-text-fit"),p=new pe(null,0,n&&(s||!e.hasIconData()||r.get("icon-optional")),s&&(n||!e.hasTextData()||r.get("text-optional")),!0);!e.collisionArrays&&o&&(e.hasIconCollisionBoxData()||e.hasIconCollisionCircleData()||e.hasTextCollisionBoxData()||e.hasTextCollisionCircleData())&&e.deserializeCollisionBoxes(o);for(var d=0;d<e.symbolInstances.length;d++){var _=e.symbolInstances.get(d),f=_.numHorizontalGlyphVertices,m=_.numVerticalGlyphVertices,g=_.crossTileID,v=i[g],y=this.opacities[g];v?y=a:y||(y=p,this.opacities[g]=y),i[g]=!0;var x=f>0||m>0,b=_.numIconVertices>0;if(x){for(var w=Se(y.text),E=(f+m)/4,T=0;T<E;T++)e.text.opacityVertexArray.emplaceBack(w);var I=y.text.isHidden()?1:0,C=this.placedOrientations[_.crossTileID],S=C===t.WritingMode.horizontal||C===t.WritingMode.horizontalOnly?1:0,P=C===t.WritingMode.vertical?1:0;[_.rightJustifiedTextSymbolIndex,_.centerJustifiedTextSymbolIndex,_.leftJustifiedTextSymbolIndex].forEach(function(t){t>=0&&(e.text.placedSymbolArray.get(t).hidden=I||P);}),_.verticalPlacedTextSymbolIndex>=0&&(e.text.placedSymbolArray.get(_.verticalPlacedTextSymbolIndex).hidden=I||S);var z=this.variableOffsets[_.crossTileID];z&&this.markUsedJustification(e,z.anchor,_,C);var L=this.placedOrientations[_.crossTileID];L&&(this.markUsedJustification(e,"left",_,L),this.markUsedOrientation(e,L,_));}if(b){for(var D=Se(y.icon),M=0;M<_.numIconVertices/4;M++)e.icon.opacityVertexArray.emplaceBack(D);e.icon.placedSymbolArray.get(d).hidden=y.icon.isHidden();}if(e.hasIconCollisionBoxData()||e.hasIconCollisionCircleData()||e.hasTextCollisionBoxData()||e.hasTextCollisionCircleData()){var R=e.collisionArrays[d];if(R){var A=new t.Point(0,0);if(R.textBox){var k=!0;if(l){var B=this.variableOffsets[g];B?(A=me(B.anchor,B.width,B.height,B.textOffset,B.textBoxScale),c&&A._rotate(u?this.transform.angle:-this.transform.angle)):k=!1;}ye(e.textCollisionBox.collisionVertexArray,y.text.placed,!k,A.x,A.y);}R.iconBox&&ye(e.iconCollisionBox.collisionVertexArray,y.icon.placed,!1,h?A.x:0,h?A.y:0);var O=R.textCircles;if(O&&e.hasTextCollisionCircleData())for(var F=0;F<O.length;F+=5){var U=v||0===O[F+4];ye(e.textCollisionCircle.collisionVertexArray,y.text.placed,U);}}}}e.sortFeatures(this.transform.angle),this.retainedQueryData[e.bucketInstanceId]&&(this.retainedQueryData[e.bucketInstanceId].featureSortOrder=e.featureSortOrder),e.hasTextData()&&e.text.opacityVertexBuffer&&e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),e.hasIconData()&&e.icon.opacityVertexBuffer&&e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),e.hasIconCollisionBoxData()&&e.iconCollisionBox.collisionVertexBuffer&&e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),e.hasTextCollisionBoxData()&&e.textCollisionBox.collisionVertexBuffer&&e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),e.hasIconCollisionCircleData()&&e.iconCollisionCircle.collisionVertexBuffer&&e.iconCollisionCircle.collisionVertexBuffer.updateData(e.iconCollisionCircle.collisionVertexArray),e.hasTextCollisionCircleData()&&e.textCollisionCircle.collisionVertexBuffer&&e.textCollisionCircle.collisionVertexBuffer.updateData(e.textCollisionCircle.collisionVertexArray);},ve.prototype.symbolFadeChange=function(t){return 0===this.fadeDuration?1:(t-this.commitTime)/this.fadeDuration},ve.prototype.hasTransitions=function(t){return this.stale||t-this.lastPlacementChangeTime<this.fadeDuration},ve.prototype.stillRecent=function(t){return this.commitTime+this.fadeDuration>t},ve.prototype.setStale=function(){this.stale=!0;};var xe=Math.pow(2,25),be=Math.pow(2,24),we=Math.pow(2,17),Ee=Math.pow(2,16),Te=Math.pow(2,9),Ie=Math.pow(2,8),Ce=Math.pow(2,1);function Se(t){if(0===t.opacity&&!t.placed)return 0;if(1===t.opacity&&t.placed)return 4294967295;var e=t.placed?1:0,i=Math.floor(127*t.opacity);return i*xe+e*be+i*we+e*Ee+i*Te+e*Ie+i*Ce+e}var Pe=function(){this._currentTileIndex=0,this._seenCrossTileIDs={};};Pe.prototype.continuePlacement=function(t,e,i,o,r){for(;this._currentTileIndex<t.length;){var a=t[this._currentTileIndex];if(e.placeLayerTile(o,a,i,this._seenCrossTileIDs),this._currentTileIndex++,r())return !0}};var ze=function(t,e,i,o,r,a,n){this.placement=new ve(t,r,a,n),this._currentPlacementIndex=e.length-1,this._forceFullPlacement=i,this._showCollisionBoxes=o,this._done=!1;};ze.prototype.isDone=function(){return this._done},ze.prototype.continuePlacement=function(e,i,o){for(var r=this,a=t.browser.now(),n=function(){var e=t.browser.now()-a;return !r._forceFullPlacement&&e>2};this._currentPlacementIndex>=0;){var s=i[e[this._currentPlacementIndex]],l=this.placement.collisionIndex.transform.zoom;if("symbol"===s.type&&(!s.minzoom||s.minzoom<=l)&&(!s.maxzoom||s.maxzoom>l)){if(this._inProgressLayer||(this._inProgressLayer=new Pe),this._inProgressLayer.continuePlacement(o[s.source],this.placement,this._showCollisionBoxes,s,n))return;delete this._inProgressLayer;}this._currentPlacementIndex--;}this._done=!0;},ze.prototype.commit=function(t){return this.placement.commit(t),this.placement};var Le=512/t.EXTENT/2,De=function(t,e,i){this.tileID=t,this.indexedSymbolInstances={},this.bucketInstanceId=i;for(var o=0;o<e.length;o++){var r=e.get(o),a=r.key;this.indexedSymbolInstances[a]||(this.indexedSymbolInstances[a]=[]),this.indexedSymbolInstances[a].push({crossTileID:r.crossTileID,coord:this.getScaledCoordinates(r,t)});}};De.prototype.getScaledCoordinates=function(e,i){var o=i.canonical.z-this.tileID.canonical.z,r=Le/Math.pow(2,o);return {x:Math.floor((i.canonical.x*t.EXTENT+e.anchorX)*r),y:Math.floor((i.canonical.y*t.EXTENT+e.anchorY)*r)}},De.prototype.findMatches=function(t,e,i){for(var o=this.tileID.canonical.z<e.canonical.z?1:Math.pow(2,this.tileID.canonical.z-e.canonical.z),r=0;r<t.length;r++){var a=t.get(r);if(!a.crossTileID){var n=this.indexedSymbolInstances[a.key];if(n)for(var s=this.getScaledCoordinates(a,e),l=0,c=n;l<c.length;l+=1){var u=c[l];if(Math.abs(u.coord.x-s.x)<=o&&Math.abs(u.coord.y-s.y)<=o&&!i[u.crossTileID]){i[u.crossTileID]=!0,a.crossTileID=u.crossTileID;break}}}}};var Me=function(){this.maxCrossTileID=0;};Me.prototype.generate=function(){return ++this.maxCrossTileID};var Re=function(){this.indexes={},this.usedCrossTileIDs={},this.lng=0;};Re.prototype.handleWrapJump=function(t){var e=Math.round((t-this.lng)/360);if(0!==e)for(var i in this.indexes){var o=this.indexes[i],r={};for(var a in o){var n=o[a];n.tileID=n.tileID.unwrapTo(n.tileID.wrap+e),r[n.tileID.key]=n;}this.indexes[i]=r;}this.lng=t;},Re.prototype.addBucket=function(t,e,i){if(this.indexes[t.overscaledZ]&&this.indexes[t.overscaledZ][t.key]){if(this.indexes[t.overscaledZ][t.key].bucketInstanceId===e.bucketInstanceId)return !1;this.removeBucketCrossTileIDs(t.overscaledZ,this.indexes[t.overscaledZ][t.key]);}for(var o=0;o<e.symbolInstances.length;o++){e.symbolInstances.get(o).crossTileID=0;}this.usedCrossTileIDs[t.overscaledZ]||(this.usedCrossTileIDs[t.overscaledZ]={});var r=this.usedCrossTileIDs[t.overscaledZ];for(var a in this.indexes){var n=this.indexes[a];if(Number(a)>t.overscaledZ)for(var s in n){var l=n[s];l.tileID.isChildOf(t)&&l.findMatches(e.symbolInstances,t,r);}else{var c=n[t.scaledTo(Number(a)).key];c&&c.findMatches(e.symbolInstances,t,r);}}for(var u=0;u<e.symbolInstances.length;u++){var h=e.symbolInstances.get(u);h.crossTileID||(h.crossTileID=i.generate(),r[h.crossTileID]=!0);}return void 0===this.indexes[t.overscaledZ]&&(this.indexes[t.overscaledZ]={}),this.indexes[t.overscaledZ][t.key]=new De(t,e.symbolInstances,e.bucketInstanceId),!0},Re.prototype.removeBucketCrossTileIDs=function(t,e){for(var i in e.indexedSymbolInstances)for(var o=0,r=e.indexedSymbolInstances[i];o<r.length;o+=1){var a=r[o];delete this.usedCrossTileIDs[t][a.crossTileID];}},Re.prototype.removeStaleBuckets=function(t){var e=!1;for(var i in this.indexes){var o=this.indexes[i];for(var r in o)t[o[r].bucketInstanceId]||(this.removeBucketCrossTileIDs(i,o[r]),delete o[r],e=!0);}return e};var Ae=function(){this.layerIndexes={},this.crossTileIDs=new Me,this.maxBucketInstanceId=0,this.bucketsInCurrentPlacement={};};Ae.prototype.addLayer=function(t,e,i){var o=this.layerIndexes[t.id];void 0===o&&(o=this.layerIndexes[t.id]=new Re);var r=!1,a={};o.handleWrapJump(i);for(var n=0,s=e;n<s.length;n+=1){var l=s[n],c=l.getBucket(t);c&&t.id===c.layerIds[0]&&(c.bucketInstanceId||(c.bucketInstanceId=++this.maxBucketInstanceId),o.addBucket(l.tileID,c,this.crossTileIDs)&&(r=!0),a[c.bucketInstanceId]=!0);}return o.removeStaleBuckets(a)&&(r=!0),r},Ae.prototype.pruneUnusedLayers=function(t){var e={};for(var i in t.forEach(function(t){e[t]=!0;}),this.layerIndexes)e[i]||delete this.layerIndexes[i];};var ke=function(e,i){return t.emitValidationErrors(e,i&&i.filter(function(t){return "source.canvas"!==t.identifier}))},Be=t.pick(Ut,["addLayer","removeLayer","setPaintProperty","setLayoutProperty","setFilter","addSource","removeSource","setLayerZoomRange","setLight","setTransition","setGeoJSONSourceData"]),Oe=t.pick(Ut,["setCenter","setZoom","setBearing","setPitch"]),Fe=function(e){function i(o,r){var a=this;void 0===r&&(r={}),e.call(this),this.map=o,this.dispatcher=new T((kt||(kt=new At),kt),this),this.imageManager=new p,this.imageManager.setEventedParent(this),this.glyphManager=new y(o._requestManager,r.localIdeographFontFamily),this.lineAtlas=new E(256,512),this.crossTileSymbolIndex=new Ae,this._layers={},this._order=[],this.sourceCaches={},this.zoomHistory=new t.ZoomHistory,this._loaded=!1,this._resetUpdates(),this.dispatcher.broadcast("setReferrer",t.getReferrer());var n=this;this._rtlTextPluginCallback=i.registerForPluginAvailability(function(t){for(var e in n.dispatcher.broadcast("loadRTLTextPlugin",t.pluginURL,t.completionCallback),n.sourceCaches)n.sourceCaches[e].reload();}),this.on("data",function(t){if("source"===t.dataType&&"metadata"===t.sourceDataType){var e=a.sourceCaches[t.sourceId];if(e){var i=e.getSource();if(i&&i.vectorLayerIds)for(var o in a._layers){var r=a._layers[o];r.source===i.id&&a._validateLayer(r);}}}});}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.loadURL=function(e,i){var o=this;void 0===i&&(i={}),this.fire(new t.Event("dataloading",{dataType:"style"}));var r="boolean"==typeof i.validate?i.validate:!t.isMapboxURL(e);e=this.map._requestManager.normalizeStyleURL(e,i.accessToken);var a=this.map._requestManager.transformRequest(e,t.ResourceType.Style);this._request=t.getJSON(a,function(e,i){o._request=null,e?o.fire(new t.ErrorEvent(e)):i&&o._load(i,r);});},i.prototype.loadJSON=function(e,i){var o=this;void 0===i&&(i={}),this.fire(new t.Event("dataloading",{dataType:"style"})),this._request=t.browser.frame(function(){o._request=null,o._load(e,!1!==i.validate);});},i.prototype._load=function(e,i){var o=this;if(!i||!ke(this,t.validateStyle(e))){for(var r in this._loaded=!0,this.stylesheet=e,e.sources)this.addSource(r,e.sources[r],{validate:!1});e.sprite?this._spriteRequest=function(e,i,o){var r,a,n,s=t.browser.devicePixelRatio>1?"@2x":"",l=t.getJSON(i.transformRequest(i.normalizeSpriteURL(e,s,".json"),t.ResourceType.SpriteJSON),function(t,e){l=null,n||(n=t,r=e,u());}),c=t.getImage(i.transformRequest(i.normalizeSpriteURL(e,s,".png"),t.ResourceType.SpriteImage),function(t,e){c=null,n||(n=t,a=e,u());});function u(){if(n)o(n);else if(r&&a){var e=t.browser.getImageData(a),i={};for(var s in r){var l=r[s],c=l.width,u=l.height,h=l.x,p=l.y,d=l.sdf,_=l.pixelRatio,f=new t.RGBAImage({width:c,height:u});t.RGBAImage.copy(e,f,{x:h,y:p},{x:0,y:0},{width:c,height:u}),i[s]={data:f,pixelRatio:_,sdf:d};}o(null,i);}}return {cancel:function(){l&&(l.cancel(),l=null),c&&(c.cancel(),c=null);}}}(e.sprite,this.map._requestManager,function(e,i){if(o._spriteRequest=null,e)o.fire(new t.ErrorEvent(e));else if(i)for(var r in i)o.imageManager.addImage(r,i[r]);o.imageManager.setLoaded(!0),o.dispatcher.broadcast("setImages",o.imageManager.listImages()),o.fire(new t.Event("data",{dataType:"style"}));}):this.imageManager.setLoaded(!0),this.glyphManager.setURL(e.glyphs);var a=Ft(this.stylesheet.layers);this._order=a.map(function(t){return t.id}),this._layers={};for(var n=0,s=a;n<s.length;n+=1){var l=s[n];(l=t.createStyleLayer(l)).setEventedParent(this,{layer:{id:l.id}}),this._layers[l.id]=l;}this.dispatcher.broadcast("setLayers",this._serializeLayers(this._order)),this.light=new w(this.stylesheet.light),this.fire(new t.Event("data",{dataType:"style"})),this.fire(new t.Event("style.load"));}},i.prototype._validateLayer=function(e){var i=this.sourceCaches[e.source];if(i){var o=e.sourceLayer;if(o){var r=i.getSource();("geojson"===r.type||r.vectorLayerIds&&-1===r.vectorLayerIds.indexOf(o))&&this.fire(new t.ErrorEvent(new Error('Source layer "'+o+'" does not exist on source "'+r.id+'" as specified by style layer "'+e.id+'"')));}}},i.prototype.loaded=function(){if(!this._loaded)return !1;if(Object.keys(this._updatedSources).length)return !1;for(var t in this.sourceCaches)if(!this.sourceCaches[t].loaded())return !1;return !!this.imageManager.isLoaded()},i.prototype._serializeLayers=function(t){for(var e=[],i=0,o=t;i<o.length;i+=1){var r=o[i],a=this._layers[r];"custom"!==a.type&&e.push(a.serialize());}return e},i.prototype.hasTransitions=function(){if(this.light&&this.light.hasTransition())return !0;for(var t in this.sourceCaches)if(this.sourceCaches[t].hasTransition())return !0;for(var e in this._layers)if(this._layers[e].hasTransition())return !0;return !1},i.prototype._checkLoaded=function(){if(!this._loaded)throw new Error("Style is not done loading")},i.prototype.update=function(e){if(this._loaded){var i=this._changed;if(this._changed){var o=Object.keys(this._updatedLayers),r=Object.keys(this._removedLayers);for(var a in(o.length||r.length)&&this._updateWorkerLayers(o,r),this._updatedSources){var n=this._updatedSources[a];"reload"===n?this._reloadSource(a):"clear"===n&&this._clearSource(a);}for(var s in this._updatedPaintProps)this._layers[s].updateTransitions(e);this.light.updateTransitions(e),this._resetUpdates();}for(var l in this.sourceCaches)this.sourceCaches[l].used=!1;for(var c=0,u=this._order;c<u.length;c+=1){var h=u[c],p=this._layers[h];p.recalculate(e,this.imageManager.listImages()),!p.isHidden(e.zoom)&&p.source&&(this.sourceCaches[p.source].used=!0);}this.light.recalculate(e),this.z=e.zoom,i&&this.fire(new t.Event("data",{dataType:"style"}));}},i.prototype._updateWorkerLayers=function(t,e){this.dispatcher.broadcast("updateLayers",{layers:this._serializeLayers(t),removedIds:e});},i.prototype._resetUpdates=function(){this._changed=!1,this._updatedLayers={},this._removedLayers={},this._updatedSources={},this._updatedPaintProps={};},i.prototype.setState=function(e){var i=this;if(this._checkLoaded(),ke(this,t.validateStyle(e)))return !1;(e=t.clone$1(e)).layers=Ft(e.layers);var o=Xt(this.serialize(),e).filter(function(t){return !(t.command in Oe)});if(0===o.length)return !1;var r=o.filter(function(t){return !(t.command in Be)});if(r.length>0)throw new Error("Unimplemented: "+r.map(function(t){return t.command}).join(", ")+".");return o.forEach(function(t){"setTransition"!==t.command&&i[t.command].apply(i,t.args);}),this.stylesheet=e,!0},i.prototype.addImage=function(e,i){if(this.getImage(e))return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));this.imageManager.addImage(e,i),this.fire(new t.Event("data",{dataType:"style"}));},i.prototype.updateImage=function(t,e){this.imageManager.updateImage(t,e);},i.prototype.getImage=function(t){return this.imageManager.getImage(t)},i.prototype.removeImage=function(e){if(!this.getImage(e))return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));this.imageManager.removeImage(e),this.fire(new t.Event("data",{dataType:"style"}));},i.prototype.listImages=function(){return this._checkLoaded(),this.imageManager.listImages()},i.prototype.addSource=function(e,i,o){var r=this;if(void 0===o&&(o={}),this._checkLoaded(),void 0!==this.sourceCaches[e])throw new Error("There is already a source with this ID");if(!i.type)throw new Error("The type property must be defined, but the only the following properties were given: "+Object.keys(i).join(", ")+".");if(!(["vector","raster","geojson","video","image"].indexOf(i.type)>=0)||!this._validate(t.validateStyle.source,"sources."+e,i,null,o)){this.map&&this.map._collectResourceTiming&&(i.collectResourceTiming=!0);var a=this.sourceCaches[e]=new Lt(e,i,this.dispatcher);a.style=this,a.setEventedParent(this,function(){return {isSourceLoaded:r.loaded(),source:a.serialize(),sourceId:e}}),a.onAdd(this.map),this._changed=!0;}},i.prototype.removeSource=function(e){if(this._checkLoaded(),void 0===this.sourceCaches[e])throw new Error("There is no source with this ID");for(var i in this._layers)if(this._layers[i].source===e)return this.fire(new t.ErrorEvent(new Error('Source "'+e+'" cannot be removed while layer "'+i+'" is using it.')));var o=this.sourceCaches[e];delete this.sourceCaches[e],delete this._updatedSources[e],o.fire(new t.Event("data",{sourceDataType:"metadata",dataType:"source",sourceId:e})),o.setEventedParent(null),o.clearTiles(),o.onRemove&&o.onRemove(this.map),this._changed=!0;},i.prototype.setGeoJSONSourceData=function(t,e){this._checkLoaded(),this.sourceCaches[t].getSource().setData(e),this._changed=!0;},i.prototype.getSource=function(t){return this.sourceCaches[t]&&this.sourceCaches[t].getSource()},i.prototype.addLayer=function(e,i,o){void 0===o&&(o={}),this._checkLoaded();var r=e.id;if(this.getLayer(r))this.fire(new t.ErrorEvent(new Error('Layer with id "'+r+'" already exists on this map')));else{var a;if("custom"===e.type){if(ke(this,t.validateCustomStyleLayer(e)))return;a=t.createStyleLayer(e);}else{if("object"==typeof e.source&&(this.addSource(r,e.source),e=t.clone$1(e),e=t.extend(e,{source:r})),this._validate(t.validateStyle.layer,"layers."+r,e,{arrayIndex:-1},o))return;a=t.createStyleLayer(e),this._validateLayer(a),a.setEventedParent(this,{layer:{id:r}});}var n=i?this._order.indexOf(i):this._order.length;if(i&&-1===n)this.fire(new t.ErrorEvent(new Error('Layer with id "'+i+'" does not exist on this map.')));else{if(this._order.splice(n,0,r),this._layerOrderChanged=!0,this._layers[r]=a,this._removedLayers[r]&&a.source&&"custom"!==a.type){var s=this._removedLayers[r];delete this._removedLayers[r],s.type!==a.type?this._updatedSources[a.source]="clear":(this._updatedSources[a.source]="reload",this.sourceCaches[a.source].pause());}this._updateLayer(a),a.onAdd&&a.onAdd(this.map);}}},i.prototype.moveLayer=function(e,i){if(this._checkLoaded(),this._changed=!0,this._layers[e]){if(e!==i){var o=this._order.indexOf(e);this._order.splice(o,1);var r=i?this._order.indexOf(i):this._order.length;i&&-1===r?this.fire(new t.ErrorEvent(new Error('Layer with id "'+i+'" does not exist on this map.'))):(this._order.splice(r,0,e),this._layerOrderChanged=!0);}}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be moved.")));},i.prototype.removeLayer=function(e){this._checkLoaded();var i=this._layers[e];if(i){i.setEventedParent(null);var o=this._order.indexOf(e);this._order.splice(o,1),this._layerOrderChanged=!0,this._changed=!0,this._removedLayers[e]=i,delete this._layers[e],delete this._updatedLayers[e],delete this._updatedPaintProps[e],i.onRemove&&i.onRemove(this.map);}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be removed.")));},i.prototype.getLayer=function(t){return this._layers[t]},i.prototype.setLayerZoomRange=function(e,i,o){this._checkLoaded();var r=this.getLayer(e);r?r.minzoom===i&&r.maxzoom===o||(null!=i&&(r.minzoom=i),null!=o&&(r.maxzoom=o),this._updateLayer(r)):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot have zoom extent.")));},i.prototype.setFilter=function(e,i,o){void 0===o&&(o={}),this._checkLoaded();var r=this.getLayer(e);if(r){if(!t.deepEqual(r.filter,i))return null==i?(r.filter=void 0,void this._updateLayer(r)):void(this._validate(t.validateStyle.filter,"layers."+r.id+".filter",i,null,o)||(r.filter=t.clone$1(i),this._updateLayer(r)))}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be filtered.")));},i.prototype.getFilter=function(e){return t.clone$1(this.getLayer(e).filter)},i.prototype.setLayoutProperty=function(e,i,o,r){void 0===r&&(r={}),this._checkLoaded();var a=this.getLayer(e);a?t.deepEqual(a.getLayoutProperty(i),o)||(a.setLayoutProperty(i,o,r),this._updateLayer(a)):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")));},i.prototype.getLayoutProperty=function(e,i){var o=this.getLayer(e);if(o)return o.getLayoutProperty(i);this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style.")));},i.prototype.setPaintProperty=function(e,i,o,r){void 0===r&&(r={}),this._checkLoaded();var a=this.getLayer(e);a?t.deepEqual(a.getPaintProperty(i),o)||(a.setPaintProperty(i,o,r)&&this._updateLayer(a),this._changed=!0,this._updatedPaintProps[e]=!0):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")));},i.prototype.getPaintProperty=function(t,e){return this.getLayer(t).getPaintProperty(e)},i.prototype.setFeatureState=function(e,i){this._checkLoaded();var o=e.source,r=e.sourceLayer,a=this.sourceCaches[o],n=parseInt(e.id,10);if(void 0!==a){var s=a.getSource().type;"geojson"===s&&r?this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))):"vector"!==s||r?isNaN(n)||n<0?this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided and non-negative."))):a.setFeatureState(r,n,i):this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+o+"' does not exist in the map's style.")));},i.prototype.removeFeatureState=function(e,i){this._checkLoaded();var o=e.source,r=this.sourceCaches[o];if(void 0!==r){var a=r.getSource().type,n="vector"===a?e.sourceLayer:void 0,s=parseInt(e.id,10);"vector"!==a||n?void 0!==e.id&&isNaN(s)||s<0?this.fire(new t.ErrorEvent(new Error("The feature id parameter must be non-negative."))):i&&"string"!=typeof e.id&&"number"!=typeof e.id?this.fire(new t.ErrorEvent(new Error("A feature id is requred to remove its specific state property."))):r.removeFeatureState(n,s,i):this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+o+"' does not exist in the map's style.")));},i.prototype.getFeatureState=function(e){this._checkLoaded();var i=e.source,o=e.sourceLayer,r=this.sourceCaches[i],a=parseInt(e.id,10);if(void 0!==r)if("vector"!==r.getSource().type||o){if(!(isNaN(a)||a<0))return r.getFeatureState(o,a);this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided and non-negative.")));}else this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));else this.fire(new t.ErrorEvent(new Error("The source '"+i+"' does not exist in the map's style.")));},i.prototype.getTransition=function(){return t.extend({duration:300,delay:0},this.stylesheet&&this.stylesheet.transition)},i.prototype.serialize=function(){return t.filterObject({version:this.stylesheet.version,name:this.stylesheet.name,metadata:this.stylesheet.metadata,light:this.stylesheet.light,center:this.stylesheet.center,zoom:this.stylesheet.zoom,bearing:this.stylesheet.bearing,pitch:this.stylesheet.pitch,sprite:this.stylesheet.sprite,glyphs:this.stylesheet.glyphs,transition:this.stylesheet.transition,sources:t.mapObject(this.sourceCaches,function(t){return t.serialize()}),layers:this._serializeLayers(this._order)},function(t){return void 0!==t})},i.prototype._updateLayer=function(t){this._updatedLayers[t.id]=!0,t.source&&!this._updatedSources[t.source]&&(this._updatedSources[t.source]="reload",this.sourceCaches[t.source].pause()),this._changed=!0;},i.prototype._flattenAndSortRenderedFeatures=function(t){for(var e=this,i=function(t){return "fill-extrusion"===e._layers[t].type},o={},r=[],a=this._order.length-1;a>=0;a--){var n=this._order[a];if(i(n)){o[n]=a;for(var s=0,l=t;s<l.length;s+=1){var c=l[s][n];if(c)for(var u=0,h=c;u<h.length;u+=1){var p=h[u];r.push(p);}}}}r.sort(function(t,e){return e.intersectionZ-t.intersectionZ});for(var d=[],_=this._order.length-1;_>=0;_--){var f=this._order[_];if(i(f))for(var m=r.length-1;m>=0;m--){var g=r[m].feature;if(o[g.layer.id]<_)break;d.push(g),r.pop();}else for(var v=0,y=t;v<y.length;v+=1){var x=y[v][f];if(x)for(var b=0,w=x;b<w.length;b+=1){var E=w[b];d.push(E.feature);}}}return d},i.prototype.queryRenderedFeatures=function(e,i,o){i&&i.filter&&this._validate(t.validateStyle.filter,"queryRenderedFeatures.filter",i.filter,null,i);var r={};if(i&&i.layers){if(!Array.isArray(i.layers))return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))),[];for(var a=0,n=i.layers;a<n.length;a+=1){var s=n[a],l=this._layers[s];if(!l)return this.fire(new t.ErrorEvent(new Error("The layer '"+s+"' does not exist in the map's style and cannot be queried for features."))),[];r[l.source]=!0;}}var c=[];for(var u in this.sourceCaches)i.layers&&!r[u]||c.push(O(this.sourceCaches[u],this._layers,e,i,o));return this.placement&&c.push(function(t,e,i,o,r,a){for(var n={},s=r.queryRenderedSymbols(i),l=[],c=0,u=Object.keys(s).map(Number);c<u.length;c+=1){var h=u[c];l.push(a[h]);}l.sort(F);for(var p=function(){var e=_[d],i=e.featureIndex.lookupSymbolFeatures(s[e.bucketInstanceId],e.bucketIndex,e.sourceLayerIndex,o.filter,o.layers,t);for(var r in i){var a=n[r]=n[r]||[],l=i[r];l.sort(function(t,i){var o=e.featureSortOrder;if(o){var r=o.indexOf(t.featureIndex);return o.indexOf(i.featureIndex)-r}return i.featureIndex-t.featureIndex});for(var c=0,u=l;c<u.length;c+=1){var h=u[c];a.push(h);}}},d=0,_=l;d<_.length;d+=1)p();var f=function(i){n[i].forEach(function(o){var r=o.feature,a=t[i],n=e[a.source].getFeatureState(r.layer["source-layer"],r.id);r.source=r.layer.source,r.layer["source-layer"]&&(r.sourceLayer=r.layer["source-layer"]),r.state=n;});};for(var m in n)f(m);return n}(this._layers,this.sourceCaches,e,i,this.placement.collisionIndex,this.placement.retainedQueryData)),this._flattenAndSortRenderedFeatures(c)},i.prototype.querySourceFeatures=function(e,i){i&&i.filter&&this._validate(t.validateStyle.filter,"querySourceFeatures.filter",i.filter,null,i);var o=this.sourceCaches[e];return o?function(t,e){for(var i=t.getRenderableIds().map(function(e){return t.getTileByID(e)}),o=[],r={},a=0;a<i.length;a++){var n=i[a],s=n.tileID.canonical.key;r[s]||(r[s]=!0,n.querySourceFeatures(o,e));}return o}(o,i):[]},i.prototype.addSourceType=function(t,e,o){return i.getSourceType(t)?o(new Error('A source type called "'+t+'" already exists.')):(i.setSourceType(t,e),e.workerSourceURL?void this.dispatcher.broadcast("loadWorkerSource",{name:t,url:e.workerSourceURL},o):o(null,null))},i.prototype.getLight=function(){return this.light.getLight()},i.prototype.setLight=function(e,i){void 0===i&&(i={}),this._checkLoaded();var o=this.light.getLight(),r=!1;for(var a in e)if(!t.deepEqual(e[a],o[a])){r=!0;break}if(r){var n={now:t.browser.now(),transition:t.extend({duration:300,delay:0},this.stylesheet.transition)};this.light.setLight(e,i),this.light.updateTransitions(n);}},i.prototype._validate=function(e,i,o,r,a){return void 0===a&&(a={}),(!a||!1!==a.validate)&&ke(this,e.call(t.validateStyle,t.extend({key:i,style:this.serialize(),value:o,styleSpec:t.styleSpec},r)))},i.prototype._remove=function(){for(var e in this._request&&(this._request.cancel(),this._request=null),this._spriteRequest&&(this._spriteRequest.cancel(),this._spriteRequest=null),t.evented.off("pluginAvailable",this._rtlTextPluginCallback),this.sourceCaches)this.sourceCaches[e].clearTiles();this.dispatcher.remove();},i.prototype._clearSource=function(t){this.sourceCaches[t].clearTiles();},i.prototype._reloadSource=function(t){this.sourceCaches[t].resume(),this.sourceCaches[t].reload();},i.prototype._updateSources=function(t){for(var e in this.sourceCaches)this.sourceCaches[e].update(t);},i.prototype._generateCollisionBoxes=function(){for(var t in this.sourceCaches)this._reloadSource(t);},i.prototype._updatePlacement=function(e,i,o,r){for(var a=!1,n=!1,s={},l=0,c=this._order;l<c.length;l+=1){var u=c[l],h=this._layers[u];if("symbol"===h.type){if(!s[h.source]){var p=this.sourceCaches[h.source];s[h.source]=p.getRenderableIds(!0).map(function(t){return p.getTileByID(t)}).sort(function(t,e){return e.tileID.overscaledZ-t.tileID.overscaledZ||(t.tileID.isLessThan(e.tileID)?-1:1)});}var d=this.crossTileSymbolIndex.addLayer(h,s[h.source],e.center.lng);a=a||d;}}this.crossTileSymbolIndex.pruneUnusedLayers(this._order);var _=this._layerOrderChanged||0===o;if((_||!this.pauseablePlacement||this.pauseablePlacement.isDone()&&!this.placement.stillRecent(t.browser.now()))&&(this.pauseablePlacement=new ze(e,this._order,_,i,o,r,this.placement),this._layerOrderChanged=!1),this.pauseablePlacement.isDone()?this.placement.setStale():(this.pauseablePlacement.continuePlacement(this._order,this._layers,s),this.pauseablePlacement.isDone()&&(this.placement=this.pauseablePlacement.commit(t.browser.now()),n=!0),a&&this.pauseablePlacement.placement.setStale()),n||a)for(var f=0,m=this._order;f<m.length;f+=1){var g=m[f],v=this._layers[g];"symbol"===v.type&&this.placement.updateLayerOpacities(v,s[v.source]);}return !this.pauseablePlacement.isDone()||this.placement.hasTransitions(t.browser.now())},i.prototype._releaseSymbolFadeTiles=function(){for(var t in this.sourceCaches)this.sourceCaches[t].releaseSymbolFadeTiles();},i.prototype.getImages=function(t,e,i){this.imageManager.getImages(e.icons,i);},i.prototype.getGlyphs=function(t,e,i){this.glyphManager.getGlyphs(e.stacks,i);},i.prototype.getResource=function(e,i,o){return t.makeRequest(i,o)},i}(t.Evented);Fe.getSourceType=function(t){return A[t]},Fe.setSourceType=function(t,e){A[t]=e;},Fe.registerForPluginAvailability=t.registerForPluginAvailability;var Ue=t.createLayout([{name:"a_pos",type:"Int16",components:2}]),Ne=hi("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif","#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"),Ze=hi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),Ve=hi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),qe=hi("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),je=hi("void main() {gl_FragColor=vec4(1.0);}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),Ge=hi("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),We=hi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),Xe=hi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}","attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),He=hi("uniform float u_overscale_factor;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main() {float alpha=0.5;vec4 color=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {color=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {color*=.2;}float extrude_scale_length=length(v_extrude_scale);float extrude_length=length(v_extrude)*extrude_scale_length;float stroke_width=15.0*extrude_scale_length/u_overscale_factor;float radius=v_radius*extrude_scale_length;float distance_to_edge=abs(extrude_length-radius);float opacity_t=smoothstep(-stroke_width,0.0,-distance_to_edge);gl_FragColor=opacity_t*color;}","attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);highp float padding_factor=1.2;gl_Position.xy+=a_extrude*u_extrude_scale*padding_factor*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;v_radius=abs(a_extrude.y);v_extrude=a_extrude*padding_factor;v_extrude_scale=u_extrude_scale*u_camera_to_center_distance*collision_perspective_ratio;}"),Ke=hi("uniform highp vec4 u_color;void main() {gl_FragColor=u_color;}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),Je=hi("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),Ye=hi("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),Qe=hi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec4 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),$e=hi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec4 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileZoomRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),ti=hi("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),ei=hi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec4 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),ii=hi("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform float u_maxzoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggeration=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/ pow(2.0,(u_zoom-u_maxzoom)*exaggeration+19.2562-u_zoom);gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),oi=hi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),ri=hi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),ai=hi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp float v_lineprogress;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,vec2(v_lineprogress,0.5));gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define MAX_LINE_DISTANCE 32767.0\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_lineprogress;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_lineprogress=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0/MAX_LINE_DISTANCE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),ni=hi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec4 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileZoomRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x,1.0);float x_b=mod(v_linesofar/pattern_size_b.x,1.0);float y_a=0.5+(v_normal.y*clamp(v_width2.s,0.0,(pattern_size_a.y+2.0)/2.0)/pattern_size_a.y);float y_b=0.5+(v_normal.y*clamp(v_width2.s,0.0,(pattern_size_b.y+2.0)/2.0)/pattern_size_b.y);vec2 pos_a=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,vec2(x_a,y_a));vec2 pos_b=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,vec2(x_b,y_b));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);}"),si=hi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),li=hi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),ci=hi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size[0],a_size[1],u_size_t)/256.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size[0]/256.0;} else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {size=u_size;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"),ui=hi("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size[0],a_size[1],u_size_t)/256.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size[0]/256.0;} else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {size=u_size;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=vec2(tex.x,tex.y);v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}");function hi(t,e){var i=/#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,o={};return {fragmentSource:t=t.replace(i,function(t,e,i,r,a){return o[a]=!0,"define"===e?"\n#ifndef HAS_UNIFORM_u_"+a+"\nvarying "+i+" "+r+" "+a+";\n#else\nuniform "+i+" "+r+" u_"+a+";\n#endif\n":"\n#ifdef HAS_UNIFORM_u_"+a+"\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n"}),vertexSource:e=e.replace(i,function(t,e,i,r,a){var n="float"===r?"vec2":"vec4",s=a.match(/color/)?"color":n;return o[a]?"define"===e?"\n#ifndef HAS_UNIFORM_u_"+a+"\nuniform lowp float u_"+a+"_t;\nattribute "+i+" "+n+" a_"+a+";\nvarying "+i+" "+r+" "+a+";\n#else\nuniform "+i+" "+r+" u_"+a+";\n#endif\n":"vec4"===s?"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+a+" = a_"+a+";\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n":"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+a+" = unpack_mix_"+s+"(a_"+a+", u_"+a+"_t);\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n":"define"===e?"\n#ifndef HAS_UNIFORM_u_"+a+"\nuniform lowp float u_"+a+"_t;\nattribute "+i+" "+n+" a_"+a+";\n#else\nuniform "+i+" "+r+" u_"+a+";\n#endif\n":"vec4"===s?"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+i+" "+r+" "+a+" = a_"+a+";\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n":"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+i+" "+r+" "+a+" = unpack_mix_"+s+"(a_"+a+", u_"+a+"_t);\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n"})}}var pi=Object.freeze({prelude:Ne,background:Ze,backgroundPattern:Ve,circle:qe,clippingMask:je,heatmap:Ge,heatmapTexture:We,collisionBox:Xe,collisionCircle:He,debug:Ke,fill:Je,fillOutline:Ye,fillOutlinePattern:Qe,fillPattern:$e,fillExtrusion:ti,fillExtrusionPattern:ei,hillshadePrepare:ii,hillshade:oi,line:ri,lineGradient:ai,linePattern:ni,lineSDF:si,raster:li,symbolIcon:ci,symbolSDF:ui}),di=function(){this.boundProgram=null,this.boundLayoutVertexBuffer=null,this.boundPaintVertexBuffers=[],this.boundIndexBuffer=null,this.boundVertexOffset=null,this.boundDynamicVertexBuffer=null,this.vao=null;};di.prototype.bind=function(t,e,i,o,r,a,n,s){this.context=t;for(var l=this.boundPaintVertexBuffers.length!==o.length,c=0;!l&&c<o.length;c++)this.boundPaintVertexBuffers[c]!==o[c]&&(l=!0);var u=!this.vao||this.boundProgram!==e||this.boundLayoutVertexBuffer!==i||l||this.boundIndexBuffer!==r||this.boundVertexOffset!==a||this.boundDynamicVertexBuffer!==n||this.boundDynamicVertexBuffer2!==s;!t.extVertexArrayObject||u?this.freshBind(e,i,o,r,a,n,s):(t.bindVertexArrayOES.set(this.vao),n&&n.bind(),r&&r.dynamicDraw&&r.bind(),s&&s.bind());},di.prototype.freshBind=function(t,e,i,o,r,a,n){var s,l=t.numAttributes,c=this.context,u=c.gl;if(c.extVertexArrayObject)this.vao&&this.destroy(),this.vao=c.extVertexArrayObject.createVertexArrayOES(),c.bindVertexArrayOES.set(this.vao),s=0,this.boundProgram=t,this.boundLayoutVertexBuffer=e,this.boundPaintVertexBuffers=i,this.boundIndexBuffer=o,this.boundVertexOffset=r,this.boundDynamicVertexBuffer=a,this.boundDynamicVertexBuffer2=n;else{s=c.currentNumAttributes||0;for(var h=l;h<s;h++)u.disableVertexAttribArray(h);}e.enableAttributes(u,t);for(var p=0,d=i;p<d.length;p+=1){d[p].enableAttributes(u,t);}a&&a.enableAttributes(u,t),n&&n.enableAttributes(u,t),e.bind(),e.setVertexAttribPointers(u,t,r);for(var _=0,f=i;_<f.length;_+=1){var m=f[_];m.bind(),m.setVertexAttribPointers(u,t,r);}a&&(a.bind(),a.setVertexAttribPointers(u,t,r)),o&&o.bind(),n&&(n.bind(),n.setVertexAttribPointers(u,t,r)),c.currentNumAttributes=l;},di.prototype.destroy=function(){this.vao&&(this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),this.vao=null);};var _i=function(t,e,i,o,r){var a=t.gl;this.program=a.createProgram();var n=i.defines();r&&n.push("#define OVERDRAW_INSPECTOR;");var s=n.concat(Ne.fragmentSource,e.fragmentSource).join("\n"),l=n.concat(Ne.vertexSource,e.vertexSource).join("\n"),c=a.createShader(a.FRAGMENT_SHADER);a.shaderSource(c,s),a.compileShader(c),a.attachShader(this.program,c);var u=a.createShader(a.VERTEX_SHADER);a.shaderSource(u,l),a.compileShader(u),a.attachShader(this.program,u);for(var h=i.layoutAttributes||[],p=0;p<h.length;p++)a.bindAttribLocation(this.program,p,h[p].name);a.linkProgram(this.program),this.numAttributes=a.getProgramParameter(this.program,a.ACTIVE_ATTRIBUTES),this.attributes={};for(var d={},_=0;_<this.numAttributes;_++){var f=a.getActiveAttrib(this.program,_);f&&(this.attributes[f.name]=a.getAttribLocation(this.program,f.name));}for(var m=a.getProgramParameter(this.program,a.ACTIVE_UNIFORMS),g=0;g<m;g++){var v=a.getActiveUniform(this.program,g);v&&(d[v.name]=a.getUniformLocation(this.program,v.name));}this.fixedUniforms=o(t,d),this.binderUniforms=i.getUniforms(t,d);};function fi(e,i,o){var r=1/ue(o,1,i.transform.tileZoom),a=Math.pow(2,o.tileID.overscaledZ),n=o.tileSize*Math.pow(2,i.transform.tileZoom)/a,s=n*(o.tileID.canonical.x+o.tileID.wrap*a),l=n*o.tileID.canonical.y;return {u_image:0,u_texsize:o.imageAtlasTexture.size,u_scale:[t.browser.devicePixelRatio,r,e.fromScale,e.toScale],u_fade:e.t,u_pixel_coord_upper:[s>>16,l>>16],u_pixel_coord_lower:[65535&s,65535&l]}}_i.prototype.draw=function(t,e,i,o,r,a,n,s,l,c,u,h,p,d,_,f){var m,g=t.gl;for(var v in t.program.set(this.program),t.setDepthMode(i),t.setStencilMode(o),t.setColorMode(r),t.setCullFace(a),this.fixedUniforms)this.fixedUniforms[v].set(n[v]);d&&d.setUniforms(t,this.binderUniforms,h,{zoom:p});for(var y=(m={},m[g.LINES]=2,m[g.TRIANGLES]=3,m[g.LINE_STRIP]=1,m)[e],x=0,b=u.get();x<b.length;x+=1){var w=b[x],E=w.vaos||(w.vaos={});(E[s]||(E[s]=new di)).bind(t,this,l,d?d.getPaintVertexBuffers():[],c,w.vertexOffset,_,f),g.drawElements(e,w.primitiveLength*y,g.UNSIGNED_SHORT,w.primitiveOffset*y*2);}};var mi=function(e,i,o,r){var a=i.style.light,n=a.properties.get("position"),s=[n.x,n.y,n.z],l=t.create$1();"viewport"===a.properties.get("anchor")&&t.fromRotation(l,-i.transform.angle),t.transformMat3(s,s,l);var c=a.properties.get("color");return {u_matrix:e,u_lightpos:s,u_lightintensity:a.properties.get("intensity"),u_lightcolor:[c.r,c.g,c.b],u_vertical_gradient:+o,u_opacity:r}},gi=function(e,i,o,r,a,n,s){return t.extend(mi(e,i,o,r),fi(n,i,s),{u_height_factor:-Math.pow(2,a.overscaledZ)/s.tileSize/8})},vi=function(t){return {u_matrix:t}},yi=function(e,i,o,r){return t.extend(vi(e),fi(o,i,r))},xi=function(t,e){return {u_matrix:t,u_world:e}},bi=function(e,i,o,r,a){return t.extend(yi(e,i,o,r),{u_world:a})},wi=function(e,i,o,r){var a,n,s=e.transform;if("map"===r.paint.get("circle-pitch-alignment")){var l=ue(o,1,s.zoom);a=!0,n=[l,l];}else a=!1,n=s.pixelsToGLUnits;return {u_camera_to_center_distance:s.cameraToCenterDistance,u_scale_with_map:+("map"===r.paint.get("circle-pitch-scale")),u_matrix:e.translatePosMatrix(i.posMatrix,o,r.paint.get("circle-translate"),r.paint.get("circle-translate-anchor")),u_pitch_with_map:+a,u_device_pixel_ratio:t.browser.devicePixelRatio,u_extrude_scale:n}},Ei=function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pixels_to_tile_units:new t.Uniform1f(e,i.u_pixels_to_tile_units),u_extrude_scale:new t.Uniform2f(e,i.u_extrude_scale),u_overscale_factor:new t.Uniform1f(e,i.u_overscale_factor)}},Ti=function(t,e,i){var o=ue(i,1,e.zoom),r=Math.pow(2,e.zoom-i.tileID.overscaledZ),a=i.tileID.overscaleFactor();return {u_matrix:t,u_camera_to_center_distance:e.cameraToCenterDistance,u_pixels_to_tile_units:o,u_extrude_scale:[e.pixelsToGLUnits[0]/(o*r),e.pixelsToGLUnits[1]/(o*r)],u_overscale_factor:a}},Ii=function(t,e){return {u_matrix:t,u_color:e}},Ci=function(t){return {u_matrix:t}},Si=function(t,e,i,o){return {u_matrix:t,u_extrude_scale:ue(e,1,i),u_intensity:o}},Pi=function(e,i,o,r){var a=t.create();t.ortho(a,0,e.width,e.height,0,0,1);var n=e.context.gl;return {u_matrix:a,u_world:[n.drawingBufferWidth,n.drawingBufferHeight],u_image:o,u_color_ramp:r,u_opacity:i.paint.get("heatmap-opacity")}},zi=function(t,e,i){var o=i.paint.get("hillshade-shadow-color"),r=i.paint.get("hillshade-highlight-color"),a=i.paint.get("hillshade-accent-color"),n=i.paint.get("hillshade-illumination-direction")*(Math.PI/180);"viewport"===i.paint.get("hillshade-illumination-anchor")&&(n-=t.transform.angle);var s=!t.options.moving;return {u_matrix:t.transform.calculatePosMatrix(e.tileID.toUnwrapped(),s),u_image:0,u_latrange:Di(t,e.tileID),u_light:[i.paint.get("hillshade-exaggeration"),n],u_shadow:o,u_highlight:r,u_accent:a}},Li=function(e,i,o){var r=i.stride,a=t.create();return t.ortho(a,0,t.EXTENT,-t.EXTENT,0,0,1),t.translate(a,a,[0,-t.EXTENT,0]),{u_matrix:a,u_image:1,u_dimension:[r,r],u_zoom:e.overscaledZ,u_maxzoom:o,u_unpack:i.getUnpackVector()}};function Di(e,i){var o=Math.pow(2,i.canonical.z),r=i.canonical.y;return [new t.MercatorCoordinate(0,r/o).toLngLat().lat,new t.MercatorCoordinate(0,(r+1)/o).toLngLat().lat]}var Mi=function(e,i,o){var r=e.transform;return {u_matrix:Oi(e,i,o),u_ratio:1/ue(i,1,r.zoom),u_device_pixel_ratio:t.browser.devicePixelRatio,u_units_to_pixels:[1/r.pixelsToGLUnits[0],1/r.pixelsToGLUnits[1]]}},Ri=function(e,i,o){return t.extend(Mi(e,i,o),{u_image:0})},Ai=function(e,i,o,r){var a=e.transform,n=Bi(i,a);return {u_matrix:Oi(e,i,o),u_texsize:i.imageAtlasTexture.size,u_ratio:1/ue(i,1,a.zoom),u_device_pixel_ratio:t.browser.devicePixelRatio,u_image:0,u_scale:[t.browser.devicePixelRatio,n,r.fromScale,r.toScale],u_fade:r.t,u_units_to_pixels:[1/a.pixelsToGLUnits[0],1/a.pixelsToGLUnits[1]]}},ki=function(e,i,o,r,a){var n=e.transform,s=e.lineAtlas,l=Bi(i,n),c="round"===o.layout.get("line-cap"),u=s.getDash(r.from,c),h=s.getDash(r.to,c),p=u.width*a.fromScale,d=h.width*a.toScale;return t.extend(Mi(e,i,o),{u_patternscale_a:[l/p,-u.height/2],u_patternscale_b:[l/d,-h.height/2],u_sdfgamma:s.width/(256*Math.min(p,d)*t.browser.devicePixelRatio)/2,u_image:0,u_tex_y_a:u.y,u_tex_y_b:h.y,u_mix:a.t})};function Bi(t,e){return 1/ue(t,1,e.tileZoom)}function Oi(t,e,i){return t.translatePosMatrix(e.tileID.posMatrix,e,i.paint.get("line-translate"),i.paint.get("line-translate-anchor"))}var Fi=function(t,e,i,o,r){return {u_matrix:t,u_tl_parent:e,u_scale_parent:i,u_buffer_scale:1,u_fade_t:o.mix,u_opacity:o.opacity*r.paint.get("raster-opacity"),u_image0:0,u_image1:1,u_brightness_low:r.paint.get("raster-brightness-min"),u_brightness_high:r.paint.get("raster-brightness-max"),u_saturation_factor:(n=r.paint.get("raster-saturation"),n>0?1-1/(1.001-n):-n),u_contrast_factor:(a=r.paint.get("raster-contrast"),a>0?1/(1-a):1+a),u_spin_weights:Ui(r.paint.get("raster-hue-rotate"))};var a,n;};function Ui(t){t*=Math.PI/180;var e=Math.sin(t),i=Math.cos(t);return [(2*i+1)/3,(-Math.sqrt(3)*e-i+1)/3,(Math.sqrt(3)*e-i+1)/3]}var Ni=function(t,e,i,o,r,a,n,s,l,c){var u=r.transform;return {u_is_size_zoom_constant:+("constant"===t||"source"===t),u_is_size_feature_constant:+("constant"===t||"camera"===t),u_size_t:e?e.uSizeT:0,u_size:e?e.uSize:0,u_camera_to_center_distance:u.cameraToCenterDistance,u_pitch:u.pitch/360*2*Math.PI,u_rotate_symbol:+i,u_aspect_ratio:u.width/u.height,u_fade_change:r.options.fadeDuration?r.symbolFadeChange:1,u_matrix:a,u_label_plane_matrix:n,u_coord_matrix:s,u_is_text:+l,u_pitch_with_map:+o,u_texsize:c,u_texture:0}},Zi=function(e,i,o,r,a,n,s,l,c,u,h){var p=a.transform;return t.extend(Ni(e,i,o,r,a,n,s,l,c,u),{u_gamma_scale:r?Math.cos(p._pitch)*p.cameraToCenterDistance:1,u_device_pixel_ratio:t.browser.devicePixelRatio,u_is_halo:+h})},Vi=function(t,e,i){return {u_matrix:t,u_opacity:e,u_color:i}},qi=function(e,i,o,r,a,n){return t.extend(function(t,e,i,o){var r=i.imageManager.getPattern(t.from.toString()),a=i.imageManager.getPattern(t.to.toString()),n=i.imageManager.getPixelSize(),s=n.width,l=n.height,c=Math.pow(2,o.tileID.overscaledZ),u=o.tileSize*Math.pow(2,i.transform.tileZoom)/c,h=u*(o.tileID.canonical.x+o.tileID.wrap*c),p=u*o.tileID.canonical.y;return {u_image:0,u_pattern_tl_a:r.tl,u_pattern_br_a:r.br,u_pattern_tl_b:a.tl,u_pattern_br_b:a.br,u_texsize:[s,l],u_mix:e.t,u_pattern_size_a:r.displaySize,u_pattern_size_b:a.displaySize,u_scale_a:e.fromScale,u_scale_b:e.toScale,u_tile_units_to_pixels:1/ue(o,1,i.transform.tileZoom),u_pixel_coord_upper:[h>>16,p>>16],u_pixel_coord_lower:[65535&h,65535&p]}}(r,n,o,a),{u_matrix:e,u_opacity:i})},ji={fillExtrusion:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_lightpos:new t.Uniform3f(e,i.u_lightpos),u_lightintensity:new t.Uniform1f(e,i.u_lightintensity),u_lightcolor:new t.Uniform3f(e,i.u_lightcolor),u_vertical_gradient:new t.Uniform1f(e,i.u_vertical_gradient),u_opacity:new t.Uniform1f(e,i.u_opacity)}},fillExtrusionPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_lightpos:new t.Uniform3f(e,i.u_lightpos),u_lightintensity:new t.Uniform1f(e,i.u_lightintensity),u_lightcolor:new t.Uniform3f(e,i.u_lightcolor),u_vertical_gradient:new t.Uniform1f(e,i.u_vertical_gradient),u_height_factor:new t.Uniform1f(e,i.u_height_factor),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform4f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade),u_opacity:new t.Uniform1f(e,i.u_opacity)}},fill:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},fillPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform4f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},fillOutline:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world)}},fillOutlinePattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform4f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},circle:function(e,i){return {u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_scale_with_map:new t.Uniform1i(e,i.u_scale_with_map),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_extrude_scale:new t.Uniform2f(e,i.u_extrude_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},collisionBox:Ei,collisionCircle:Ei,debug:function(e,i){return {u_color:new t.UniformColor(e,i.u_color),u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},clippingMask:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},heatmap:function(e,i){return {u_extrude_scale:new t.Uniform1f(e,i.u_extrude_scale),u_intensity:new t.Uniform1f(e,i.u_intensity),u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},heatmapTexture:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world),u_image:new t.Uniform1i(e,i.u_image),u_color_ramp:new t.Uniform1i(e,i.u_color_ramp),u_opacity:new t.Uniform1f(e,i.u_opacity)}},hillshade:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_latrange:new t.Uniform2f(e,i.u_latrange),u_light:new t.Uniform2f(e,i.u_light),u_shadow:new t.UniformColor(e,i.u_shadow),u_highlight:new t.UniformColor(e,i.u_highlight),u_accent:new t.UniformColor(e,i.u_accent)}},hillshadePrepare:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_dimension:new t.Uniform2f(e,i.u_dimension),u_zoom:new t.Uniform1f(e,i.u_zoom),u_maxzoom:new t.Uniform1f(e,i.u_maxzoom),u_unpack:new t.Uniform4f(e,i.u_unpack)}},line:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels)}},lineGradient:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_image:new t.Uniform1i(e,i.u_image)}},linePattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_texsize:new t.Uniform2f(e,i.u_texsize),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_image:new t.Uniform1i(e,i.u_image),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_scale:new t.Uniform4f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},lineSDF:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_patternscale_a:new t.Uniform2f(e,i.u_patternscale_a),u_patternscale_b:new t.Uniform2f(e,i.u_patternscale_b),u_sdfgamma:new t.Uniform1f(e,i.u_sdfgamma),u_image:new t.Uniform1i(e,i.u_image),u_tex_y_a:new t.Uniform1f(e,i.u_tex_y_a),u_tex_y_b:new t.Uniform1f(e,i.u_tex_y_b),u_mix:new t.Uniform1f(e,i.u_mix)}},raster:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_tl_parent:new t.Uniform2f(e,i.u_tl_parent),u_scale_parent:new t.Uniform1f(e,i.u_scale_parent),u_buffer_scale:new t.Uniform1f(e,i.u_buffer_scale),u_fade_t:new t.Uniform1f(e,i.u_fade_t),u_opacity:new t.Uniform1f(e,i.u_opacity),u_image0:new t.Uniform1i(e,i.u_image0),u_image1:new t.Uniform1i(e,i.u_image1),u_brightness_low:new t.Uniform1f(e,i.u_brightness_low),u_brightness_high:new t.Uniform1f(e,i.u_brightness_high),u_saturation_factor:new t.Uniform1f(e,i.u_saturation_factor),u_contrast_factor:new t.Uniform1f(e,i.u_contrast_factor),u_spin_weights:new t.Uniform3f(e,i.u_spin_weights)}},symbolIcon:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1f(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texture:new t.Uniform1i(e,i.u_texture)}},symbolSDF:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1f(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texture:new t.Uniform1i(e,i.u_texture),u_gamma_scale:new t.Uniform1f(e,i.u_gamma_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_is_halo:new t.Uniform1f(e,i.u_is_halo)}},background:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_opacity:new t.Uniform1f(e,i.u_opacity),u_color:new t.UniformColor(e,i.u_color)}},backgroundPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_opacity:new t.Uniform1f(e,i.u_opacity),u_image:new t.Uniform1i(e,i.u_image),u_pattern_tl_a:new t.Uniform2f(e,i.u_pattern_tl_a),u_pattern_br_a:new t.Uniform2f(e,i.u_pattern_br_a),u_pattern_tl_b:new t.Uniform2f(e,i.u_pattern_tl_b),u_pattern_br_b:new t.Uniform2f(e,i.u_pattern_br_b),u_texsize:new t.Uniform2f(e,i.u_texsize),u_mix:new t.Uniform1f(e,i.u_mix),u_pattern_size_a:new t.Uniform2f(e,i.u_pattern_size_a),u_pattern_size_b:new t.Uniform2f(e,i.u_pattern_size_b),u_scale_a:new t.Uniform1f(e,i.u_scale_a),u_scale_b:new t.Uniform1f(e,i.u_scale_b),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_tile_units_to_pixels:new t.Uniform1f(e,i.u_tile_units_to_pixels)}}};function Gi(e,i){for(var o=e.sort(function(t,e){return t.tileID.isLessThan(e.tileID)?-1:e.tileID.isLessThan(t.tileID)?1:0}),r=0;r<o.length;r++){var a={},n=o[r],s=o.slice(r+1);Wi(n.tileID.wrapped(),n.tileID,s,new t.OverscaledTileID(0,n.tileID.wrap+1,0,0,0),a),n.setMask(a,i);}}function Wi(e,i,o,r,a){for(var n=0;n<o.length;n++){var s=o[n];if(r.isLessThan(s.tileID))break;if(i.key===s.tileID.key)return;if(s.tileID.isChildOf(i)){for(var l=i.children(1/0),c=0;c<l.length;c++){Wi(e,l[c],o.slice(n),r,a);}return}}var u=i.overscaledZ-e.overscaledZ,h=new t.CanonicalTileID(u,i.canonical.x-(e.canonical.x<<u),i.canonical.y-(e.canonical.y<<u));a[h.key]=a[h.key]||h;}function Xi(t,e,i,o,r,a,n,s){for(var l=t.context,c=l.gl,u=r?t.useProgram("collisionCircle"):t.useProgram("collisionBox"),h=0;h<o.length;h++){var p=o[h],d=e.getTile(p),_=d.getBucket(i);if(_){var f=r?s?_.textCollisionCircle:_.iconCollisionCircle:s?_.textCollisionBox:_.iconCollisionBox;if(f){var m=p.posMatrix;0===a[0]&&0===a[1]||(m=t.translatePosMatrix(p.posMatrix,d,a,n)),u.draw(l,r?c.TRIANGLES:c.LINES,It.disabled,Ct.disabled,t.colorModeForRenderPass(),Pt.disabled,Ti(m,t.transform,d),i.id,f.layoutVertexBuffer,f.indexBuffer,f.segments,null,t.transform.zoom,null,null,f.collisionVertexBuffer);}}}}function Hi(t,e,i,o,r,a,n){Xi(t,e,i,o,!1,r,a,n),Xi(t,e,i,o,!0,r,a,n);}var Ki=t.identity(new Float32Array(16));function Ji(e,i,o,r,a,n){var s=t.getAnchorAlignment(e),l=-(s.horizontalAlign-.5)*i,c=-(s.verticalAlign-.5)*o,u=t.evaluateVariableOffset(e,r);return new t.Point((l/a+u[0])*n,(c/a+u[1])*n)}function Yi(e,i,o,r,a,n,s,l,c,u,h){var p=e.text.placedSymbolArray,d=e.text.dynamicLayoutVertexArray,_=e.icon.dynamicLayoutVertexArray,f={};d.clear();for(var m=0;m<p.length;m++){var g=p.get(m),v=e.allowVerticalPlacement&&!g.placedOrientation,y=g.hidden||!g.crossTileID||v?null:r[g.crossTileID];if(y){var x=new t.Point(g.anchorX,g.anchorY),b=Yt(x,o?l:s),w=.5+n.cameraToCenterDistance/b.signedDistanceFromCamera*.5,E=a.evaluateSizeForFeature(e.textSizeData,u,g)*w/t.ONE_EM;o&&(E*=e.tilePixelRatio/c);for(var T=y.width,I=y.height,C=Ji(y.anchor,T,I,y.textOffset,y.textBoxScale,E),S=o?Yt(x.add(C),s).point:b.point.add(i?C.rotate(-n.angle):C),P=e.allowVerticalPlacement&&g.placedOrientation===t.WritingMode.vertical?Math.PI/2:0,z=0;z<g.numGlyphs;z++)t.addDynamicAttributes(d,S,P);h&&g.associatedIconIndex>=0&&(f[g.associatedIconIndex]={shiftedAnchor:S,angle:P});}else ne(g.numGlyphs,d);}if(h){_.clear();for(var L=e.icon.placedSymbolArray,D=0;D<L.length;D++){var M=L.get(D);if(M.hidden)ne(M.numGlyphs,_);else{var R=f[D];if(R)for(var A=0;A<M.numGlyphs;A++)t.addDynamicAttributes(_,R.shiftedAnchor,R.angle);else ne(M.numGlyphs,_);}}e.icon.dynamicLayoutVertexBuffer.updateData(_);}e.text.dynamicLayoutVertexBuffer.updateData(d);}function Qi(e){var i=e.text.placedSymbolArray,o=e.text.dynamicLayoutVertexArray;o.clear();for(var r=0;r<i.length;r++){var a=i.get(r);if(a.hidden||!a.placedOrientation)ne(a.numGlyphs,o);else for(var n=new t.Point(a.anchorX,a.anchorY),s=e.allowVerticalPlacement&&a.placedOrientation===t.WritingMode.vertical?Math.PI/2:0,l=0;l<a.numGlyphs;l++)t.addDynamicAttributes(o,n,s);}e.text.dynamicLayoutVertexBuffer.updateData(o);}function $i(e,i,o,r,a,n,s,l,c,u,h,p){for(var d,_,f=e.context,m=f.gl,g=e.transform,v="map"===l,y="map"===c,x=v&&"point"!==o.layout.get("symbol-placement"),b=v&&!y&&!x,w=void 0!==o.layout.get("symbol-sort-key").constantOr(1),E=e.depthModeForSublayer(0,It.ReadOnly),T=o.layout.get("text-variable-anchor"),I=[],C=0,S=r;C<S.length;C+=1){var P=S[C],z=i.getTile(P),L=z.getBucket(o);if(L){var D=a?L.text:L.icon;if(D&&D.segments.get().length){var M=D.programConfigurations.get(o.id),R=a||L.sdfIcons,A=a?L.textSizeData:L.iconSizeData;d||(d=e.useProgram(R?"symbolSDF":"symbolIcon",M),_=t.evaluateSizeForZoom(A,g.zoom)),f.activeTexture.set(m.TEXTURE0);var k=void 0,B=void 0,O=void 0;if(a)B=z.glyphAtlasTexture,O=m.LINEAR,k=z.glyphAtlasTexture.size;else{var F=1!==o.layout.get("icon-size").constantOr(0)||L.iconsNeedLinear,U=y||0!==g.pitch;B=z.imageAtlasTexture,O=R||e.options.rotating||e.options.zooming||F||U?m.LINEAR:m.NEAREST,k=z.imageAtlasTexture.size;}var N=ue(z,1,e.transform.zoom),Z=Kt(P.posMatrix,y,v,e.transform,N),V=Jt(P.posMatrix,y,v,e.transform,N),q=T&&L.hasTextData(),j="none"!==o.layout.get("icon-text-fit")&&q&&L.hasIconData();x?$t(L,P.posMatrix,e,a,Z,V,y,u):a&&_&&L.allowVerticalPlacement&&!T&&Qi(L);var G=e.translatePosMatrix(P.posMatrix,z,n,s),W=x||a&&T||j?Ki:Z,X=e.translatePosMatrix(V,z,n,s,!0),H=R&&0!==o.paint.get(a?"text-halo-width":"icon-halo-width").constantOr(1),K={program:d,buffers:D,uniformValues:R?Zi(A.kind,_,b,y,e,G,W,X,a,k,!0):Ni(A.kind,_,b,y,e,G,W,X,a,k),atlasTexture:B,atlasInterpolation:O,isSDF:R,hasHalo:H};if(w)for(var J=0,Y=D.segments.get();J<Y.length;J+=1){var Q=Y[J];I.push({segments:new t.SegmentVector([Q]),sortKey:Q.sortKey,state:K});}else I.push({segments:D.segments,sortKey:0,state:K});}}}w&&I.sort(function(t,e){return t.sortKey-e.sortKey});for(var $=0,tt=I;$<tt.length;$+=1){var et=tt[$],it=et.state;if(it.atlasTexture.bind(it.atlasInterpolation,m.CLAMP_TO_EDGE),it.isSDF){var ot=it.uniformValues;it.hasHalo&&(ot.u_is_halo=1,to(it.buffers,et.segments,o,e,it.program,E,h,p,ot)),ot.u_is_halo=0;}to(it.buffers,et.segments,o,e,it.program,E,h,p,it.uniformValues);}}function to(t,e,i,o,r,a,n,s,l){var c=o.context,u=c.gl;r.draw(c,u.TRIANGLES,a,n,s,Pt.disabled,l,i.id,t.layoutVertexBuffer,t.indexBuffer,e,i.paint,o.transform.zoom,t.programConfigurations.get(i.id),t.dynamicLayoutVertexBuffer,t.opacityVertexBuffer);}function eo(t,e,i,o,r,a,n){var s,l,c,u,h,p=t.context.gl,d=i.paint.get("fill-pattern"),_=d&&d.constantOr(1),f=i.getCrossfadeParameters();n?(l=_&&!i.getPaintProperty("fill-outline-color")?"fillOutlinePattern":"fillOutline",s=p.LINES):(l=_?"fillPattern":"fill",s=p.TRIANGLES);for(var m=0,g=o;m<g.length;m+=1){var v=g[m],y=e.getTile(v);if(!_||y.patternsLoaded()){var x=y.getBucket(i);if(x){var b=x.programConfigurations.get(i.id),w=t.useProgram(l,b);_&&(t.context.activeTexture.set(p.TEXTURE0),y.imageAtlasTexture.bind(p.LINEAR,p.CLAMP_TO_EDGE),b.updatePatternPaintBuffers(f));var E=d.constantOr(null);if(E&&y.imageAtlas){var T=y.imageAtlas,I=T.patternPositions[E.to.toString()],C=T.patternPositions[E.from.toString()];I&&C&&b.setConstantPatternPositions(I,C);}var S=t.translatePosMatrix(v.posMatrix,y,i.paint.get("fill-translate"),i.paint.get("fill-translate-anchor"));if(n){u=x.indexBuffer2,h=x.segments2;var P=[p.drawingBufferWidth,p.drawingBufferHeight];c="fillOutlinePattern"===l&&_?bi(S,t,f,y,P):xi(S,P);}else u=x.indexBuffer,h=x.segments,c=_?yi(S,t,f,y):vi(S);w.draw(t.context,s,r,t.stencilModeForClipping(v),a,Pt.disabled,c,i.id,x.layoutVertexBuffer,u,h,i.paint,t.transform.zoom,b);}}}}function io(t,e,i,o,r,a,n){for(var s=t.context,l=s.gl,c=i.paint.get("fill-extrusion-pattern"),u=c.constantOr(1),h=i.getCrossfadeParameters(),p=i.paint.get("fill-extrusion-opacity"),d=0,_=o;d<_.length;d+=1){var f=_[d],m=e.getTile(f),g=m.getBucket(i);if(g){var v=g.programConfigurations.get(i.id),y=t.useProgram(u?"fillExtrusionPattern":"fillExtrusion",v);u&&(t.context.activeTexture.set(l.TEXTURE0),m.imageAtlasTexture.bind(l.LINEAR,l.CLAMP_TO_EDGE),v.updatePatternPaintBuffers(h));var x=c.constantOr(null);if(x&&m.imageAtlas){var b=m.imageAtlas,w=b.patternPositions[x.to.toString()],E=b.patternPositions[x.from.toString()];w&&E&&v.setConstantPatternPositions(w,E);}var T=t.translatePosMatrix(f.posMatrix,m,i.paint.get("fill-extrusion-translate"),i.paint.get("fill-extrusion-translate-anchor")),I=i.paint.get("fill-extrusion-vertical-gradient"),C=u?gi(T,t,I,p,f,h,m):mi(T,t,I,p);y.draw(s,s.gl.TRIANGLES,r,a,n,Pt.backCCW,C,i.id,g.layoutVertexBuffer,g.indexBuffer,g.segments,i.paint,t.transform.zoom,v);}}}function oo(t,e,i,o,r,a){var n=t.context,s=n.gl,l=e.fbo;if(l){var c=t.useProgram("hillshade");n.activeTexture.set(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,l.colorAttachment.get());var u=zi(t,e,i);e.maskedBoundsBuffer&&e.maskedIndexBuffer&&e.segments?c.draw(n,s.TRIANGLES,o,r,a,Pt.disabled,u,i.id,e.maskedBoundsBuffer,e.maskedIndexBuffer,e.segments):c.draw(n,s.TRIANGLES,o,r,a,Pt.disabled,u,i.id,t.rasterBoundsBuffer,t.quadTriangleIndexBuffer,t.rasterBoundsSegments);}}function ro(e,i,o,r,a,n,s){var l=e.context,c=l.gl,u=i.dem;if(u&&u.data){var h=u.dim,p=u.stride,d=u.getPixels();if(l.activeTexture.set(c.TEXTURE1),l.pixelStoreUnpackPremultiplyAlpha.set(!1),i.demTexture=i.demTexture||e.getTileTexture(p),i.demTexture){var _=i.demTexture;_.update(d,{premultiply:!1}),_.bind(c.NEAREST,c.CLAMP_TO_EDGE);}else i.demTexture=new t.Texture(l,d,c.RGBA,{premultiply:!1}),i.demTexture.bind(c.NEAREST,c.CLAMP_TO_EDGE);l.activeTexture.set(c.TEXTURE0);var f=i.fbo;if(!f){var m=new t.Texture(l,{width:h,height:h,data:null},c.RGBA);m.bind(c.LINEAR,c.CLAMP_TO_EDGE),(f=i.fbo=l.createFramebuffer(h,h)).colorAttachment.set(m.texture);}l.bindFramebuffer.set(f.framebuffer),l.viewport.set([0,0,h,h]),e.useProgram("hillshadePrepare").draw(l,c.TRIANGLES,a,n,s,Pt.disabled,Li(i.tileID,u,r),o.id,e.rasterBoundsBuffer,e.quadTriangleIndexBuffer,e.rasterBoundsSegments),i.needsHillshadePrepare=!1;}}function ao(e,i,o,r,a){var n=r.paint.get("raster-fade-duration");if(n>0){var s=t.browser.now(),l=(s-e.timeAdded)/n,c=i?(s-i.timeAdded)/n:-1,u=o.getSource(),h=a.coveringZoomLevel({tileSize:u.tileSize,roundZoom:u.roundZoom}),p=!i||Math.abs(i.tileID.overscaledZ-h)>Math.abs(e.tileID.overscaledZ-h),d=p&&e.refreshedUponExpiration?1:t.clamp(p?l:1-c,0,1);return e.refreshedUponExpiration&&l>=1&&(e.refreshedUponExpiration=!1),i?{opacity:1,mix:1-d}:{opacity:d,mix:0}}return {opacity:1,mix:0}}function no(e,i,o){var r=e.context,a=r.gl,n=o.posMatrix,s=e.useProgram("debug"),l=It.disabled,c=Ct.disabled,u=e.colorModeForRenderPass(),h="$debug";s.draw(r,a.LINE_STRIP,l,c,u,Pt.disabled,Ii(n,t.Color.red),h,e.debugBuffer,e.tileBorderIndexBuffer,e.debugSegments);for(var p=i.getTileByID(o.key).latestRawTileData,d=p&&p.byteLength||0,_=Math.floor(d/1024),f=i.getTile(o).tileSize,m=512/Math.min(f,512),g=function(t,e,i,o){o=o||1;var r,a,n,s,l,c,u,h,p=[];for(r=0,a=t.length;r<a;r++)if(l=so[t[r]]){for(h=null,n=0,s=l[1].length;n<s;n+=2)-1===l[1][n]&&-1===l[1][n+1]?h=null:(c=e+l[1][n]*o,u=i-l[1][n+1]*o,h&&p.push(h.x,h.y,c,u),h={x:c,y:u});e+=l[0]*o;}return p}(o.toString()+" "+_+"kb",50,200*m,5*m),v=new t.StructArrayLayout2i4,y=new t.StructArrayLayout2ui4,x=0;x<g.length;x+=2)v.emplaceBack(g[x],g[x+1]),y.emplaceBack(x,x+1);for(var b=r.createVertexBuffer(v,Ue.members),w=r.createIndexBuffer(y),E=t.SegmentVector.simpleSegment(0,0,v.length/2,v.length/2),T=t.EXTENT/(Math.pow(2,e.transform.zoom-o.overscaledZ)*f*m),I=[],C=-1;C<=1;C++)for(var S=-1;S<=1&&(0!==C||0!==S);S++)I.push([C,S]);for(var P=0;P<I.length;P++){var z=I[P];s.draw(r,a.LINES,l,c,u,Pt.disabled,Ii(t.translate([],n,[T*z[0],T*z[1],0]),t.Color.white),h,b,w,E);}s.draw(r,a.LINES,l,c,u,Pt.disabled,Ii(n,t.Color.black),h,b,w,E);}var so={" ":[16,[]],"!":[10,[5,21,5,7,-1,-1,5,2,4,1,5,0,6,1,5,2]],'"':[16,[4,21,4,14,-1,-1,12,21,12,14]],"#":[21,[11,25,4,-7,-1,-1,17,25,10,-7,-1,-1,4,12,18,12,-1,-1,3,6,17,6]],$:[20,[8,25,8,-4,-1,-1,12,25,12,-4,-1,-1,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3]],"%":[24,[21,21,3,0,-1,-1,8,21,10,19,10,17,9,15,7,14,5,14,3,16,3,18,4,20,6,21,8,21,10,20,13,19,16,19,19,20,21,21,-1,-1,17,7,15,6,14,4,14,2,16,0,18,0,20,1,21,3,21,5,19,7,17,7]],"&":[26,[23,12,23,13,22,14,21,14,20,13,19,11,17,6,15,3,13,1,11,0,7,0,5,1,4,2,3,4,3,6,4,8,5,9,12,13,13,14,14,16,14,18,13,20,11,21,9,20,8,18,8,16,9,13,11,10,16,3,18,1,20,0,22,0,23,1,23,2]],"'":[10,[5,19,4,20,5,21,6,20,6,18,5,16,4,15]],"(":[14,[11,25,9,23,7,20,5,16,4,11,4,7,5,2,7,-2,9,-5,11,-7]],")":[14,[3,25,5,23,7,20,9,16,10,11,10,7,9,2,7,-2,5,-5,3,-7]],"*":[16,[8,21,8,9,-1,-1,3,18,13,12,-1,-1,13,18,3,12]],"+":[26,[13,18,13,0,-1,-1,4,9,22,9]],",":[10,[6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4]],"-":[26,[4,9,22,9]],".":[10,[5,2,4,1,5,0,6,1,5,2]],"/":[22,[20,25,2,-7]],0:[20,[9,21,6,20,4,17,3,12,3,9,4,4,6,1,9,0,11,0,14,1,16,4,17,9,17,12,16,17,14,20,11,21,9,21]],1:[20,[6,17,8,18,11,21,11,0]],2:[20,[4,16,4,17,5,19,6,20,8,21,12,21,14,20,15,19,16,17,16,15,15,13,13,10,3,0,17,0]],3:[20,[5,21,16,21,10,13,13,13,15,12,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4]],4:[20,[13,21,3,7,18,7,-1,-1,13,21,13,0]],5:[20,[15,21,5,21,4,12,5,13,8,14,11,14,14,13,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4]],6:[20,[16,18,15,20,12,21,10,21,7,20,5,17,4,12,4,7,5,3,7,1,10,0,11,0,14,1,16,3,17,6,17,7,16,10,14,12,11,13,10,13,7,12,5,10,4,7]],7:[20,[17,21,7,0,-1,-1,3,21,17,21]],8:[20,[8,21,5,20,4,18,4,16,5,14,7,13,11,12,14,11,16,9,17,7,17,4,16,2,15,1,12,0,8,0,5,1,4,2,3,4,3,7,4,9,6,11,9,12,13,13,15,14,16,16,16,18,15,20,12,21,8,21]],9:[20,[16,14,15,11,13,9,10,8,9,8,6,9,4,11,3,14,3,15,4,18,6,20,9,21,10,21,13,20,15,18,16,14,16,9,15,4,13,1,10,0,8,0,5,1,4,3]],":":[10,[5,14,4,13,5,12,6,13,5,14,-1,-1,5,2,4,1,5,0,6,1,5,2]],";":[10,[5,14,4,13,5,12,6,13,5,14,-1,-1,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4]],"<":[24,[20,18,4,9,20,0]],"=":[26,[4,12,22,12,-1,-1,4,6,22,6]],">":[24,[4,18,20,9,4,0]],"?":[18,[3,16,3,17,4,19,5,20,7,21,11,21,13,20,14,19,15,17,15,15,14,13,13,12,9,10,9,7,-1,-1,9,2,8,1,9,0,10,1,9,2]],"@":[27,[18,13,17,15,15,16,12,16,10,15,9,14,8,11,8,8,9,6,11,5,14,5,16,6,17,8,-1,-1,12,16,10,14,9,11,9,8,10,6,11,5,-1,-1,18,16,17,8,17,6,19,5,21,5,23,7,24,10,24,12,23,15,22,17,20,19,18,20,15,21,12,21,9,20,7,19,5,17,4,15,3,12,3,9,4,6,5,4,7,2,9,1,12,0,15,0,18,1,20,2,21,3,-1,-1,19,16,18,8,18,6,19,5]],A:[18,[9,21,1,0,-1,-1,9,21,17,0,-1,-1,4,7,14,7]],B:[21,[4,21,4,0,-1,-1,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,-1,-1,4,11,13,11,16,10,17,9,18,7,18,4,17,2,16,1,13,0,4,0]],C:[21,[18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5]],D:[21,[4,21,4,0,-1,-1,4,21,11,21,14,20,16,18,17,16,18,13,18,8,17,5,16,3,14,1,11,0,4,0]],E:[19,[4,21,4,0,-1,-1,4,21,17,21,-1,-1,4,11,12,11,-1,-1,4,0,17,0]],F:[18,[4,21,4,0,-1,-1,4,21,17,21,-1,-1,4,11,12,11]],G:[21,[18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,18,8,-1,-1,13,8,18,8]],H:[22,[4,21,4,0,-1,-1,18,21,18,0,-1,-1,4,11,18,11]],I:[8,[4,21,4,0]],J:[16,[12,21,12,5,11,2,10,1,8,0,6,0,4,1,3,2,2,5,2,7]],K:[21,[4,21,4,0,-1,-1,18,21,4,7,-1,-1,9,12,18,0]],L:[17,[4,21,4,0,-1,-1,4,0,16,0]],M:[24,[4,21,4,0,-1,-1,4,21,12,0,-1,-1,20,21,12,0,-1,-1,20,21,20,0]],N:[22,[4,21,4,0,-1,-1,4,21,18,0,-1,-1,18,21,18,0]],O:[22,[9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21]],P:[21,[4,21,4,0,-1,-1,4,21,13,21,16,20,17,19,18,17,18,14,17,12,16,11,13,10,4,10]],Q:[22,[9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21,-1,-1,12,4,18,-2]],R:[21,[4,21,4,0,-1,-1,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,4,11,-1,-1,11,11,18,0]],S:[20,[17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3]],T:[16,[8,21,8,0,-1,-1,1,21,15,21]],U:[22,[4,21,4,6,5,3,7,1,10,0,12,0,15,1,17,3,18,6,18,21]],V:[18,[1,21,9,0,-1,-1,17,21,9,0]],W:[24,[2,21,7,0,-1,-1,12,21,7,0,-1,-1,12,21,17,0,-1,-1,22,21,17,0]],X:[20,[3,21,17,0,-1,-1,17,21,3,0]],Y:[18,[1,21,9,11,9,0,-1,-1,17,21,9,11]],Z:[20,[17,21,3,0,-1,-1,3,21,17,21,-1,-1,3,0,17,0]],"[":[14,[4,25,4,-7,-1,-1,5,25,5,-7,-1,-1,4,25,11,25,-1,-1,4,-7,11,-7]],"\\":[14,[0,21,14,-3]],"]":[14,[9,25,9,-7,-1,-1,10,25,10,-7,-1,-1,3,25,10,25,-1,-1,3,-7,10,-7]],"^":[16,[6,15,8,18,10,15,-1,-1,3,12,8,17,13,12,-1,-1,8,17,8,0]],_:[16,[0,-2,16,-2]],"`":[10,[6,21,5,20,4,18,4,16,5,15,6,16,5,17]],a:[19,[15,14,15,0,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],b:[19,[4,21,4,0,-1,-1,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3]],c:[18,[15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],d:[19,[15,21,15,0,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],e:[18,[3,8,15,8,15,10,14,12,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],f:[12,[10,21,8,21,6,20,5,17,5,0,-1,-1,2,14,9,14]],g:[19,[15,14,15,-2,14,-5,13,-6,11,-7,8,-7,6,-6,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],h:[19,[4,21,4,0,-1,-1,4,10,7,13,9,14,12,14,14,13,15,10,15,0]],i:[8,[3,21,4,20,5,21,4,22,3,21,-1,-1,4,14,4,0]],j:[10,[5,21,6,20,7,21,6,22,5,21,-1,-1,6,14,6,-3,5,-6,3,-7,1,-7]],k:[17,[4,21,4,0,-1,-1,14,14,4,4,-1,-1,8,8,15,0]],l:[8,[4,21,4,0]],m:[30,[4,14,4,0,-1,-1,4,10,7,13,9,14,12,14,14,13,15,10,15,0,-1,-1,15,10,18,13,20,14,23,14,25,13,26,10,26,0]],n:[19,[4,14,4,0,-1,-1,4,10,7,13,9,14,12,14,14,13,15,10,15,0]],o:[19,[8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3,16,6,16,8,15,11,13,13,11,14,8,14]],p:[19,[4,14,4,-7,-1,-1,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3]],q:[19,[15,14,15,-7,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],r:[13,[4,14,4,0,-1,-1,4,8,5,11,7,13,9,14,12,14]],s:[17,[14,11,13,13,10,14,7,14,4,13,3,11,4,9,6,8,11,7,13,6,14,4,14,3,13,1,10,0,7,0,4,1,3,3]],t:[12,[5,21,5,4,6,1,8,0,10,0,-1,-1,2,14,9,14]],u:[19,[4,14,4,4,5,1,7,0,10,0,12,1,15,4,-1,-1,15,14,15,0]],v:[16,[2,14,8,0,-1,-1,14,14,8,0]],w:[22,[3,14,7,0,-1,-1,11,14,7,0,-1,-1,11,14,15,0,-1,-1,19,14,15,0]],x:[17,[3,14,14,0,-1,-1,14,14,3,0]],y:[16,[2,14,8,0,-1,-1,14,14,8,0,6,-4,4,-6,2,-7,1,-7]],z:[17,[14,14,3,0,-1,-1,3,14,14,14,-1,-1,3,0,14,0]],"{":[14,[9,25,7,24,6,23,5,21,5,19,6,17,7,16,8,14,8,12,6,10,-1,-1,7,24,6,22,6,20,7,18,8,17,9,15,9,13,8,11,4,9,8,7,9,5,9,3,8,1,7,0,6,-2,6,-4,7,-6,-1,-1,6,8,8,6,8,4,7,2,6,1,5,-1,5,-3,6,-5,7,-6,9,-7]],"|":[8,[4,25,4,-7]],"}":[14,[5,25,7,24,8,23,9,21,9,19,8,17,7,16,6,14,6,12,8,10,-1,-1,7,24,8,22,8,20,7,18,6,17,5,15,5,13,6,11,10,9,6,7,5,5,5,3,6,1,7,0,8,-2,8,-4,7,-6,-1,-1,8,8,6,6,6,4,7,2,8,1,9,-1,9,-3,8,-5,7,-6,5,-7]],"~":[24,[3,6,3,8,4,11,6,12,8,12,10,11,14,8,16,7,18,7,20,8,21,10,-1,-1,3,8,4,10,6,11,8,11,10,10,14,7,16,6,18,6,20,7,21,10,21,12]]};var lo={symbol:function(e,i,o,r,a){if("translucent"===e.renderPass){var n=Ct.disabled,s=e.colorModeForRenderPass();o.layout.get("text-variable-anchor")&&function(e,i,o,r,a,n,s){for(var l=i.transform,c="map"===a,u="map"===n,h=0,p=e;h<p.length;h+=1){var d=p[h],_=r.getTile(d),f=_.getBucket(o);if(f&&f.text&&f.text.segments.get().length){var m=f.textSizeData,g=t.evaluateSizeForZoom(m,l.zoom),v=ue(_,1,i.transform.zoom),y=Kt(d.posMatrix,u,c,i.transform,v),x="none"!==o.layout.get("icon-text-fit")&&f.hasIconData();if(g){var b=Math.pow(2,l.zoom-_.tileID.overscaledZ);Yi(f,c,u,s,t.symbolSize,l,y,d.posMatrix,b,g,x);}}}}(r,e,o,i,o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),a),0!==o.paint.get("icon-opacity").constantOr(1)&&$i(e,i,o,r,!1,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),o.layout.get("icon-rotation-alignment"),o.layout.get("icon-pitch-alignment"),o.layout.get("icon-keep-upright"),n,s),0!==o.paint.get("text-opacity").constantOr(1)&&$i(e,i,o,r,!0,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),o.layout.get("text-keep-upright"),n,s),i.map.showCollisionBoxes&&(Hi(e,i,o,r,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),!0),Hi(e,i,o,r,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),!1));}},circle:function(e,i,o,r){if("translucent"===e.renderPass){var a=o.paint.get("circle-opacity"),n=o.paint.get("circle-stroke-width"),s=o.paint.get("circle-stroke-opacity"),l=void 0!==o.layout.get("circle-sort-key").constantOr(1);if(0!==a.constantOr(1)||0!==n.constantOr(1)&&0!==s.constantOr(1)){for(var c=e.context,u=c.gl,h=e.depthModeForSublayer(0,It.ReadOnly),p=Ct.disabled,d=e.colorModeForRenderPass(),_=[],f=0;f<r.length;f++){var m=r[f],g=i.getTile(m),v=g.getBucket(o);if(v){var y=v.programConfigurations.get(o.id),x={programConfiguration:y,program:e.useProgram("circle",y),layoutVertexBuffer:v.layoutVertexBuffer,indexBuffer:v.indexBuffer,uniformValues:wi(e,m,g,o)};if(l)for(var b=0,w=v.segments.get();b<w.length;b+=1){var E=w[b];_.push({segments:new t.SegmentVector([E]),sortKey:E.sortKey,state:x});}else _.push({segments:v.segments,sortKey:0,state:x});}}l&&_.sort(function(t,e){return t.sortKey-e.sortKey});for(var T=0,I=_;T<I.length;T+=1){var C=I[T],S=C.state,P=S.programConfiguration,z=S.program,L=S.layoutVertexBuffer,D=S.indexBuffer,M=S.uniformValues,R=C.segments;z.draw(c,u.TRIANGLES,h,p,d,Pt.disabled,M,o.id,L,D,R,o.paint,e.transform.zoom,P);}}}},heatmap:function(e,i,o,r){if(0!==o.paint.get("heatmap-opacity"))if("offscreen"===e.renderPass){var a=e.context,n=a.gl,s=e.depthModeForSublayer(0,It.ReadOnly),l=Ct.disabled,c=new St([n.ONE,n.ONE],t.Color.transparent,[!0,!0,!0,!0]);!function(t,e,i){var o=t.gl;t.activeTexture.set(o.TEXTURE1),t.viewport.set([0,0,e.width/4,e.height/4]);var r=i.heatmapFbo;if(r)o.bindTexture(o.TEXTURE_2D,r.colorAttachment.get()),t.bindFramebuffer.set(r.framebuffer);else{var a=o.createTexture();o.bindTexture(o.TEXTURE_2D,a),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.LINEAR),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.LINEAR),r=i.heatmapFbo=t.createFramebuffer(e.width/4,e.height/4),function t(e,i,o,r){var a=e.gl;a.texImage2D(a.TEXTURE_2D,0,a.RGBA,i.width/4,i.height/4,0,a.RGBA,e.extTextureHalfFloat?e.extTextureHalfFloat.HALF_FLOAT_OES:a.UNSIGNED_BYTE,null);r.colorAttachment.set(o);e.extTextureHalfFloat&&a.checkFramebufferStatus(a.FRAMEBUFFER)!==a.FRAMEBUFFER_COMPLETE&&(e.extTextureHalfFloat=null,r.colorAttachment.setDirty(),t(e,i,o,r));}(t,e,a,r);}}(a,e,o),a.clear({color:t.Color.transparent});for(var u=0;u<r.length;u++){var h=r[u];if(!i.hasRenderableParent(h)){var p=i.getTile(h),d=p.getBucket(o);if(d){var _=d.programConfigurations.get(o.id),f=e.useProgram("heatmap",_),m=e.transform.zoom;f.draw(a,n.TRIANGLES,s,l,c,Pt.disabled,Si(h.posMatrix,p,m,o.paint.get("heatmap-intensity")),o.id,d.layoutVertexBuffer,d.indexBuffer,d.segments,o.paint,e.transform.zoom,_);}}}a.viewport.set([0,0,e.width,e.height]);}else"translucent"===e.renderPass&&(e.context.setColorMode(e.colorModeForRenderPass()),function(e,i){var o=e.context,r=o.gl,a=i.heatmapFbo;if(!a)return;o.activeTexture.set(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,a.colorAttachment.get()),o.activeTexture.set(r.TEXTURE1);var n=i.colorRampTexture;n||(n=i.colorRampTexture=new t.Texture(o,i.colorRamp,r.RGBA));n.bind(r.LINEAR,r.CLAMP_TO_EDGE),e.useProgram("heatmapTexture").draw(o,r.TRIANGLES,It.disabled,Ct.disabled,e.colorModeForRenderPass(),Pt.disabled,Pi(e,i,0,1),i.id,e.viewportBuffer,e.quadTriangleIndexBuffer,e.viewportSegments,i.paint,e.transform.zoom);}(e,o));},line:function(e,i,o,r){if("translucent"===e.renderPass){var a=o.paint.get("line-opacity"),n=o.paint.get("line-width");if(0!==a.constantOr(1)&&0!==n.constantOr(1)){var s=e.depthModeForSublayer(0,It.ReadOnly),l=e.colorModeForRenderPass(),c=o.paint.get("line-dasharray"),u=o.paint.get("line-pattern"),h=u.constantOr(1),p=o.paint.get("line-gradient"),d=o.getCrossfadeParameters(),_=c?"lineSDF":h?"linePattern":p?"lineGradient":"line",f=e.context,m=f.gl,g=!0;if(p){f.activeTexture.set(m.TEXTURE0);var v=o.gradientTexture;if(!o.gradient)return;v||(v=o.gradientTexture=new t.Texture(f,o.gradient,m.RGBA)),v.bind(m.LINEAR,m.CLAMP_TO_EDGE);}for(var y=0,x=r;y<x.length;y+=1){var b=x[y],w=i.getTile(b);if(!h||w.patternsLoaded()){var E=w.getBucket(o);if(E){var T=E.programConfigurations.get(o.id),I=e.context.program.get(),C=e.useProgram(_,T),S=g||C.program!==I,P=u.constantOr(null);if(P&&w.imageAtlas){var z=w.imageAtlas,L=z.patternPositions[P.to.toString()],D=z.patternPositions[P.from.toString()];L&&D&&T.setConstantPatternPositions(L,D);}var M=c?ki(e,w,o,c,d):h?Ai(e,w,o,d):p?Ri(e,w,o):Mi(e,w,o);c&&(S||e.lineAtlas.dirty)?(f.activeTexture.set(m.TEXTURE0),e.lineAtlas.bind(f)):h&&(f.activeTexture.set(m.TEXTURE0),w.imageAtlasTexture.bind(m.LINEAR,m.CLAMP_TO_EDGE),T.updatePatternPaintBuffers(d)),C.draw(f,m.TRIANGLES,s,e.stencilModeForClipping(b),l,Pt.disabled,M,o.id,E.layoutVertexBuffer,E.indexBuffer,E.segments,o.paint,e.transform.zoom,T),g=!1;}}}}}},fill:function(e,i,o,r){var a=o.paint.get("fill-color"),n=o.paint.get("fill-opacity");if(0!==n.constantOr(1)){var s=e.colorModeForRenderPass(),l=o.paint.get("fill-pattern"),c=e.opaquePassEnabledForLayer()&&!l.constantOr(1)&&1===a.constantOr(t.Color.transparent).a&&1===n.constantOr(0)?"opaque":"translucent";if(e.renderPass===c){var u=e.depthModeForSublayer(1,"opaque"===e.renderPass?It.ReadWrite:It.ReadOnly);eo(e,i,o,r,u,s,!1);}if("translucent"===e.renderPass&&o.paint.get("fill-antialias")){var h=e.depthModeForSublayer(o.getPaintProperty("fill-outline-color")?2:0,It.ReadOnly);eo(e,i,o,r,h,s,!0);}}},"fill-extrusion":function(t,e,i,o){var r=i.paint.get("fill-extrusion-opacity");if(0!==r&&"translucent"===t.renderPass){var a=new It(t.context.gl.LEQUAL,It.ReadWrite,t.depthRangeFor3D);if(1!==r||i.paint.get("fill-extrusion-pattern").constantOr(1))io(t,e,i,o,a,Ct.disabled,St.disabled),io(t,e,i,o,a,t.stencilModeFor3D(),t.colorModeForRenderPass());else{var n=t.colorModeForRenderPass();io(t,e,i,o,a,Ct.disabled,n);}}},hillshade:function(t,e,i,o){if("offscreen"===t.renderPass||"translucent"===t.renderPass){for(var r=t.context,a=e.getSource().maxzoom,n=t.depthModeForSublayer(0,It.ReadOnly),s=Ct.disabled,l=t.colorModeForRenderPass(),c=0,u=o;c<u.length;c+=1){var h=u[c],p=e.getTile(h);p.needsHillshadePrepare&&"offscreen"===t.renderPass?ro(t,p,i,a,n,s,l):"translucent"===t.renderPass&&oo(t,p,i,n,s,l);}r.viewport.set([0,0,t.width,t.height]);}},raster:function(t,e,i,o){if("translucent"===t.renderPass&&0!==i.paint.get("raster-opacity"))for(var r=t.context,a=r.gl,n=e.getSource(),s=t.useProgram("raster"),l=Ct.disabled,c=t.colorModeForRenderPass(),u=o.length&&o[0].overscaledZ,h=!t.options.moving,p=0,d=o;p<d.length;p+=1){var _=d[p],f=t.depthModeForSublayer(_.overscaledZ-u,1===i.paint.get("raster-opacity")?It.ReadWrite:It.ReadOnly,a.LESS),m=e.getTile(_),g=t.transform.calculatePosMatrix(_.toUnwrapped(),h);m.registerFadeDuration(i.paint.get("raster-fade-duration"));var v=e.findLoadedParent(_,0),y=ao(m,v,e,i,t.transform),x=void 0,b=void 0,w="nearest"===i.paint.get("raster-resampling")?a.NEAREST:a.LINEAR;r.activeTexture.set(a.TEXTURE0),m.texture.bind(w,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST),r.activeTexture.set(a.TEXTURE1),v?(v.texture.bind(w,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST),x=Math.pow(2,v.tileID.overscaledZ-m.tileID.overscaledZ),b=[m.tileID.canonical.x*x%1,m.tileID.canonical.y*x%1]):m.texture.bind(w,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST);var E=Fi(g,b||[0,0],x||1,y,i);n instanceof D?s.draw(r,a.TRIANGLES,f,l,c,Pt.disabled,E,i.id,n.boundsBuffer,t.quadTriangleIndexBuffer,n.boundsSegments):m.maskedBoundsBuffer&&m.maskedIndexBuffer&&m.segments?s.draw(r,a.TRIANGLES,f,l,c,Pt.disabled,E,i.id,m.maskedBoundsBuffer,m.maskedIndexBuffer,m.segments,i.paint,t.transform.zoom):s.draw(r,a.TRIANGLES,f,l,c,Pt.disabled,E,i.id,t.rasterBoundsBuffer,t.quadTriangleIndexBuffer,t.rasterBoundsSegments);}},background:function(t,e,i){var o=i.paint.get("background-color"),r=i.paint.get("background-opacity");if(0!==r){var a=t.context,n=a.gl,s=t.transform,l=s.tileSize,c=i.paint.get("background-pattern");if(!t.isPatternMissing(c)){var u=!c&&1===o.a&&1===r&&t.opaquePassEnabledForLayer()?"opaque":"translucent";if(t.renderPass===u){var h=Ct.disabled,p=t.depthModeForSublayer(0,"opaque"===u?It.ReadWrite:It.ReadOnly),d=t.colorModeForRenderPass(),_=t.useProgram(c?"backgroundPattern":"background"),f=s.coveringTiles({tileSize:l});c&&(a.activeTexture.set(n.TEXTURE0),t.imageManager.bind(t.context));for(var m=i.getCrossfadeParameters(),g=0,v=f;g<v.length;g+=1){var y=v[g],x=t.transform.calculatePosMatrix(y.toUnwrapped()),b=c?qi(x,r,t,c,{tileID:y,tileSize:l},m):Vi(x,r,o);_.draw(a,n.TRIANGLES,p,h,d,Pt.disabled,b,i.id,t.tileExtentBuffer,t.quadTriangleIndexBuffer,t.tileExtentSegments);}}}}},debug:function(t,e,i){for(var o=0;o<i.length;o++)no(t,e,i[o]);},custom:function(t,e,i){var o=t.context,r=i.implementation;if("offscreen"===t.renderPass){var a=r.prerender;a&&(t.setCustomLayerDefaults(),o.setColorMode(t.colorModeForRenderPass()),a.call(r,o.gl,t.transform.customLayerMatrix()),o.setDirty(),t.setBaseState());}else if("translucent"===t.renderPass){t.setCustomLayerDefaults(),o.setColorMode(t.colorModeForRenderPass()),o.setStencilMode(Ct.disabled);var n="3d"===r.renderingMode?new It(t.context.gl.LEQUAL,It.ReadWrite,t.depthRangeFor3D):t.depthModeForSublayer(0,It.ReadOnly);o.setDepthMode(n),r.render(o.gl,t.transform.customLayerMatrix()),o.setDirty(),t.setBaseState(),o.bindFramebuffer.set(null);}}},co=function(e,i){this.context=new zt(e),this.transform=i,this._tileTextures={},this.setup(),this.numSublayers=Lt.maxUnderzooming+Lt.maxOverzooming+1,this.depthEpsilon=1/Math.pow(2,16),this.depthRboNeedsClear=!0,this.emptyProgramConfiguration=new t.ProgramConfiguration,this.crossTileSymbolIndex=new Ae;};function uo(t,e){if(t.y>e.y){var i=t;t=e,e=i;}return {x0:t.x,y0:t.y,x1:e.x,y1:e.y,dx:e.x-t.x,dy:e.y-t.y}}function ho(t,e,i,o,r){var a=Math.max(i,Math.floor(e.y0)),n=Math.min(o,Math.ceil(e.y1));if(t.x0===e.x0&&t.y0===e.y0?t.x0+e.dy/t.dy*t.dx<e.x1:t.x1-e.dy/t.dy*t.dx<e.x0){var s=t;t=e,e=s;}for(var l=t.dx/t.dy,c=e.dx/e.dy,u=t.dx>0,h=e.dx<0,p=a;p<n;p++){var d=l*Math.max(0,Math.min(t.dy,p+u-t.y0))+t.x0,_=c*Math.max(0,Math.min(e.dy,p+h-e.y0))+e.x0;r(Math.floor(_),Math.ceil(d),p);}}function po(t,e,i,o,r,a){var n,s=uo(t,e),l=uo(e,i),c=uo(i,t);s.dy>l.dy&&(n=s,s=l,l=n),s.dy>c.dy&&(n=s,s=c,c=n),l.dy>c.dy&&(n=l,l=c,c=n),s.dy&&ho(c,s,o,r,a),l.dy&&ho(c,l,o,r,a);}co.prototype.resize=function(e,i){var o=this.context.gl;if(this.width=e*t.browser.devicePixelRatio,this.height=i*t.browser.devicePixelRatio,this.context.viewport.set([0,0,this.width,this.height]),this.style)for(var r=0,a=this.style._order;r<a.length;r+=1){var n=a[r];this.style._layers[n].resize();}this.depthRbo&&(o.deleteRenderbuffer(this.depthRbo),this.depthRbo=null);},co.prototype.setup=function(){var e=this.context,i=new t.StructArrayLayout2i4;i.emplaceBack(0,0),i.emplaceBack(t.EXTENT,0),i.emplaceBack(0,t.EXTENT),i.emplaceBack(t.EXTENT,t.EXTENT),this.tileExtentBuffer=e.createVertexBuffer(i,Ue.members),this.tileExtentSegments=t.SegmentVector.simpleSegment(0,0,4,2);var o=new t.StructArrayLayout2i4;o.emplaceBack(0,0),o.emplaceBack(t.EXTENT,0),o.emplaceBack(0,t.EXTENT),o.emplaceBack(t.EXTENT,t.EXTENT),this.debugBuffer=e.createVertexBuffer(o,Ue.members),this.debugSegments=t.SegmentVector.simpleSegment(0,0,4,5);var r=new t.StructArrayLayout4i8;r.emplaceBack(0,0,0,0),r.emplaceBack(t.EXTENT,0,t.EXTENT,0),r.emplaceBack(0,t.EXTENT,0,t.EXTENT),r.emplaceBack(t.EXTENT,t.EXTENT,t.EXTENT,t.EXTENT),this.rasterBoundsBuffer=e.createVertexBuffer(r,t.rasterBoundsAttributes.members),this.rasterBoundsSegments=t.SegmentVector.simpleSegment(0,0,4,2);var a=new t.StructArrayLayout2i4;a.emplaceBack(0,0),a.emplaceBack(1,0),a.emplaceBack(0,1),a.emplaceBack(1,1),this.viewportBuffer=e.createVertexBuffer(a,Ue.members),this.viewportSegments=t.SegmentVector.simpleSegment(0,0,4,2);var n=new t.StructArrayLayout1ui2;n.emplaceBack(0),n.emplaceBack(1),n.emplaceBack(3),n.emplaceBack(2),n.emplaceBack(0),this.tileBorderIndexBuffer=e.createIndexBuffer(n);var s=new t.StructArrayLayout3ui6;s.emplaceBack(0,1,2),s.emplaceBack(2,1,3),this.quadTriangleIndexBuffer=e.createIndexBuffer(s);var l=this.context.gl;this.stencilClearMode=new Ct({func:l.ALWAYS,mask:0},0,255,l.ZERO,l.ZERO,l.ZERO);},co.prototype.clearStencil=function(){var e=this.context,i=e.gl;this.nextStencilID=1,this.currentStencilSource=void 0;var o=t.create();t.ortho(o,0,this.width,this.height,0,0,1),t.scale(o,o,[i.drawingBufferWidth,i.drawingBufferHeight,0]),this.useProgram("clippingMask").draw(e,i.TRIANGLES,It.disabled,this.stencilClearMode,St.disabled,Pt.disabled,Ci(o),"$clipping",this.viewportBuffer,this.quadTriangleIndexBuffer,this.viewportSegments);},co.prototype._renderTileClippingMasks=function(t,e){if(this.currentStencilSource!==t.source&&t.isTileClipped()&&e&&e.length){this.currentStencilSource=t.source;var i=this.context,o=i.gl;this.nextStencilID+e.length>256&&this.clearStencil(),i.setColorMode(St.disabled),i.setDepthMode(It.disabled);var r=this.useProgram("clippingMask");this._tileClippingMaskIDs={};for(var a=0,n=e;a<n.length;a+=1){var s=n[a],l=this._tileClippingMaskIDs[s.key]=this.nextStencilID++;r.draw(i,o.TRIANGLES,It.disabled,new Ct({func:o.ALWAYS,mask:0},l,255,o.KEEP,o.KEEP,o.REPLACE),St.disabled,Pt.disabled,Ci(s.posMatrix),"$clipping",this.tileExtentBuffer,this.quadTriangleIndexBuffer,this.tileExtentSegments);}}},co.prototype.stencilModeFor3D=function(){this.currentStencilSource=void 0,this.nextStencilID+1>256&&this.clearStencil();var t=this.nextStencilID++,e=this.context.gl;return new Ct({func:e.NOTEQUAL,mask:255},t,255,e.KEEP,e.KEEP,e.REPLACE)},co.prototype.stencilModeForClipping=function(t){var e=this.context.gl;return new Ct({func:e.EQUAL,mask:255},this._tileClippingMaskIDs[t.key],0,e.KEEP,e.KEEP,e.REPLACE)},co.prototype.colorModeForRenderPass=function(){var e=this.context.gl;if(this._showOverdrawInspector){return new St([e.CONSTANT_COLOR,e.ONE],new t.Color(1/8,1/8,1/8,0),[!0,!0,!0,!0])}return "opaque"===this.renderPass?St.unblended:St.alphaBlended},co.prototype.depthModeForSublayer=function(t,e,i){if(!this.opaquePassEnabledForLayer())return It.disabled;var o=1-((1+this.currentLayer)*this.numSublayers+t)*this.depthEpsilon;return new It(i||this.context.gl.LEQUAL,e,[o,o])},co.prototype.opaquePassEnabledForLayer=function(){return this.currentLayer<this.opaquePassCutoff},co.prototype.render=function(e,i){this.style=e,this.options=i,this.lineAtlas=e.lineAtlas,this.imageManager=e.imageManager,this.glyphManager=e.glyphManager,this.symbolFadeChange=e.placement.symbolFadeChange(t.browser.now()),this.imageManager.beginFrame();var o=this.style._order,r=this.style.sourceCaches;for(var a in r){var n=r[a];n.used&&n.prepare(this.context);}var s={},l={},c={};for(var u in r){var h=r[u];s[u]=h.getVisibleCoordinates(),l[u]=s[u].slice().reverse(),c[u]=h.getVisibleCoordinates(!0).reverse();}for(var p in r){var d=r[p],_=d.getSource();if("raster"===_.type||"raster-dem"===_.type){for(var f=[],m=0,g=s[p];m<g.length;m+=1){var v=g[m];f.push(d.getTile(v));}Gi(f,this.context);}}this.opaquePassCutoff=1/0;for(var y=0;y<o.length;y++){var x=o[y];if(this.style._layers[x].is3D()){this.opaquePassCutoff=y;break}}this.renderPass="offscreen",this.depthRboNeedsClear=!0;for(var b=0,w=o;b<w.length;b+=1){var E=w[b],T=this.style._layers[E];if(T.hasOffscreenPass()&&!T.isHidden(this.transform.zoom)){var I=l[T.source];("custom"===T.type||I.length)&&this.renderLayer(this,r[T.source],T,I);}}for(this.context.bindFramebuffer.set(null),this.context.clear({color:i.showOverdrawInspector?t.Color.black:t.Color.transparent,depth:1}),this.clearStencil(),this._showOverdrawInspector=i.showOverdrawInspector,this.depthRangeFor3D=[0,1-(e._order.length+2)*this.numSublayers*this.depthEpsilon],this.renderPass="opaque",this.currentLayer=o.length-1;this.currentLayer>=0;this.currentLayer--){var C=this.style._layers[o[this.currentLayer]],S=r[C.source],P=s[C.source];this._renderTileClippingMasks(C,P),this.renderLayer(this,S,C,P);}for(this.renderPass="translucent",this.currentLayer=0;this.currentLayer<o.length;this.currentLayer++){var z=this.style._layers[o[this.currentLayer]],L=r[z.source],D=("symbol"===z.type?c:l)[z.source];this._renderTileClippingMasks(z,s[z.source]),this.renderLayer(this,L,z,D);}if(this.options.showTileBoundaries)for(var M in r){lo.debug(this,r[M],s[M]);break}this.context.setDefault();},co.prototype.setupOffscreenDepthRenderbuffer=function(){var t=this.context;this.depthRbo||(this.depthRbo=t.createRenderbuffer(t.gl.DEPTH_COMPONENT16,this.width,this.height));},co.prototype.renderLayer=function(t,e,i,o){i.isHidden(this.transform.zoom)||("background"===i.type||"custom"===i.type||o.length)&&(this.id=i.id,lo[i.type](t,e,i,o,this.style.placement.variableOffsets));},co.prototype.translatePosMatrix=function(e,i,o,r,a){if(!o[0]&&!o[1])return e;var n=a?"map"===r?this.transform.angle:0:"viewport"===r?-this.transform.angle:0;if(n){var s=Math.sin(n),l=Math.cos(n);o=[o[0]*l-o[1]*s,o[0]*s+o[1]*l];}var c=[a?o[0]:ue(i,o[0],this.transform.zoom),a?o[1]:ue(i,o[1],this.transform.zoom),0],u=new Float32Array(16);return t.translate(u,e,c),u},co.prototype.saveTileTexture=function(t){var e=this._tileTextures[t.size[0]];e?e.push(t):this._tileTextures[t.size[0]]=[t];},co.prototype.getTileTexture=function(t){var e=this._tileTextures[t];return e&&e.length>0?e.pop():null},co.prototype.isPatternMissing=function(t){if(!t)return !1;var e=this.imageManager.getPattern(t.from.toString()),i=this.imageManager.getPattern(t.to.toString());return !e||!i},co.prototype.useProgram=function(t,e){void 0===e&&(e=this.emptyProgramConfiguration),this.cache=this.cache||{};var i=""+t+(e.cacheKey||"")+(this._showOverdrawInspector?"/overdraw":"");return this.cache[i]||(this.cache[i]=new _i(this.context,pi[t],e,ji[t],this._showOverdrawInspector)),this.cache[i]},co.prototype.setCustomLayerDefaults=function(){this.context.unbindVAO(),this.context.cullFace.setDefault(),this.context.activeTexture.setDefault(),this.context.pixelStoreUnpack.setDefault(),this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.context.pixelStoreUnpackFlipY.setDefault();},co.prototype.setBaseState=function(){var t=this.context.gl;this.context.cullFace.set(!1),this.context.viewport.set([0,0,this.width,this.height]),this.context.blendEquation.set(t.FUNC_ADD);};var _o=function(e,i,o){this.tileSize=512,this.maxValidLatitude=85.051129,this._renderWorldCopies=void 0===o||o,this._minZoom=e||0,this._maxZoom=i||22,this.setMaxBounds(),this.width=0,this.height=0,this._center=new t.LngLat(0,0),this.zoom=0,this.angle=0,this._fov=.6435011087932844,this._pitch=0,this._unmodified=!0,this._posMatrixCache={},this._alignedPosMatrixCache={};},fo={minZoom:{configurable:!0},maxZoom:{configurable:!0},renderWorldCopies:{configurable:!0},worldSize:{configurable:!0},centerPoint:{configurable:!0},size:{configurable:!0},bearing:{configurable:!0},pitch:{configurable:!0},fov:{configurable:!0},zoom:{configurable:!0},center:{configurable:!0},unmodified:{configurable:!0},point:{configurable:!0}};_o.prototype.clone=function(){var t=new _o(this._minZoom,this._maxZoom,this._renderWorldCopies);return t.tileSize=this.tileSize,t.latRange=this.latRange,t.width=this.width,t.height=this.height,t._center=this._center,t.zoom=this.zoom,t.angle=this.angle,t._fov=this._fov,t._pitch=this._pitch,t._unmodified=this._unmodified,t._calcMatrices(),t},fo.minZoom.get=function(){return this._minZoom},fo.minZoom.set=function(t){this._minZoom!==t&&(this._minZoom=t,this.zoom=Math.max(this.zoom,t));},fo.maxZoom.get=function(){return this._maxZoom},fo.maxZoom.set=function(t){this._maxZoom!==t&&(this._maxZoom=t,this.zoom=Math.min(this.zoom,t));},fo.renderWorldCopies.get=function(){return this._renderWorldCopies},fo.renderWorldCopies.set=function(t){void 0===t?t=!0:null===t&&(t=!1),this._renderWorldCopies=t;},fo.worldSize.get=function(){return this.tileSize*this.scale},fo.centerPoint.get=function(){return this.size._div(2)},fo.size.get=function(){return new t.Point(this.width,this.height)},fo.bearing.get=function(){return -this.angle/Math.PI*180},fo.bearing.set=function(e){var i=-t.wrap(e,-180,180)*Math.PI/180;this.angle!==i&&(this._unmodified=!1,this.angle=i,this._calcMatrices(),this.rotationMatrix=t.create$2(),t.rotate(this.rotationMatrix,this.rotationMatrix,this.angle));},fo.pitch.get=function(){return this._pitch/Math.PI*180},fo.pitch.set=function(e){var i=t.clamp(e,0,60)/180*Math.PI;this._pitch!==i&&(this._unmodified=!1,this._pitch=i,this._calcMatrices());},fo.fov.get=function(){return this._fov/Math.PI*180},fo.fov.set=function(t){t=Math.max(.01,Math.min(60,t)),this._fov!==t&&(this._unmodified=!1,this._fov=t/180*Math.PI,this._calcMatrices());},fo.zoom.get=function(){return this._zoom},fo.zoom.set=function(t){var e=Math.min(Math.max(t,this.minZoom),this.maxZoom);this._zoom!==e&&(this._unmodified=!1,this._zoom=e,this.scale=this.zoomScale(e),this.tileZoom=Math.floor(e),this.zoomFraction=e-this.tileZoom,this._constrain(),this._calcMatrices());},fo.center.get=function(){return this._center},fo.center.set=function(t){t.lat===this._center.lat&&t.lng===this._center.lng||(this._unmodified=!1,this._center=t,this._constrain(),this._calcMatrices());},_o.prototype.coveringZoomLevel=function(t){return (t.roundZoom?Math.round:Math.floor)(this.zoom+this.scaleZoom(this.tileSize/t.tileSize))},_o.prototype.getVisibleUnwrappedCoordinates=function(e){var i=[new t.UnwrappedTileID(0,e)];if(this._renderWorldCopies)for(var o=this.pointCoordinate(new t.Point(0,0)),r=this.pointCoordinate(new t.Point(this.width,0)),a=this.pointCoordinate(new t.Point(this.width,this.height)),n=this.pointCoordinate(new t.Point(0,this.height)),s=Math.floor(Math.min(o.x,r.x,a.x,n.x)),l=Math.floor(Math.max(o.x,r.x,a.x,n.x)),c=s-1;c<=l+1;c++)0!==c&&i.push(new t.UnwrappedTileID(c,e));return i},_o.prototype.coveringTiles=function(e){var i=this.coveringZoomLevel(e),o=i;if(void 0!==e.minzoom&&i<e.minzoom)return [];void 0!==e.maxzoom&&i>e.maxzoom&&(i=e.maxzoom);var r=t.MercatorCoordinate.fromLngLat(this.center),a=Math.pow(2,i),n=new t.Point(a*r.x-.5,a*r.y-.5);return function(e,i,o,r){void 0===r&&(r=!0);var a=1<<e,n={};function s(i,s,l){var c,u,h,p;if(l>=0&&l<=a)for(c=i;c<s;c++)u=Math.floor(c/a),h=(c%a+a)%a,0!==u&&!0!==r||(p=new t.OverscaledTileID(o,u,e,h,l),n[p.key]=p);}var l=i.map(function(e){return new t.Point(e.x,e.y)._mult(a)});return po(l[0],l[1],l[2],0,a,s),po(l[2],l[3],l[0],0,a,s),Object.keys(n).map(function(t){return n[t]})}(i,[this.pointCoordinate(new t.Point(0,0)),this.pointCoordinate(new t.Point(this.width,0)),this.pointCoordinate(new t.Point(this.width,this.height)),this.pointCoordinate(new t.Point(0,this.height))],e.reparseOverscaled?o:i,this._renderWorldCopies).sort(function(t,e){return n.dist(t.canonical)-n.dist(e.canonical)})},_o.prototype.resize=function(t,e){this.width=t,this.height=e,this.pixelsToGLUnits=[2/t,-2/e],this._constrain(),this._calcMatrices();},fo.unmodified.get=function(){return this._unmodified},_o.prototype.zoomScale=function(t){return Math.pow(2,t)},_o.prototype.scaleZoom=function(t){return Math.log(t)/Math.LN2},_o.prototype.project=function(e){var i=t.clamp(e.lat,-this.maxValidLatitude,this.maxValidLatitude);return new t.Point(t.mercatorXfromLng(e.lng)*this.worldSize,t.mercatorYfromLat(i)*this.worldSize)},_o.prototype.unproject=function(e){return new t.MercatorCoordinate(e.x/this.worldSize,e.y/this.worldSize).toLngLat()},fo.point.get=function(){return this.project(this.center)},_o.prototype.setLocationAtPoint=function(e,i){var o=this.pointCoordinate(i),r=this.pointCoordinate(this.centerPoint),a=this.locationCoordinate(e),n=new t.MercatorCoordinate(a.x-(o.x-r.x),a.y-(o.y-r.y));this.center=this.coordinateLocation(n),this._renderWorldCopies&&(this.center=this.center.wrap());},_o.prototype.locationPoint=function(t){return this.coordinatePoint(this.locationCoordinate(t))},_o.prototype.pointLocation=function(t){return this.coordinateLocation(this.pointCoordinate(t))},_o.prototype.locationCoordinate=function(e){return t.MercatorCoordinate.fromLngLat(e)},_o.prototype.coordinateLocation=function(t){return t.toLngLat()},_o.prototype.pointCoordinate=function(e){var i=[e.x,e.y,0,1],o=[e.x,e.y,1,1];t.transformMat4(i,i,this.pixelMatrixInverse),t.transformMat4(o,o,this.pixelMatrixInverse);var r=i[3],a=o[3],n=i[0]/r,s=o[0]/a,l=i[1]/r,c=o[1]/a,u=i[2]/r,h=o[2]/a,p=u===h?0:(0-u)/(h-u);return new t.MercatorCoordinate(t.number(n,s,p)/this.worldSize,t.number(l,c,p)/this.worldSize)},_o.prototype.coordinatePoint=function(e){var i=[e.x*this.worldSize,e.y*this.worldSize,0,1];return t.transformMat4(i,i,this.pixelMatrix),new t.Point(i[0]/i[3],i[1]/i[3])},_o.prototype.getBounds=function(){return (new t.LngLatBounds).extend(this.pointLocation(new t.Point(0,0))).extend(this.pointLocation(new t.Point(this.width,0))).extend(this.pointLocation(new t.Point(this.width,this.height))).extend(this.pointLocation(new t.Point(0,this.height)))},_o.prototype.getMaxBounds=function(){return this.latRange&&2===this.latRange.length&&this.lngRange&&2===this.lngRange.length?new t.LngLatBounds([this.lngRange[0],this.latRange[0]],[this.lngRange[1],this.latRange[1]]):null},_o.prototype.setMaxBounds=function(t){t?(this.lngRange=[t.getWest(),t.getEast()],this.latRange=[t.getSouth(),t.getNorth()],this._constrain()):(this.lngRange=null,this.latRange=[-this.maxValidLatitude,this.maxValidLatitude]);},_o.prototype.calculatePosMatrix=function(e,i){void 0===i&&(i=!1);var o=e.key,r=i?this._alignedPosMatrixCache:this._posMatrixCache;if(r[o])return r[o];var a=e.canonical,n=this.worldSize/this.zoomScale(a.z),s=a.x+Math.pow(2,a.z)*e.wrap,l=t.identity(new Float64Array(16));return t.translate(l,l,[s*n,a.y*n,0]),t.scale(l,l,[n/t.EXTENT,n/t.EXTENT,1]),t.multiply(l,i?this.alignedProjMatrix:this.projMatrix,l),r[o]=new Float32Array(l),r[o]},_o.prototype.customLayerMatrix=function(){return this.mercatorMatrix.slice()},_o.prototype._constrain=function(){if(this.center&&this.width&&this.height&&!this._constraining){this._constraining=!0;var e,i,o,r,a=-90,n=90,s=-180,l=180,c=this.size,u=this._unmodified;if(this.latRange){var h=this.latRange;a=t.mercatorYfromLat(h[1])*this.worldSize,e=(n=t.mercatorYfromLat(h[0])*this.worldSize)-a<c.y?c.y/(n-a):0;}if(this.lngRange){var p=this.lngRange;s=t.mercatorXfromLng(p[0])*this.worldSize,i=(l=t.mercatorXfromLng(p[1])*this.worldSize)-s<c.x?c.x/(l-s):0;}var d=this.point,_=Math.max(i||0,e||0);if(_)return this.center=this.unproject(new t.Point(i?(l+s)/2:d.x,e?(n+a)/2:d.y)),this.zoom+=this.scaleZoom(_),this._unmodified=u,void(this._constraining=!1);if(this.latRange){var f=d.y,m=c.y/2;f-m<a&&(r=a+m),f+m>n&&(r=n-m);}if(this.lngRange){var g=d.x,v=c.x/2;g-v<s&&(o=s+v),g+v>l&&(o=l-v);}void 0===o&&void 0===r||(this.center=this.unproject(new t.Point(void 0!==o?o:d.x,void 0!==r?r:d.y))),this._unmodified=u,this._constraining=!1;}},_o.prototype._calcMatrices=function(){if(this.height){this.cameraToCenterDistance=.5/Math.tan(this._fov/2)*this.height;var e=this._fov/2,i=Math.PI/2+this._pitch,o=Math.sin(e)*this.cameraToCenterDistance/Math.sin(Math.PI-i-e),r=this.point,a=r.x,n=r.y,s=1.01*(Math.cos(Math.PI/2-this._pitch)*o+this.cameraToCenterDistance),l=this.height/50,c=new Float64Array(16);t.perspective(c,this._fov,this.width/this.height,l,s),t.scale(c,c,[1,-1,1]),t.translate(c,c,[0,0,-this.cameraToCenterDistance]),t.rotateX(c,c,this._pitch),t.rotateZ(c,c,this.angle),t.translate(c,c,[-a,-n,0]),this.mercatorMatrix=t.scale([],c,[this.worldSize,this.worldSize,this.worldSize]),t.scale(c,c,[1,1,t.mercatorZfromAltitude(1,this.center.lat)*this.worldSize,1]),this.projMatrix=c;var u=this.width%2/2,h=this.height%2/2,p=Math.cos(this.angle),d=Math.sin(this.angle),_=a-Math.round(a)+p*u+d*h,f=n-Math.round(n)+p*h+d*u,m=new Float64Array(c);if(t.translate(m,m,[_>.5?_-1:_,f>.5?f-1:f,0]),this.alignedProjMatrix=m,c=t.create(),t.scale(c,c,[this.width/2,-this.height/2,1]),t.translate(c,c,[1,-1,0]),this.labelPlaneMatrix=c,c=t.create(),t.scale(c,c,[1,-1,1]),t.translate(c,c,[-1,-1,0]),t.scale(c,c,[2/this.width,2/this.height,1]),this.glCoordMatrix=c,this.pixelMatrix=t.multiply(new Float64Array(16),this.labelPlaneMatrix,this.projMatrix),!(c=t.invert(new Float64Array(16),this.pixelMatrix)))throw new Error("failed to invert matrix");this.pixelMatrixInverse=c,this._posMatrixCache={},this._alignedPosMatrixCache={};}},_o.prototype.maxPitchScaleFactor=function(){if(!this.pixelMatrixInverse)return 1;var e=this.pointCoordinate(new t.Point(0,0)),i=[e.x*this.worldSize,e.y*this.worldSize,0,1];return t.transformMat4(i,i,this.pixelMatrix)[3]/this.cameraToCenterDistance},_o.prototype.getCameraPoint=function(){var e=this._pitch,i=Math.tan(e)*(this.cameraToCenterDistance||1);return this.centerPoint.add(new t.Point(0,i))},_o.prototype.getCameraQueryGeometry=function(e){var i=this.getCameraPoint();if(1===e.length)return [e[0],i];for(var o=i.x,r=i.y,a=i.x,n=i.y,s=0,l=e;s<l.length;s+=1){var c=l[s];o=Math.min(o,c.x),r=Math.min(r,c.y),a=Math.max(a,c.x),n=Math.max(n,c.y);}return [new t.Point(o,r),new t.Point(a,r),new t.Point(a,n),new t.Point(o,n),new t.Point(o,r)]},Object.defineProperties(_o.prototype,fo);var mo=function(){var e,i,o,r,a;t.bindAll(["_onHashChange","_updateHash"],this),this._updateHash=(e=this._updateHashUnthrottled.bind(this),i=300,o=!1,r=null,a=function(){r=null,o&&(e(),r=setTimeout(a,i),o=!1);},function(){return o=!0,r||a(),r});};mo.prototype.addTo=function(e){return this._map=e,t.window.addEventListener("hashchange",this._onHashChange,!1),this._map.on("moveend",this._updateHash),this},mo.prototype.remove=function(){return t.window.removeEventListener("hashchange",this._onHashChange,!1),this._map.off("moveend",this._updateHash),clearTimeout(this._updateHash()),delete this._map,this},mo.prototype.getHashString=function(t){var e=this._map.getCenter(),i=Math.round(100*this._map.getZoom())/100,o=Math.ceil((i*Math.LN2+Math.log(512/360/.5))/Math.LN10),r=Math.pow(10,o),a=Math.round(e.lng*r)/r,n=Math.round(e.lat*r)/r,s=this._map.getBearing(),l=this._map.getPitch(),c="";return c+=t?"#/"+a+"/"+n+"/"+i:"#"+i+"/"+n+"/"+a,(s||l)&&(c+="/"+Math.round(10*s)/10),l&&(c+="/"+Math.round(l)),c},mo.prototype._onHashChange=function(){var e=t.window.location.hash.replace("#","").split("/");return e.length>=3&&(this._map.jumpTo({center:[+e[2],+e[1]],zoom:+e[0],bearing:+(e[3]||0),pitch:+(e[4]||0)}),!0)},mo.prototype._updateHashUnthrottled=function(){var e=this.getHashString();try{t.window.history.replaceState(t.window.history.state,"",e);}catch(t){}};var go=function(e){function o(o,r,a,n){void 0===n&&(n={});var s=i.mousePos(r.getCanvasContainer(),a),l=r.unproject(s);e.call(this,o,t.extend({point:s,lngLat:l,originalEvent:a},n)),this._defaultPrevented=!1,this.target=r;}e&&(o.__proto__=e),o.prototype=Object.create(e&&e.prototype),o.prototype.constructor=o;var r={defaultPrevented:{configurable:!0}};return o.prototype.preventDefault=function(){this._defaultPrevented=!0;},r.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(o.prototype,r),o}(t.Event),vo=function(e){function o(o,r,a){var n=i.touchPos(r.getCanvasContainer(),a),s=n.map(function(t){return r.unproject(t)}),l=n.reduce(function(t,e,i,o){return t.add(e.div(o.length))},new t.Point(0,0)),c=r.unproject(l);e.call(this,o,{points:n,point:l,lngLats:s,lngLat:c,originalEvent:a}),this._defaultPrevented=!1;}e&&(o.__proto__=e),o.prototype=Object.create(e&&e.prototype),o.prototype.constructor=o;var r={defaultPrevented:{configurable:!0}};return o.prototype.preventDefault=function(){this._defaultPrevented=!0;},r.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(o.prototype,r),o}(t.Event),yo=function(t){function e(e,i,o){t.call(this,e,{originalEvent:o}),this._defaultPrevented=!1;}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var i={defaultPrevented:{configurable:!0}};return e.prototype.preventDefault=function(){this._defaultPrevented=!0;},i.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(e.prototype,i),e}(t.Event),xo=function(e){this._map=e,this._el=e.getCanvasContainer(),this._delta=0,this._defaultZoomRate=.01,this._wheelZoomRate=1/450,t.bindAll(["_onWheel","_onTimeout","_onScrollFrame","_onScrollFinished"],this);};xo.prototype.setZoomRate=function(t){this._defaultZoomRate=t;},xo.prototype.setWheelZoomRate=function(t){this._wheelZoomRate=t;},xo.prototype.isEnabled=function(){return !!this._enabled},xo.prototype.isActive=function(){return !!this._active},xo.prototype.isZooming=function(){return !!this._zooming},xo.prototype.enable=function(t){this.isEnabled()||(this._enabled=!0,this._aroundCenter=t&&"center"===t.around);},xo.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},xo.prototype.onWheel=function(e){if(this.isEnabled()){var i=e.deltaMode===t.window.WheelEvent.DOM_DELTA_LINE?40*e.deltaY:e.deltaY,o=t.browser.now(),r=o-(this._lastWheelEventTime||0);this._lastWheelEventTime=o,0!==i&&i%4.000244140625==0?this._type="wheel":0!==i&&Math.abs(i)<4?this._type="trackpad":r>400?(this._type=null,this._lastValue=i,this._timeout=setTimeout(this._onTimeout,40,e)):this._type||(this._type=Math.abs(r*i)<200?"trackpad":"wheel",this._timeout&&(clearTimeout(this._timeout),this._timeout=null,i+=this._lastValue)),e.shiftKey&&i&&(i/=4),this._type&&(this._lastWheelEvent=e,this._delta-=i,this.isActive()||this._start(e)),e.preventDefault();}},xo.prototype._onTimeout=function(t){this._type="wheel",this._delta-=this._lastValue,this.isActive()||this._start(t);},xo.prototype._start=function(e){if(this._delta){this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),this._active=!0,this.isZooming()||(this._zooming=!0,this._map.fire(new t.Event("movestart",{originalEvent:e})),this._map.fire(new t.Event("zoomstart",{originalEvent:e}))),this._finishTimeout&&clearTimeout(this._finishTimeout);var o=i.mousePos(this._el,e);this._around=t.LngLat.convert(this._aroundCenter?this._map.getCenter():this._map.unproject(o)),this._aroundPoint=this._map.transform.locationPoint(this._around),this._frameId||(this._frameId=this._map._requestRenderFrame(this._onScrollFrame));}},xo.prototype._onScrollFrame=function(){var e=this;if(this._frameId=null,this.isActive()){var i=this._map.transform;if(0!==this._delta){var o="wheel"===this._type&&Math.abs(this._delta)>4.000244140625?this._wheelZoomRate:this._defaultZoomRate,r=2/(1+Math.exp(-Math.abs(this._delta*o)));this._delta<0&&0!==r&&(r=1/r);var a="number"==typeof this._targetZoom?i.zoomScale(this._targetZoom):i.scale;this._targetZoom=Math.min(i.maxZoom,Math.max(i.minZoom,i.scaleZoom(a*r))),"wheel"===this._type&&(this._startZoom=i.zoom,this._easing=this._smoothOutEasing(200)),this._delta=0;}var n="number"==typeof this._targetZoom?this._targetZoom:i.zoom,s=this._startZoom,l=this._easing,c=!1;if("wheel"===this._type&&s&&l){var u=Math.min((t.browser.now()-this._lastWheelEventTime)/200,1),h=l(u);i.zoom=t.number(s,n,h),u<1?this._frameId||(this._frameId=this._map._requestRenderFrame(this._onScrollFrame)):c=!0;}else i.zoom=n,c=!0;i.setLocationAtPoint(this._around,this._aroundPoint),this._map.fire(new t.Event("move",{originalEvent:this._lastWheelEvent})),this._map.fire(new t.Event("zoom",{originalEvent:this._lastWheelEvent})),c&&(this._active=!1,this._finishTimeout=setTimeout(function(){e._zooming=!1,e._map.fire(new t.Event("zoomend",{originalEvent:e._lastWheelEvent})),e._map.fire(new t.Event("moveend",{originalEvent:e._lastWheelEvent})),delete e._targetZoom;},200));}},xo.prototype._smoothOutEasing=function(e){var i=t.ease;if(this._prevEase){var o=this._prevEase,r=(t.browser.now()-o.start)/o.duration,a=o.easing(r+.01)-o.easing(r),n=.27/Math.sqrt(a*a+1e-4)*.01,s=Math.sqrt(.0729-n*n);i=t.bezier(n,s,.25,1);}return this._prevEase={start:t.browser.now(),duration:e,easing:i},i};var bo=function(e,i){this._map=e,this._el=e.getCanvasContainer(),this._container=e.getContainer(),this._clickTolerance=i.clickTolerance||1,t.bindAll(["_onMouseMove","_onMouseUp","_onKeyDown"],this);};bo.prototype.isEnabled=function(){return !!this._enabled},bo.prototype.isActive=function(){return !!this._active},bo.prototype.enable=function(){this.isEnabled()||(this._enabled=!0);},bo.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},bo.prototype.onMouseDown=function(e){this.isEnabled()&&e.shiftKey&&0===e.button&&(t.window.document.addEventListener("mousemove",this._onMouseMove,!1),t.window.document.addEventListener("keydown",this._onKeyDown,!1),t.window.document.addEventListener("mouseup",this._onMouseUp,!1),i.disableDrag(),this._startPos=this._lastPos=i.mousePos(this._el,e),this._active=!0);},bo.prototype._onMouseMove=function(t){var e=i.mousePos(this._el,t);if(!(this._lastPos.equals(e)||!this._box&&e.dist(this._startPos)<this._clickTolerance)){var o=this._startPos;this._lastPos=e,this._box||(this._box=i.create("div","mapboxgl-boxzoom",this._container),this._container.classList.add("mapboxgl-crosshair"),this._fireEvent("boxzoomstart",t));var r=Math.min(o.x,e.x),a=Math.max(o.x,e.x),n=Math.min(o.y,e.y),s=Math.max(o.y,e.y);i.setTransform(this._box,"translate("+r+"px,"+n+"px)"),this._box.style.width=a-r+"px",this._box.style.height=s-n+"px";}},bo.prototype._onMouseUp=function(e){if(0===e.button){var o=this._startPos,r=i.mousePos(this._el,e);this._finish(),i.suppressClick(),o.x===r.x&&o.y===r.y?this._fireEvent("boxzoomcancel",e):this._map.fitScreenCoordinates(o,r,this._map.getBearing(),{linear:!0}).fire(new t.Event("boxzoomend",{originalEvent:e}));}},bo.prototype._onKeyDown=function(t){27===t.keyCode&&(this._finish(),this._fireEvent("boxzoomcancel",t));},bo.prototype._finish=function(){this._active=!1,t.window.document.removeEventListener("mousemove",this._onMouseMove,!1),t.window.document.removeEventListener("keydown",this._onKeyDown,!1),t.window.document.removeEventListener("mouseup",this._onMouseUp,!1),this._container.classList.remove("mapboxgl-crosshair"),this._box&&(i.remove(this._box),this._box=null),i.enableDrag(),delete this._startPos,delete this._lastPos;},bo.prototype._fireEvent=function(e,i){return this._map.fire(new t.Event(e,{originalEvent:i}))};var wo=t.bezier(0,0,.25,1),Eo=function(e,i){this._map=e,this._el=i.element||e.getCanvasContainer(),this._state="disabled",this._button=i.button||"right",this._bearingSnap=i.bearingSnap||0,this._pitchWithRotate=!1!==i.pitchWithRotate,t.bindAll(["onMouseDown","_onMouseMove","_onMouseUp","_onBlur","_onDragFrame"],this);};Eo.prototype.isEnabled=function(){return "disabled"!==this._state},Eo.prototype.isActive=function(){return "active"===this._state},Eo.prototype.enable=function(){this.isEnabled()||(this._state="enabled");},Eo.prototype.disable=function(){if(this.isEnabled())switch(this._state){case"active":this._state="disabled",this._unbind(),this._deactivate(),this._fireEvent("rotateend"),this._pitchWithRotate&&this._fireEvent("pitchend"),this._fireEvent("moveend");break;case"pending":this._state="disabled",this._unbind();break;default:this._state="disabled";}},Eo.prototype.onMouseDown=function(e){if("enabled"===this._state){var o="touchstart"===e.type;if(o)this._startTime=Date.now();else if("right"===this._button){if(this._eventButton=i.mouseButton(e),this._eventButton!==(e.ctrlKey?0:2))return}else{if(e.ctrlKey||0!==i.mouseButton(e))return;this._eventButton=0;}i.disableDrag(),o?(t.window.document.addEventListener("touchmove",this._onMouseMove,{capture:!0}),t.window.document.addEventListener("touchend",this._onMouseUp)):(t.window.document.addEventListener("mousemove",this._onMouseMove,{capture:!0}),t.window.document.addEventListener("mouseup",this._onMouseUp)),t.window.addEventListener("blur",this._onBlur),this._state="pending",this._inertia=[[t.browser.now(),this._map.getBearing()]],this._startPos=this._prevPos=this._lastPos=i.mousePos(this._el,e),this._center=this._map.transform.centerPoint,e.preventDefault();}},Eo.prototype._onMouseMove=function(t){var e=i.mousePos(this._el,t);this._lastPos.equals(e)||(this._lastMoveEvent=t,this._lastPos=e,"pending"===this._state&&(this._state="active",this._fireEvent("rotatestart",t),this._fireEvent("movestart",t),this._pitchWithRotate&&this._fireEvent("pitchstart",t)),this._frameId||(this._frameId=this._map._requestRenderFrame(this._onDragFrame)));},Eo.prototype._onDragFrame=function(){this._frameId=null;var e=this._lastMoveEvent;if(e){var i=this._map.transform,o=this._prevPos,r=this._lastPos,a=.8*(o.x-r.x),n=-.5*(o.y-r.y),s=i.bearing-a,l=i.pitch-n,c=this._inertia,u=c[c.length-1];this._drainInertiaBuffer(),c.push([t.browser.now(),this._map._normalizeBearing(s,u[1])]),i.bearing=s,this._pitchWithRotate&&(this._fireEvent("pitch",e),i.pitch=l),this._fireEvent("rotate",e),this._fireEvent("move",e),delete this._lastMoveEvent,this._prevPos=this._lastPos;}},Eo.prototype._onMouseUp=function(t){if("touchend"===t.type&&this._startPos===this._lastPos&&Date.now()-this._startTime<300&&this._el.click(),i.mouseButton(t)===this._eventButton)switch(this._state){case"active":this._state="enabled",i.suppressClick(),this._unbind(),this._deactivate(),this._inertialRotate(t);break;case"pending":this._state="enabled",this._unbind();}},Eo.prototype._onBlur=function(t){switch(this._state){case"active":this._state="enabled",this._unbind(),this._deactivate(),this._fireEvent("rotateend",t),this._pitchWithRotate&&this._fireEvent("pitchend",t),this._fireEvent("moveend",t);break;case"pending":this._state="enabled",this._unbind();}},Eo.prototype._unbind=function(){t.window.document.removeEventListener("mousemove",this._onMouseMove,{capture:!0}),t.window.document.removeEventListener("mouseup",this._onMouseUp),t.window.document.removeEventListener("touchmove",this._onMouseMove,{capture:!0}),t.window.document.removeEventListener("touchend",this._onMouseUp),t.window.removeEventListener("blur",this._onBlur),i.enableDrag();},Eo.prototype._deactivate=function(){this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),delete this._lastMoveEvent,delete this._startPos,delete this._prevPos,delete this._lastPos;},Eo.prototype._inertialRotate=function(t){var e=this;this._fireEvent("rotateend",t),this._drainInertiaBuffer();var i=this._map,o=i.getBearing(),r=this._inertia,a=function(){Math.abs(o)<e._bearingSnap?i.resetNorth({noMoveStart:!0},{originalEvent:t}):e._fireEvent("moveend",t),e._pitchWithRotate&&e._fireEvent("pitchend",t);};if(r.length<2)a();else{var n=r[0],s=r[r.length-1],l=r[r.length-2],c=i._normalizeBearing(o,l[1]),u=s[1]-n[1],h=u<0?-1:1,p=(s[0]-n[0])/1e3;if(0!==u&&0!==p){var d=Math.abs(u*(.25/p));d>180&&(d=180);var _=d/180;c+=h*d*(_/2),Math.abs(i._normalizeBearing(c,0))<this._bearingSnap&&(c=i._normalizeBearing(0,c)),i.rotateTo(c,{duration:1e3*_,easing:wo,noMoveStart:!0},{originalEvent:t});}else a();}},Eo.prototype._fireEvent=function(e,i){return this._map.fire(new t.Event(e,i?{originalEvent:i}:{}))},Eo.prototype._drainInertiaBuffer=function(){for(var e=this._inertia,i=t.browser.now();e.length>0&&i-e[0][0]>160;)e.shift();};var To=t.bezier(0,0,.3,1),Io=function(e,i){this._map=e,this._el=e.getCanvasContainer(),this._state="disabled",this._clickTolerance=i.clickTolerance||1,t.bindAll(["_onMove","_onMouseUp","_onTouchEnd","_onBlur","_onDragFrame"],this);};Io.prototype.isEnabled=function(){return "disabled"!==this._state},Io.prototype.isActive=function(){return "active"===this._state},Io.prototype.enable=function(){this.isEnabled()||(this._el.classList.add("mapboxgl-touch-drag-pan"),this._state="enabled");},Io.prototype.disable=function(){if(this.isEnabled())switch(this._el.classList.remove("mapboxgl-touch-drag-pan"),this._state){case"active":this._state="disabled",this._unbind(),this._deactivate(),this._fireEvent("dragend"),this._fireEvent("moveend");break;case"pending":this._state="disabled",this._unbind();break;default:this._state="disabled";}},Io.prototype.onMouseDown=function(e){"enabled"===this._state&&(e.ctrlKey||0!==i.mouseButton(e)||(i.addEventListener(t.window.document,"mousemove",this._onMove,{capture:!0}),i.addEventListener(t.window.document,"mouseup",this._onMouseUp),this._start(e)));},Io.prototype.onTouchStart=function(e){this.isEnabled()&&(e.touches&&e.touches.length>1&&("pending"===this._state||"active"===this._state)||(i.addEventListener(t.window.document,"touchmove",this._onMove,{capture:!0,passive:!1}),i.addEventListener(t.window.document,"touchend",this._onTouchEnd),this._start(e)));},Io.prototype._start=function(e){t.window.addEventListener("blur",this._onBlur),this._state="pending",this._startPos=this._mouseDownPos=this._prevPos=this._lastPos=i.mousePos(this._el,e),this._startTouch=this._lastTouch=t.window.TouchEvent&&e instanceof t.window.TouchEvent?i.touchPos(this._el,e):null,this._inertia=[[t.browser.now(),this._startPos]];},Io.prototype._touchesMatch=function(t,e){return !(!t||!e||t.length!==e.length)&&t.every(function(t,i){return e[i]===t})},Io.prototype._onMove=function(e){e.preventDefault();var o=t.window.TouchEvent&&e instanceof t.window.TouchEvent?i.touchPos(this._el,e):null,r=i.mousePos(this._el,e);(o?this._touchesMatch(this._lastTouch,o):this._lastPos.equals(r))||"pending"===this._state&&r.dist(this._mouseDownPos)<this._clickTolerance||(this._lastMoveEvent=e,this._lastPos=r,this._lastTouch=o,this._drainInertiaBuffer(),this._inertia.push([t.browser.now(),this._lastPos]),"pending"===this._state&&(this._state="active",this._shouldStart=!0),this._frameId||(this._frameId=this._map._requestRenderFrame(this._onDragFrame)));},Io.prototype._onDragFrame=function(){this._frameId=null;var t=this._lastMoveEvent;if(t)if(this._map.touchZoomRotate.isActive())this._abort(t);else if(this._shouldStart&&(this._fireEvent("dragstart",t),this._fireEvent("movestart",t),this._shouldStart=!1),this.isActive()){var e=this._map.transform;e.setLocationAtPoint(e.pointLocation(this._prevPos),this._lastPos),this._fireEvent("drag",t),this._fireEvent("move",t),this._prevPos=this._lastPos,delete this._lastMoveEvent;}},Io.prototype._onMouseUp=function(t){if(0===i.mouseButton(t))switch(this._state){case"active":this._state="enabled",i.suppressClick(),this._unbind(),this._deactivate(),this._inertialPan(t);break;case"pending":this._state="enabled",this._unbind();}},Io.prototype._onTouchEnd=function(t){if(t.touches&&0!==t.touches.length)switch(this._state){case"pending":case"active":break;case"enabled":this.onTouchStart(t);}else switch(this._state){case"active":this._state="enabled",this._unbind(),this._deactivate(),this._inertialPan(t);break;case"pending":this._state="enabled",this._unbind();break;case"enabled":this._unbind();}},Io.prototype._abort=function(e){switch(this._state){case"active":this._state="enabled",this._shouldStart||(this._fireEvent("dragend",e),this._fireEvent("moveend",e)),this._unbind(),this._deactivate(),t.window.TouchEvent&&e instanceof t.window.TouchEvent&&e.touches.length>1&&i.addEventListener(t.window.document,"touchend",this._onTouchEnd);break;case"pending":this._state="enabled",this._unbind();break;case"enabled":this._unbind();}},Io.prototype._onBlur=function(t){this._abort(t);},Io.prototype._unbind=function(){i.removeEventListener(t.window.document,"touchmove",this._onMove,{capture:!0,passive:!1}),i.removeEventListener(t.window.document,"touchend",this._onTouchEnd),i.removeEventListener(t.window.document,"mousemove",this._onMove,{capture:!0}),i.removeEventListener(t.window.document,"mouseup",this._onMouseUp),i.removeEventListener(t.window,"blur",this._onBlur);},Io.prototype._deactivate=function(){this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),delete this._lastMoveEvent,delete this._startPos,delete this._prevPos,delete this._mouseDownPos,delete this._lastPos,delete this._startTouch,delete this._lastTouch,delete this._shouldStart;},Io.prototype._inertialPan=function(t){this._fireEvent("dragend",t),this._drainInertiaBuffer();var e=this._inertia;if(e.length<2)this._fireEvent("moveend",t);else{var i=e[e.length-1],o=e[0],r=i[1].sub(o[1]),a=(i[0]-o[0])/1e3;if(0===a||i[1].equals(o[1]))this._fireEvent("moveend",t);else{var n=r.mult(.3/a),s=n.mag();s>1400&&(s=1400,n._unit()._mult(s));var l=s/750,c=n.mult(-l/2);this._map.panBy(c,{duration:1e3*l,easing:To,noMoveStart:!0},{originalEvent:t});}}},Io.prototype._fireEvent=function(e,i){return this._map.fire(new t.Event(e,i?{originalEvent:i}:{}))},Io.prototype._drainInertiaBuffer=function(){for(var e=this._inertia,i=t.browser.now();e.length>0&&i-e[0][0]>160;)e.shift();};var Co=function(e){this._map=e,this._el=e.getCanvasContainer(),t.bindAll(["_onKeyDown"],this);};function So(t){return t*(2-t)}Co.prototype.isEnabled=function(){return !!this._enabled},Co.prototype.enable=function(){this.isEnabled()||(this._el.addEventListener("keydown",this._onKeyDown,!1),this._enabled=!0);},Co.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("keydown",this._onKeyDown),this._enabled=!1);},Co.prototype._onKeyDown=function(t){if(!(t.altKey||t.ctrlKey||t.metaKey)){var e=0,i=0,o=0,r=0,a=0;switch(t.keyCode){case 61:case 107:case 171:case 187:e=1;break;case 189:case 109:case 173:e=-1;break;case 37:t.shiftKey?i=-1:(t.preventDefault(),r=-1);break;case 39:t.shiftKey?i=1:(t.preventDefault(),r=1);break;case 38:t.shiftKey?o=1:(t.preventDefault(),a=-1);break;case 40:t.shiftKey?o=-1:(a=1,t.preventDefault());break;default:return}var n=this._map,s=n.getZoom(),l={duration:300,delayEndEvents:500,easing:So,zoom:e?Math.round(s)+e*(t.shiftKey?2:1):s,bearing:n.getBearing()+15*i,pitch:n.getPitch()+10*o,offset:[100*-r,100*-a],center:n.getCenter()};n.easeTo(l,{originalEvent:t});}};var Po=function(e){this._map=e,t.bindAll(["_onDblClick","_onZoomEnd"],this);};Po.prototype.isEnabled=function(){return !!this._enabled},Po.prototype.isActive=function(){return !!this._active},Po.prototype.enable=function(){this.isEnabled()||(this._enabled=!0);},Po.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},Po.prototype.onTouchStart=function(t){var e=this;if(this.isEnabled()&&!(t.points.length>1))if(this._tapped){var i=t.points[0],o=this._tappedPoint;if(o&&o.dist(i)<=30){t.originalEvent.preventDefault();var r=function(){e._tapped&&e._zoom(t),e._map.off("touchcancel",a),e._resetTapped();},a=function(){e._map.off("touchend",r),e._resetTapped();};this._map.once("touchend",r),this._map.once("touchcancel",a);}else this._resetTapped();}else this._tappedPoint=t.points[0],this._tapped=setTimeout(function(){e._tapped=null,e._tappedPoint=null;},300);},Po.prototype._resetTapped=function(){clearTimeout(this._tapped),this._tapped=null,this._tappedPoint=null;},Po.prototype.onDblClick=function(t){this.isEnabled()&&(t.originalEvent.preventDefault(),this._zoom(t));},Po.prototype._zoom=function(t){this._active=!0,this._map.on("zoomend",this._onZoomEnd),this._map.zoomTo(this._map.getZoom()+(t.originalEvent.shiftKey?-1:1),{around:t.lngLat},t);},Po.prototype._onZoomEnd=function(){this._active=!1,this._map.off("zoomend",this._onZoomEnd);};var zo=t.bezier(0,0,.15,1),Lo=function(e){this._map=e,this._el=e.getCanvasContainer(),t.bindAll(["_onMove","_onEnd","_onTouchFrame"],this);};Lo.prototype.isEnabled=function(){return !!this._enabled},Lo.prototype.enable=function(t){this.isEnabled()||(this._el.classList.add("mapboxgl-touch-zoom-rotate"),this._enabled=!0,this._aroundCenter=!!t&&"center"===t.around);},Lo.prototype.disable=function(){this.isEnabled()&&(this._el.classList.remove("mapboxgl-touch-zoom-rotate"),this._enabled=!1);},Lo.prototype.disableRotation=function(){this._rotationDisabled=!0;},Lo.prototype.enableRotation=function(){this._rotationDisabled=!1;},Lo.prototype.isActive=function(){return this.isEnabled()&&!!this._gestureIntent},Lo.prototype.onStart=function(e){if(this.isEnabled()&&2===e.touches.length){var o=i.mousePos(this._el,e.touches[0]),r=i.mousePos(this._el,e.touches[1]),a=o.add(r).div(2);this._startVec=o.sub(r),this._startAround=this._map.transform.pointLocation(a),this._gestureIntent=void 0,this._inertia=[],i.addEventListener(t.window.document,"touchmove",this._onMove,{passive:!1}),i.addEventListener(t.window.document,"touchend",this._onEnd);}},Lo.prototype._getTouchEventData=function(t){var e=i.mousePos(this._el,t.touches[0]),o=i.mousePos(this._el,t.touches[1]),r=e.sub(o);return {vec:r,center:e.add(o).div(2),scale:r.mag()/this._startVec.mag(),bearing:this._rotationDisabled?0:180*r.angleWith(this._startVec)/Math.PI}},Lo.prototype._onMove=function(e){if(2===e.touches.length){var i=this._getTouchEventData(e),o=i.vec,r=i.scale,a=i.bearing;if(!this._gestureIntent){var n=this._rotationDisabled&&1!==r||Math.abs(1-r)>.15;Math.abs(a)>10?this._gestureIntent="rotate":n&&(this._gestureIntent="zoom"),this._gestureIntent&&(this._map.fire(new t.Event(this._gestureIntent+"start",{originalEvent:e})),this._map.fire(new t.Event("movestart",{originalEvent:e})),this._startVec=o);}this._lastTouchEvent=e,this._frameId||(this._frameId=this._map._requestRenderFrame(this._onTouchFrame)),e.preventDefault();}},Lo.prototype._onTouchFrame=function(){this._frameId=null;var e=this._gestureIntent;if(e){var i=this._map.transform;this._startScale||(this._startScale=i.scale,this._startBearing=i.bearing);var o=this._getTouchEventData(this._lastTouchEvent),r=o.center,a=o.bearing,n=o.scale,s=i.pointLocation(r),l=i.locationPoint(s);"rotate"===e&&(i.bearing=this._startBearing+a),i.zoom=i.scaleZoom(this._startScale*n),i.setLocationAtPoint(this._startAround,l),this._map.fire(new t.Event(e,{originalEvent:this._lastTouchEvent})),this._map.fire(new t.Event("move",{originalEvent:this._lastTouchEvent})),this._drainInertiaBuffer(),this._inertia.push([t.browser.now(),n,r]);}},Lo.prototype._onEnd=function(e){i.removeEventListener(t.window.document,"touchmove",this._onMove,{passive:!1}),i.removeEventListener(t.window.document,"touchend",this._onEnd);var o=this._gestureIntent,r=this._startScale;if(this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),delete this._gestureIntent,delete this._startScale,delete this._startBearing,delete this._lastTouchEvent,o){this._map.fire(new t.Event(o+"end",{originalEvent:e})),this._drainInertiaBuffer();var a=this._inertia,n=this._map;if(a.length<2)n.snapToNorth({},{originalEvent:e});else{var s=a[a.length-1],l=a[0],c=n.transform.scaleZoom(r*s[1]),u=n.transform.scaleZoom(r*l[1]),h=c-u,p=(s[0]-l[0])/1e3,d=s[2];if(0!==p&&c!==u){var _=.15*h/p;Math.abs(_)>2.5&&(_=_>0?2.5:-2.5);var f=1e3*Math.abs(_/(12*.15)),m=c+_*f/2e3;m<0&&(m=0),n.easeTo({zoom:m,duration:f,easing:zo,around:this._aroundCenter?n.getCenter():n.unproject(d),noMoveStart:!0},{originalEvent:e});}else n.snapToNorth({},{originalEvent:e});}}},Lo.prototype._drainInertiaBuffer=function(){for(var e=this._inertia,i=t.browser.now();e.length>2&&i-e[0][0]>160;)e.shift();};var Do={scrollZoom:xo,boxZoom:bo,dragRotate:Eo,dragPan:Io,keyboard:Co,doubleClickZoom:Po,touchZoomRotate:Lo};var Mo=function(e){function i(i,o){e.call(this),this._moving=!1,this._zooming=!1,this.transform=i,this._bearingSnap=o.bearingSnap,t.bindAll(["_renderFrameCallback"],this);}return e&&(i.__proto__=e),i.prototype=Object.create(e&&e.prototype),i.prototype.constructor=i,i.prototype.getCenter=function(){return new t.LngLat(this.transform.center.lng,this.transform.center.lat)},i.prototype.setCenter=function(t,e){return this.jumpTo({center:t},e)},i.prototype.panBy=function(e,i,o){return e=t.Point.convert(e).mult(-1),this.panTo(this.transform.center,t.extend({offset:e},i),o)},i.prototype.panTo=function(e,i,o){return this.easeTo(t.extend({center:e},i),o)},i.prototype.getZoom=function(){return this.transform.zoom},i.prototype.setZoom=function(t,e){return this.jumpTo({zoom:t},e),this},i.prototype.zoomTo=function(e,i,o){return this.easeTo(t.extend({zoom:e},i),o)},i.prototype.zoomIn=function(t,e){return this.zoomTo(this.getZoom()+1,t,e),this},i.prototype.zoomOut=function(t,e){return this.zoomTo(this.getZoom()-1,t,e),this},i.prototype.getBearing=function(){return this.transform.bearing},i.prototype.setBearing=function(t,e){return this.jumpTo({bearing:t},e),this},i.prototype.rotateTo=function(e,i,o){return this.easeTo(t.extend({bearing:e},i),o)},i.prototype.resetNorth=function(e,i){return this.rotateTo(0,t.extend({duration:1e3},e),i),this},i.prototype.resetNorthPitch=function(e,i){return this.easeTo(t.extend({bearing:0,pitch:0,duration:1e3},e),i),this},i.prototype.snapToNorth=function(t,e){return Math.abs(this.getBearing())<this._bearingSnap?this.resetNorth(t,e):this},i.prototype.getPitch=function(){return this.transform.pitch},i.prototype.setPitch=function(t,e){return this.jumpTo({pitch:t},e),this},i.prototype.cameraForBounds=function(e,i){return e=t.LngLatBounds.convert(e),this._cameraForBoxAndBearing(e.getNorthWest(),e.getSouthEast(),0,i)},i.prototype._cameraForBoxAndBearing=function(e,i,o,r){if("number"==typeof(r=t.extend({padding:{top:0,bottom:0,right:0,left:0},offset:[0,0],maxZoom:this.transform.maxZoom},r)).padding){var a=r.padding;r.padding={top:a,bottom:a,right:a,left:a};}if(t.deepEqual(Object.keys(r.padding).sort(function(t,e){return t<e?-1:t>e?1:0}),["bottom","left","right","top"])){var n=this.transform,s=n.project(t.LngLat.convert(e)),l=n.project(t.LngLat.convert(i)),c=s.rotate(-o*Math.PI/180),u=l.rotate(-o*Math.PI/180),h=new t.Point(Math.max(c.x,u.x),Math.max(c.y,u.y)),p=new t.Point(Math.min(c.x,u.x),Math.min(c.y,u.y)),d=h.sub(p),_=(n.width-r.padding.left-r.padding.right)/d.x,f=(n.height-r.padding.top-r.padding.bottom)/d.y;if(!(f<0||_<0)){var m=Math.min(n.scaleZoom(n.scale*Math.min(_,f)),r.maxZoom),g=t.Point.convert(r.offset),v=(r.padding.left-r.padding.right)/2,y=(r.padding.top-r.padding.bottom)/2,x=new t.Point(g.x+v,g.y+y).mult(n.scale/n.zoomScale(m));return {center:n.unproject(s.add(l).div(2).sub(x)),zoom:m,bearing:o}}t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");}else t.warnOnce("options.padding must be a positive number, or an Object with keys 'bottom', 'left', 'right', 'top'");},i.prototype.fitBounds=function(t,e,i){return this._fitInternal(this.cameraForBounds(t,e),e,i)},i.prototype.fitScreenCoordinates=function(e,i,o,r,a){return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)),this.transform.pointLocation(t.Point.convert(i)),o,r),r,a)},i.prototype._fitInternal=function(e,i,o){return e?(i=t.extend(e,i)).linear?this.easeTo(i,o):this.flyTo(i,o):this},i.prototype.jumpTo=function(e,i){this.stop();var o=this.transform,r=!1,a=!1,n=!1;return "zoom"in e&&o.zoom!==+e.zoom&&(r=!0,o.zoom=+e.zoom),void 0!==e.center&&(o.center=t.LngLat.convert(e.center)),"bearing"in e&&o.bearing!==+e.bearing&&(a=!0,o.bearing=+e.bearing),"pitch"in e&&o.pitch!==+e.pitch&&(n=!0,o.pitch=+e.pitch),this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),r&&this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),a&&this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),n&&this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),this.fire(new t.Event("moveend",i))},i.prototype.easeTo=function(e,i){var o=this;this.stop(),(!1===(e=t.extend({offset:[0,0],duration:500,easing:t.ease},e)).animate||t.browser.prefersReducedMotion)&&(e.duration=0);var r=this.transform,a=this.getZoom(),n=this.getBearing(),s=this.getPitch(),l="zoom"in e?+e.zoom:a,c="bearing"in e?this._normalizeBearing(e.bearing,n):n,u="pitch"in e?+e.pitch:s,h=r.centerPoint.add(t.Point.convert(e.offset)),p=r.pointLocation(h),d=t.LngLat.convert(e.center||p);this._normalizeCenter(d);var _,f,m=r.project(p),g=r.project(d).sub(m),v=r.zoomScale(l-a);return e.around&&(_=t.LngLat.convert(e.around),f=r.locationPoint(_)),this._zooming=l!==a,this._rotating=n!==c,this._pitching=u!==s,this._prepareEase(i,e.noMoveStart),clearTimeout(this._easeEndTimeoutID),this._ease(function(e){if(o._zooming&&(r.zoom=t.number(a,l,e)),o._rotating&&(r.bearing=t.number(n,c,e)),o._pitching&&(r.pitch=t.number(s,u,e)),_)r.setLocationAtPoint(_,f);else{var p=r.zoomScale(r.zoom-a),d=l>a?Math.min(2,v):Math.max(.5,v),y=Math.pow(d,1-e),x=r.unproject(m.add(g.mult(e*y)).mult(p));r.setLocationAtPoint(r.renderWorldCopies?x.wrap():x,h);}o._fireMoveEvents(i);},function(){e.delayEndEvents?o._easeEndTimeoutID=setTimeout(function(){return o._afterEase(i)},e.delayEndEvents):o._afterEase(i);},e),this},i.prototype._prepareEase=function(e,i){this._moving=!0,i||this.fire(new t.Event("movestart",e)),this._zooming&&this.fire(new t.Event("zoomstart",e)),this._rotating&&this.fire(new t.Event("rotatestart",e)),this._pitching&&this.fire(new t.Event("pitchstart",e));},i.prototype._fireMoveEvents=function(e){this.fire(new t.Event("move",e)),this._zooming&&this.fire(new t.Event("zoom",e)),this._rotating&&this.fire(new t.Event("rotate",e)),this._pitching&&this.fire(new t.Event("pitch",e));},i.prototype._afterEase=function(e){var i=this._zooming,o=this._rotating,r=this._pitching;this._moving=!1,this._zooming=!1,this._rotating=!1,this._pitching=!1,i&&this.fire(new t.Event("zoomend",e)),o&&this.fire(new t.Event("rotateend",e)),r&&this.fire(new t.Event("pitchend",e)),this.fire(new t.Event("moveend",e));},i.prototype.flyTo=function(e,i){var o=this;if(t.browser.prefersReducedMotion){var r=t.pick(e,["center","zoom","bearing","pitch","around"]);return this.jumpTo(r,i)}this.stop(),e=t.extend({offset:[0,0],speed:1.2,curve:1.42,easing:t.ease},e);var a=this.transform,n=this.getZoom(),s=this.getBearing(),l=this.getPitch(),c="zoom"in e?t.clamp(+e.zoom,a.minZoom,a.maxZoom):n,u="bearing"in e?this._normalizeBearing(e.bearing,s):s,h="pitch"in e?+e.pitch:l,p=a.zoomScale(c-n),d=a.centerPoint.add(t.Point.convert(e.offset)),_=a.pointLocation(d),f=t.LngLat.convert(e.center||_);this._normalizeCenter(f);var m=a.project(_),g=a.project(f).sub(m),v=e.curve,y=Math.max(a.width,a.height),x=y/p,b=g.mag();if("minZoom"in e){var w=t.clamp(Math.min(e.minZoom,n,c),a.minZoom,a.maxZoom),E=y/a.zoomScale(w-n);v=Math.sqrt(E/b*2);}var T=v*v;function I(t){var e=(x*x-y*y+(t?-1:1)*T*T*b*b)/(2*(t?x:y)*T*b);return Math.log(Math.sqrt(e*e+1)-e)}function C(t){return (Math.exp(t)-Math.exp(-t))/2}function S(t){return (Math.exp(t)+Math.exp(-t))/2}var P=I(0),z=function(t){return S(P)/S(P+v*t)},L=function(t){return y*((S(P)*(C(e=P+v*t)/S(e))-C(P))/T)/b;var e;},D=(I(1)-P)/v;if(Math.abs(b)<1e-6||!isFinite(D)){if(Math.abs(y-x)<1e-6)return this.easeTo(e,i);var M=x<y?-1:1;D=Math.abs(Math.log(x/y))/v,L=function(){return 0},z=function(t){return Math.exp(M*v*t)};}if("duration"in e)e.duration=+e.duration;else{var R="screenSpeed"in e?+e.screenSpeed/v:+e.speed;e.duration=1e3*D/R;}return e.maxDuration&&e.duration>e.maxDuration&&(e.duration=0),this._zooming=!0,this._rotating=s!==u,this._pitching=h!==l,this._prepareEase(i,!1),this._ease(function(e){var r=e*D,p=1/z(r);a.zoom=1===e?c:n+a.scaleZoom(p),o._rotating&&(a.bearing=t.number(s,u,e)),o._pitching&&(a.pitch=t.number(l,h,e));var _=1===e?f:a.unproject(m.add(g.mult(L(r))).mult(p));a.setLocationAtPoint(a.renderWorldCopies?_.wrap():_,d),o._fireMoveEvents(i);},function(){return o._afterEase(i)},e),this},i.prototype.isEasing=function(){return !!this._easeFrameId},i.prototype.stop=function(){if(this._easeFrameId&&(this._cancelRenderFrame(this._easeFrameId),delete this._easeFrameId,delete this._onEaseFrame),this._onEaseEnd){var t=this._onEaseEnd;delete this._onEaseEnd,t.call(this);}return this},i.prototype._ease=function(e,i,o){!1===o.animate||0===o.duration?(e(1),i()):(this._easeStart=t.browser.now(),this._easeOptions=o,this._onEaseFrame=e,this._onEaseEnd=i,this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback));},i.prototype._renderFrameCallback=function(){var e=Math.min((t.browser.now()-this._easeStart)/this._easeOptions.duration,1);this._onEaseFrame(this._easeOptions.easing(e)),e<1?this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback):this.stop();},i.prototype._normalizeBearing=function(e,i){e=t.wrap(e,-180,180);var o=Math.abs(e-i);return Math.abs(e-360-i)<o&&(e-=360),Math.abs(e+360-i)<o&&(e+=360),e},i.prototype._normalizeCenter=function(t){var e=this.transform;if(e.renderWorldCopies&&!e.lngRange){var i=t.lng-e.center.lng;t.lng+=i>180?-360:i<-180?360:0;}},i}(t.Evented),Ro=function(e){void 0===e&&(e={}),this.options=e,t.bindAll(["_updateEditLink","_updateData","_updateCompact"],this);};Ro.prototype.getDefaultPosition=function(){return "bottom-right"},Ro.prototype.onAdd=function(t){var e=this.options&&this.options.compact;return this._map=t,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-attrib"),this._innerContainer=i.create("div","mapboxgl-ctrl-attrib-inner",this._container),e&&this._container.classList.add("mapboxgl-compact"),this._updateAttributions(),this._updateEditLink(),this._map.on("styledata",this._updateData),this._map.on("sourcedata",this._updateData),this._map.on("moveend",this._updateEditLink),void 0===e&&(this._map.on("resize",this._updateCompact),this._updateCompact()),this._container},Ro.prototype.onRemove=function(){i.remove(this._container),this._map.off("styledata",this._updateData),this._map.off("sourcedata",this._updateData),this._map.off("moveend",this._updateEditLink),this._map.off("resize",this._updateCompact),this._map=void 0;},Ro.prototype._updateEditLink=function(){var e=this._editLink;e||(e=this._editLink=this._container.querySelector(".mapbox-improve-map"));var i=[{key:"owner",value:this.styleOwner},{key:"id",value:this.styleId},{key:"access_token",value:this._map._requestManager._customAccessToken||t.config.ACCESS_TOKEN}];if(e){var o=i.reduce(function(t,e,o){return e.value&&(t+=e.key+"="+e.value+(o<i.length-1?"&":"")),t},"?");e.href=t.config.FEEDBACK_URL+"/"+o+(this._map._hash?this._map._hash.getHashString(!0):""),e.rel="noopener nofollow";}},Ro.prototype._updateData=function(t){!t||"metadata"!==t.sourceDataType&&"style"!==t.dataType||(this._updateAttributions(),this._updateEditLink());},Ro.prototype._updateAttributions=function(){if(this._map.style){var t=[];if(this.options.customAttribution&&(Array.isArray(this.options.customAttribution)?t=t.concat(this.options.customAttribution.map(function(t){return "string"!=typeof t?"":t})):"string"==typeof this.options.customAttribution&&t.push(this.options.customAttribution)),this._map.style.stylesheet){var e=this._map.style.stylesheet;this.styleOwner=e.owner,this.styleId=e.id;}var i=this._map.style.sourceCaches;for(var o in i){var r=i[o];if(r.used){var a=r.getSource();a.attribution&&t.indexOf(a.attribution)<0&&t.push(a.attribution);}}t.sort(function(t,e){return t.length-e.length});var n=(t=t.filter(function(e,i){for(var o=i+1;o<t.length;o++)if(t[o].indexOf(e)>=0)return !1;return !0})).join(" | ");n!==this._attribHTML&&(this._attribHTML=n,t.length?(this._innerContainer.innerHTML=n,this._container.classList.remove("mapboxgl-attrib-empty")):this._container.classList.add("mapboxgl-attrib-empty"),this._editLink=null);}},Ro.prototype._updateCompact=function(){this._map.getCanvasContainer().offsetWidth<=640?this._container.classList.add("mapboxgl-compact"):this._container.classList.remove("mapboxgl-compact");};var Ao=function(){t.bindAll(["_updateLogo"],this),t.bindAll(["_updateCompact"],this);};Ao.prototype.onAdd=function(t){this._map=t,this._container=i.create("div","mapboxgl-ctrl");var e=i.create("a","mapboxgl-ctrl-logo");return e.target="_blank",e.rel="noopener nofollow",e.href="https://www.mapbox.com/",e.setAttribute("aria-label","Mapbox logo"),e.setAttribute("rel","noopener nofollow"),this._container.appendChild(e),this._container.style.display="none",this._map.on("sourcedata",this._updateLogo),this._updateLogo(),this._map.on("resize",this._updateCompact),this._updateCompact(),this._container},Ao.prototype.onRemove=function(){i.remove(this._container),this._map.off("sourcedata",this._updateLogo),this._map.off("resize",this._updateCompact);},Ao.prototype.getDefaultPosition=function(){return "bottom-left"},Ao.prototype._updateLogo=function(t){t&&"metadata"!==t.sourceDataType||(this._container.style.display=this._logoRequired()?"block":"none");},Ao.prototype._logoRequired=function(){if(this._map.style){var t=this._map.style.sourceCaches;for(var e in t){if(t[e].getSource().mapbox_logo)return !0}return !1}},Ao.prototype._updateCompact=function(){var t=this._container.children;if(t.length){var e=t[0];this._map.getCanvasContainer().offsetWidth<250?e.classList.add("mapboxgl-compact"):e.classList.remove("mapboxgl-compact");}};var ko=function(){this._queue=[],this._id=0,this._cleared=!1,this._currentlyRunning=!1;};ko.prototype.add=function(t){var e=++this._id;return this._queue.push({callback:t,id:e,cancelled:!1}),e},ko.prototype.remove=function(t){for(var e=this._currentlyRunning,i=0,o=e?this._queue.concat(e):this._queue;i<o.length;i+=1){var r=o[i];if(r.id===t)return void(r.cancelled=!0)}},ko.prototype.run=function(){var t=this._currentlyRunning=this._queue;this._queue=[];for(var e=0,i=t;e<i.length;e+=1){var o=i[e];if(!o.cancelled&&(o.callback(),this._cleared))break}this._cleared=!1,this._currentlyRunning=!1;},ko.prototype.clear=function(){this._currentlyRunning&&(this._cleared=!0),this._queue=[];};var Bo=t.window.HTMLImageElement,Oo=t.window.HTMLElement,Fo={center:[0,0],zoom:0,bearing:0,pitch:0,minZoom:0,maxZoom:22,interactive:!0,scrollZoom:!0,boxZoom:!0,dragRotate:!0,dragPan:!0,keyboard:!0,doubleClickZoom:!0,touchZoomRotate:!0,bearingSnap:7,clickTolerance:3,hash:!1,attributionControl:!0,failIfMajorPerformanceCaveat:!1,preserveDrawingBuffer:!1,trackResize:!0,renderWorldCopies:!0,refreshExpiredTiles:!0,maxTileCacheSize:null,localIdeographFontFamily:"sans-serif",transformRequest:null,accessToken:null,fadeDuration:300,crossSourceCollisions:!0},Uo=function(o){function r(e){var r=this;if(null!=(e=t.extend({},Fo,e)).minZoom&&null!=e.maxZoom&&e.minZoom>e.maxZoom)throw new Error("maxZoom must be greater than minZoom");var a=new _o(e.minZoom,e.maxZoom,e.renderWorldCopies);if(o.call(this,a,e),this._interactive=e.interactive,this._maxTileCacheSize=e.maxTileCacheSize,this._failIfMajorPerformanceCaveat=e.failIfMajorPerformanceCaveat,this._preserveDrawingBuffer=e.preserveDrawingBuffer,this._antialias=e.antialias,this._trackResize=e.trackResize,this._bearingSnap=e.bearingSnap,this._refreshExpiredTiles=e.refreshExpiredTiles,this._fadeDuration=e.fadeDuration,this._crossSourceCollisions=e.crossSourceCollisions,this._crossFadingFactor=1,this._collectResourceTiming=e.collectResourceTiming,this._renderTaskQueue=new ko,this._controls=[],this._mapId=t.uniqueId(),this._requestManager=new t.RequestManager(e.transformRequest,e.accessToken),"string"==typeof e.container){if(this._container=t.window.document.getElementById(e.container),!this._container)throw new Error("Container '"+e.container+"' not found.")}else{if(!(e.container instanceof Oo))throw new Error("Invalid type: 'container' must be a String or HTMLElement.");this._container=e.container;}if(e.maxBounds&&this.setMaxBounds(e.maxBounds),t.bindAll(["_onWindowOnline","_onWindowResize","_contextLost","_contextRestored"],this),this._setupContainer(),this._setupPainter(),void 0===this.painter)throw new Error("Failed to initialize WebGL.");this.on("move",function(){return r._update(!1)}),this.on("moveend",function(){return r._update(!1)}),this.on("zoom",function(){return r._update(!0)}),void 0!==t.window&&(t.window.addEventListener("online",this._onWindowOnline,!1),t.window.addEventListener("resize",this._onWindowResize,!1)),function(t,e){var o=t.getCanvasContainer(),r=null,a=!1,n=null;for(var s in Do)t[s]=new Do[s](t,e),e.interactive&&e[s]&&t[s].enable(e[s]);i.addEventListener(o,"mouseout",function(e){t.fire(new go("mouseout",t,e));}),i.addEventListener(o,"mousedown",function(r){a=!0,n=i.mousePos(o,r);var s=new go("mousedown",t,r);if(t.fire(s),s.defaultPrevented)return;e.interactive&&!t.doubleClickZoom.isActive()&&t.stop();t.boxZoom.onMouseDown(r),t.boxZoom.isActive()||t.dragPan.isActive()||t.dragRotate.onMouseDown(r);t.boxZoom.isActive()||t.dragRotate.isActive()||t.dragPan.onMouseDown(r);}),i.addEventListener(o,"mouseup",function(e){var i=t.dragRotate.isActive();r&&!i&&t.fire(new go("contextmenu",t,r));r=null,a=!1,t.fire(new go("mouseup",t,e));}),i.addEventListener(o,"mousemove",function(e){if(t.dragPan.isActive())return;if(t.dragRotate.isActive())return;var i=e.target;for(;i&&i!==o;)i=i.parentNode;if(i!==o)return;t.fire(new go("mousemove",t,e));}),i.addEventListener(o,"mouseover",function(e){var i=e.target;for(;i&&i!==o;)i=i.parentNode;if(i!==o)return;t.fire(new go("mouseover",t,e));}),i.addEventListener(o,"touchstart",function(i){var o=new vo("touchstart",t,i);if(t.fire(o),o.defaultPrevented)return;e.interactive&&t.stop();t.boxZoom.isActive()||t.dragRotate.isActive()||t.dragPan.onTouchStart(i);t.touchZoomRotate.onStart(i),t.doubleClickZoom.onTouchStart(o);},{passive:!1}),i.addEventListener(o,"touchmove",function(e){t.fire(new vo("touchmove",t,e));},{passive:!1}),i.addEventListener(o,"touchend",function(e){t.fire(new vo("touchend",t,e));}),i.addEventListener(o,"touchcancel",function(e){t.fire(new vo("touchcancel",t,e));}),i.addEventListener(o,"click",function(r){var a=i.mousePos(o,r);(!n||a.equals(n)||a.dist(n)<e.clickTolerance)&&t.fire(new go("click",t,r));}),i.addEventListener(o,"dblclick",function(e){var i=new go("dblclick",t,e);if(t.fire(i),i.defaultPrevented)return;t.doubleClickZoom.onDblClick(i);}),i.addEventListener(o,"contextmenu",function(e){var i=t.dragRotate.isActive();a||i?a&&(r=e):t.fire(new go("contextmenu",t,e));(t.dragRotate.isEnabled()||t.listens("contextmenu"))&&e.preventDefault();}),i.addEventListener(o,"wheel",function(i){e.interactive&&t.stop();var o=new yo("wheel",t,i);if(t.fire(o),o.defaultPrevented)return;t.scrollZoom.onWheel(i);},{passive:!1});}(this,e),this._hash=e.hash&&(new mo).addTo(this),this._hash&&this._hash._onHashChange()||(this.jumpTo({center:e.center,zoom:e.zoom,bearing:e.bearing,pitch:e.pitch}),e.bounds&&(this.resize(),this.fitBounds(e.bounds,t.extend({},e.fitBoundsOptions,{duration:0})))),this.resize(),this._localIdeographFontFamily=e.localIdeographFontFamily,e.style&&this.setStyle(e.style,{localIdeographFontFamily:e.localIdeographFontFamily}),e.attributionControl&&this.addControl(new Ro({customAttribution:e.customAttribution})),this.addControl(new Ao,e.logoPosition),this.on("style.load",function(){r.transform.unmodified&&r.jumpTo(r.style.stylesheet);}),this.on("data",function(e){r._update("style"===e.dataType),r.fire(new t.Event(e.dataType+"data",e));}),this.on("dataloading",function(e){r.fire(new t.Event(e.dataType+"dataloading",e));});}o&&(r.__proto__=o),r.prototype=Object.create(o&&o.prototype),r.prototype.constructor=r;var a={showTileBoundaries:{configurable:!0},showCollisionBoxes:{configurable:!0},showOverdrawInspector:{configurable:!0},repaint:{configurable:!0},vertices:{configurable:!0},version:{configurable:!0}};return r.prototype._getMapId=function(){return this._mapId},r.prototype.addControl=function(e,i){if(void 0===i&&e.getDefaultPosition&&(i=e.getDefaultPosition()),void 0===i&&(i="top-right"),!e||!e.onAdd)return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));var o=e.onAdd(this);this._controls.push(e);var r=this._controlPositions[i];return -1!==i.indexOf("bottom")?r.insertBefore(o,r.firstChild):r.appendChild(o),this},r.prototype.removeControl=function(e){if(!e||!e.onRemove)return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));var i=this._controls.indexOf(e);return i>-1&&this._controls.splice(i,1),e.onRemove(this),this},r.prototype.resize=function(e){var i=this._containerDimensions(),o=i[0],r=i[1];return this._resizeCanvas(o,r),this.transform.resize(o,r),this.painter.resize(o,r),this.fire(new t.Event("movestart",e)).fire(new t.Event("move",e)).fire(new t.Event("resize",e)).fire(new t.Event("moveend",e)),this},r.prototype.getBounds=function(){return this.transform.getBounds()},r.prototype.getMaxBounds=function(){return this.transform.getMaxBounds()},r.prototype.setMaxBounds=function(e){return this.transform.setMaxBounds(t.LngLatBounds.convert(e)),this._update()},r.prototype.setMinZoom=function(t){if((t=null==t?0:t)>=0&&t<=this.transform.maxZoom)return this.transform.minZoom=t,this._update(),this.getZoom()<t&&this.setZoom(t),this;throw new Error("minZoom must be between 0 and the current maxZoom, inclusive")},r.prototype.getMinZoom=function(){return this.transform.minZoom},r.prototype.setMaxZoom=function(t){if((t=null==t?22:t)>=this.transform.minZoom)return this.transform.maxZoom=t,this._update(),this.getZoom()>t&&this.setZoom(t),this;throw new Error("maxZoom must be greater than the current minZoom")},r.prototype.getMaxZoom=function(){return this.transform.maxZoom},r.prototype.getRenderWorldCopies=function(){return this.transform.renderWorldCopies},r.prototype.setRenderWorldCopies=function(t){return this.transform.renderWorldCopies=t,this._update()},r.prototype.project=function(e){return this.transform.locationPoint(t.LngLat.convert(e))},r.prototype.unproject=function(e){return this.transform.pointLocation(t.Point.convert(e))},r.prototype.isMoving=function(){return this._moving||this.dragPan.isActive()||this.dragRotate.isActive()||this.scrollZoom.isActive()},r.prototype.isZooming=function(){return this._zooming||this.scrollZoom.isZooming()},r.prototype.isRotating=function(){return this._rotating||this.dragRotate.isActive()},r.prototype.on=function(t,e,i){var r=this;if(void 0===i)return o.prototype.on.call(this,t,e);var a=function(){var o;if("mouseenter"===t||"mouseover"===t){var a=!1;return {layer:e,listener:i,delegates:{mousemove:function(o){var n=r.getLayer(e)?r.queryRenderedFeatures(o.point,{layers:[e]}):[];n.length?a||(a=!0,i.call(r,new go(t,r,o.originalEvent,{features:n}))):a=!1;},mouseout:function(){a=!1;}}}}if("mouseleave"===t||"mouseout"===t){var n=!1;return {layer:e,listener:i,delegates:{mousemove:function(o){(r.getLayer(e)?r.queryRenderedFeatures(o.point,{layers:[e]}):[]).length?n=!0:n&&(n=!1,i.call(r,new go(t,r,o.originalEvent)));},mouseout:function(e){n&&(n=!1,i.call(r,new go(t,r,e.originalEvent)));}}}}return {layer:e,listener:i,delegates:(o={},o[t]=function(t){var o=r.getLayer(e)?r.queryRenderedFeatures(t.point,{layers:[e]}):[];o.length&&(t.features=o,i.call(r,t),delete t.features);},o)}}();for(var n in this._delegatedListeners=this._delegatedListeners||{},this._delegatedListeners[t]=this._delegatedListeners[t]||[],this._delegatedListeners[t].push(a),a.delegates)this.on(n,a.delegates[n]);return this},r.prototype.off=function(t,e,i){if(void 0===i)return o.prototype.off.call(this,t,e);if(this._delegatedListeners&&this._delegatedListeners[t])for(var r=this._delegatedListeners[t],a=0;a<r.length;a++){var n=r[a];if(n.layer===e&&n.listener===i){for(var s in n.delegates)this.off(s,n.delegates[s]);return r.splice(a,1),this}}return this},r.prototype.queryRenderedFeatures=function(e,i){if(!this.style)return [];var o;if(void 0!==i||void 0===e||e instanceof t.Point||Array.isArray(e)||(i=e,e=void 0),i=i||{},(e=e||[[0,0],[this.transform.width,this.transform.height]])instanceof t.Point||"number"==typeof e[0])o=[t.Point.convert(e)];else{var r=t.Point.convert(e[0]),a=t.Point.convert(e[1]);o=[r,new t.Point(a.x,r.y),a,new t.Point(r.x,a.y),r];}return this.style.queryRenderedFeatures(o,i,this.transform)},r.prototype.querySourceFeatures=function(t,e){return this.style.querySourceFeatures(t,e)},r.prototype.setStyle=function(e,i){return !1!==(i=t.extend({},{localIdeographFontFamily:this._localIdeographFontFamily},i)).diff&&i.localIdeographFontFamily===this._localIdeographFontFamily&&this.style&&e?(this._diffStyle(e,i),this):(this._localIdeographFontFamily=i.localIdeographFontFamily,this._updateStyle(e,i))},r.prototype._updateStyle=function(t,e){return this.style&&(this.style.setEventedParent(null),this.style._remove()),t?(this.style=new Fe(this,e||{}),this.style.setEventedParent(this,{style:this.style}),"string"==typeof t?this.style.loadURL(t):this.style.loadJSON(t),this):(delete this.style,this)},r.prototype._diffStyle=function(e,i){var o=this;if("string"==typeof e){var r=this._requestManager.normalizeStyleURL(e),a=this._requestManager.transformRequest(r,t.ResourceType.Style);t.getJSON(a,function(e,r){e?o.fire(new t.ErrorEvent(e)):r&&o._updateDiff(r,i);});}else"object"==typeof e&&this._updateDiff(e,i);},r.prototype._updateDiff=function(e,i){try{this.style.setState(e)&&this._update(!0);}catch(o){t.warnOnce("Unable to perform style diff: "+(o.message||o.error||o)+".  Rebuilding the style from scratch."),this._updateStyle(e,i);}},r.prototype.getStyle=function(){if(this.style)return this.style.serialize()},r.prototype.isStyleLoaded=function(){return this.style?this.style.loaded():t.warnOnce("There is no style added to the map.")},r.prototype.addSource=function(t,e){return this.style.addSource(t,e),this._update(!0)},r.prototype.isSourceLoaded=function(e){var i=this.style&&this.style.sourceCaches[e];if(void 0!==i)return i.loaded();this.fire(new t.ErrorEvent(new Error("There is no source with ID '"+e+"'")));},r.prototype.areTilesLoaded=function(){var t=this.style&&this.style.sourceCaches;for(var e in t){var i=t[e]._tiles;for(var o in i){var r=i[o];if("loaded"!==r.state&&"errored"!==r.state)return !1}}return !0},r.prototype.addSourceType=function(t,e,i){return this.style.addSourceType(t,e,i)},r.prototype.removeSource=function(t){return this.style.removeSource(t),this._update(!0)},r.prototype.getSource=function(t){return this.style.getSource(t)},r.prototype.addImage=function(e,i,o){void 0===o&&(o={});var r=o.pixelRatio;void 0===r&&(r=1);var a=o.sdf;void 0===a&&(a=!1);if(i instanceof Bo){var n=t.browser.getImageData(i),s=n.width,l=n.height,c=n.data;this.style.addImage(e,{data:new t.RGBAImage({width:s,height:l},c),pixelRatio:r,sdf:a,version:0});}else{if(void 0===i.width||void 0===i.height)return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));var u=i.width,h=i.height,p=i.data,d=i;this.style.addImage(e,{data:new t.RGBAImage({width:u,height:h},new Uint8Array(p)),pixelRatio:r,sdf:a,version:0,userImage:d}),d.onAdd&&d.onAdd(this,e);}},r.prototype.updateImage=function(e,i){var o=this.style.getImage(e);if(!o)return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));var r=i instanceof Bo?t.browser.getImageData(i):i,a=r.width,n=r.height,s=r.data;if(void 0===a||void 0===n)return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));if(a!==o.data.width||n!==o.data.height)return this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));var l=!(i instanceof Bo);o.data.replace(s,l),this.style.updateImage(e,o);},r.prototype.hasImage=function(e){return e?!!this.style.getImage(e):(this.fire(new t.ErrorEvent(new Error("Missing required image id"))),!1)},r.prototype.removeImage=function(t){this.style.removeImage(t);},r.prototype.loadImage=function(e,i){t.getImage(this._requestManager.transformRequest(e,t.ResourceType.Image),i);},r.prototype.listImages=function(){return this.style.listImages()},r.prototype.addLayer=function(t,e){return this.style.addLayer(t,e),this._update(!0)},r.prototype.moveLayer=function(t,e){return this.style.moveLayer(t,e),this._update(!0)},r.prototype.removeLayer=function(t){return this.style.removeLayer(t),this._update(!0)},r.prototype.getLayer=function(t){return this.style.getLayer(t)},r.prototype.setLayerZoomRange=function(t,e,i){return this.style.setLayerZoomRange(t,e,i),this._update(!0)},r.prototype.setFilter=function(t,e,i){return void 0===i&&(i={}),this.style.setFilter(t,e,i),this._update(!0)},r.prototype.getFilter=function(t){return this.style.getFilter(t)},r.prototype.setPaintProperty=function(t,e,i,o){return void 0===o&&(o={}),this.style.setPaintProperty(t,e,i,o),this._update(!0)},r.prototype.getPaintProperty=function(t,e){return this.style.getPaintProperty(t,e)},r.prototype.setLayoutProperty=function(t,e,i,o){return void 0===o&&(o={}),this.style.setLayoutProperty(t,e,i,o),this._update(!0)},r.prototype.getLayoutProperty=function(t,e){return this.style.getLayoutProperty(t,e)},r.prototype.setLight=function(t,e){return void 0===e&&(e={}),this.style.setLight(t,e),this._update(!0)},r.prototype.getLight=function(){return this.style.getLight()},r.prototype.setFeatureState=function(t,e){return this.style.setFeatureState(t,e),this._update()},r.prototype.removeFeatureState=function(t,e){return this.style.removeFeatureState(t,e),this._update()},r.prototype.getFeatureState=function(t){return this.style.getFeatureState(t)},r.prototype.getContainer=function(){return this._container},r.prototype.getCanvasContainer=function(){return this._canvasContainer},r.prototype.getCanvas=function(){return this._canvas},r.prototype._containerDimensions=function(){var t=0,e=0;return this._container&&(t=this._container.clientWidth||400,e=this._container.clientHeight||300),[t,e]},r.prototype._detectMissingCSS=function(){"rgb(250, 128, 114)"!==t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color")&&t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");},r.prototype._setupContainer=function(){var t=this._container;t.classList.add("mapboxgl-map"),(this._missingCSSCanary=i.create("div","mapboxgl-canary",t)).style.visibility="hidden",this._detectMissingCSS();var e=this._canvasContainer=i.create("div","mapboxgl-canvas-container",t);this._interactive&&e.classList.add("mapboxgl-interactive"),this._canvas=i.create("canvas","mapboxgl-canvas",e),this._canvas.style.position="absolute",this._canvas.addEventListener("webglcontextlost",this._contextLost,!1),this._canvas.addEventListener("webglcontextrestored",this._contextRestored,!1),this._canvas.setAttribute("tabindex","0"),this._canvas.setAttribute("aria-label","Map");var o=this._containerDimensions();this._resizeCanvas(o[0],o[1]);var r=this._controlContainer=i.create("div","mapboxgl-control-container",t),a=this._controlPositions={};["top-left","top-right","bottom-left","bottom-right"].forEach(function(t){a[t]=i.create("div","mapboxgl-ctrl-"+t,r);});},r.prototype._resizeCanvas=function(e,i){var o=t.window.devicePixelRatio||1;this._canvas.width=o*e,this._canvas.height=o*i,this._canvas.style.width=e+"px",this._canvas.style.height=i+"px";},r.prototype._setupPainter=function(){var i=t.extend({},e.webGLContextAttributes,{failIfMajorPerformanceCaveat:this._failIfMajorPerformanceCaveat,preserveDrawingBuffer:this._preserveDrawingBuffer,antialias:this._antialias||!1}),o=this._canvas.getContext("webgl",i)||this._canvas.getContext("experimental-webgl",i);o?(this.painter=new co(o,this.transform),t.webpSupported.testSupport(o)):this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));},r.prototype._contextLost=function(e){e.preventDefault(),this._frame&&(this._frame.cancel(),this._frame=null),this.fire(new t.Event("webglcontextlost",{originalEvent:e}));},r.prototype._contextRestored=function(e){this._setupPainter(),this.resize(),this._update(),this.fire(new t.Event("webglcontextrestored",{originalEvent:e}));},r.prototype.loaded=function(){return !this._styleDirty&&!this._sourcesDirty&&!!this.style&&this.style.loaded()},r.prototype._update=function(t){return this.style?(this._styleDirty=this._styleDirty||t,this._sourcesDirty=!0,this.triggerRepaint(),this):this},r.prototype._requestRenderFrame=function(t){return this._update(),this._renderTaskQueue.add(t)},r.prototype._cancelRenderFrame=function(t){this._renderTaskQueue.remove(t);},r.prototype._render=function(){this.painter.context.setDirty(),this.painter.setBaseState(),this._renderTaskQueue.run();var e=!1;if(this.style&&this._styleDirty){this._styleDirty=!1;var i=this.transform.zoom,o=t.browser.now();this.style.zoomHistory.update(i,o);var r=new t.EvaluationParameters(i,{now:o,fadeDuration:this._fadeDuration,zoomHistory:this.style.zoomHistory,transition:this.style.getTransition()}),a=r.crossFadingFactor();1===a&&a===this._crossFadingFactor||(e=!0,this._crossFadingFactor=a),this.style.update(r);}return this.style&&this._sourcesDirty&&(this._sourcesDirty=!1,this.style._updateSources(this.transform)),this._placementDirty=this.style&&this.style._updatePlacement(this.painter.transform,this.showCollisionBoxes,this._fadeDuration,this._crossSourceCollisions),this.painter.render(this.style,{showTileBoundaries:this.showTileBoundaries,showOverdrawInspector:this._showOverdrawInspector,rotating:this.isRotating(),zooming:this.isZooming(),moving:this.isMoving(),fadeDuration:this._fadeDuration}),this.fire(new t.Event("render")),this.loaded()&&!this._loaded&&(this._loaded=!0,this.fire(new t.Event("load"))),this.style&&(this.style.hasTransitions()||e)&&(this._styleDirty=!0),this.style&&!this._placementDirty&&this.style._releaseSymbolFadeTiles(),this._sourcesDirty||this._repaint||this._styleDirty||this._placementDirty?this.triggerRepaint():!this.isMoving()&&this.loaded()&&this.fire(new t.Event("idle")),this},r.prototype.remove=function(){this._hash&&this._hash.remove();for(var e=0,i=this._controls;e<i.length;e+=1){i[e].onRemove(this);}this._controls=[],this._frame&&(this._frame.cancel(),this._frame=null),this._renderTaskQueue.clear(),this.setStyle(null),void 0!==t.window&&(t.window.removeEventListener("resize",this._onWindowResize,!1),t.window.removeEventListener("online",this._onWindowOnline,!1));var o=this.painter.context.gl.getExtension("WEBGL_lose_context");o&&o.loseContext(),No(this._canvasContainer),No(this._controlContainer),No(this._missingCSSCanary),this._container.classList.remove("mapboxgl-map"),this.fire(new t.Event("remove"));},r.prototype.triggerRepaint=function(){var e=this;this.style&&!this._frame&&(this._frame=t.browser.frame(function(){e._frame=null,e._render();}));},r.prototype._onWindowOnline=function(){this._update();},r.prototype._onWindowResize=function(t){this._trackResize&&this.resize({originalEvent:t})._update();},a.showTileBoundaries.get=function(){return !!this._showTileBoundaries},a.showTileBoundaries.set=function(t){this._showTileBoundaries!==t&&(this._showTileBoundaries=t,this._update());},a.showCollisionBoxes.get=function(){return !!this._showCollisionBoxes},a.showCollisionBoxes.set=function(t){this._showCollisionBoxes!==t&&(this._showCollisionBoxes=t,t?this.style._generateCollisionBoxes():this._update());},a.showOverdrawInspector.get=function(){return !!this._showOverdrawInspector},a.showOverdrawInspector.set=function(t){this._showOverdrawInspector!==t&&(this._showOverdrawInspector=t,this._update());},a.repaint.get=function(){return !!this._repaint},a.repaint.set=function(t){this._repaint!==t&&(this._repaint=t,this.triggerRepaint());},a.vertices.get=function(){return !!this._vertices},a.vertices.set=function(t){this._vertices=t,this._update();},r.prototype._setCacheLimits=function(e,i){t.setCacheLimits(e,i);},a.version.get=function(){return t.version},Object.defineProperties(r.prototype,a),r}(Mo);function No(t){t.parentNode&&t.parentNode.removeChild(t);}var Zo={showCompass:!0,showZoom:!0,visualizePitch:!1},Vo=function(e){var o=this;this.options=t.extend({},Zo,e),this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._container.addEventListener("contextmenu",function(t){return t.preventDefault()}),this.options.showZoom&&(t.bindAll(["_updateZoomButtons"],this),this._zoomInButton=this._createButton("mapboxgl-ctrl-icon mapboxgl-ctrl-zoom-in","Zoom in",function(t){return o._map.zoomIn({},{originalEvent:t})}),this._zoomOutButton=this._createButton("mapboxgl-ctrl-icon mapboxgl-ctrl-zoom-out","Zoom out",function(t){return o._map.zoomOut({},{originalEvent:t})})),this.options.showCompass&&(t.bindAll(["_rotateCompassArrow"],this),this._compass=this._createButton("mapboxgl-ctrl-icon mapboxgl-ctrl-compass","Reset bearing to north",function(t){o.options.visualizePitch?o._map.resetNorthPitch({},{originalEvent:t}):o._map.resetNorth({},{originalEvent:t});}),this._compassArrow=i.create("span","mapboxgl-ctrl-compass-arrow",this._compass));};function qo(e,i,o){if(e=new t.LngLat(e.lng,e.lat),i){var r=new t.LngLat(e.lng-360,e.lat),a=new t.LngLat(e.lng+360,e.lat),n=o.locationPoint(e).distSqr(i);o.locationPoint(r).distSqr(i)<n?e=r:o.locationPoint(a).distSqr(i)<n&&(e=a);}for(;Math.abs(e.lng-o.center.lng)>180;){var s=o.locationPoint(e);if(s.x>=0&&s.y>=0&&s.x<=o.width&&s.y<=o.height)break;e.lng>o.center.lng?e.lng-=360:e.lng+=360;}return e}Vo.prototype._updateZoomButtons=function(){var t=this._map.getZoom();t===this._map.getMaxZoom()?this._zoomInButton.classList.add("mapboxgl-ctrl-icon-disabled"):this._zoomInButton.classList.remove("mapboxgl-ctrl-icon-disabled"),t===this._map.getMinZoom()?this._zoomOutButton.classList.add("mapboxgl-ctrl-icon-disabled"):this._zoomOutButton.classList.remove("mapboxgl-ctrl-icon-disabled");},Vo.prototype._rotateCompassArrow=function(){var t=this.options.visualizePitch?"scale("+1/Math.pow(Math.cos(this._map.transform.pitch*(Math.PI/180)),.5)+") rotateX("+this._map.transform.pitch+"deg) rotateZ("+this._map.transform.angle*(180/Math.PI)+"deg)":"rotate("+this._map.transform.angle*(180/Math.PI)+"deg)";this._compassArrow.style.transform=t;},Vo.prototype.onAdd=function(t){return this._map=t,this.options.showZoom&&(this._map.on("zoom",this._updateZoomButtons),this._updateZoomButtons()),this.options.showCompass&&(this.options.visualizePitch&&this._map.on("pitch",this._rotateCompassArrow),this._map.on("rotate",this._rotateCompassArrow),this._rotateCompassArrow(),this._handler=new Eo(t,{button:"left",element:this._compass}),i.addEventListener(this._compass,"mousedown",this._handler.onMouseDown),i.addEventListener(this._compass,"touchstart",this._handler.onMouseDown,{passive:!1}),this._handler.enable()),this._container},Vo.prototype.onRemove=function(){i.remove(this._container),this.options.showZoom&&this._map.off("zoom",this._updateZoomButtons),this.options.showCompass&&(this.options.visualizePitch&&this._map.off("pitch",this._rotateCompassArrow),this._map.off("rotate",this._rotateCompassArrow),i.removeEventListener(this._compass,"mousedown",this._handler.onMouseDown),i.removeEventListener(this._compass,"touchstart",this._handler.onMouseDown,{passive:!1}),this._handler.disable(),delete this._handler),delete this._map;},Vo.prototype._createButton=function(t,e,o){var r=i.create("button",t,this._container);return r.type="button",r.title=e,r.setAttribute("aria-label",e),r.addEventListener("click",o),r};var jo={center:"translate(-50%,-50%)",top:"translate(-50%,0)","top-left":"translate(0,0)","top-right":"translate(-100%,0)",bottom:"translate(-50%,-100%)","bottom-left":"translate(0,-100%)","bottom-right":"translate(-100%,-100%)",left:"translate(0,-50%)",right:"translate(-100%,-50%)"};function Go(t,e,i){var o=t.classList;for(var r in jo)o.remove("mapboxgl-"+i+"-anchor-"+r);o.add("mapboxgl-"+i+"-anchor-"+e);}var Wo,Xo=function(e){function o(o,r){if(e.call(this),(o instanceof t.window.HTMLElement||r)&&(o=t.extend({element:o},r)),t.bindAll(["_update","_onMove","_onUp","_addDragHandler","_onMapClick"],this),this._anchor=o&&o.anchor||"center",this._color=o&&o.color||"#3FB1CE",this._draggable=o&&o.draggable||!1,this._state="inactive",o&&o.element)this._element=o.element,this._offset=t.Point.convert(o&&o.offset||[0,0]);else{this._defaultMarker=!0,this._element=i.create("div");var a=i.createNS("http://www.w3.org/2000/svg","svg");a.setAttributeNS(null,"display","block"),a.setAttributeNS(null,"height","41px"),a.setAttributeNS(null,"width","27px"),a.setAttributeNS(null,"viewBox","0 0 27 41");var n=i.createNS("http://www.w3.org/2000/svg","g");n.setAttributeNS(null,"stroke","none"),n.setAttributeNS(null,"stroke-width","1"),n.setAttributeNS(null,"fill","none"),n.setAttributeNS(null,"fill-rule","evenodd");var s=i.createNS("http://www.w3.org/2000/svg","g");s.setAttributeNS(null,"fill-rule","nonzero");var l=i.createNS("http://www.w3.org/2000/svg","g");l.setAttributeNS(null,"transform","translate(3.0, 29.0)"),l.setAttributeNS(null,"fill","#000000");for(var c=0,u=[{rx:"10.5",ry:"5.25002273"},{rx:"10.5",ry:"5.25002273"},{rx:"9.5",ry:"4.77275007"},{rx:"8.5",ry:"4.29549936"},{rx:"7.5",ry:"3.81822308"},{rx:"6.5",ry:"3.34094679"},{rx:"5.5",ry:"2.86367051"},{rx:"4.5",ry:"2.38636864"}];c<u.length;c+=1){var h=u[c],p=i.createNS("http://www.w3.org/2000/svg","ellipse");p.setAttributeNS(null,"opacity","0.04"),p.setAttributeNS(null,"cx","10.5"),p.setAttributeNS(null,"cy","5.80029008"),p.setAttributeNS(null,"rx",h.rx),p.setAttributeNS(null,"ry",h.ry),l.appendChild(p);}var d=i.createNS("http://www.w3.org/2000/svg","g");d.setAttributeNS(null,"fill",this._color);var _=i.createNS("http://www.w3.org/2000/svg","path");_.setAttributeNS(null,"d","M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"),d.appendChild(_);var f=i.createNS("http://www.w3.org/2000/svg","g");f.setAttributeNS(null,"opacity","0.25"),f.setAttributeNS(null,"fill","#000000");var m=i.createNS("http://www.w3.org/2000/svg","path");m.setAttributeNS(null,"d","M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"),f.appendChild(m);var g=i.createNS("http://www.w3.org/2000/svg","g");g.setAttributeNS(null,"transform","translate(6.0, 7.0)"),g.setAttributeNS(null,"fill","#FFFFFF");var v=i.createNS("http://www.w3.org/2000/svg","g");v.setAttributeNS(null,"transform","translate(8.0, 8.0)");var y=i.createNS("http://www.w3.org/2000/svg","circle");y.setAttributeNS(null,"fill","#000000"),y.setAttributeNS(null,"opacity","0.25"),y.setAttributeNS(null,"cx","5.5"),y.setAttributeNS(null,"cy","5.5"),y.setAttributeNS(null,"r","5.4999962");var x=i.createNS("http://www.w3.org/2000/svg","circle");x.setAttributeNS(null,"fill","#FFFFFF"),x.setAttributeNS(null,"cx","5.5"),x.setAttributeNS(null,"cy","5.5"),x.setAttributeNS(null,"r","5.4999962"),v.appendChild(y),v.appendChild(x),s.appendChild(l),s.appendChild(d),s.appendChild(f),s.appendChild(g),s.appendChild(v),a.appendChild(s),this._element.appendChild(a),this._offset=t.Point.convert(o&&o.offset||[0,-14]);}this._element.classList.add("mapboxgl-marker"),this._element.addEventListener("dragstart",function(t){t.preventDefault();}),Go(this._element,this._anchor,"marker"),this._popup=null;}return e&&(o.__proto__=e),o.prototype=Object.create(e&&e.prototype),o.prototype.constructor=o,o.prototype.addTo=function(t){return this.remove(),this._map=t,t.getCanvasContainer().appendChild(this._element),t.on("move",this._update),t.on("moveend",this._update),this.setDraggable(this._draggable),this._update(),this._map.on("click",this._onMapClick),this},o.prototype.remove=function(){return this._map&&(this._map.off("click",this._onMapClick),this._map.off("move",this._update),this._map.off("moveend",this._update),this._map.off("mousedown",this._addDragHandler),this._map.off("touchstart",this._addDragHandler),this._map.off("mouseup",this._onUp),this._map.off("touchend",this._onUp),this._map.off("mousemove",this._onMove),this._map.off("touchmove",this._onMove),delete this._map),i.remove(this._element),this._popup&&this._popup.remove(),this},o.prototype.getLngLat=function(){return this._lngLat},o.prototype.setLngLat=function(e){return this._lngLat=t.LngLat.convert(e),this._pos=null,this._popup&&this._popup.setLngLat(this._lngLat),this._update(),this},o.prototype.getElement=function(){return this._element},o.prototype.setPopup=function(t){if(this._popup&&(this._popup.remove(),this._popup=null),t){if(!("offset"in t.options)){var e=Math.sqrt(Math.pow(13.5,2)/2);t.options.offset=this._defaultMarker?{top:[0,0],"top-left":[0,0],"top-right":[0,0],bottom:[0,-38.1],"bottom-left":[e,-1*(24.6+e)],"bottom-right":[-e,-1*(24.6+e)],left:[13.5,-24.6],right:[-13.5,-24.6]}:this._offset;}this._popup=t,this._lngLat&&this._popup.setLngLat(this._lngLat);}return this},o.prototype._onMapClick=function(t){var e=t.originalEvent.target,i=this._element;this._popup&&(e===i||i.contains(e))&&this.togglePopup();},o.prototype.getPopup=function(){return this._popup},o.prototype.togglePopup=function(){var t=this._popup;return t?(t.isOpen()?t.remove():t.addTo(this._map),this):this},o.prototype._update=function(t){this._map&&(this._map.transform.renderWorldCopies&&(this._lngLat=qo(this._lngLat,this._pos,this._map.transform)),this._pos=this._map.project(this._lngLat)._add(this._offset),t&&"moveend"!==t.type||(this._pos=this._pos.round()),i.setTransform(this._element,jo[this._anchor]+" translate("+this._pos.x+"px, "+this._pos.y+"px)"));},o.prototype.getOffset=function(){return this._offset},o.prototype.setOffset=function(e){return this._offset=t.Point.convert(e),this._update(),this},o.prototype._onMove=function(e){this._pos=e.point.sub(this._positionDelta),this._lngLat=this._map.unproject(this._pos),this.setLngLat(this._lngLat),this._element.style.pointerEvents="none","pending"===this._state&&(this._state="active",this.fire(new t.Event("dragstart"))),this.fire(new t.Event("drag"));},o.prototype._onUp=function(){this._element.style.pointerEvents="auto",this._positionDelta=null,this._map.off("mousemove",this._onMove),this._map.off("touchmove",this._onMove),"active"===this._state&&this.fire(new t.Event("dragend")),this._state="inactive";},o.prototype._addDragHandler=function(t){this._element.contains(t.originalEvent.target)&&(t.preventDefault(),this._positionDelta=t.point.sub(this._pos).add(this._offset),this._state="pending",this._map.on("mousemove",this._onMove),this._map.on("touchmove",this._onMove),this._map.once("mouseup",this._onUp),this._map.once("touchend",this._onUp));},o.prototype.setDraggable=function(t){return this._draggable=!!t,this._map&&(t?(this._map.on("mousedown",this._addDragHandler),this._map.on("touchstart",this._addDragHandler)):(this._map.off("mousedown",this._addDragHandler),this._map.off("touchstart",this._addDragHandler))),this},o.prototype.isDraggable=function(){return this._draggable},o}(t.Evented),Ho={positionOptions:{enableHighAccuracy:!1,maximumAge:0,timeout:6e3},fitBoundsOptions:{maxZoom:15},trackUserLocation:!1,showUserLocation:!0};var Ko=function(e){function o(i){e.call(this),this.options=t.extend({},Ho,i),t.bindAll(["_onSuccess","_onError","_finish","_setupUI","_updateCamera","_updateMarker"],this);}return e&&(o.__proto__=e),o.prototype=Object.create(e&&e.prototype),o.prototype.constructor=o,o.prototype.onAdd=function(e){var o;return this._map=e,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),o=this._setupUI,void 0!==Wo?o(Wo):void 0!==t.window.navigator.permissions?t.window.navigator.permissions.query({name:"geolocation"}).then(function(t){Wo="denied"!==t.state,o(Wo);}):(Wo=!!t.window.navigator.geolocation,o(Wo)),this._container},o.prototype.onRemove=function(){void 0!==this._geolocationWatchID&&(t.window.navigator.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0),this.options.showUserLocation&&this._userLocationDotMarker&&this._userLocationDotMarker.remove(),i.remove(this._container),this._map=void 0;},o.prototype._onSuccess=function(e){if(this.options.trackUserLocation)switch(this._lastKnownPosition=e,this._watchState){case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"BACKGROUND":case"BACKGROUND_ERROR":this._watchState="BACKGROUND",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");}this.options.showUserLocation&&"OFF"!==this._watchState&&this._updateMarker(e),this.options.trackUserLocation&&"ACTIVE_LOCK"!==this._watchState||this._updateCamera(e),this.options.showUserLocation&&this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"),this.fire(new t.Event("geolocate",e)),this._finish();},o.prototype._updateCamera=function(e){var i=new t.LngLat(e.coords.longitude,e.coords.latitude),o=e.coords.accuracy,r=this._map.getBearing(),a=t.extend({bearing:r},this.options.fitBoundsOptions);this._map.fitBounds(i.toBounds(o),a,{geolocateSource:!0});},o.prototype._updateMarker=function(t){t?this._userLocationDotMarker.setLngLat([t.coords.longitude,t.coords.latitude]).addTo(this._map):this._userLocationDotMarker.remove();},o.prototype._onError=function(e){if(this.options.trackUserLocation)if(1===e.code)this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),void 0!==this._geolocationWatchID&&this._clearWatch();else switch(this._watchState){case"WAITING_ACTIVE":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"ACTIVE_LOCK":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");break;case"BACKGROUND":this._watchState="BACKGROUND_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");}"OFF"!==this._watchState&&this.options.showUserLocation&&this._dotElement.classList.add("mapboxgl-user-location-dot-stale"),this.fire(new t.Event("error",e)),this._finish();},o.prototype._finish=function(){this._timeoutId&&clearTimeout(this._timeoutId),this._timeoutId=void 0;},o.prototype._setupUI=function(e){var o=this;!1!==e?(this._container.addEventListener("contextmenu",function(t){return t.preventDefault()}),this._geolocateButton=i.create("button","mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate",this._container),this._geolocateButton.type="button",this._geolocateButton.title="Find my location",this._geolocateButton.setAttribute("aria-label","Find my location"),this.options.trackUserLocation&&(this._geolocateButton.setAttribute("aria-pressed","false"),this._watchState="OFF"),this.options.showUserLocation&&(this._dotElement=i.create("div","mapboxgl-user-location-dot"),this._userLocationDotMarker=new Xo(this._dotElement),this.options.trackUserLocation&&(this._watchState="OFF")),this._geolocateButton.addEventListener("click",this.trigger.bind(this)),this._setup=!0,this.options.trackUserLocation&&this._map.on("movestart",function(e){var i=e.originalEvent&&"resize"===e.originalEvent.type;e.geolocateSource||"ACTIVE_LOCK"!==o._watchState||i||(o._watchState="BACKGROUND",o._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),o._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),o.fire(new t.Event("trackuserlocationend")));})):t.warnOnce("Geolocation support is not available, the GeolocateControl will not be visible.");},o.prototype.trigger=function(){if(!this._setup)return t.warnOnce("Geolocate control triggered before added to a map"),!1;if(this.options.trackUserLocation){switch(this._watchState){case"OFF":this._watchState="WAITING_ACTIVE",this.fire(new t.Event("trackuserlocationstart"));break;case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":case"BACKGROUND_ERROR":this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this.fire(new t.Event("trackuserlocationend"));break;case"BACKGROUND":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._lastKnownPosition&&this._updateCamera(this._lastKnownPosition),this.fire(new t.Event("trackuserlocationstart"));}switch(this._watchState){case"WAITING_ACTIVE":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_LOCK":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"BACKGROUND":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");break;case"BACKGROUND_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");}"OFF"===this._watchState&&void 0!==this._geolocationWatchID?this._clearWatch():void 0===this._geolocationWatchID&&(this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","true"),this._geolocationWatchID=t.window.navigator.geolocation.watchPosition(this._onSuccess,this._onError,this.options.positionOptions));}else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess,this._onError,this.options.positionOptions),this._timeoutId=setTimeout(this._finish,1e4);return !0},o.prototype._clearWatch=function(){t.window.navigator.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0,this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","false"),this.options.showUserLocation&&this._updateMarker(null);},o}(t.Evented),Jo={maxWidth:100,unit:"metric"},Yo=function(e){this.options=t.extend({},Jo,e),t.bindAll(["_onMove","setUnit"],this);};function Qo(t,e,i){var o,r,a,n,s,l,c=i&&i.maxWidth||100,u=t._container.clientHeight/2,h=(o=t.unproject([0,u]),r=t.unproject([c,u]),a=Math.PI/180,n=o.lat*a,s=r.lat*a,l=Math.sin(n)*Math.sin(s)+Math.cos(n)*Math.cos(s)*Math.cos((r.lng-o.lng)*a),6371e3*Math.acos(Math.min(l,1)));if(i&&"imperial"===i.unit){var p=3.2808*h;if(p>5280)$o(e,c,p/5280,"mi");else $o(e,c,p,"ft");}else if(i&&"nautical"===i.unit){$o(e,c,h/1852,"nm");}else $o(e,c,h,"m");}function $o(t,e,i,o){var r,a,n,s=(r=i,a=Math.pow(10,(""+Math.floor(r)).length-1),n=(n=r/a)>=10?10:n>=5?5:n>=3?3:n>=2?2:n>=1?1:function(t){var e=Math.pow(10,Math.ceil(-Math.log(t)/Math.LN10));return Math.round(t*e)/e}(n),a*n),l=s/i;"m"===o&&s>=1e3&&(s/=1e3,o="km"),t.style.width=e*l+"px",t.innerHTML=s+o;}Yo.prototype.getDefaultPosition=function(){return "bottom-left"},Yo.prototype._onMove=function(){Qo(this._map,this._container,this.options);},Yo.prototype.onAdd=function(t){return this._map=t,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-scale",t.getContainer()),this._map.on("move",this._onMove),this._onMove(),this._container},Yo.prototype.onRemove=function(){i.remove(this._container),this._map.off("move",this._onMove),this._map=void 0;},Yo.prototype.setUnit=function(t){this.options.unit=t,Qo(this._map,this._container,this.options);};var tr=function(e){this._fullscreen=!1,e&&e.container&&(e.container instanceof t.window.HTMLElement?this._container=e.container:t.warnOnce("Full screen control 'container' must be a DOM element.")),t.bindAll(["_onClickFullscreen","_changeIcon"],this),"onfullscreenchange"in t.window.document?this._fullscreenchange="fullscreenchange":"onmozfullscreenchange"in t.window.document?this._fullscreenchange="mozfullscreenchange":"onwebkitfullscreenchange"in t.window.document?this._fullscreenchange="webkitfullscreenchange":"onmsfullscreenchange"in t.window.document&&(this._fullscreenchange="MSFullscreenChange"),this._className="mapboxgl-ctrl";};tr.prototype.onAdd=function(e){return this._map=e,this._container||(this._container=this._map.getContainer()),this._controlContainer=i.create("div",this._className+" mapboxgl-ctrl-group"),this._checkFullscreenSupport()?this._setupUI():(this._controlContainer.style.display="none",t.warnOnce("This device does not support fullscreen mode.")),this._controlContainer},tr.prototype.onRemove=function(){i.remove(this._controlContainer),this._map=null,t.window.document.removeEventListener(this._fullscreenchange,this._changeIcon);},tr.prototype._checkFullscreenSupport=function(){return !!(t.window.document.fullscreenEnabled||t.window.document.mozFullScreenEnabled||t.window.document.msFullscreenEnabled||t.window.document.webkitFullscreenEnabled)},tr.prototype._setupUI=function(){(this._fullscreenButton=i.create("button",this._className+"-icon "+this._className+"-fullscreen",this._controlContainer)).type="button",this._updateTitle(),this._fullscreenButton.addEventListener("click",this._onClickFullscreen),t.window.document.addEventListener(this._fullscreenchange,this._changeIcon);},tr.prototype._updateTitle=function(){var t=this._isFullscreen()?"Exit fullscreen":"Enter fullscreen";this._fullscreenButton.setAttribute("aria-label",t),this._fullscreenButton.title=t;},tr.prototype._isFullscreen=function(){return this._fullscreen},tr.prototype._changeIcon=function(){(t.window.document.fullscreenElement||t.window.document.mozFullScreenElement||t.window.document.webkitFullscreenElement||t.window.document.msFullscreenElement)===this._container!==this._fullscreen&&(this._fullscreen=!this._fullscreen,this._fullscreenButton.classList.toggle(this._className+"-shrink"),this._fullscreenButton.classList.toggle(this._className+"-fullscreen"),this._updateTitle());},tr.prototype._onClickFullscreen=function(){this._isFullscreen()?t.window.document.exitFullscreen?t.window.document.exitFullscreen():t.window.document.mozCancelFullScreen?t.window.document.mozCancelFullScreen():t.window.document.msExitFullscreen?t.window.document.msExitFullscreen():t.window.document.webkitCancelFullScreen&&t.window.document.webkitCancelFullScreen():this._container.requestFullscreen?this._container.requestFullscreen():this._container.mozRequestFullScreen?this._container.mozRequestFullScreen():this._container.msRequestFullscreen?this._container.msRequestFullscreen():this._container.webkitRequestFullscreen&&this._container.webkitRequestFullscreen();};var er={closeButton:!0,closeOnClick:!0,className:"",maxWidth:"240px"},ir=function(e){function o(i){e.call(this),this.options=t.extend(Object.create(er),i),t.bindAll(["_update","_onClickClose","remove"],this);}return e&&(o.__proto__=e),o.prototype=Object.create(e&&e.prototype),o.prototype.constructor=o,o.prototype.addTo=function(e){var i=this;return this._map=e,this.options.closeOnClick&&this._map.on("click",this._onClickClose),this._map.on("remove",this.remove),this._update(),this._trackPointer?(this._map.on("mousemove",function(t){i._update(t.point);}),this._map.on("mouseup",function(t){i._update(t.point);}),this._container&&this._container.classList.add("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.add("mapboxgl-track-pointer")):this._map.on("move",this._update),this.fire(new t.Event("open")),this},o.prototype.isOpen=function(){return !!this._map},o.prototype.remove=function(){return this._content&&i.remove(this._content),this._container&&(i.remove(this._container),delete this._container),this._map&&(this._map.off("move",this._update),this._map.off("click",this._onClickClose),this._map.off("remove",this.remove),this._map.off("mousemove"),delete this._map),this.fire(new t.Event("close")),this},o.prototype.getLngLat=function(){return this._lngLat},o.prototype.setLngLat=function(e){return this._lngLat=t.LngLat.convert(e),this._pos=null,this._trackPointer=!1,this._update(),this._map&&(this._map.on("move",this._update),this._map.off("mousemove"),this._container&&this._container.classList.remove("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")),this},o.prototype.trackPointer=function(){var t=this;return this._trackPointer=!0,this._pos=null,this._update(),this._map&&(this._map.off("move",this._update),this._map.on("mousemove",function(e){t._update(e.point);}),this._map.on("drag",function(e){t._update(e.point);}),this._container&&this._container.classList.add("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.add("mapboxgl-track-pointer")),this},o.prototype.getElement=function(){return this._container},o.prototype.setText=function(e){return this.setDOMContent(t.window.document.createTextNode(e))},o.prototype.setHTML=function(e){var i,o=t.window.document.createDocumentFragment(),r=t.window.document.createElement("body");for(r.innerHTML=e;i=r.firstChild;)o.appendChild(i);return this.setDOMContent(o)},o.prototype.getMaxWidth=function(){return this._container.style.maxWidth},o.prototype.setMaxWidth=function(t){return this.options.maxWidth=t,this._update(),this},o.prototype.setDOMContent=function(t){return this._createContent(),this._content.appendChild(t),this._update(),this},o.prototype._createContent=function(){this._content&&i.remove(this._content),this._content=i.create("div","mapboxgl-popup-content",this._container),this.options.closeButton&&(this._closeButton=i.create("button","mapboxgl-popup-close-button",this._content),this._closeButton.type="button",this._closeButton.setAttribute("aria-label","Close popup"),this._closeButton.innerHTML="&#215;",this._closeButton.addEventListener("click",this._onClickClose));},o.prototype._update=function(e){var o=this,r=this._lngLat||this._trackPointer;if(this._map&&r&&this._content&&(this._container||(this._container=i.create("div","mapboxgl-popup",this._map.getContainer()),this._tip=i.create("div","mapboxgl-popup-tip",this._container),this._container.appendChild(this._content),this.options.className&&this.options.className.split(" ").forEach(function(t){return o._container.classList.add(t)}),this._trackPointer&&this._container.classList.add("mapboxgl-popup-track-pointer")),this.options.maxWidth&&this._container.style.maxWidth!==this.options.maxWidth&&(this._container.style.maxWidth=this.options.maxWidth),this._map.transform.renderWorldCopies&&!this._trackPointer&&(this._lngLat=qo(this._lngLat,this._pos,this._map.transform)),!this._trackPointer||e)){var a=this._pos=this._trackPointer&&e?e:this._map.project(this._lngLat),n=this.options.anchor,s=function e(i){if(i){if("number"==typeof i){var o=Math.round(Math.sqrt(.5*Math.pow(i,2)));return {center:new t.Point(0,0),top:new t.Point(0,i),"top-left":new t.Point(o,o),"top-right":new t.Point(-o,o),bottom:new t.Point(0,-i),"bottom-left":new t.Point(o,-o),"bottom-right":new t.Point(-o,-o),left:new t.Point(i,0),right:new t.Point(-i,0)}}if(i instanceof t.Point||Array.isArray(i)){var r=t.Point.convert(i);return {center:r,top:r,"top-left":r,"top-right":r,bottom:r,"bottom-left":r,"bottom-right":r,left:r,right:r}}return {center:t.Point.convert(i.center||[0,0]),top:t.Point.convert(i.top||[0,0]),"top-left":t.Point.convert(i["top-left"]||[0,0]),"top-right":t.Point.convert(i["top-right"]||[0,0]),bottom:t.Point.convert(i.bottom||[0,0]),"bottom-left":t.Point.convert(i["bottom-left"]||[0,0]),"bottom-right":t.Point.convert(i["bottom-right"]||[0,0]),left:t.Point.convert(i.left||[0,0]),right:t.Point.convert(i.right||[0,0])}}return e(new t.Point(0,0))}(this.options.offset);if(!n){var l,c=this._container.offsetWidth,u=this._container.offsetHeight;l=a.y+s.bottom.y<u?["top"]:a.y>this._map.transform.height-u?["bottom"]:[],a.x<c/2?l.push("left"):a.x>this._map.transform.width-c/2&&l.push("right"),n=0===l.length?"bottom":l.join("-");}var h=a.add(s[n]).round();i.setTransform(this._container,jo[n]+" translate("+h.x+"px,"+h.y+"px)"),Go(this._container,n,"popup");}},o.prototype._onClickClose=function(){this.remove();},o}(t.Evented);var or={version:t.version,supported:e,setRTLTextPlugin:t.setRTLTextPlugin,Map:Uo,NavigationControl:Vo,GeolocateControl:Ko,AttributionControl:Ro,ScaleControl:Yo,FullscreenControl:tr,Popup:ir,Marker:Xo,Style:Fe,LngLat:t.LngLat,LngLatBounds:t.LngLatBounds,Point:t.Point,MercatorCoordinate:t.MercatorCoordinate,Evented:t.Evented,config:t.config,get accessToken(){return t.config.ACCESS_TOKEN},set accessToken(e){t.config.ACCESS_TOKEN=e;},get baseApiUrl(){return t.config.API_URL},set baseApiUrl(e){t.config.API_URL=e;},get workerCount(){return At.workerCount},set workerCount(t){At.workerCount=t;},get maxParallelImageRequests(){return t.config.MAX_PARALLEL_IMAGE_REQUESTS},set maxParallelImageRequests(e){t.config.MAX_PARALLEL_IMAGE_REQUESTS=e;},clearStorage:function(e){t.clearTileCache(e);},workerUrl:""};return or});

	//

	return mapboxgl;

	}));

	});
	var mapboxGl_1 = mapboxGl.Map;
	var mapboxGl_2 = mapboxGl.setRTLTextPlugin;
	var mapboxGl_3 = mapboxGl.supported;
	var mapboxGl_4 = mapboxGl.Marker;

	var env = {
		domain: "atlas.microsoft.com",
		staticAssetsDomain: "atlas.microsoft.com",
		styleDefinitionsPath: "styles/definitions/2019-10-16.json",
		appInsightsKey: "e96cb745-c6f5-409c-a775-c4313e468c1d",
		aadInstance: "https://login.microsoftonline.com/"
	};
	var constants = {
		authorizationHeaderName: "Authorization",
		authorizationTokenPrefix: "Bearer ",
		domainPlaceHolder: "{azMapsDomain}",
		mapAgentHeaderName: "Map-Agent",
		msClientIdHeaderName: "x-ms-client-id",
		msOriginHeaderName: "Ms-Am-Request-Origin",
		msOriginHeaderValue: "MapControl",
		resourceId: "https://atlas.microsoft.com/",
		sessionIdHeaderName: "Session-Id"
	};

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __awaiter(thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	/**
	 * @private
	 */
	var Options = /** @class */ (function () {
	    function Options() {
	    }
	    /**
	     * @internal
	     */
	    Options.prototype.merge = function () {
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        var defaults;
	        for (var _a = 0, valuesList_1 = valuesList; _a < valuesList_1.length; _a++) {
	            var values = valuesList_1[_a];
	            if (!values) {
	                continue;
	            }
	            for (var property in values) {
	                if (values.hasOwnProperty(property) && this.hasOwnProperty(property)) {
	                    if (values[property] !== undefined && values[property] != null) {
	                        // Check for nested options and merge them rather than simply overwriting.
	                        if (this[property] instanceof Options) {
	                            this[property].merge(values[property]);
	                        }
	                        else {
	                            this[property] = values[property];
	                        }
	                    }
	                    else {
	                        // Assume a value of undefined or null intends to take the default value.
	                        // Create a new object to access its defaults.
	                        if (!defaults) {
	                            defaults = new (Object.getPrototypeOf(this).constructor)();
	                        }
	                        this[property] = defaults[property];
	                    }
	                }
	            }
	        }
	        return this;
	    };
	    return Options;
	}());

	/**
	 * @private
	 */
	var UrlOptions = /** @class */ (function (_super) {
	    __extends(UrlOptions, _super);
	    function UrlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.domain = undefined;
	        _this.headers = {};
	        _this.path = "";
	        _this.protocol = "https";
	        _this.queryParams = {};
	        _this.subdomain = "";
	        return _this;
	    }
	    return UrlOptions;
	}(Options));
	/**
	 * @private
	 */
	// tslint:disable-next-line:max-classes-per-file
	var Url = /** @class */ (function () {
	    function Url(options) {
	        this.options = new UrlOptions().merge(options);
	    }
	    // tslint:disable-next-line:no-reserved-keywords
	    Url.prototype.get = function () {
	        return fetch(this.toString(), {
	            method: "GET",
	            mode: "cors",
	            headers: new Headers(this.options.headers)
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP " + response.status + ": " + response.statusText);
	            }
	        });
	    };
	    Url.prototype.toString = function () {
	        var queryParamsString = Object.entries(this.options.queryParams)
	            .map(function (_a) {
	            var key = _a[0], value = _a[1];
	            return key + "=" + value;
	        }).join("&");
	        var url = [];
	        if (!Url.protoRegEx.test(this.options.domain)) {
	            // If the domain doesn't include a protocol use the separate protocol and subdomain properties.
	            // If the domain includes a protocol assume it also includes the subdomain.
	            url.push(this.options.protocol + "://");
	            url.push((this.options.subdomain) ? this.options.subdomain + "." : "");
	        }
	        url.push(this.options.domain);
	        url.push((this.options.path) ? "/" + this.options.path : "");
	        url.push((queryParamsString) ? "?" + queryParamsString : "");
	        return url.join("");
	    };
	    Url.protoRegEx = new RegExp(/^\w+:\/\//);
	    return Url;
	}());

	var version = "2.0.20";

	/**
	 * A helper class that provides methods for getting various forms of the map controls current version.
	 */
	var Version = /** @class */ (function () {
	    function Version() {
	    }
	    /**
	     * Returns the full version string for the map control.
	     * For example, `"1.3.5"`.
	     */
	    Version.getFullVersion = function () {
	        return version;
	    };
	    /**
	     * Returns the endpoint compatible version string for the map control.
	     * For example, `"1.3.5"` becomes `"1.3"`.
	     */
	    Version.getEndpointVersion = function () {
	        // Get the index of the second "."
	        var index = version.indexOf(".");
	        index = version.indexOf(".", index + 1);
	        // If the index of the second "." can't be found just return the whole version string.
	        if (index === -1) {
	            return version;
	        }
	        return version.substring(0, index);
	    };
	    return Version;
	}());

	(function (ControlPosition) {
	    /**
	     * Places the control in the top left of the map.
	     * Literal value `"top-left"`
	     */
	    ControlPosition["TopLeft"] = "top-left";
	    /**
	     * Places the control in the top right of the map.
	     * Literal value `"top-right"`
	     */
	    ControlPosition["TopRight"] = "top-right";
	    /**
	     * Places the control in the bottom left of the map.
	     * Literal value `"bottom-left"`
	     */
	    ControlPosition["BottomLeft"] = "bottom-left";
	    /**
	     * Places the control in the bottom right of the map.
	     * Literal value `"bottom-right"`
	     */
	    ControlPosition["BottomRight"] = "bottom-right";
	    /**
	     * The control will place itself in its default location.
	     * Literal value `"non-fixed"`
	     */
	    ControlPosition["NonFixed"] = "non-fixed";
	})(exports.ControlPosition || (exports.ControlPosition = {}));
	/**
	 * The options for adding a control to the map.
	 */
	var ControlOptions = /** @class */ (function (_super) {
	    __extends(ControlOptions, _super);
	    function ControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The position the control will be placed on the map. If not specified, the control will be located at the
	         * default position it defines.
	         * default `ControlPosition.NonFixed`
	         * @default ControlPosition.NonFixed
	         */
	        _this.position = exports.ControlPosition.NonFixed;
	        return _this;
	    }
	    return ControlOptions;
	}(Options));

	var colorName = {
		"aliceblue": [240, 248, 255],
		"antiquewhite": [250, 235, 215],
		"aqua": [0, 255, 255],
		"aquamarine": [127, 255, 212],
		"azure": [240, 255, 255],
		"beige": [245, 245, 220],
		"bisque": [255, 228, 196],
		"black": [0, 0, 0],
		"blanchedalmond": [255, 235, 205],
		"blue": [0, 0, 255],
		"blueviolet": [138, 43, 226],
		"brown": [165, 42, 42],
		"burlywood": [222, 184, 135],
		"cadetblue": [95, 158, 160],
		"chartreuse": [127, 255, 0],
		"chocolate": [210, 105, 30],
		"coral": [255, 127, 80],
		"cornflowerblue": [100, 149, 237],
		"cornsilk": [255, 248, 220],
		"crimson": [220, 20, 60],
		"cyan": [0, 255, 255],
		"darkblue": [0, 0, 139],
		"darkcyan": [0, 139, 139],
		"darkgoldenrod": [184, 134, 11],
		"darkgray": [169, 169, 169],
		"darkgreen": [0, 100, 0],
		"darkgrey": [169, 169, 169],
		"darkkhaki": [189, 183, 107],
		"darkmagenta": [139, 0, 139],
		"darkolivegreen": [85, 107, 47],
		"darkorange": [255, 140, 0],
		"darkorchid": [153, 50, 204],
		"darkred": [139, 0, 0],
		"darksalmon": [233, 150, 122],
		"darkseagreen": [143, 188, 143],
		"darkslateblue": [72, 61, 139],
		"darkslategray": [47, 79, 79],
		"darkslategrey": [47, 79, 79],
		"darkturquoise": [0, 206, 209],
		"darkviolet": [148, 0, 211],
		"deeppink": [255, 20, 147],
		"deepskyblue": [0, 191, 255],
		"dimgray": [105, 105, 105],
		"dimgrey": [105, 105, 105],
		"dodgerblue": [30, 144, 255],
		"firebrick": [178, 34, 34],
		"floralwhite": [255, 250, 240],
		"forestgreen": [34, 139, 34],
		"fuchsia": [255, 0, 255],
		"gainsboro": [220, 220, 220],
		"ghostwhite": [248, 248, 255],
		"gold": [255, 215, 0],
		"goldenrod": [218, 165, 32],
		"gray": [128, 128, 128],
		"green": [0, 128, 0],
		"greenyellow": [173, 255, 47],
		"grey": [128, 128, 128],
		"honeydew": [240, 255, 240],
		"hotpink": [255, 105, 180],
		"indianred": [205, 92, 92],
		"indigo": [75, 0, 130],
		"ivory": [255, 255, 240],
		"khaki": [240, 230, 140],
		"lavender": [230, 230, 250],
		"lavenderblush": [255, 240, 245],
		"lawngreen": [124, 252, 0],
		"lemonchiffon": [255, 250, 205],
		"lightblue": [173, 216, 230],
		"lightcoral": [240, 128, 128],
		"lightcyan": [224, 255, 255],
		"lightgoldenrodyellow": [250, 250, 210],
		"lightgray": [211, 211, 211],
		"lightgreen": [144, 238, 144],
		"lightgrey": [211, 211, 211],
		"lightpink": [255, 182, 193],
		"lightsalmon": [255, 160, 122],
		"lightseagreen": [32, 178, 170],
		"lightskyblue": [135, 206, 250],
		"lightslategray": [119, 136, 153],
		"lightslategrey": [119, 136, 153],
		"lightsteelblue": [176, 196, 222],
		"lightyellow": [255, 255, 224],
		"lime": [0, 255, 0],
		"limegreen": [50, 205, 50],
		"linen": [250, 240, 230],
		"magenta": [255, 0, 255],
		"maroon": [128, 0, 0],
		"mediumaquamarine": [102, 205, 170],
		"mediumblue": [0, 0, 205],
		"mediumorchid": [186, 85, 211],
		"mediumpurple": [147, 112, 219],
		"mediumseagreen": [60, 179, 113],
		"mediumslateblue": [123, 104, 238],
		"mediumspringgreen": [0, 250, 154],
		"mediumturquoise": [72, 209, 204],
		"mediumvioletred": [199, 21, 133],
		"midnightblue": [25, 25, 112],
		"mintcream": [245, 255, 250],
		"mistyrose": [255, 228, 225],
		"moccasin": [255, 228, 181],
		"navajowhite": [255, 222, 173],
		"navy": [0, 0, 128],
		"oldlace": [253, 245, 230],
		"olive": [128, 128, 0],
		"olivedrab": [107, 142, 35],
		"orange": [255, 165, 0],
		"orangered": [255, 69, 0],
		"orchid": [218, 112, 214],
		"palegoldenrod": [238, 232, 170],
		"palegreen": [152, 251, 152],
		"paleturquoise": [175, 238, 238],
		"palevioletred": [219, 112, 147],
		"papayawhip": [255, 239, 213],
		"peachpuff": [255, 218, 185],
		"peru": [205, 133, 63],
		"pink": [255, 192, 203],
		"plum": [221, 160, 221],
		"powderblue": [176, 224, 230],
		"purple": [128, 0, 128],
		"rebeccapurple": [102, 51, 153],
		"red": [255, 0, 0],
		"rosybrown": [188, 143, 143],
		"royalblue": [65, 105, 225],
		"saddlebrown": [139, 69, 19],
		"salmon": [250, 128, 114],
		"sandybrown": [244, 164, 96],
		"seagreen": [46, 139, 87],
		"seashell": [255, 245, 238],
		"sienna": [160, 82, 45],
		"silver": [192, 192, 192],
		"skyblue": [135, 206, 235],
		"slateblue": [106, 90, 205],
		"slategray": [112, 128, 144],
		"slategrey": [112, 128, 144],
		"snow": [255, 250, 250],
		"springgreen": [0, 255, 127],
		"steelblue": [70, 130, 180],
		"tan": [210, 180, 140],
		"teal": [0, 128, 128],
		"thistle": [216, 191, 216],
		"tomato": [255, 99, 71],
		"turquoise": [64, 224, 208],
		"violet": [238, 130, 238],
		"wheat": [245, 222, 179],
		"white": [255, 255, 255],
		"whitesmoke": [245, 245, 245],
		"yellow": [255, 255, 0],
		"yellowgreen": [154, 205, 50]
	};

	var isArrayish = function isArrayish(obj) {
		if (!obj || typeof obj === 'string') {
			return false;
		}

		return obj instanceof Array || Array.isArray(obj) ||
			(obj.length >= 0 && (obj.splice instanceof Function ||
				(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
	};

	var simpleSwizzle = createCommonjsModule(function (module) {



	var concat = Array.prototype.concat;
	var slice = Array.prototype.slice;

	var swizzle = module.exports = function swizzle(args) {
		var results = [];

		for (var i = 0, len = args.length; i < len; i++) {
			var arg = args[i];

			if (isArrayish(arg)) {
				// http://jsperf.com/javascript-array-concat-vs-push/98
				results = concat.call(results, slice.call(arg));
			} else {
				results.push(arg);
			}
		}

		return results;
	};

	swizzle.wrap = function (fn) {
		return function () {
			return fn(swizzle(arguments));
		};
	};
	});

	var colorString = createCommonjsModule(function (module) {
	/* MIT license */



	var reverseNames = {};

	// create a list of reverse color names
	for (var name in colorName) {
		if (colorName.hasOwnProperty(name)) {
			reverseNames[colorName[name]] = name;
		}
	}

	var cs = module.exports = {
		to: {},
		get: {}
	};

	cs.get = function (string) {
		var prefix = string.substring(0, 3).toLowerCase();
		var val;
		var model;
		switch (prefix) {
			case 'hsl':
				val = cs.get.hsl(string);
				model = 'hsl';
				break;
			case 'hwb':
				val = cs.get.hwb(string);
				model = 'hwb';
				break;
			default:
				val = cs.get.rgb(string);
				model = 'rgb';
				break;
		}

		if (!val) {
			return null;
		}

		return {model: model, value: val};
	};

	cs.get.rgb = function (string) {
		if (!string) {
			return null;
		}

		var abbr = /^#([a-f0-9]{3,4})$/i;
		var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
		var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
		var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
		var keyword = /(\D+)/;

		var rgb = [0, 0, 0, 1];
		var match;
		var i;
		var hexAlpha;

		if (match = string.match(hex)) {
			hexAlpha = match[2];
			match = match[1];

			for (i = 0; i < 3; i++) {
				// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
				var i2 = i * 2;
				rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
			}

			if (hexAlpha) {
				rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
			}
		} else if (match = string.match(abbr)) {
			match = match[1];
			hexAlpha = match[3];

			for (i = 0; i < 3; i++) {
				rgb[i] = parseInt(match[i] + match[i], 16);
			}

			if (hexAlpha) {
				rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
			}
		} else if (match = string.match(rgba)) {
			for (i = 0; i < 3; i++) {
				rgb[i] = parseInt(match[i + 1], 0);
			}

			if (match[4]) {
				rgb[3] = parseFloat(match[4]);
			}
		} else if (match = string.match(per)) {
			for (i = 0; i < 3; i++) {
				rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
			}

			if (match[4]) {
				rgb[3] = parseFloat(match[4]);
			}
		} else if (match = string.match(keyword)) {
			if (match[1] === 'transparent') {
				return [0, 0, 0, 0];
			}

			rgb = colorName[match[1]];

			if (!rgb) {
				return null;
			}

			rgb[3] = 1;

			return rgb;
		} else {
			return null;
		}

		for (i = 0; i < 3; i++) {
			rgb[i] = clamp(rgb[i], 0, 255);
		}
		rgb[3] = clamp(rgb[3], 0, 1);

		return rgb;
	};

	cs.get.hsl = function (string) {
		if (!string) {
			return null;
		}

		var hsl = /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
		var match = string.match(hsl);

		if (match) {
			var alpha = parseFloat(match[4]);
			var h = (parseFloat(match[1]) + 360) % 360;
			var s = clamp(parseFloat(match[2]), 0, 100);
			var l = clamp(parseFloat(match[3]), 0, 100);
			var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

			return [h, s, l, a];
		}

		return null;
	};

	cs.get.hwb = function (string) {
		if (!string) {
			return null;
		}

		var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
		var match = string.match(hwb);

		if (match) {
			var alpha = parseFloat(match[4]);
			var h = ((parseFloat(match[1]) % 360) + 360) % 360;
			var w = clamp(parseFloat(match[2]), 0, 100);
			var b = clamp(parseFloat(match[3]), 0, 100);
			var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
			return [h, w, b, a];
		}

		return null;
	};

	cs.to.hex = function () {
		var rgba = simpleSwizzle(arguments);

		return (
			'#' +
			hexDouble(rgba[0]) +
			hexDouble(rgba[1]) +
			hexDouble(rgba[2]) +
			(rgba[3] < 1
				? (hexDouble(Math.round(rgba[3] * 255)))
				: '')
		);
	};

	cs.to.rgb = function () {
		var rgba = simpleSwizzle(arguments);

		return rgba.length < 4 || rgba[3] === 1
			? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
			: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
	};

	cs.to.rgb.percent = function () {
		var rgba = simpleSwizzle(arguments);

		var r = Math.round(rgba[0] / 255 * 100);
		var g = Math.round(rgba[1] / 255 * 100);
		var b = Math.round(rgba[2] / 255 * 100);

		return rgba.length < 4 || rgba[3] === 1
			? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
			: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
	};

	cs.to.hsl = function () {
		var hsla = simpleSwizzle(arguments);
		return hsla.length < 4 || hsla[3] === 1
			? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
			: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
	};

	// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
	// (hwb have alpha optional & 1 is default value)
	cs.to.hwb = function () {
		var hwba = simpleSwizzle(arguments);

		var a = '';
		if (hwba.length >= 4 && hwba[3] !== 1) {
			a = ', ' + hwba[3];
		}

		return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
	};

	cs.to.keyword = function (rgb) {
		return reverseNames[rgb.slice(0, 3)];
	};

	// helpers
	function clamp(num, min, max) {
		return Math.min(Math.max(min, num), max);
	}

	function hexDouble(num) {
		var str = num.toString(16).toUpperCase();
		return (str.length < 2) ? '0' + str : str;
	}
	});
	var colorString_1 = colorString.to;
	var colorString_2 = colorString.get;

	var conversions = createCommonjsModule(function (module) {
	/* MIT license */


	// NOTE: conversions should only return primitive values (i.e. arrays, or
	//       values that give correct `typeof` results).
	//       do not use box values types (i.e. Number(), String(), etc.)

	var reverseKeywords = {};
	for (var key in colorName) {
		if (colorName.hasOwnProperty(key)) {
			reverseKeywords[colorName[key]] = key;
		}
	}

	var convert = module.exports = {
		rgb: {channels: 3, labels: 'rgb'},
		hsl: {channels: 3, labels: 'hsl'},
		hsv: {channels: 3, labels: 'hsv'},
		hwb: {channels: 3, labels: 'hwb'},
		cmyk: {channels: 4, labels: 'cmyk'},
		xyz: {channels: 3, labels: 'xyz'},
		lab: {channels: 3, labels: 'lab'},
		lch: {channels: 3, labels: 'lch'},
		hex: {channels: 1, labels: ['hex']},
		keyword: {channels: 1, labels: ['keyword']},
		ansi16: {channels: 1, labels: ['ansi16']},
		ansi256: {channels: 1, labels: ['ansi256']},
		hcg: {channels: 3, labels: ['h', 'c', 'g']},
		apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
		gray: {channels: 1, labels: ['gray']}
	};

	// hide .channels and .labels properties
	for (var model in convert) {
		if (convert.hasOwnProperty(model)) {
			if (!('channels' in convert[model])) {
				throw new Error('missing channels property: ' + model);
			}

			if (!('labels' in convert[model])) {
				throw new Error('missing channel labels property: ' + model);
			}

			if (convert[model].labels.length !== convert[model].channels) {
				throw new Error('channel and label counts mismatch: ' + model);
			}

			var channels = convert[model].channels;
			var labels = convert[model].labels;
			delete convert[model].channels;
			delete convert[model].labels;
			Object.defineProperty(convert[model], 'channels', {value: channels});
			Object.defineProperty(convert[model], 'labels', {value: labels});
		}
	}

	convert.rgb.hsl = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var min = Math.min(r, g, b);
		var max = Math.max(r, g, b);
		var delta = max - min;
		var h;
		var s;
		var l;

		if (max === min) {
			h = 0;
		} else if (r === max) {
			h = (g - b) / delta;
		} else if (g === max) {
			h = 2 + (b - r) / delta;
		} else if (b === max) {
			h = 4 + (r - g) / delta;
		}

		h = Math.min(h * 60, 360);

		if (h < 0) {
			h += 360;
		}

		l = (min + max) / 2;

		if (max === min) {
			s = 0;
		} else if (l <= 0.5) {
			s = delta / (max + min);
		} else {
			s = delta / (2 - max - min);
		}

		return [h, s * 100, l * 100];
	};

	convert.rgb.hsv = function (rgb) {
		var rdif;
		var gdif;
		var bdif;
		var h;
		var s;

		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var v = Math.max(r, g, b);
		var diff = v - Math.min(r, g, b);
		var diffc = function (c) {
			return (v - c) / 6 / diff + 1 / 2;
		};

		if (diff === 0) {
			h = s = 0;
		} else {
			s = diff / v;
			rdif = diffc(r);
			gdif = diffc(g);
			bdif = diffc(b);

			if (r === v) {
				h = bdif - gdif;
			} else if (g === v) {
				h = (1 / 3) + rdif - bdif;
			} else if (b === v) {
				h = (2 / 3) + gdif - rdif;
			}
			if (h < 0) {
				h += 1;
			} else if (h > 1) {
				h -= 1;
			}
		}

		return [
			h * 360,
			s * 100,
			v * 100
		];
	};

	convert.rgb.hwb = function (rgb) {
		var r = rgb[0];
		var g = rgb[1];
		var b = rgb[2];
		var h = convert.rgb.hsl(rgb)[0];
		var w = 1 / 255 * Math.min(r, Math.min(g, b));

		b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

		return [h, w * 100, b * 100];
	};

	convert.rgb.cmyk = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var c;
		var m;
		var y;
		var k;

		k = Math.min(1 - r, 1 - g, 1 - b);
		c = (1 - r - k) / (1 - k) || 0;
		m = (1 - g - k) / (1 - k) || 0;
		y = (1 - b - k) / (1 - k) || 0;

		return [c * 100, m * 100, y * 100, k * 100];
	};

	/**
	 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	 * */
	function comparativeDistance(x, y) {
		return (
			Math.pow(x[0] - y[0], 2) +
			Math.pow(x[1] - y[1], 2) +
			Math.pow(x[2] - y[2], 2)
		);
	}

	convert.rgb.keyword = function (rgb) {
		var reversed = reverseKeywords[rgb];
		if (reversed) {
			return reversed;
		}

		var currentClosestDistance = Infinity;
		var currentClosestKeyword;

		for (var keyword in colorName) {
			if (colorName.hasOwnProperty(keyword)) {
				var value = colorName[keyword];

				// Compute comparative distance
				var distance = comparativeDistance(rgb, value);

				// Check if its less, if so set as closest
				if (distance < currentClosestDistance) {
					currentClosestDistance = distance;
					currentClosestKeyword = keyword;
				}
			}
		}

		return currentClosestKeyword;
	};

	convert.keyword.rgb = function (keyword) {
		return colorName[keyword];
	};

	convert.rgb.xyz = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;

		// assume sRGB
		r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
		g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
		b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

		var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
		var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
		var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

		return [x * 100, y * 100, z * 100];
	};

	convert.rgb.lab = function (rgb) {
		var xyz = convert.rgb.xyz(rgb);
		var x = xyz[0];
		var y = xyz[1];
		var z = xyz[2];
		var l;
		var a;
		var b;

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

		l = (116 * y) - 16;
		a = 500 * (x - y);
		b = 200 * (y - z);

		return [l, a, b];
	};

	convert.hsl.rgb = function (hsl) {
		var h = hsl[0] / 360;
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var t1;
		var t2;
		var t3;
		var rgb;
		var val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		} else {
			t2 = l + s - l * s;
		}

		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (var i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * -(i - 1);
			if (t3 < 0) {
				t3++;
			}
			if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			} else if (2 * t3 < 1) {
				val = t2;
			} else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			} else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	};

	convert.hsl.hsv = function (hsl) {
		var h = hsl[0];
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var smin = s;
		var lmin = Math.max(l, 0.01);
		var sv;
		var v;

		l *= 2;
		s *= (l <= 1) ? l : 2 - l;
		smin *= lmin <= 1 ? lmin : 2 - lmin;
		v = (l + s) / 2;
		sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

		return [h, sv * 100, v * 100];
	};

	convert.hsv.rgb = function (hsv) {
		var h = hsv[0] / 60;
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;
		var hi = Math.floor(h) % 6;

		var f = h - Math.floor(h);
		var p = 255 * v * (1 - s);
		var q = 255 * v * (1 - (s * f));
		var t = 255 * v * (1 - (s * (1 - f)));
		v *= 255;

		switch (hi) {
			case 0:
				return [v, t, p];
			case 1:
				return [q, v, p];
			case 2:
				return [p, v, t];
			case 3:
				return [p, q, v];
			case 4:
				return [t, p, v];
			case 5:
				return [v, p, q];
		}
	};

	convert.hsv.hsl = function (hsv) {
		var h = hsv[0];
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;
		var vmin = Math.max(v, 0.01);
		var lmin;
		var sl;
		var l;

		l = (2 - s) * v;
		lmin = (2 - s) * vmin;
		sl = s * vmin;
		sl /= (lmin <= 1) ? lmin : 2 - lmin;
		sl = sl || 0;
		l /= 2;

		return [h, sl * 100, l * 100];
	};

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	convert.hwb.rgb = function (hwb) {
		var h = hwb[0] / 360;
		var wh = hwb[1] / 100;
		var bl = hwb[2] / 100;
		var ratio = wh + bl;
		var i;
		var v;
		var f;
		var n;

		// wh + bl cant be > 1
		if (ratio > 1) {
			wh /= ratio;
			bl /= ratio;
		}

		i = Math.floor(6 * h);
		v = 1 - bl;
		f = 6 * h - i;

		if ((i & 0x01) !== 0) {
			f = 1 - f;
		}

		n = wh + f * (v - wh); // linear interpolation

		var r;
		var g;
		var b;
		switch (i) {
			default:
			case 6:
			case 0: r = v; g = n; b = wh; break;
			case 1: r = n; g = v; b = wh; break;
			case 2: r = wh; g = v; b = n; break;
			case 3: r = wh; g = n; b = v; break;
			case 4: r = n; g = wh; b = v; break;
			case 5: r = v; g = wh; b = n; break;
		}

		return [r * 255, g * 255, b * 255];
	};

	convert.cmyk.rgb = function (cmyk) {
		var c = cmyk[0] / 100;
		var m = cmyk[1] / 100;
		var y = cmyk[2] / 100;
		var k = cmyk[3] / 100;
		var r;
		var g;
		var b;

		r = 1 - Math.min(1, c * (1 - k) + k);
		g = 1 - Math.min(1, m * (1 - k) + k);
		b = 1 - Math.min(1, y * (1 - k) + k);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.rgb = function (xyz) {
		var x = xyz[0] / 100;
		var y = xyz[1] / 100;
		var z = xyz[2] / 100;
		var r;
		var g;
		var b;

		r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
		g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
		b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

		// assume sRGB
		r = r > 0.0031308
			? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
			: r * 12.92;

		g = g > 0.0031308
			? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
			: g * 12.92;

		b = b > 0.0031308
			? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
			: b * 12.92;

		r = Math.min(Math.max(0, r), 1);
		g = Math.min(Math.max(0, g), 1);
		b = Math.min(Math.max(0, b), 1);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.lab = function (xyz) {
		var x = xyz[0];
		var y = xyz[1];
		var z = xyz[2];
		var l;
		var a;
		var b;

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

		l = (116 * y) - 16;
		a = 500 * (x - y);
		b = 200 * (y - z);

		return [l, a, b];
	};

	convert.lab.xyz = function (lab) {
		var l = lab[0];
		var a = lab[1];
		var b = lab[2];
		var x;
		var y;
		var z;

		y = (l + 16) / 116;
		x = a / 500 + y;
		z = y - b / 200;

		var y2 = Math.pow(y, 3);
		var x2 = Math.pow(x, 3);
		var z2 = Math.pow(z, 3);
		y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
		x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
		z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

		x *= 95.047;
		y *= 100;
		z *= 108.883;

		return [x, y, z];
	};

	convert.lab.lch = function (lab) {
		var l = lab[0];
		var a = lab[1];
		var b = lab[2];
		var hr;
		var h;
		var c;

		hr = Math.atan2(b, a);
		h = hr * 360 / 2 / Math.PI;

		if (h < 0) {
			h += 360;
		}

		c = Math.sqrt(a * a + b * b);

		return [l, c, h];
	};

	convert.lch.lab = function (lch) {
		var l = lch[0];
		var c = lch[1];
		var h = lch[2];
		var a;
		var b;
		var hr;

		hr = h / 360 * 2 * Math.PI;
		a = c * Math.cos(hr);
		b = c * Math.sin(hr);

		return [l, a, b];
	};

	convert.rgb.ansi16 = function (args) {
		var r = args[0];
		var g = args[1];
		var b = args[2];
		var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

		value = Math.round(value / 50);

		if (value === 0) {
			return 30;
		}

		var ansi = 30
			+ ((Math.round(b / 255) << 2)
			| (Math.round(g / 255) << 1)
			| Math.round(r / 255));

		if (value === 2) {
			ansi += 60;
		}

		return ansi;
	};

	convert.hsv.ansi16 = function (args) {
		// optimization here; we already know the value and don't need to get
		// it converted for us.
		return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	};

	convert.rgb.ansi256 = function (args) {
		var r = args[0];
		var g = args[1];
		var b = args[2];

		// we use the extended greyscale palette here, with the exception of
		// black and white. normal palette only has 4 greyscale shades.
		if (r === g && g === b) {
			if (r < 8) {
				return 16;
			}

			if (r > 248) {
				return 231;
			}

			return Math.round(((r - 8) / 247) * 24) + 232;
		}

		var ansi = 16
			+ (36 * Math.round(r / 255 * 5))
			+ (6 * Math.round(g / 255 * 5))
			+ Math.round(b / 255 * 5);

		return ansi;
	};

	convert.ansi16.rgb = function (args) {
		var color = args % 10;

		// handle greyscale
		if (color === 0 || color === 7) {
			if (args > 50) {
				color += 3.5;
			}

			color = color / 10.5 * 255;

			return [color, color, color];
		}

		var mult = (~~(args > 50) + 1) * 0.5;
		var r = ((color & 1) * mult) * 255;
		var g = (((color >> 1) & 1) * mult) * 255;
		var b = (((color >> 2) & 1) * mult) * 255;

		return [r, g, b];
	};

	convert.ansi256.rgb = function (args) {
		// handle greyscale
		if (args >= 232) {
			var c = (args - 232) * 10 + 8;
			return [c, c, c];
		}

		args -= 16;

		var rem;
		var r = Math.floor(args / 36) / 5 * 255;
		var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
		var b = (rem % 6) / 5 * 255;

		return [r, g, b];
	};

	convert.rgb.hex = function (args) {
		var integer = ((Math.round(args[0]) & 0xFF) << 16)
			+ ((Math.round(args[1]) & 0xFF) << 8)
			+ (Math.round(args[2]) & 0xFF);

		var string = integer.toString(16).toUpperCase();
		return '000000'.substring(string.length) + string;
	};

	convert.hex.rgb = function (args) {
		var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
		if (!match) {
			return [0, 0, 0];
		}

		var colorString = match[0];

		if (match[0].length === 3) {
			colorString = colorString.split('').map(function (char) {
				return char + char;
			}).join('');
		}

		var integer = parseInt(colorString, 16);
		var r = (integer >> 16) & 0xFF;
		var g = (integer >> 8) & 0xFF;
		var b = integer & 0xFF;

		return [r, g, b];
	};

	convert.rgb.hcg = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var max = Math.max(Math.max(r, g), b);
		var min = Math.min(Math.min(r, g), b);
		var chroma = (max - min);
		var grayscale;
		var hue;

		if (chroma < 1) {
			grayscale = min / (1 - chroma);
		} else {
			grayscale = 0;
		}

		if (chroma <= 0) {
			hue = 0;
		} else
		if (max === r) {
			hue = ((g - b) / chroma) % 6;
		} else
		if (max === g) {
			hue = 2 + (b - r) / chroma;
		} else {
			hue = 4 + (r - g) / chroma + 4;
		}

		hue /= 6;
		hue %= 1;

		return [hue * 360, chroma * 100, grayscale * 100];
	};

	convert.hsl.hcg = function (hsl) {
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var c = 1;
		var f = 0;

		if (l < 0.5) {
			c = 2.0 * s * l;
		} else {
			c = 2.0 * s * (1.0 - l);
		}

		if (c < 1.0) {
			f = (l - 0.5 * c) / (1.0 - c);
		}

		return [hsl[0], c * 100, f * 100];
	};

	convert.hsv.hcg = function (hsv) {
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;

		var c = s * v;
		var f = 0;

		if (c < 1.0) {
			f = (v - c) / (1 - c);
		}

		return [hsv[0], c * 100, f * 100];
	};

	convert.hcg.rgb = function (hcg) {
		var h = hcg[0] / 360;
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;

		if (c === 0.0) {
			return [g * 255, g * 255, g * 255];
		}

		var pure = [0, 0, 0];
		var hi = (h % 1) * 6;
		var v = hi % 1;
		var w = 1 - v;
		var mg = 0;

		switch (Math.floor(hi)) {
			case 0:
				pure[0] = 1; pure[1] = v; pure[2] = 0; break;
			case 1:
				pure[0] = w; pure[1] = 1; pure[2] = 0; break;
			case 2:
				pure[0] = 0; pure[1] = 1; pure[2] = v; break;
			case 3:
				pure[0] = 0; pure[1] = w; pure[2] = 1; break;
			case 4:
				pure[0] = v; pure[1] = 0; pure[2] = 1; break;
			default:
				pure[0] = 1; pure[1] = 0; pure[2] = w;
		}

		mg = (1.0 - c) * g;

		return [
			(c * pure[0] + mg) * 255,
			(c * pure[1] + mg) * 255,
			(c * pure[2] + mg) * 255
		];
	};

	convert.hcg.hsv = function (hcg) {
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;

		var v = c + g * (1.0 - c);
		var f = 0;

		if (v > 0.0) {
			f = c / v;
		}

		return [hcg[0], f * 100, v * 100];
	};

	convert.hcg.hsl = function (hcg) {
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;

		var l = g * (1.0 - c) + 0.5 * c;
		var s = 0;

		if (l > 0.0 && l < 0.5) {
			s = c / (2 * l);
		} else
		if (l >= 0.5 && l < 1.0) {
			s = c / (2 * (1 - l));
		}

		return [hcg[0], s * 100, l * 100];
	};

	convert.hcg.hwb = function (hcg) {
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;
		var v = c + g * (1.0 - c);
		return [hcg[0], (v - c) * 100, (1 - v) * 100];
	};

	convert.hwb.hcg = function (hwb) {
		var w = hwb[1] / 100;
		var b = hwb[2] / 100;
		var v = 1 - b;
		var c = v - w;
		var g = 0;

		if (c < 1) {
			g = (v - c) / (1 - c);
		}

		return [hwb[0], c * 100, g * 100];
	};

	convert.apple.rgb = function (apple) {
		return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
	};

	convert.rgb.apple = function (rgb) {
		return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
	};

	convert.gray.rgb = function (args) {
		return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	};

	convert.gray.hsl = convert.gray.hsv = function (args) {
		return [0, 0, args[0]];
	};

	convert.gray.hwb = function (gray) {
		return [0, 100, gray[0]];
	};

	convert.gray.cmyk = function (gray) {
		return [0, 0, 0, gray[0]];
	};

	convert.gray.lab = function (gray) {
		return [gray[0], 0, 0];
	};

	convert.gray.hex = function (gray) {
		var val = Math.round(gray[0] / 100 * 255) & 0xFF;
		var integer = (val << 16) + (val << 8) + val;

		var string = integer.toString(16).toUpperCase();
		return '000000'.substring(string.length) + string;
	};

	convert.rgb.gray = function (rgb) {
		var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
		return [val / 255 * 100];
	};
	});
	var conversions_1 = conversions.rgb;
	var conversions_2 = conversions.hsl;
	var conversions_3 = conversions.hsv;
	var conversions_4 = conversions.hwb;
	var conversions_5 = conversions.cmyk;
	var conversions_6 = conversions.xyz;
	var conversions_7 = conversions.lab;
	var conversions_8 = conversions.lch;
	var conversions_9 = conversions.hex;
	var conversions_10 = conversions.keyword;
	var conversions_11 = conversions.ansi16;
	var conversions_12 = conversions.ansi256;
	var conversions_13 = conversions.hcg;
	var conversions_14 = conversions.apple;
	var conversions_15 = conversions.gray;

	/*
		this function routes a model to all other models.

		all functions that are routed have a property `.conversion` attached
		to the returned synthetic function. This property is an array
		of strings, each with the steps in between the 'from' and 'to'
		color models (inclusive).

		conversions that are not possible simply are not included.
	*/

	function buildGraph() {
		var graph = {};
		// https://jsperf.com/object-keys-vs-for-in-with-closure/3
		var models = Object.keys(conversions);

		for (var len = models.length, i = 0; i < len; i++) {
			graph[models[i]] = {
				// http://jsperf.com/1-vs-infinity
				// micro-opt, but this is simple.
				distance: -1,
				parent: null
			};
		}

		return graph;
	}

	// https://en.wikipedia.org/wiki/Breadth-first_search
	function deriveBFS(fromModel) {
		var graph = buildGraph();
		var queue = [fromModel]; // unshift -> queue -> pop

		graph[fromModel].distance = 0;

		while (queue.length) {
			var current = queue.pop();
			var adjacents = Object.keys(conversions[current]);

			for (var len = adjacents.length, i = 0; i < len; i++) {
				var adjacent = adjacents[i];
				var node = graph[adjacent];

				if (node.distance === -1) {
					node.distance = graph[current].distance + 1;
					node.parent = current;
					queue.unshift(adjacent);
				}
			}
		}

		return graph;
	}

	function link(from, to) {
		return function (args) {
			return to(from(args));
		};
	}

	function wrapConversion(toModel, graph) {
		var path = [graph[toModel].parent, toModel];
		var fn = conversions[graph[toModel].parent][toModel];

		var cur = graph[toModel].parent;
		while (graph[cur].parent) {
			path.unshift(graph[cur].parent);
			fn = link(conversions[graph[cur].parent][cur], fn);
			cur = graph[cur].parent;
		}

		fn.conversion = path;
		return fn;
	}

	var route = function (fromModel) {
		var graph = deriveBFS(fromModel);
		var conversion = {};

		var models = Object.keys(graph);
		for (var len = models.length, i = 0; i < len; i++) {
			var toModel = models[i];
			var node = graph[toModel];

			if (node.parent === null) {
				// no possible conversion, or this node is the source model.
				continue;
			}

			conversion[toModel] = wrapConversion(toModel, graph);
		}

		return conversion;
	};

	var convert = {};

	var models = Object.keys(conversions);

	function wrapRaw(fn) {
		var wrappedFn = function (args) {
			if (args === undefined || args === null) {
				return args;
			}

			if (arguments.length > 1) {
				args = Array.prototype.slice.call(arguments);
			}

			return fn(args);
		};

		// preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	function wrapRounded(fn) {
		var wrappedFn = function (args) {
			if (args === undefined || args === null) {
				return args;
			}

			if (arguments.length > 1) {
				args = Array.prototype.slice.call(arguments);
			}

			var result = fn(args);

			// we're assuming the result is an array here.
			// see notice in conversions.js; don't use box types
			// in conversion functions.
			if (typeof result === 'object') {
				for (var len = result.length, i = 0; i < len; i++) {
					result[i] = Math.round(result[i]);
				}
			}

			return result;
		};

		// preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	models.forEach(function (fromModel) {
		convert[fromModel] = {};

		Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
		Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

		var routes = route(fromModel);
		var routeModels = Object.keys(routes);

		routeModels.forEach(function (toModel) {
			var fn = routes[toModel];

			convert[fromModel][toModel] = wrapRounded(fn);
			convert[fromModel][toModel].raw = wrapRaw(fn);
		});
	});

	var colorConvert = convert;

	var _slice = [].slice;

	var skippedModels = [
		// to be honest, I don't really feel like keyword belongs in color convert, but eh.
		'keyword',

		// gray conflicts with some method names, and has its own method defined.
		'gray',

		// shouldn't really be in color-convert either...
		'hex'
	];

	var hashedModelKeys = {};
	Object.keys(colorConvert).forEach(function (model) {
		hashedModelKeys[_slice.call(colorConvert[model].labels).sort().join('')] = model;
	});

	var limiters = {};

	function Color(obj, model) {
		if (!(this instanceof Color)) {
			return new Color(obj, model);
		}

		if (model && model in skippedModels) {
			model = null;
		}

		if (model && !(model in colorConvert)) {
			throw new Error('Unknown model: ' + model);
		}

		var i;
		var channels;

		if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
			this.model = 'rgb';
			this.color = [0, 0, 0];
			this.valpha = 1;
		} else if (obj instanceof Color) {
			this.model = obj.model;
			this.color = obj.color.slice();
			this.valpha = obj.valpha;
		} else if (typeof obj === 'string') {
			var result = colorString.get(obj);
			if (result === null) {
				throw new Error('Unable to parse color from string: ' + obj);
			}

			this.model = result.model;
			channels = colorConvert[this.model].channels;
			this.color = result.value.slice(0, channels);
			this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
		} else if (obj.length) {
			this.model = model || 'rgb';
			channels = colorConvert[this.model].channels;
			var newArr = _slice.call(obj, 0, channels);
			this.color = zeroArray(newArr, channels);
			this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
		} else if (typeof obj === 'number') {
			// this is always RGB - can be converted later on.
			obj &= 0xFFFFFF;
			this.model = 'rgb';
			this.color = [
				(obj >> 16) & 0xFF,
				(obj >> 8) & 0xFF,
				obj & 0xFF
			];
			this.valpha = 1;
		} else {
			this.valpha = 1;

			var keys = Object.keys(obj);
			if ('alpha' in obj) {
				keys.splice(keys.indexOf('alpha'), 1);
				this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
			}

			var hashedKeys = keys.sort().join('');
			if (!(hashedKeys in hashedModelKeys)) {
				throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
			}

			this.model = hashedModelKeys[hashedKeys];

			var labels = colorConvert[this.model].labels;
			var color = [];
			for (i = 0; i < labels.length; i++) {
				color.push(obj[labels[i]]);
			}

			this.color = zeroArray(color);
		}

		// perform limitations (clamping, etc.)
		if (limiters[this.model]) {
			channels = colorConvert[this.model].channels;
			for (i = 0; i < channels; i++) {
				var limit = limiters[this.model][i];
				if (limit) {
					this.color[i] = limit(this.color[i]);
				}
			}
		}

		this.valpha = Math.max(0, Math.min(1, this.valpha));

		if (Object.freeze) {
			Object.freeze(this);
		}
	}

	Color.prototype = {
		toString: function () {
			return this.string();
		},

		toJSON: function () {
			return this[this.model]();
		},

		string: function (places) {
			var self = this.model in colorString.to ? this : this.rgb();
			self = self.round(typeof places === 'number' ? places : 1);
			var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
			return colorString.to[self.model](args);
		},

		percentString: function (places) {
			var self = this.rgb().round(typeof places === 'number' ? places : 1);
			var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
			return colorString.to.rgb.percent(args);
		},

		array: function () {
			return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
		},

		object: function () {
			var result = {};
			var channels = colorConvert[this.model].channels;
			var labels = colorConvert[this.model].labels;

			for (var i = 0; i < channels; i++) {
				result[labels[i]] = this.color[i];
			}

			if (this.valpha !== 1) {
				result.alpha = this.valpha;
			}

			return result;
		},

		unitArray: function () {
			var rgb = this.rgb().color;
			rgb[0] /= 255;
			rgb[1] /= 255;
			rgb[2] /= 255;

			if (this.valpha !== 1) {
				rgb.push(this.valpha);
			}

			return rgb;
		},

		unitObject: function () {
			var rgb = this.rgb().object();
			rgb.r /= 255;
			rgb.g /= 255;
			rgb.b /= 255;

			if (this.valpha !== 1) {
				rgb.alpha = this.valpha;
			}

			return rgb;
		},

		round: function (places) {
			places = Math.max(places || 0, 0);
			return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
		},

		alpha: function (val) {
			if (arguments.length) {
				return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
			}

			return this.valpha;
		},

		// rgb
		red: getset('rgb', 0, maxfn(255)),
		green: getset('rgb', 1, maxfn(255)),
		blue: getset('rgb', 2, maxfn(255)),

		hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

		saturationl: getset('hsl', 1, maxfn(100)),
		lightness: getset('hsl', 2, maxfn(100)),

		saturationv: getset('hsv', 1, maxfn(100)),
		value: getset('hsv', 2, maxfn(100)),

		chroma: getset('hcg', 1, maxfn(100)),
		gray: getset('hcg', 2, maxfn(100)),

		white: getset('hwb', 1, maxfn(100)),
		wblack: getset('hwb', 2, maxfn(100)),

		cyan: getset('cmyk', 0, maxfn(100)),
		magenta: getset('cmyk', 1, maxfn(100)),
		yellow: getset('cmyk', 2, maxfn(100)),
		black: getset('cmyk', 3, maxfn(100)),

		x: getset('xyz', 0, maxfn(100)),
		y: getset('xyz', 1, maxfn(100)),
		z: getset('xyz', 2, maxfn(100)),

		l: getset('lab', 0, maxfn(100)),
		a: getset('lab', 1),
		b: getset('lab', 2),

		keyword: function (val) {
			if (arguments.length) {
				return new Color(val);
			}

			return colorConvert[this.model].keyword(this.color);
		},

		hex: function (val) {
			if (arguments.length) {
				return new Color(val);
			}

			return colorString.to.hex(this.rgb().round().color);
		},

		rgbNumber: function () {
			var rgb = this.rgb().color;
			return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
		},

		luminosity: function () {
			// http://www.w3.org/TR/WCAG20/#relativeluminancedef
			var rgb = this.rgb().color;

			var lum = [];
			for (var i = 0; i < rgb.length; i++) {
				var chan = rgb[i] / 255;
				lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
			}

			return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
		},

		contrast: function (color2) {
			// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
			var lum1 = this.luminosity();
			var lum2 = color2.luminosity();

			if (lum1 > lum2) {
				return (lum1 + 0.05) / (lum2 + 0.05);
			}

			return (lum2 + 0.05) / (lum1 + 0.05);
		},

		level: function (color2) {
			var contrastRatio = this.contrast(color2);
			if (contrastRatio >= 7.1) {
				return 'AAA';
			}

			return (contrastRatio >= 4.5) ? 'AA' : '';
		},

		isDark: function () {
			// YIQ equation from http://24ways.org/2010/calculating-color-contrast
			var rgb = this.rgb().color;
			var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
			return yiq < 128;
		},

		isLight: function () {
			return !this.isDark();
		},

		negate: function () {
			var rgb = this.rgb();
			for (var i = 0; i < 3; i++) {
				rgb.color[i] = 255 - rgb.color[i];
			}
			return rgb;
		},

		lighten: function (ratio) {
			var hsl = this.hsl();
			hsl.color[2] += hsl.color[2] * ratio;
			return hsl;
		},

		darken: function (ratio) {
			var hsl = this.hsl();
			hsl.color[2] -= hsl.color[2] * ratio;
			return hsl;
		},

		saturate: function (ratio) {
			var hsl = this.hsl();
			hsl.color[1] += hsl.color[1] * ratio;
			return hsl;
		},

		desaturate: function (ratio) {
			var hsl = this.hsl();
			hsl.color[1] -= hsl.color[1] * ratio;
			return hsl;
		},

		whiten: function (ratio) {
			var hwb = this.hwb();
			hwb.color[1] += hwb.color[1] * ratio;
			return hwb;
		},

		blacken: function (ratio) {
			var hwb = this.hwb();
			hwb.color[2] += hwb.color[2] * ratio;
			return hwb;
		},

		grayscale: function () {
			// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
			var rgb = this.rgb().color;
			var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
			return Color.rgb(val, val, val);
		},

		fade: function (ratio) {
			return this.alpha(this.valpha - (this.valpha * ratio));
		},

		opaquer: function (ratio) {
			return this.alpha(this.valpha + (this.valpha * ratio));
		},

		rotate: function (degrees) {
			var hsl = this.hsl();
			var hue = hsl.color[0];
			hue = (hue + degrees) % 360;
			hue = hue < 0 ? 360 + hue : hue;
			hsl.color[0] = hue;
			return hsl;
		},

		mix: function (mixinColor, weight) {
			// ported from sass implementation in C
			// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
			if (!mixinColor || !mixinColor.rgb) {
				throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
			}
			var color1 = mixinColor.rgb();
			var color2 = this.rgb();
			var p = weight === undefined ? 0.5 : weight;

			var w = 2 * p - 1;
			var a = color1.alpha() - color2.alpha();

			var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			var w2 = 1 - w1;

			return Color.rgb(
					w1 * color1.red() + w2 * color2.red(),
					w1 * color1.green() + w2 * color2.green(),
					w1 * color1.blue() + w2 * color2.blue(),
					color1.alpha() * p + color2.alpha() * (1 - p));
		}
	};

	// model conversion methods and static constructors
	Object.keys(colorConvert).forEach(function (model) {
		if (skippedModels.indexOf(model) !== -1) {
			return;
		}

		var channels = colorConvert[model].channels;

		// conversion methods
		Color.prototype[model] = function () {
			if (this.model === model) {
				return new Color(this);
			}

			if (arguments.length) {
				return new Color(arguments, model);
			}

			var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
			return new Color(assertArray(colorConvert[this.model][model].raw(this.color)).concat(newAlpha), model);
		};

		// 'static' construction methods
		Color[model] = function (color) {
			if (typeof color === 'number') {
				color = zeroArray(_slice.call(arguments), channels);
			}
			return new Color(color, model);
		};
	});

	function roundTo(num, places) {
		return Number(num.toFixed(places));
	}

	function roundToPlace(places) {
		return function (num) {
			return roundTo(num, places);
		};
	}

	function getset(model, channel, modifier) {
		model = Array.isArray(model) ? model : [model];

		model.forEach(function (m) {
			(limiters[m] || (limiters[m] = []))[channel] = modifier;
		});

		model = model[0];

		return function (val) {
			var result;

			if (arguments.length) {
				if (modifier) {
					val = modifier(val);
				}

				result = this[model]();
				result.color[channel] = val;
				return result;
			}

			result = this[model]().color[channel];
			if (modifier) {
				result = modifier(result);
			}

			return result;
		};
	}

	function maxfn(max) {
		return function (v) {
			return Math.max(0, Math.min(max, v));
		};
	}

	function assertArray(val) {
		return Array.isArray(val) ? val : [val];
	}

	function zeroArray(arr, length) {
		for (var i = 0; i < length; i++) {
			if (typeof arr[i] !== 'number') {
				arr[i] = 0;
			}
		}

		return arr;
	}

	var color = Color;

	/**
	 * Available styles for a Control.
	 */
	(function (ControlStyle) {
	    /**
	     * The control will be in the light style.
	     * Literal value `"light"`
	     */
	    ControlStyle["light"] = "light";
	    /**
	     * The control will be in the dark style.
	     * Literal value `"dark"`
	     */
	    ControlStyle["dark"] = "dark";
	    /**
	     * The control will automatically switch styles based on the style of the map.
	     * If a control doesn't support automatic styling the light style will be used by default.
	     * Literal value `"auto"`
	     */
	    ControlStyle["auto"] = "auto";
	})(exports.ControlStyle || (exports.ControlStyle = {}));

	/**
	 * For internal use only.
	 * Implements control interface and provides support for automatic styling based on the map style.
	 */
	var ControlBase = /** @class */ (function () {
	    function ControlBase() {
	        var _this = this;
	        /**
	         * A callback for when the map's style changes.
	         * Used for auto styling.
	         */
	        this._onStyleChange = function () {
	            if (_this._map.getStyle().style.toLowerCase().startsWith("blank")) {
	                // If the style is blank the div background should decide the theme.
	                if (!_this._observer) {
	                    // Add an observer to see changes to the background.
	                    _this._onBackgroundChange();
	                    _this._observer = new MutationObserver(_this._onBackgroundChange);
	                    _this._observer.observe(_this._map.getMapContainer(), { attributes: true, attributeFilter: ["style"] });
	                }
	            }
	            else {
	                if (_this._observer) {
	                    // Remove any existing observer for non-blank styles.
	                    _this._observer.disconnect();
	                    delete _this._observer;
	                }
	                // If the style is anything but blank the style definition should decide the theme.
	                var theme = _this._map.styles.getTheme(_this._map.getStyle());
	                _this._setTheme(theme);
	            }
	        };
	        /**
	         * A callback for when the map's
	         */
	        this._onBackgroundChange = function () {
	            // Calculate the luminosity of the map div's background to determine the theme.
	            try {
	                // Try to parse the color, could fail if something complex like a gradient is used.
	                var color$1 = color(_this._map.getMapContainer().style.backgroundColor);
	                var theme = color$1.luminosity() > 0.5 ? exports.ControlStyle.light : exports.ControlStyle.dark;
	                _this._setTheme(theme);
	            }
	            catch (_a) {
	                // If the background color can't be parsed assume it is light.
	                _this._setTheme(exports.ControlStyle.light);
	            }
	        };
	    }
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    ControlBase.prototype.onRemove = function () {
	        if (this._container) {
	            this._container.remove();
	            delete this._container;
	        }
	        if (this._map) {
	            this._map.events.remove("styledata", this._onStyleChange);
	            delete this._map;
	        }
	        if (this._observer) {
	            this._observer.disconnect();
	            delete this._observer;
	        }
	        delete this._theme;
	    };
	    /**
	     * Build the outermost container for the control, applies styling including any listeners for auto styling.
	     */
	    ControlBase.prototype.buildContainer = function (map, style, ariaLabel, tagName) {
	        var _this = this;
	        this._map = map;
	        this._container = document.createElement(tagName || "div");
	        this._container.classList.add("azure-maps-control-container");
	        if (typeof ariaLabel === "string") {
	            this._container.setAttribute("aria-label", ariaLabel);
	        }
	        // Set the style or add the auto listener.
	        if (style.toLowerCase() === exports.ControlStyle.auto) {
	            this._map.styles.initialize().then(function () {
	                _this._onStyleChange();
	                _this._map.events.add("styledata", _this._onStyleChange);
	            });
	        }
	        else {
	            this._container.classList.add(style);
	        }
	        return this._container;
	    };
	    /**
	     * Sets the control's theme (light/dark).
	     * Only applies changes if the theme is different than the previous.
	     */
	    ControlBase.prototype._setTheme = function (theme) {
	        // Only update if the theme is different.
	        if (this._theme !== theme) {
	            this._container.classList.remove(this._theme);
	            this._container.classList.add(theme);
	            this._theme = theme;
	        }
	    };
	    return ControlBase;
	}());

	/**
	 * The options for a CompassControl object.
	 */
	var CompassControlOptions = /** @class */ (function (_super) {
	    __extends(CompassControlOptions, _super);
	    function CompassControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will rotate with each click of the control.
	         * Default `15`.
	         * @default 15
	         */
	        _this.rotationDegreesDelta = 15;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return CompassControlOptions;
	}(Options));

	/**
	 * A control for changing the rotation of the map.
	 */
	var CompassControl = /** @class */ (function (_super) {
	    __extends(CompassControl, _super);
	    /**
	     * Constructs a CompassControl.
	     * @param options The options for the control.
	     */
	    function CompassControl(options) {
	        var _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.options = new CompassControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    CompassControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Rotation Control");
	        var rotationButton = this.constructRotationButton(map);
	        var rotationRightButton = this.constructRightRotationButton(map);
	        var rotationLeftButton = this.constructLeftRotationButton(map);
	        container.addEventListener("mouseover", function () {
	            _this.hasMouse = true;
	            container.classList.add("in-use");
	            rotationRightButton.classList.remove("hidden-accessible-element");
	            rotationLeftButton.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("focusin", function () {
	            container.classList.add("in-use");
	            rotationRightButton.classList.remove("hidden-accessible-element");
	            rotationLeftButton.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            container.classList.remove("in-use");
	            rotationRightButton.classList.add("hidden-accessible-element");
	            rotationLeftButton.classList.add("hidden-accessible-element");
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!_this.hasMouse &&
	                !(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                container.classList.remove("in-use");
	                rotationRightButton.classList.add("hidden-accessible-element");
	                rotationLeftButton.classList.add("hidden-accessible-element");
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && CompassControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(rotationRightButton);
	            container.appendChild(rotationLeftButton);
	            container.appendChild(rotationButton);
	        }
	        else {
	            container.appendChild(rotationButton);
	            container.appendChild(rotationLeftButton);
	            container.appendChild(rotationRightButton);
	        }
	        return container;
	    };
	    CompassControl.prototype.constructRotationButton = function (map) {
	        var rotationButton = document.createElement("button");
	        rotationButton.classList.add("azure-maps-control-button");
	        rotationButton.classList.add("rotation");
	        rotationButton.setAttribute("title", "Reset to Default Rotation");
	        rotationButton.setAttribute("alt", "Reset to Default Rotation");
	        rotationButton.setAttribute("type", "button");
	        var icon = document.createElement("div");
	        rotationButton.appendChild(icon);
	        rotationButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: CompassControl.DefaultRotation
	            }, true);
	        });
	        map.events.add("rotate", function (e) {
	            icon.style.transform = "rotate(" + -e.map.getCamera().bearing + "deg)";
	        });
	        return rotationButton;
	    };
	    CompassControl.prototype.constructRightRotationButton = function (map) {
	        var _this = this;
	        var rotationRightButton = document.createElement("button");
	        rotationRightButton.classList.add("azure-maps-control-button");
	        rotationRightButton.classList.add("rotation-right");
	        rotationRightButton.classList.add("hidden-accessible-element");
	        rotationRightButton.setAttribute("title", "Rotate Right");
	        rotationRightButton.setAttribute("alt", "Rotate Right");
	        rotationRightButton.setAttribute("type", "button");
	        rotationRightButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing + _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease",
	            }, true);
	        });
	        return rotationRightButton;
	    };
	    CompassControl.prototype.constructLeftRotationButton = function (map) {
	        var _this = this;
	        var rotationLeftButton = document.createElement("button");
	        rotationLeftButton.classList.add("azure-maps-control-button");
	        rotationLeftButton.classList.add("rotation-left");
	        rotationLeftButton.classList.add("hidden-accessible-element");
	        rotationLeftButton.setAttribute("title", "Rotate Left");
	        rotationLeftButton.setAttribute("alt", "Rotate Left");
	        rotationLeftButton.setAttribute("type", "button");
	        rotationLeftButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing - _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease"
	            }, true);
	        });
	        return rotationLeftButton;
	    };
	    CompassControl.DefaultRotation = 0;
	    /** @internal */ CompassControl.RotationDuration = 100;
	    CompassControl.InvertOrderPositions = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return CompassControl;
	}(ControlBase));

	/**
	 * The options for a PitchControl object.
	 */
	var PitchControlOptions = /** @class */ (function (_super) {
	    __extends(PitchControlOptions, _super);
	    function PitchControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will tilt with each click of the control.
	         * Default `10`.
	         * @default 10
	         */
	        _this.pitchDegreesDelta = 10;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return PitchControlOptions;
	}(Options));

	/**
	 * A control for changing the pitch of the map.
	 */
	var PitchControl = /** @class */ (function (_super) {
	    __extends(PitchControl, _super);
	    /**
	     * Constructs a PitchControl.
	     * @param options The options for the control.
	     */
	    function PitchControl(options) {
	        var _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.options = new PitchControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    PitchControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Pitch Control");
	        var pitchButton = this.constructPitchButton(map);
	        var pitchIncrementButton = this.constructPitchIncrementButton(map);
	        var pitchDecrementButton = this.constructPitchDecrementButton(map);
	        container.addEventListener("mouseover", function () {
	            _this.hasMouse = true;
	            container.classList.add("in-use");
	            pitchIncrementButton.classList.remove("hidden-accessible-element");
	            pitchDecrementButton.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("focusin", function () {
	            container.classList.add("in-use");
	            pitchIncrementButton.classList.remove("hidden-accessible-element");
	            pitchDecrementButton.classList.remove("hidden-accessible-element");
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            container.classList.remove("in-use");
	            pitchIncrementButton.classList.add("hidden-accessible-element");
	            pitchDecrementButton.classList.add("hidden-accessible-element");
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!_this.hasMouse &&
	                !(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                container.classList.remove("in-use");
	                pitchIncrementButton.classList.add("hidden-accessible-element");
	                pitchDecrementButton.classList.add("hidden-accessible-element");
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && PitchControl.INVERT_ORDER_POSITIONS.includes(options.position)) {
	            container.appendChild(pitchDecrementButton);
	            container.appendChild(pitchIncrementButton);
	            container.appendChild(pitchButton);
	        }
	        else {
	            container.appendChild(pitchButton);
	            container.appendChild(pitchIncrementButton);
	            container.appendChild(pitchDecrementButton);
	        }
	        return container;
	    };
	    PitchControl.prototype.constructPitchButton = function (map) {
	        var pitchButton = document.createElement("button");
	        pitchButton.classList.add("azure-maps-control-button");
	        pitchButton.classList.add("pitch");
	        pitchButton.setAttribute("title", "Reset to Default Pitch");
	        pitchButton.setAttribute("alt", "Reset to Default Pitch");
	        pitchButton.setAttribute("type", "button");
	        pitchButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: PitchControl.DEFAULT_PITCH
	            }, true);
	        });
	        return pitchButton;
	    };
	    PitchControl.prototype.constructPitchDecrementButton = function (map) {
	        var _this = this;
	        var pitchDecrementButton = document.createElement("button");
	        pitchDecrementButton.classList.add("azure-maps-control-button");
	        pitchDecrementButton.classList.add("pitch-down");
	        pitchDecrementButton.classList.add("hidden-accessible-element");
	        pitchDecrementButton.setAttribute("title", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("alt", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("type", "button");
	        pitchDecrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch - _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchDecrementButton;
	    };
	    PitchControl.prototype.constructPitchIncrementButton = function (map) {
	        var _this = this;
	        var pitchIncrementButton = document.createElement("button");
	        pitchIncrementButton.classList.add("azure-maps-control-button");
	        pitchIncrementButton.classList.add("pitch-up");
	        pitchIncrementButton.classList.add("hidden-accessible-element");
	        pitchIncrementButton.setAttribute("title", "Increase Pitch");
	        pitchIncrementButton.setAttribute("alt", "Increase Pitch");
	        pitchIncrementButton.setAttribute("type", "button");
	        pitchIncrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch + _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchIncrementButton;
	    };
	    PitchControl.PITCH_DURATION_MS = 100;
	    PitchControl.DEFAULT_PITCH = 0;
	    PitchControl.INVERT_ORDER_POSITIONS = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return PitchControl;
	}(ControlBase));

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new _ListCache;
	  this.size = 0;
	}

	var _stackClear = stackClear;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/** Built-in value references. */
	var Symbol$1 = _root.Symbol;

	var _Symbol = Symbol$1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var Map$1 = _getNative(_root, 'Map');

	var _Map = Map$1;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof _ListCache) {
	    var pairs = data.__data__;
	    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new _MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new _ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = _stackClear;
	Stack.prototype['delete'] = _stackDelete;
	Stack.prototype.get = _stackGet;
	Stack.prototype.has = _stackHas;
	Stack.prototype.set = _stackSet;

	var _Stack = Stack;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var _arrayEach = arrayEach;

	var defineProperty = (function() {
	  try {
	    var func = _getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty = defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && _defineProperty) {
	    _defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$4.call(object, key) && eq_1(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignValue = assignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      _baseAssignValue(object, key, newValue);
	    } else {
	      _assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	  return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	var isArguments_1 = isArguments;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	var isArray_1 = isArray;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	var isBuffer_1 = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse_1;

	module.exports = isBuffer;
	});

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	var isLength_1 = isLength;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike_1(value) &&
	    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary;

	var _nodeUtil = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && _freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;
	});

	/* Node.js helper references. */
	var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

	var isTypedArray_1 = isTypedArray;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray_1(value),
	      isArg = !isArr && isArguments_1(value),
	      isBuff = !isArr && !isArg && isBuffer_1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? _baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           _isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

	  return value === proto;
	}

	var _isPrototype = isPrototype;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = _overArg(Object.keys, Object);

	var _nativeKeys = nativeKeys;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!_isPrototype(object)) {
	    return _nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength_1(value.length) && !isFunction_1(value);
	}

	var isArrayLike_1 = isArrayLike;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
	}

	var keys_1 = keys;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && _copyObject(source, keys_1(source), object);
	}

	var _baseAssign = baseAssign;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject_1(object)) {
	    return _nativeKeysIn(object);
	  }
	  var isProto = _isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$1(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
	}

	var keysIn_1 = keysIn$1;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && _copyObject(source, keysIn_1(source), object);
	}

	var _baseAssignIn = baseAssignIn;

	var _cloneBuffer = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;
	});

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	var stubArray_1 = stubArray;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return _copyObject(source, _getSymbols(source), object);
	}

	var _copySymbols = copySymbols;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush;

	/** Built-in value references. */
	var getPrototype = _overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
	  var result = [];
	  while (object) {
	    _arrayPush(result, _getSymbols(object));
	    object = _getPrototype(object);
	  }
	  return result;
	};

	var _getSymbolsIn = getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return _copyObject(source, _getSymbolsIn(source), object);
	}

	var _copySymbolsIn = copySymbolsIn;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return _baseGetAllKeys(object, keys_1, _getSymbols);
	}

	var _getAllKeys = getAllKeys;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
	}

	var _getAllKeysIn = getAllKeysIn;

	/* Built-in method references that are verified to be native. */
	var DataView = _getNative(_root, 'DataView');

	var _DataView = DataView;

	/* Built-in method references that are verified to be native. */
	var Promise$1 = _getNative(_root, 'Promise');

	var _Promise = Promise$1;

	/* Built-in method references that are verified to be native. */
	var Set$1 = _getNative(_root, 'Set');

	var _Set = Set$1;

	/* Built-in method references that are verified to be native. */
	var WeakMap = _getNative(_root, 'WeakMap');

	var _WeakMap = WeakMap;

	/** `Object#toString` result references. */
	var mapTag$1 = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$1 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$1 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = _toSource(_DataView),
	    mapCtorString = _toSource(_Map),
	    promiseCtorString = _toSource(_Promise),
	    setCtorString = _toSource(_Set),
	    weakMapCtorString = _toSource(_WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = _baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
	    (_Map && getTag(new _Map) != mapTag$1) ||
	    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
	    (_Set && getTag(new _Set) != setTag$1) ||
	    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = _baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? _toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$1;
	        case mapCtorString: return mapTag$1;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$1;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	var _initCloneArray = initCloneArray;

	/** Built-in value references. */
	var Uint8Array$1 = _root.Uint8Array;

	var _Uint8Array = Uint8Array$1;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	var _cloneDataView = cloneDataView;

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	var _cloneRegExp = cloneRegExp;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	var _cloneSymbol = cloneSymbol;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$1:
	      return _cloneArrayBuffer(object);

	    case boolTag$1:
	    case dateTag$1:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return _cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return _cloneTypedArray(object, isDeep);

	    case mapTag$2:
	      return new Ctor;

	    case numberTag$1:
	    case stringTag$1:
	      return new Ctor(object);

	    case regexpTag$1:
	      return _cloneRegExp(object);

	    case setTag$2:
	      return new Ctor;

	    case symbolTag:
	      return _cloneSymbol(object);
	  }
	}

	var _initCloneByTag = initCloneByTag;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject_1(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !_isPrototype(object))
	    ? _baseCreate(_getPrototype(object))
	    : {};
	}

	var _initCloneObject = initCloneObject;

	/** `Object#toString` result references. */
	var mapTag$3 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike_1(value) && _getTag(value) == mapTag$3;
	}

	var _baseIsMap = baseIsMap;

	/* Node.js helper references. */
	var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

	var isMap_1 = isMap;

	/** `Object#toString` result references. */
	var setTag$3 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike_1(value) && _getTag(value) == setTag$3;
	}

	var _baseIsSet = baseIsSet;

	/* Node.js helper references. */
	var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

	var isSet_1 = isSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    mapTag$4 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$4 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$1 = '[object Symbol]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
	cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
	cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
	cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
	cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
	cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
	cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
	cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
	cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
	cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag$2] =
	cloneableTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject_1(value)) {
	    return value;
	  }
	  var isArr = isArray_1(value);
	  if (isArr) {
	    result = _initCloneArray(value);
	    if (!isDeep) {
	      return _copyArray(value, result);
	    }
	  } else {
	    var tag = _getTag(value),
	        isFunc = tag == funcTag$2 || tag == genTag$1;

	    if (isBuffer_1(value)) {
	      return _cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$2 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? _copySymbolsIn(value, _baseAssignIn(result, value))
	          : _copySymbols(value, _baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = _initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new _Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet_1(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap_1(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? _getAllKeysIn : _getAllKeys)
	    : (isFlat ? keysIn : keys_1);

	  var props = isArr ? undefined : keysFunc(value);
	  _arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	var _baseClone = baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
	}

	var cloneDeep_1 = cloneDeep;

	var Dictionary = Map;

	/**
	 * The options for a StyleControl object.
	 */
	var StyleControlOptions = /** @class */ (function (_super) {
	    __extends(StyleControlOptions, _super);
	    function StyleControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The layout to display the styles in.
	         * <p>`"icons"`: A row of clickable icons for each style.</p>
	         * <p>`"list"`: A scrollable list with the icons and names for each style.</p>
	         * Default `"icons"`
	         * @default "icons"
	         */
	        _this.layout = "icons";
	        /**
	         * The map styles to show in the control.
	         * Style names are case sensitive.
	         * If an included style isn't supported by the map it will be ignored.
	         * Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article.
	         * If "all" is specified, all map styles will be shown.
	         * Default `["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]`
	         * @default ["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]
	         */
	        _this.mapStyles = ["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"];
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return StyleControlOptions;
	}(Options));

	/**
	 * A control for changing the style of the map.
	 */
	var StyleControl = /** @class */ (function (_super) {
	    __extends(StyleControl, _super);
	    /**
	     * Constructs a StyleControl.
	     * @param options The options for the control.
	     */
	    function StyleControl(options) {
	        var _this = _super.call(this) || this;
	        _this.styleIcons = new Dictionary();
	        /**
	         * Callback handler for the style changing.
	         */
	        _this.onStyleChange = function () {
	            var newStyle = _this.map.getStyle().style;
	            if (_this.styleIcons.has(newStyle)) {
	                _this.currStyleImage.src = _this.styleIcons.get(newStyle);
	                _this.currStyleImage.alt = newStyle;
	            }
	        };
	        _this.options = new StyleControlOptions().merge(cloneDeep_1(options));
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    StyleControl.prototype.onAdd = function (map, options) {
	        this.map = map;
	        var container = this.buildContainer(map, this.options.style, "Map Style Control");
	        var styleOpsGrid = this.buildStyleOpsGrid(container);
	        var currStyleButton = this.buildCurrStyleBtn(container, styleOpsGrid);
	        if (options && StyleControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(styleOpsGrid);
	            container.appendChild(currStyleButton);
	        }
	        else {
	            container.appendChild(currStyleButton);
	            container.appendChild(styleOpsGrid);
	        }
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    StyleControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        this.map.events.remove("styledata", this.onStyleChange);
	    };
	    StyleControl.prototype.buildSelectStyleBtn = function (container, opsGrid, name, icon) {
	        var _this = this;
	        var styleOptionButton = document.createElement("button");
	        styleOptionButton.setAttribute("title", name);
	        styleOptionButton.setAttribute("alt", name);
	        styleOptionButton.setAttribute("type", "button");
	        var styleIconImage = new Image(28, 28);
	        styleIconImage.src = icon;
	        styleIconImage.alt = name;
	        styleOptionButton.appendChild(styleIconImage);
	        if (this.options.layout === "icons") {
	            styleOptionButton.classList.add(StyleControl.Css.button);
	        }
	        else {
	            styleOptionButton.appendChild(document.createTextNode(name));
	        }
	        styleOptionButton.addEventListener("click", function () {
	            _this.map.setStyle({ style: name });
	            _this.setStyleOpsVisible(container, opsGrid, false);
	        });
	        return styleOptionButton;
	    };
	    StyleControl.prototype.buildCurrStyleBtn = function (container, opsGrid) {
	        var _this = this;
	        var selectCurrButton = document.createElement("button");
	        selectCurrButton.classList.add(StyleControl.Css.button);
	        selectCurrButton.classList.add(StyleControl.Css.currentStyle);
	        selectCurrButton.setAttribute("title", "Select Style");
	        selectCurrButton.setAttribute("alt", "Select Style");
	        selectCurrButton.setAttribute("type", "button");
	        this.currStyleImage = new Image(28, 28);
	        selectCurrButton.appendChild(this.currStyleImage);
	        var selectCurrButtonIcon = document.createElement("div");
	        selectCurrButtonIcon.classList.add("icon");
	        selectCurrButton.appendChild(selectCurrButtonIcon);
	        selectCurrButton.addEventListener("click", function () {
	            _this.setStyleOpsVisible(container, opsGrid, !container.classList.contains(StyleControl.Css.inUse));
	        });
	        return selectCurrButton;
	    };
	    StyleControl.prototype.buildStyleOpsGrid = function (container) {
	        var _this = this;
	        var styleOpsGrid = document.createElement("div");
	        styleOpsGrid.classList.add(StyleControl.Css.styleOptions);
	        styleOpsGrid.classList.add(this.options.layout);
	        styleOpsGrid.setAttribute("aria-label", "Style Options");
	        styleOpsGrid.style.display = "none";
	        // Once the map's style definition is initialized create a map between style names and icons.
	        // If a style is one of those to be shown by the style picker also create it's element.
	        this.map.styles.initialize().then(function () {
	            var styleDef = _this.map.styles.getDef();
	            var currStyle = _this.map.getStyle().style;
	            for (var _i = 0, _a = styleDef.styles; _i < _a.length; _i++) {
	                var style = _a[_i];
	                var iconUrl = new Url({
	                    domain: styleDef.domain,
	                    path: style.iconPath
	                }).toString();
	                // Always add a style even if it won't be shown by the style picker.
	                // This way the map's style can be set to something other than the picker.
	                // The style picker will still show the correct icon.
	                _this.styleIcons.set(style.name, iconUrl);
	                if (style.name === currStyle) {
	                    _this.currStyleImage.src = iconUrl;
	                    _this.currStyleImage.alt = style.name;
	                }
	            }
	            if (_this.options.mapStyles === "all") {
	                _this.styleIcons.forEach(function (iconUrl, styleName) {
	                    var styleOptionButton = _this.buildSelectStyleBtn(container, styleOpsGrid, styleName, iconUrl);
	                    styleOpsGrid.appendChild(styleOptionButton);
	                });
	            }
	            else {
	                _this.options.mapStyles.filter(function (styleName) { return _this.styleIcons.has(styleName); }).forEach(function (styleName) {
	                    var iconUrl = _this.styleIcons.get(styleName);
	                    var styleOptionButton = _this.buildSelectStyleBtn(container, styleOpsGrid, styleName, iconUrl);
	                    styleOpsGrid.appendChild(styleOptionButton);
	                });
	            }
	            _this.map.events.add("styledata", _this.onStyleChange);
	        });
	        return styleOpsGrid;
	    };
	    StyleControl.prototype.setStyleOpsVisible = function (container, opsGrid, visible) {
	        if (visible) {
	            container.classList.add(StyleControl.Css.inUse);
	            opsGrid.style.display = "";
	        }
	        else {
	            container.classList.remove(StyleControl.Css.inUse);
	            opsGrid.style.display = "none";
	        }
	    };
	    StyleControl.InvertOrderPositions = [exports.ControlPosition.TopRight, exports.ControlPosition.BottomRight];
	    StyleControl.Css = {
	        button: "azure-maps-control-button",
	        currentStyle: "curr-style",
	        inUse: "in-use",
	        styleOptions: "style-options"
	    };
	    return StyleControl;
	}(ControlBase));

	/**
	 * The options for a ZoomControl object.
	 */
	var ZoomControlOptions = /** @class */ (function (_super) {
	    __extends(ZoomControlOptions, _super);
	    function ZoomControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The extent to which the map will zoom with each click of the control.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoomDelta = 1;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return ZoomControlOptions;
	}(Options));

	/**
	 * A control for changing the zoom of the map.
	 */
	var ZoomControl = /** @class */ (function (_super) {
	    __extends(ZoomControl, _super);
	    /**
	     * Constructs a ZoomControl.
	     * @param options The options for the control.
	     */
	    function ZoomControl(options) {
	        var _this = _super.call(this) || this;
	        _this.options = new ZoomControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    ZoomControl.prototype.onAdd = function (map) {
	        var container = this.buildContainer(map, this.options.style, "Zoom Control");
	        container.style.flexDirection = "column";
	        var zoomInButton = this.constructZoomInButton(map);
	        var zoomOutButton = this.constructZoomOutButton(map);
	        container.appendChild(zoomInButton);
	        container.appendChild(zoomOutButton);
	        return container;
	    };
	    ZoomControl.prototype.constructZoomInButton = function (map) {
	        var _this = this;
	        var zoomInButton = document.createElement("button");
	        zoomInButton.classList.add("azure-maps-control-button");
	        zoomInButton.classList.add("zoom-in");
	        zoomInButton.setAttribute("title", "Zoom In");
	        zoomInButton.setAttribute("alt", "Zoom In");
	        zoomInButton.setAttribute("type", "button");
	        zoomInButton.addEventListener("click", function () {
	            map.setCamera({
	                zoom: map.getCamera().zoom + _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomInButton;
	    };
	    ZoomControl.prototype.constructZoomOutButton = function (map) {
	        var _this = this;
	        var zoomOutButton = document.createElement("button");
	        zoomOutButton.classList.add("azure-maps-control-button");
	        zoomOutButton.classList.add("zoom-out");
	        zoomOutButton.setAttribute("title", "Zoom Out");
	        zoomOutButton.setAttribute("alt", "Zoom Out");
	        zoomOutButton.setAttribute("type", "button");
	        zoomOutButton.addEventListener("click", function () {
	            map.setCamera({
	                zoom: map.getCamera().zoom - _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomOutButton;
	    };
	    ZoomControl.ZOOM_DURATION_MS = 200;
	    return ZoomControl;
	}(ControlBase));



	var index = /*#__PURE__*/Object.freeze({
		PitchControl: PitchControl,
		CompassControl: CompassControl,
		ZoomControl: ZoomControl,
		StyleControl: StyleControl
	});

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new _MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;

	var _SetCache = SetCache;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arraySome = arraySome;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!_arraySome(other, function(othValue, othIndex) {
	            if (!_cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	var _equalArrays = equalArrays;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	var _mapToArray = mapToArray;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/** `Object#toString` result references. */
	var boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    mapTag$5 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$3 = '[object String]',
	    symbolTag$2 = '[object Symbol]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$4:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$3:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$3:
	    case dateTag$3:
	    case numberTag$3:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq_1(+object, +other);

	    case errorTag$2:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$3:
	    case stringTag$3:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$5:
	      var convert = _mapToArray;

	    case setTag$5:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
	      convert || (convert = _setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$1;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag$2:
	      if (symbolValueOf$1) {
	        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
	      }
	  }
	  return false;
	}

	var _equalByTag = equalByTag;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** Used for built-in method references. */
	var objectProto$d = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$d.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
	      objProps = _getAllKeys(object),
	      objLength = objProps.length,
	      othProps = _getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	var _equalObjects = equalObjects;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    objectTag$3 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$e = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$e.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray_1(object),
	      othIsArr = isArray_1(other),
	      objTag = objIsArr ? arrayTag$2 : _getTag(object),
	      othTag = othIsArr ? arrayTag$2 : _getTag(other);

	  objTag = objTag == argsTag$3 ? objectTag$3 : objTag;
	  othTag = othTag == argsTag$3 ? objectTag$3 : othTag;

	  var objIsObj = objTag == objectTag$3,
	      othIsObj = othTag == objectTag$3,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer_1(object)) {
	    if (!isBuffer_1(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new _Stack);
	    return (objIsArr || isTypedArray_1(object))
	      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$b.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new _Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new _Stack);
	  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	var _baseIsEqualDeep = baseIsEqualDeep;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
	    return value !== value && other !== other;
	  }
	  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	var _baseIsEqual = baseIsEqual;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return _baseIsEqual(value, other);
	}

	var isEqual_1 = isEqual;

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		'default': _nodeResolve_empty
	});

	var require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);

	var uuidRandom = createCommonjsModule(function (module) {

	(function(){

	  var 
	    buf,
	    bufIdx = 0,
	    hexBytes = [],
	    i
	  ;

	  // Improve memory performance by decreasing this number (>=16)
	  // or improve speed by increasing this number (try 16384)
	  uuid.BUFFER_SIZE = 512;

	  // Binary uuids (even faster)
	  uuid.bin = uuidbin;

	  // Test for uuid
	  uuid.test = isUUID;

	  // Cache toString(16)
	  // This is massively impactful on performance
	  for (i = 0; i < 256; i++) {

	    // This is a fast way to ensure a 2 char hex byte
	    hexBytes[i] = (i + 0x100).toString(16).substr(1);
	  }

	  // Node & Browser support
	  var _crypto;
	  if(typeof crypto !== 'undefined') {
	    _crypto = crypto;
	  } else if( (typeof window !== 'undefined') && (typeof window.msCrypto !== 'undefined')) {
	    // IE11
	    _crypto = window.msCrypto;
	  } 

	  if ( (typeof commonjsRequire === 'function')) {
	    _crypto = _crypto || require$$0;
	    module.exports = uuid;
	  } else if (typeof window !== 'undefined') {
	    window.uuid = uuid;
	  }

	  // Backup method
	  function getRandomInt(min, max) {
	    return Math.floor(Math.random() * (max - min)) + min;
	  }

	  // uuid.test
	  function isUUID(uuid) {
	    if (typeof uuid === 'string') {
	      return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(uuid);
	    }
	  }

	  // Use best RNG as possible
	  function randomBytes(n) {
	    var r;
	    if (typeof _crypto !== 'undefined') {
	      if ((typeof buf === 'undefined') || ((bufIdx + n) > uuid.BUFFER_SIZE)) {
	        bufIdx = 0;
	        if (_crypto.getRandomValues) {
	          buf = new Uint8Array(uuid.BUFFER_SIZE);
	          _crypto.getRandomValues(buf);
	        } else if (_crypto.randomBytes) {
	          buf = _crypto.randomBytes(uuid.BUFFER_SIZE);
	        } else {
	          throw new Error('Non-standard crypto library');
	        }
	      }
	      return buf.slice(bufIdx, bufIdx += n);
	    } else {
	      r = [];
	      for (i = 0; i < n; i++) {
	        r.push(getRandomInt(0, 255));
	      }
	      return r;
	    }
	  }

	  // uuid.bin
	  function uuidbin() {
	    var b = randomBytes(16);
	    b[6] = (b[6] & 0x0f) | 0x40;
	    b[8] = (b[8] & 0x3f) | 0x80;
	    return b;
	  }

	  // String UUIDv4 (Random)
	  function uuid() {
	    var b = uuidbin();
	    return hexBytes[b[0]] + hexBytes[b[1]] + 
	      hexBytes[b[2]] + hexBytes[b[3]] + '-' +
	      hexBytes[b[4]] + hexBytes[b[5]] + '-' +
	      hexBytes[b[6]] + hexBytes[b[7]] + '-' +
	      hexBytes[b[8]] + hexBytes[b[9]] + '-' +
	      hexBytes[b[10]] + hexBytes[b[11]] + 
	      hexBytes[b[12]] + hexBytes[b[13]] +
	      hexBytes[b[14]] + hexBytes[b[15]]
	    ;
	  }

	})();
	});

	/**
	 * A GeoJSON Feature object - a JSON object representing a spatially bounded entity. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.2}.
	 */
	var Feature = /** @class */ (function () {
	    /**
	     * Constructs a Feature.
	     * @param geometry The geometry of the feature.
	     * @param properties The properties of the feature.
	     * @param id The id of the feature.
	     */
	    function Feature(geometry, properties, id) {
	        /**
	         * A GeoJSON type descriptor with value "Feature".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Feature";
	        this.type = Feature.TYPE;
	        this.properties = properties || {};
	        this.id = id;
	        this.geometry = geometry;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Feature class to be used in runtime comparisons.
	     */
	    Feature.TYPE = "Feature";
	    return Feature;
	}());

	/**
	 * Represent a pixel coordinate or offset. Extends an array of [x, y].
	 */
	var Pixel = /** @class */ (function (_super) {
	    __extends(Pixel, _super);
	    /**
	     * Constructs a Pixel object and initializes it with the specified x and y coordinates.
	     * @param x The horizontal pixel offset.
	     * @param y The vertical pixel offset.
	     */
	    function Pixel(x, y) {
	        return _super.call(this, x, y) || this;
	    }
	    /**
	     * Generates a Pixel object from an object that contains coordinate information.
	     * The object is scanned for x and y properties using a case insensitive test.
	     * @param data The object to extract coordinate information from.
	     * @returns A Pixel object that represents the provided data information.
	     */
	    Pixel.fromData = function (data) {
	        var x = NaN;
	        var y = NaN;
	        var xNames = new Set(["y"]);
	        var yNames = new Set(["x"]);
	        // Do a case insensitive search through the object properties.
	        Object.keys(data).forEach(function (key) {
	            var smallKey = key.toLowerCase();
	            if (isNaN(x) && xNames.has(smallKey) && typeof data[key] === "number") {
	                x = data[key];
	            }
	            else if (isNaN(y) && yNames.has(smallKey) && typeof data[key] === "number") {
	                y = data[key];
	            }
	        });
	        // If an x and y value were found return the Pixel constructed from them.
	        if (!isNaN(x) && !isNaN(y)) {
	            return new Pixel(x, y);
	        }
	        return null;
	    };
	    /**
	     * Return the x coordinate of the specified pixel.
	     * @param pixel The pixel to get the x coordinate of.
	     */
	    Pixel.getX = function (pixel) {
	        if (pixel.length > 0) {
	            return pixel[0];
	        }
	        return NaN;
	    };
	    /**
	     * Return the y coordinate of the specified pixel.
	     * @param pixel The pixel to get the y coordinate of.
	     */
	    Pixel.getY = function (pixel) {
	        if (pixel.length > 1) {
	            return pixel[1];
	        }
	        return NaN;
	    };
	    /**
	     * Calculates a destination pixel given an origin pixel,
	     * a heading relative to the y-axis (0 = north),
	     * and a distance in pixel units.
	     * @param origin The starting pixel.
	     * @param heading The heading at which to move away from the origin pixel.
	     * @param distance The distance to move from the origin pixel.
	     */
	    Pixel.getDestination = function (origin, heading, distance) {
	        return new Pixel(Pixel.getX(origin) + distance * Math.cos((90 - heading) * Math.PI / 180), Pixel.getY(origin) + distance * Math.sin((90 - heading) * Math.PI / 180));
	    };
	    /**
	     * Calculates the distance between two pixels.
	     * Returned value is in screen pixel units.
	     * @param p1 The first pixel.
	     * @param p2 The second pixel.
	     */
	    Pixel.getDistance = function (p1, p2) {
	        var dx = Pixel.getX(p1) - Pixel.getX(p2);
	        var dy = Pixel.getY(p1) - Pixel.getY(p2);
	        return Math.sqrt(dx * dx + dy * dy);
	    };
	    /**
	     * Calculates the heading between two pixels.
	     * @param origin The pixel the heading will point away from.
	     * @param destination The pixel the heading will point toward.
	     */
	    Pixel.getHeading = function (origin, destination) {
	        var dx = Pixel.getX(destination) - Pixel.getX(origin);
	        var dy = Pixel.getY(origin) - Pixel.getY(destination);
	        return ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * 180 / Math.PI % 360;
	    };
	    return Pixel;
	}(Array));

	/**
	 * A GeoJSON Point object - a JSON object that represents a geographic position. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.2}.
	 */
	var Point = /** @class */ (function () {
	    /**
	     * Constructs a Point.
	     * @param coordinates The position defining the point.
	     */
	    function Point(coordinates) {
	        /**
	         * A GeoJSON type descriptor with value "Point".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Point";
	        this.type = Point.TYPE;
	        this.coordinates = coordinates;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Point class to be used in runtime comparisons.
	     */
	    Point.TYPE = "Point";
	    return Point;
	}());

	//////////////////////
	/// Constants
	//////////////////////
	/**
	 * Earth Radius Semi Major Axis in meters
	 */
	var EARTH_RADIUS_SEMI_MAJOR_AXIS = 6378137;
	/**
	 * A constant for Math.PI/180. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var PI_BY_180 = Math.PI / 180;
	/**
	 * A constant for 180 / Math.PI. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var INV_PI_BY_180 = 180 / Math.PI;
	/**
	 * Cached array of powers of 10. This will be faster than call Math.pow.
	 */
	var POWERS_OF_10 = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
	//////////////////////
	/// Private Functions
	//////////////////////
	/**
	 * Converts an angle that is in degrees to radians. Angle * (PI / 180).
	 * @param angle An angle in degrees.
	 * @returns An angle in radians.
	 */
	function _toRadians(angle) {
	    return angle * PI_BY_180;
	}
	/**
	 * Converts an angle that is in radians to degrees. Angle * (180 / PI).
	 * @param angle An angle in radians.
	 * @returns An angle in degrees.
	 */
	function _toDegrees(angle) {
	    return angle * INV_PI_BY_180;
	}
	/**
	 * Clips a number to the specified minimum and maximum values.
	 * @param val The number to clip.
	 * @param minValue Minimum allowable value.
	 * @param maxValue Maximum allowable value.
	 * @returns The clipped value.
	 */
	function _clip(val, minValue, maxValue) {
	    return Math.min(Math.max(val, minValue), maxValue);
	}
	/**
	 * Calculates geodetic distance between two Position objects using Haversine formula in meters.
	 * @param origin Position to calculate distance from.
	 * @param destination Position to calculate distance to.
	 * @returns A distance in meters between the two positions.
	 */
	function _haversineDistance(origin, destination) {
	    // https://en.wikipedia.org/wiki/Haversine_formula
	    var dLat = _toRadians(destination[1] - origin[1]);
	    var dLon = _toRadians(destination[0] - origin[0]);
	    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(_toRadians(origin[1])) * Math.cos(_toRadians(destination[1])) * Math.pow(Math.sin(dLon / 2), 2);
	    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    return Math.round(EARTH_RADIUS_SEMI_MAJOR_AXIS * c * 100) / 100; // Round to 1cm precision.
	}
	/**
	 * Normalizes a distance unit string. Defaults to meters.
	 * @param units The distance units to normalize.
	 * @returns A normalized distance unit string.
	 */
	function _normalizeDistanceUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feet":
	            case "foot":
	            case "ft":
	                return DistanceUnits.feet;
	            case "kilometers":
	            case "kilometer":
	            case "kilometres":
	            case "kilometre":
	            case "km":
	            case "kms":
	                return DistanceUnits.kilometers;
	            case "miles":
	            case "mile":
	            case "mi":
	                return DistanceUnits.miles;
	            case "nauticalmiles":
	            case "nauticalmile":
	            case "nms":
	            case "nm":
	                return DistanceUnits.nauticalMiles;
	            case "yards":
	            case "yard":
	            case "yds":
	            case "yrd":
	            case "yrds":
	                return DistanceUnits.yards;
	            case "meters":
	            case "metres":
	            case "m":
	            default:
	                return DistanceUnits.meters;
	        }
	    }
	    return DistanceUnits.meters;
	}
	/**
	 * Normailzes a acceleration unit string. Defaults to metersPerSecondSquared.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param units The acceleration units to normalize.
	 * @returns A normailzed acceleration unit string.
	 */
	function _normalizeAccelerationUnit(units) {
	    // Convert to metersPerSecondSquared
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milespersecondsquared": // mi/s^2
	            case "milepersecondsquared":
	            case "mi/s^2":
	            case "mi/s2":
	                return AccelerationUnits.milesPerSecondSquared;
	            case "kilometerspersecondsquared": // km/s^2
	            case "kilometrespersecondsquared":
	            case "kilometerpersecondsquared":
	            case "kilometrepersecondsquared":
	            case "km/s^2":
	            case "km/s2":
	                return AccelerationUnits.kilometersPerSecondSquared;
	            case "knotspersecond": // knts/s
	            case "knotpersecond":
	            case "knts/s":
	            case "kn/s":
	            case "kt/s":
	                return AccelerationUnits.knotsPerSecond;
	            case "standardgravity": // g
	            case "g":
	                return AccelerationUnits.standardGravity;
	            case "feetpersecondsquared": // ft/s^2
	            case "footpersecondsquared":
	            case "ft/s^2":
	            case "ft/s2":
	                return AccelerationUnits.feetPerSecondSquared;
	            case "yardspersecondsquared": // yds/s^2
	            case "yardpersecondsquared":
	            case "yds/s^2":
	            case "yds/s2":
	            case "yd/s^2":
	            case "yd/s2":
	                return AccelerationUnits.yardsPerSecondSquared;
	            case "milesperhoursecond": // mi/h/s
	            case "mileperhoursecond":
	            case "milesperhourseconds":
	            case "mileperhourseconds":
	            case "mi/h/s":
	                return AccelerationUnits.milesPerHourSecond;
	            case "kilometersperhoursecond": // km/h/s
	            case "kilometrespersoursecond":
	            case "kilometerperhoursecond":
	            case "kilometrepersoursecond":
	            case "kilometersperhourssecond":
	            case "kilometrespersourssecond":
	            case "kilometerperhourssecond":
	            case "kilometrepersourssecond":
	            case "kmhs":
	            case "km/h/s":
	                return AccelerationUnits.kilometersPerHourSecond;
	            case "meterspersecondsquared": // m/s^2
	            case "metrespersecondsquared":
	            case "meterpersecondsquared":
	            case "metrepersecondsquared":
	            case "m/s^2":
	            case "m/s2":
	            default:
	                return AccelerationUnits.metersPerSecondSquared;
	        }
	    }
	    return AccelerationUnits.metersPerSecondSquared;
	}
	/**
	 * Normailzes an area unit string. Defaults to squareMeters.
	 * @param units The area units to normalize.
	 * @returns A normailzed area unit string.
	 */
	function _normalizeAreaUnits(units) {
	    if (units) {
	        switch (units) {
	            case "acres":
	            case "ac":
	                return AreaUnits.acres;
	            case "hectares":
	            case "ha":
	                return AreaUnits.hectares;
	            case "squareFeet":
	            case "ft^2":
	            case "ft2":
	                return AreaUnits.squareFeet;
	            case "squareYards":
	            case "squareYard":
	            case "yds^2":
	            case "yds2":
	            case "yd^2":
	            case "yd2":
	                return AreaUnits.squareYards;
	            case "squareKilometers":
	            case "squareKilometres":
	            case "squareKilometer":
	            case "squareKilometre":
	            case "km^2":
	            case "km2":
	                return AreaUnits.squareKilometers;
	            case "squareMiles":
	            case "squareMile":
	            case "mi^2":
	            case "mi2":
	                return AreaUnits.squareMiles;
	            case "squareMeters":
	            case "squareMetres":
	            case "squareMeter":
	            case "squareMetre":
	            case "m^2":
	            case "m2":
	            default:
	                return AreaUnits.squareMeters;
	        }
	    }
	    return AreaUnits.squareMeters;
	}
	/**
	 * Normailzes a speed unit string. Defaults to metersPerSecond.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param units The speed units to normalize.
	 * @returns A normailzed speed unit string.
	 */
	function _normalizeSpeedUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feetpersecond":
	            case "footsecond":
	            case "ftps":
	            case "ft/s":
	                return SpeedUnits.feetPerSecond;
	            case "milesperhour":
	            case "mileperhour":
	            case "mph":
	            case "mi/hr":
	            case "mi/h":
	                return SpeedUnits.milesPerHour;
	            case "knots":
	            case "knot":
	            case "knts":
	            case "knt":
	            case "kn":
	            case "kt":
	                return SpeedUnits.knots;
	            case "mach":
	            case "m":
	                return SpeedUnits.mach;
	            case "kilometersperhour":
	            case "kilometresperhour":
	            case "kmperhour":
	            case "kmph":
	            case "km/hr":
	            case "km/h":
	                return SpeedUnits.kilometersPerHour;
	            case "meterspersecond":
	            case "metrespersecond":
	            case "mps":
	            case "ms":
	            case "m/s":
	            default:
	                return SpeedUnits.metersPerSecond;
	        }
	    }
	    return SpeedUnits.metersPerSecond;
	}
	/**
	 * Normailzes a time unit string. Defaults to seconds.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param units The time units to normalize.
	 * @returns A normailzed time unit string.
	 */
	function _normalizeTimeUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milliseconds":
	            case "ms":
	                return TimeUnits.ms;
	            case "minutes":
	            case "minute":
	            case "mins":
	            case "min":
	                return TimeUnits.minutes;
	            case "hours":
	            case "hour":
	            case "hr":
	            case "h":
	                return TimeUnits.hours;
	            case "days":
	            case "day":
	            case "d":
	                return TimeUnits.days;
	            case "seconds":
	            case "second":
	            case "secs":
	            case "sec":
	            case "s":
	            default:
	                return TimeUnits.seconds;
	        }
	    }
	    return TimeUnits.seconds;
	}
	/**
	 * Calculates the area of a polygon in square meters.
	 * @param coordinates The coordinates of the polygon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @returns The area of a polygon in square meters.
	 */
	function _calculatePolygonArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates && coordinates.length > 0) {
	        // Calculate the area of the outer/exterior ring of the polygon.
	        area = Math.abs(_calculatePolygonRingArea(coordinates[0]));
	        // Subtract the area of the holes of the polygon.
	        for (var i = 1, len = coordinates.length; i < len; i++) {
	            area -= Math.abs(_calculatePolygonRingArea(coordinates[i]));
	        }
	    }
	    return area;
	}
	/**
	 * Calculates the area of a polygon ring  in square meters.
	 * The area value will be positive if the coordinates in the ring are ordered clockwise,
	 * and negative if ordered counter-clockwise.
	 * @param coordinates The coordinates of the polygon ring.
	 * @returns The area of the ring in square meters.
	 */
	function _calculatePolygonRingArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates.length >= 3) {
	        var p1 = void 0;
	        var p2 = void 0;
	        var p3 = void 0;
	        for (var i = 0, len = coordinates.length; i < len; i++) {
	            // Create triangles from the coordinates.
	            if (i === len - 2) { // i = N-2
	                p1 = len - 2;
	                p2 = len - 1;
	                p3 = 0;
	            }
	            else if (i === len - 1) { // i = N-1
	                p1 = len - 1;
	                p2 = 0;
	                p3 = 1;
	            }
	            else { // i = 0 to N-3
	                p1 = i;
	                p2 = i + 1;
	                p3 = i + 2;
	            }
	            area += (_toRadians(coordinates[p3][0]) - _toRadians(coordinates[p1][0])) * Math.sin(_toRadians(coordinates[p2][1]));
	        }
	        area = area * EARTH_RADIUS_SEMI_MAJOR_AXIS * EARTH_RADIUS_SEMI_MAJOR_AXIS / 2;
	    }
	    return area;
	}
	/**
	 * 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.
	 * Returns a positive value, if OAB makes a counter-clockwise turn,
	 * negative for clockwise turn, and zero if the points are collinear.
	 * @param a Position A
	 * @param b Position B
	 * @param o Position O
	 * @returns The 2D cross product of OA and OB vectors.
	 */
	function _cross(a, b, o) {
	    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
	}
	/**
	 * Takes an array of positions that form a path and calculates the closest point on the path to a specified position.
	 * @param pos The position to find the closest point to.
	 * @param px The pixel value of the position at zoom level 22.
	 * @param path An array of positions that form a path.
	 * @returns The closest point on the path to the specified position.
	 */
	function _closestPointOnPath(pos, px, path) {
	    // Need atleast two points
	    if (path.length >= 2) {
	        var minDis = Infinity;
	        var d = void 0;
	        var closest = null;
	        // Convert path to pixels.
	        var pixels = mercatorPositionsToPixels(path, 22);
	        var cPx = void 0;
	        for (var i = 0, len = pixels.length - 1; i < len; i++) {
	            cPx = _closestPixelOnLineSegment(px, pixels[i], pixels[i + 1]);
	            d = Pixel.getDistance(px, cPx);
	            if (d < minDis) {
	                minDis = d;
	                closest = cPx;
	            }
	        }
	        if (closest) {
	            var cPos = mercatorPixelsToPositions([closest], 22)[0];
	            return new Feature(new Point(cPos), {
	                distance: getDistanceTo(pos, cPos)
	            });
	        }
	    }
	    else if (path.length === 1) {
	        return new Feature(new Point(path[0]), {
	            distance: getDistanceTo(pos, path[0])
	        });
	    }
	    return null;
	}
	/**
	 * Calculates the closest pixel on a line segment from a given point in 2D space.
	 * @param px The pixel near the line that we are working with.
	 * @param sPx Start pixel of the line segment.
	 * @param ePx End pixel of the line segment.
	 * @returns The closest pixel on the line segement to the specified pixel.
	 */
	function _closestPixelOnLineSegment(px, sPx, ePx) {
	    // If start and end points of line are equal, then that is the closest point.
	    if (sPx[0] === ePx[0] && sPx[1] === ePx[1]) {
	        return sPx;
	    }
	    var APx = px[0] - sPx[0];
	    var APy = px[1] - sPx[1];
	    var ABx = ePx[0] - sPx[0];
	    var ABy = ePx[1] - sPx[1];
	    var magAB2 = ABx * ABx + ABy * ABy;
	    var ABdotAP = ABx * APx + ABy * APy;
	    var t = ABdotAP / magAB2;
	    if (t < 0) {
	        return sPx;
	    }
	    else if (t > 1) {
	        return ePx;
	    }
	    else {
	        return [sPx[0] + ABx * t, sPx[1] + ABy * t];
	    }
	}
	//////////////////////
	/// Internal Functions
	//////////////////////
	/**
	 * Round a number to the specified number of decimal places.
	 * @param val The value to round.
	 * @param decimals The number of decimals.
	 * @returns A number rounded to the specified number of decimal places.
	 * @internal
	 */
	function _precision(val, decimals) {
	    if (!isNaN(val) && typeof decimals === "number" && decimals >= 0) {
	        var power = void 0;
	        if (decimals < POWERS_OF_10.length) {
	            power = POWERS_OF_10[decimals];
	        }
	        else {
	            power = Math.pow(10, decimals);
	        }
	        val = Math.round(val * power) / power;
	    }
	    return val;
	}
	//////////////////////
	/// Public Enums
	//////////////////////
	/**
	 * Units of measurement for areas.
	 */
	var AreaUnits;
	(function (AreaUnits) {
	    /**
	     * Represents areas in square meters (m^2).
	     * Literal value `""`
	     */
	    AreaUnits["squareMeters"] = "squareMeters";
	    /**
	     * Represents areas in acres (ac).
	     * Literal value `"acres"`
	     */
	    AreaUnits["acres"] = "acres";
	    /**
	     * Represents areas in hectares (ha).
	     * Literal value `"hectares"`
	     */
	    AreaUnits["hectares"] = "hectares";
	    /**
	     * Represents areas in feet (ft^2).
	     * Literal value `"squareFeet"`
	     */
	    AreaUnits["squareFeet"] = "squareFeet";
	    /**
	     * Represents areas in square kilometers (km^2).
	     * Literal value `"squareKilometers"`
	     */
	    AreaUnits["squareKilometers"] = "squareKilometers";
	    /**
	     * Represents areas in miles (mi^2).
	     * Literal value `"squareMiles"`
	     */
	    AreaUnits["squareMiles"] = "squareMiles";
	    /**
	     * Represents areas in yards (yds^2).
	     * Literal value `"squareYards"`
	     */
	    AreaUnits["squareYards"] = "squareYards";
	})(AreaUnits || (AreaUnits = {}));
	/**
	 * Units of measurement for distances.
	 */
	var DistanceUnits;
	(function (DistanceUnits) {
	    /**
	     * Represents a distance in meters (m).
	     * Literal value `"meters"`
	     */
	    DistanceUnits["meters"] = "meters";
	    /**
	     * Represents a distance in kilometers (km).
	     * Literal value `"kilometers"`
	     */
	    DistanceUnits["kilometers"] = "kilometers";
	    /**
	     * Represents a distance in feet (ft).
	     * Literal value `"feet"`
	     */
	    DistanceUnits["feet"] = "feet";
	    /**
	     * Represents a distance in miles (mi).
	     * Literal value `"miles"`
	     */
	    DistanceUnits["miles"] = "miles";
	    /**
	     * Represents a distance in nautical miles.
	     * Literal value `"nauticalMiles"`
	     */
	    DistanceUnits["nauticalMiles"] = "nauticalMiles";
	    /**
	     * Represents a distance in yards (yds).
	     * Literal value `"yards"`
	     */
	    DistanceUnits["yards"] = "yards";
	})(DistanceUnits || (DistanceUnits = {}));
	/**
	 * Units of measurement for time.
	 */
	var TimeUnits;
	(function (TimeUnits) {
	    /**
	     * Represents a time in seconds (s).
	     * Literal value `"seconds"`
	     */
	    TimeUnits["seconds"] = "seconds";
	    /**
	     * Represents a time in hours (hr).
	     * Literal value `"hours"`
	     */
	    TimeUnits["hours"] = "hours";
	    /**
	     * Represents a time in milliseconds (ms).
	     * Literal value `"ms"`
	     */
	    TimeUnits["ms"] = "ms";
	    /**
	     * Represents a time in minutes (min).
	     * Literal value `"minutes"`
	     */
	    TimeUnits["minutes"] = "minutes";
	    /**
	     * Represents a time in days (d).
	     * Literal value `"days"`
	     */
	    TimeUnits["days"] = "days";
	})(TimeUnits || (TimeUnits = {}));
	/**
	 * Units of measurement for speed.
	 */
	var SpeedUnits;
	(function (SpeedUnits) {
	    /**
	     * Represents a speed in meters per second (m/s).
	     * Literal value `"metersPerSecond"`
	     */
	    SpeedUnits["metersPerSecond"] = "metersPerSecond";
	    /**
	     * Represents a speed in kilometers per hour (km/h).
	     * Literal value `"kilometersPerHour"`
	     */
	    SpeedUnits["kilometersPerHour"] = "kilometersPerHour";
	    /**
	     * Represents a speed in feet per second (ft/s).
	     * Literal value `"feetPerSecond"`
	     */
	    SpeedUnits["feetPerSecond"] = "feetPerSecond";
	    /**
	     * Represents a speed in miles per hour (mph).
	     * Literal value `"milesPerHour"`
	     */
	    SpeedUnits["milesPerHour"] = "milesPerHour";
	    /**
	     * Represents a speed in knots (knts).
	     * Literal value `"knots"`
	     */
	    SpeedUnits["knots"] = "knots";
	    /**
	     * Represents a speed in mach.
	     * Literal value `"mach"`
	     */
	    SpeedUnits["mach"] = "mach";
	})(SpeedUnits || (SpeedUnits = {}));
	/**
	 * Units of measurement for acceleration.
	 */
	var AccelerationUnits;
	(function (AccelerationUnits) {
	    /**
	     * Represents an acceleration in miles per second squared (mi/s^2).
	     * Literal value `"milesPerSecondSquared"`
	     */
	    AccelerationUnits["milesPerSecondSquared"] = "milesPerSecondSquared";
	    /**
	     * Represents an acceleration in kilometers per second squared (km/s^2).
	     * Literal value `"kilometersPerSecondSquared"`
	     */
	    AccelerationUnits["kilometersPerSecondSquared"] = "kilometersPerSecondSquared";
	    /**
	     * Represents an acceleration in knots per second (knts/s).
	     * Literal value `"knotsPerSecond"`
	     */
	    AccelerationUnits["knotsPerSecond"] = "knotsPerSecond";
	    /**
	     * Represents an acceleration in standard gravity units (g).
	     * Literal value `"standardGravity"`
	     */
	    AccelerationUnits["standardGravity"] = "standardGravity";
	    /**
	     * Represents an acceleration in feet per second squared (ft/s^2).
	     * Literal value `"feetPerSecondSquared"`
	     */
	    AccelerationUnits["feetPerSecondSquared"] = "feetPerSecondSquared";
	    /**
	     * Represents an acceleration in yards per second squared (yds/s^2).
	     * Literal value `"yardsPerSecondSquared"`
	     */
	    AccelerationUnits["yardsPerSecondSquared"] = "yardsPerSecondSquared";
	    /**
	     * Represents an acceleration in miles per hour second (mi/h/s).
	     * Literal value `"milesPerHourSecond"`
	     */
	    AccelerationUnits["milesPerHourSecond"] = "milesPerHourSecond";
	    /**
	     * Represents an acceleration in kilometers per hours second (km/h/s).
	     * Literal value `"kilometersPerHourSecond"`
	     */
	    AccelerationUnits["kilometersPerHourSecond"] = "kilometersPerHourSecond";
	    /**
	     * Represents an acceleration in meters per second squared (m/s^2).
	     * Literal value `"metersPerSecondSquared"`
	     */
	    AccelerationUnits["metersPerSecondSquared"] = "metersPerSecondSquared";
	})(AccelerationUnits || (AccelerationUnits = {}));
	//////////////////////
	/// Public Methods
	//////////////////////
	/**
	 * Takes a BoundingBox and converts it to a polygon.
	 * @param bounds The BoundingBox to convert to a Polygon.
	 * @returns A polygon representation of the BoundingBox.
	 */
	function boundingBoxToPolygon(bounds) {
	    var w = normalizeLongitude(BoundingBox.getWest(bounds));
	    var e = normalizeLongitude(BoundingBox.getEast(bounds));
	    var n = normalizeLatitude(BoundingBox.getNorth(bounds));
	    var s = normalizeLatitude(BoundingBox.getSouth(bounds));
	    var center = BoundingBox.getCenter(bounds);
	    var pos = [
	        [w, n],
	        [w, s],
	        [center[0], s],
	        [e, s],
	        [e, n],
	        [center[0], n],
	        [w, n]
	    ];
	    return new Polygon([pos]);
	}
	/**
	 * Converts a distance from one distance units to another. Supported units: miles, nauticalMiles, yards, meters, kilometers, feet
	 * @param distance A number that represents a distance to convert.
	 * @param fromUnits The distance units the original distance is in.
	 * @param toUnits The desired distance units to convert to.
	 * @param decimals Specifies the number of decimal places to round the result to. If undefined, no rounding will occur.
	 * @returns A distance in the new units.
	 */
	function convertDistance(distance, fromUnits, toUnits, decimals) {
	    // Convert the distance to kilometers
	    switch (_normalizeDistanceUnit(fromUnits)) {
	        case DistanceUnits.meters:
	            distance /= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance /= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance /= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance /= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance /= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    // Convert from kilometers to output distance unit
	    switch (_normalizeDistanceUnit(toUnits)) {
	        case DistanceUnits.meters:
	            distance *= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance *= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance *= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance *= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance *= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    if (typeof decimals === "number" && decimals >= 0) {
	        var power = Math.pow(10, decimals);
	        distance = Math.round(distance * power) / power;
	    }
	    return distance;
	}
	/**
	 * Calculates an array of positions that form a cardinal spline between the specified array of positions.
	 * @param positions The array of positions to calculate the spline through.
	 * @param tension A number that indicates the tightness of the curve. Can be any number, although a value between 0 and 1 is usually used. Default: 0.5
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @param close A boolean indicating if the spline should be a closed ring or not. Default: false
	 * @returns An array of positions that form a cardinal spline between the specified array of positions.
	 */
	function getCardinalSpline(positions, tension, nodeSize, close) {
	    // Resources:
	    // http://www.cubic.org/docs/hermite.htm
	    // http://codeplea.com/introduction-to-splines
	    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms536358(v=vs.85).aspx
	    var locs;
	    if (!positions || positions.length <= 2) {
	        return locs;
	    }
	    if (typeof tension !== "number") {
	        tension = 0.5;
	    }
	    if (typeof nodeSize !== "number" || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    // Get the number of locations the spline passs through.
	    var len = positions.length;
	    // Create a copy of the array of locations so that we don't alter the original array.
	    locs = positions.slice(0);
	    // Add additional locations to array so that tangents can be calculated for end points.
	    if (close) {
	        // If the location array forms a closed ring, remove the last location.
	        if (Position.areEqual(locs[0], locs[len - 1])) {
	            locs.pop();
	            len--;
	        }
	        // Insert the last coordinate as the first point.
	        locs.unshift(positions[len - 1]);
	        // Add the first two points to the end of the array.
	        locs.push(positions[0]);
	        locs.push(positions[1]);
	        // Increase index so that spline wraps back around to starting location.
	        len++;
	    }
	    else {
	        // In this case the spline is not closed, so tanget of end points will be 0.
	        // Buffer the end-points so that tanget calculations can be performed.
	        locs.unshift(positions[0]);
	        locs.push(positions[len - 1]);
	    }
	    // Precalculate the hermite basis function steps along the spline.
	    var hermiteSteps = [];
	    // Force the first step between two locations to be the first location.
	    hermiteSteps.push([1, 0, 0, 0]);
	    var step;
	    var step2;
	    var step3;
	    // Calculate the steps along the spline between two locations.
	    for (var i = 1; i < nodeSize - 1; i++) {
	        step = i / nodeSize; // Scale step to go from 0 to 1.
	        step2 = step * step; // s^2
	        step3 = step * step2; // s^3
	        hermiteSteps.push([
	            2 * step3 - 3 * step2 + 1,
	            -2 * step3 + 3 * step2,
	            step3 - 2 * step2 + step,
	            step3 - step2
	        ]); // Calculate hermite basis function 4.
	    }
	    // Force the last step between two locations to be the last location.
	    hermiteSteps.push([0, 1, 0, 0]);
	    var splineLocs = [];
	    var hermiteStep;
	    // Tangents
	    var t1x;
	    var t1y;
	    var t2x;
	    var t2y;
	    var lat;
	    var lon;
	    // Loop through and calculate the spline path between each location pair.
	    for (var i = 1; i < len; i++) {
	        t1x = tension * (locs[i + 1][0] - locs[i - 1][0]);
	        t1y = tension * (locs[i + 1][1] - locs[i - 1][1]);
	        t2x = tension * (locs[i + 2][0] - locs[i][0]);
	        t2y = tension * (locs[i + 2][1] - locs[i][1]);
	        for (step = 0; step < nodeSize; step++) {
	            hermiteStep = hermiteSteps[step];
	            lon = hermiteStep[0] * locs[i][0] + hermiteStep[1] * locs[i + 1][0] + hermiteStep[2] * t1x + hermiteStep[3] * t2x;
	            lat = hermiteStep[0] * locs[i][1] + hermiteStep[1] * locs[i + 1][1] + hermiteStep[2] * t1y + hermiteStep[3] * t2y;
	            lat = _clip(lat, -85, 85);
	            splineLocs.push([lon, lat]);
	        }
	    }
	    return splineLocs;
	}
	/**
	 * Calculates a destination position based on a starting position, a heading, a distance, and a distance unit type.
	 * @param origin Position that the destination is relative to.
	 * @param heading A heading angle between 0 - 360 degrees. 0 - North, 90 - East, 180 - South, 270 - West.
	 * @param distance Distance that destination is away.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position that is the specified distance away from the origin.
	 */
	function getDestination(origin, heading, distance, units) {
	    units = units || "meters";
	    origin = getPosition(origin);
	    var radius = getEarthRadius(units);
	    // convert latitude, longitude and heading into radians
	    var latRad = _toRadians(origin[1]);
	    var lonRad = _toRadians(origin[0]);
	    var headingRad = _toRadians(heading);
	    var centralAngle = distance / radius;
	    var desLatRad = Math.asin(Math.sin(latRad) * Math.cos(centralAngle) + Math.cos(latRad) * Math.sin(centralAngle) * Math.cos(headingRad));
	    var desLonRad = lonRad + Math.atan2(Math.sin(headingRad) * Math.sin(centralAngle) * Math.cos(latRad), Math.cos(centralAngle) - Math.sin(latRad) * Math.sin(desLatRad));
	    var lat = _clip(normalizeLatitude(_toDegrees(desLatRad)), -85, 85);
	    var lon = normalizeLongitude(_toDegrees(desLonRad));
	    return [lon, lat];
	}
	/**
	 * Calculate the distance between two position objects on the surface of the earth using the Haversine formula.
	 * @param origin First position to calculate distance between.
	 * @param destination Second position to calculate distance between.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns The shortest distance between two positions in the specified units.
	 */
	function getDistanceTo(origin, destination, units) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var d = _haversineDistance(origin, destination);
	    if (units === "meters") {
	        return d;
	    }
	    return convertDistance(d, "meters", units || "meters");
	}
	/**
	 * Retrieves the radius of the earth in a specific distance unit for WGS84.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns A number that represents the radius of the earth in a specific distance unit.
	 */
	function getEarthRadius(units) {
	    var normalUnit = _normalizeDistanceUnit(units);
	    return convertDistance(EARTH_RADIUS_SEMI_MAJOR_AXIS, DistanceUnits.meters, normalUnit);
	}
	/**
	 * Takes an array of positions objects and fills in the space between them with accurately positioned positions to form an approximated Geodesic path.
	 * @param path Array of position objects that form a path to fill in.
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @returns An array of position objects that form a geodesic paths.
	 */
	function getGeodesicPath(path, nodeSize) {
	    if (!nodeSize || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    var len = locs.length - 1;
	    var outputLocs = [];
	    for (var i = 0; i < len; i++) {
	        // Convert positions from degrees to Radians
	        var lat1 = _toRadians(locs[i][1]);
	        var lon1 = _toRadians(locs[i][0]);
	        var lat2 = _toRadians(locs[i + 1][1]);
	        var lon2 = _toRadians(locs[i + 1][0]);
	        // Calculate the total extent of the route
	        var d = 2 * Math.asin(Math.sqrt(Math.pow((Math.sin((lat1 - lat2) / 2)), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow((Math.sin((lon1 - lon2) / 2)), 2)));
	        // Calculate positions at fixed intervals along the route
	        for (var k = 0; k <= nodeSize; k++) {
	            var f = (k / nodeSize);
	            var A = Math.sin((1 - f) * d) / Math.sin(d);
	            var B = Math.sin(f * d) / Math.sin(d);
	            // Obtain 3D Cartesian coordinates of each point
	            var x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
	            var y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
	            var z = A * Math.sin(lat1) + B * Math.sin(lat2);
	            // Convert these to latitude/longitude
	            var lat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
	            var lon = Math.atan2(y, x);
	            lat = _clip(_toDegrees(lat), -85, 85);
	            lon = _toDegrees(lon);
	            // Add this to the array
	            outputLocs.push([lon, lat]);
	        }
	    }
	    // TODO: Check for crossing the antimeridian, consider splitting path by -180/180 longitude
	    return outputLocs;
	}
	/**
	 * Calculates the heading from one position object to another.
	 * @param origin Point of origin.
	 * @param destination Destination to calculate relative heading to.
	 * @returns A heading in degrees between 0 and 360. 0 degrees points due North.
	 */
	function getHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    if (origin && origin.length >= 2 && destination && destination.length >= 2) {
	        var radianLat1 = _toRadians(origin[1]);
	        var radianLat2 = _toRadians(destination[1]);
	        var dLon = _toRadians(destination[0] - origin[0]);
	        var dy = Math.sin(dLon) * Math.cos(radianLat2);
	        var dx = Math.cos(radianLat1) * Math.sin(radianLat2) - Math.sin(radianLat1) * Math.cos(radianLat2) * Math.cos(dLon);
	        return (_toDegrees(Math.atan2(dy, dx)) + 360) % 360;
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance between all position objects in an array.
	 * @param path The array of position objects that make up the path to calculate the length of.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns The distance between all positions in between all position objects in an array on the surface of a earth in the specified units.
	 */
	function getLengthOfPath(path, units) {
	    var totalLength = 0;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    for (var i = 0, len = locs.length - 1; i < len; i++) {
	        totalLength += _haversineDistance(locs[i], locs[i + 1]);
	    }
	    return convertDistance(totalLength, "meters", units || "meters");
	}
	/**
	 * Calculates the position object on a path that is a specified distance away from the start of the path. If the specified distance is longer
	 * than the length of the path, the last position of the path will be returned.
	 * @param path A polyline or array of position coordinates that form a path.
	 * @param distance The distance along the path (from the start) to calculate the position for.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position object that is the specified distance away from the start of the path when following the path.
	 */
	function getPositionAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                return getDestination(locs[i - 1], heading, distance - travelled, units);
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return locs[len - 1];
	        }
	        return locs[0];
	    }
	    return null;
	}
	/**
	 * Calculates an array of position objects that are an equal distance away from a central point to create a regular polygon.
	 * @param origin Center of the regular polygon.
	 * @param radius Radius of the regular polygon.
	 * @param numberOfPositions Number of positions the polygon should have.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param offset An offset to rotate the polygon. When 0 the first position will align with North.
	 * @returns An array of position objects that form a regular polygon.
	 */
	function getRegularPolygonPath(origin, radius, numberOfPositions, units, offset) {
	    units = units || "meters";
	    offset = (offset) ? offset : 0;
	    origin = getPosition(origin);
	    var points = [];
	    var centralAngle = 360 / numberOfPositions;
	    for (var i = 0; i <= numberOfPositions; i++) {
	        points.push(getDestination(origin, (i * centralAngle + offset) % 360, radius, units));
	    }
	    // TODO: Check for crossing the antimeridian, consider splitting path by -180/180 longitude
	    return points;
	}
	/**
	 * Calculates a position object that is a fractional distance between two position objects.
	 * @param origin First position to calculate mid-point between.
	 * @param destination Second position to calculate mid-point between.
	 * @param fraction The fractional parameter to calculate a mid-point for. Default 0.5.
	 * @returns A position that lies a fraction of the distance between two position objects, relative to the first position object.
	 */
	function interpolate(origin, destination, fraction) {
	    fraction = (typeof fraction === "undefined") ? 0.5 : fraction;
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var arcLength = getDistanceTo(origin, destination, "kilometers");
	    var brng = getHeading(origin, destination);
	    return getDestination(origin, brng, arcLength * fraction, "kilometers");
	}
	/**
	 * Normalizes a latitude value between -90 and 90 degrees.
	 * @param lat The latitude value to normalize.
	 */
	function normalizeLatitude(lat) {
	    if (lat > 90) {
	        lat = (lat + 90) % 360;
	        return lat > 180 ? 90 - (lat - 180) : lat - 90;
	    }
	    else if (lat < -90) {
	        lat = (lat - 90) % 360;
	        return lat < -180 ? -90 - (lat + 180) : lat + 90;
	    }
	    else {
	        return lat;
	    }
	}
	/**
	 * Normalizes a longitude value between -180 and 180 degrees.
	 * @param lng The longitude value to normalize.
	 */
	function normalizeLongitude(lng) {
	    if (lng > 180) {
	        return ((lng + 180) % 360) - 180;
	    }
	    else if (lng < -180) {
	        return ((lng - 180) % 360) + 180;
	    }
	    else {
	        return lng;
	    }
	}
	/**
	 * Takes an array of positions and rotates them around a given position for the specified angle of rotation.
	 * @param positions An array of positions to be rotated.
	 * @param origin The position to rotate the positions around.
	 * @param angle The amount to rotate the array of positions in degrees clockwise.
	 */
	function rotatePositions(positions, origin, angle) {
	    if (angle === 0) {
	        // When the rotation is 0 the results can sometimes be odd if the coordinates are on the meridians.
	        return Object.assign({}, positions);
	    }
	    origin = getPosition(origin);
	    var rotatedPositions = [];
	    var distance;
	    var heading;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        distance = getDistanceTo(origin, positions[i]);
	        heading = getHeading(origin, positions[i]);
	        rotatedPositions.push(getDestination(origin, heading + angle, distance));
	    }
	    return rotatedPositions;
	}
	/**
	 * Calculates the pixel accurate heading from one position to another based on the Mercator map projection. This heading is visually accurate.
	 * @param origin
	 * @param destination
	 */
	function getPixelHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var _a = mercatorPositionsToPixels([origin, destination], 21), p1 = _a[0], p2 = _a[1];
	    var dx = (p2[0] - p1[0]);
	    var dy = (p1[1] - p2[1]);
	    var alpha = ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * INV_PI_BY_180 % 360;
	    return alpha;
	}
	/**
	 * Converts an array of global Mercator pixel coordinates into an array of geospatial positions at a specified zoom level.
	 * Global pixel coordinates are relative to the top left corner of the map [-180, 90].
	 * @param pixels Array of pixel coordinates.
	 * @param zoom Zoom level.
	 * @returns An array of positions.
	 */
	function mercatorPixelsToPositions(pixels, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var positions = [];
	    var x;
	    var y;
	    for (var i = 0, len = pixels.length; i < len; i++) {
	        x = (pixels[i][0] / mapSize) - 0.5;
	        y = 0.5 - (pixels[i][1] / mapSize);
	        positions.push([
	            360 * x,
	            90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI
	        ]);
	    }
	    return positions;
	}
	/**
	 * Converts an array of positions into an array of global Mercator pixel coordinates at a specified zoom level.
	 * @param positions Array of positions.
	 * @param zoom Zoom level.
	 * @returns Array of global Mercator pixels.
	 */
	function mercatorPositionsToPixels(positions, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var pixels = [];
	    var x;
	    var y;
	    var sinLatitude;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        sinLatitude = Math.sin(positions[i][1] * Math.PI / 180);
	        x = (positions[i][0] + 180) / 360;
	        y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
	        pixels.push([
	            Math.round(x * mapSize),
	            Math.round(y * mapSize)
	        ]);
	    }
	    return pixels;
	}
	/**
	 * Converts an acceleration value from one unit to another.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param acceleration The acceleration value to convert.
	 * @param fromUnits The acceleration units the value is in.
	 * @param toUnits The acceleration units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration value convertered from one unit to another.
	 */
	function convertAcceleration(acceleration, fromUnits, toUnits, decimals) {
	    // Convert the speed to meters per second squared and then convert to the toUnits.
	    switch (_normalizeAccelerationUnit(fromUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration /= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration /= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration /= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration /= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration /= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration /= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration /= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration /= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	        default:
	            break;
	    }
	    // metersPerSecondSquared to toUnit.
	    switch (_normalizeAccelerationUnit(toUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration *= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration *= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration *= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration *= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration *= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration *= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration *= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration *= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	        default:
	            break;
	    }
	    return _precision(acceleration, decimals);
	}
	/**
	 * Converts an area value from one unit to another.
	 * Supported units: squareMeters, acres, hectares, squareFeet, squareYards, squareMiles, squareKilometers
	 * @param area The area value to convert.
	 * @param fromUnits The area units the value is in.
	 * @param toUnits The area units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An area value convertered from one unit to another.
	 */
	function convertArea(area, fromUnits, toUnits, decimals) {
	    switch (_normalizeAreaUnits(fromUnits)) {
	        case AreaUnits.acres:
	            area *= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area *= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area *= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area *= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area *= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area *= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	        default:
	            break;
	    }
	    switch (_normalizeAreaUnits(toUnits)) {
	        case AreaUnits.acres:
	            area /= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area /= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area /= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area /= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area /= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area /= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	        default:
	            break;
	    }
	    return _precision(area, decimals);
	}
	/**
	 * Converts a speed value from one unit to another.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param speed The speed value to convert.
	 * @param fromUnits The speed units to convert from.
	 * @param toUnits The speed units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A speed value convertered from one unit to another.
	 */
	function convertSpeed(speed, fromUnits, toUnits, decimals) {
	    // Convert the speed to kilometers per hour and then convert to the toUnits.
	    switch (_normalizeSpeedUnit(fromUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed *= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed *= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed *= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed *= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed *= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	        default:
	            break;
	    }
	    // KMPH to toUnit.
	    switch (_normalizeSpeedUnit(toUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed /= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed /= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed /= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed /= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed /= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	        default:
	            break;
	    }
	    return _precision(speed, decimals);
	}
	/**
	 * Converts a timespan value from one unit to another.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param timespan The time value to convert.
	 * @param fromUnits The time units to convert from.
	 * @param toUnits The time units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A time value convertered from one unit to another.
	 */
	function convertTimespan(timespan, fromUnits, toUnits, decimals) {
	    // Convert the time to seconds as base units.
	    switch (_normalizeTimeUnit(fromUnits)) {
	        case TimeUnits.ms:
	            timespan /= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan *= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan *= 60;
	            break;
	        case TimeUnits.days:
	            timespan *= 86400;
	            break;
	        case TimeUnits.seconds:
	        default:
	            break;
	    }
	    // seconds to toUnit.
	    switch (_normalizeTimeUnit(toUnits)) {
	        case TimeUnits.ms:
	            timespan *= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan /= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan /= 60;
	            break;
	        case TimeUnits.days:
	            timespan /= 86400;
	            break;
	        case TimeUnits.seconds:
	        default:
	            break;
	    }
	    return _precision(timespan, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, travel distance and timespan. Formula: a = 2*(d - v*t)/t^2
	 * @param initialSpeed The initial speed.
	 * @param distance The distance that has been travelled.
	 * @param timespan The timespan that was travelled.
	 * @param distanceUnits The units of the distance information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param speedUnits The units of the speed information. If not specified m/s are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, travel distance and timespan.
	 */
	function getAcceleration(initialSpeed, distance, timespan, speedUnits, distanceUnits, timeUnits, accelerationUnits, decimals) {
	    var d = convertDistance(distance, distanceUnits, DistanceUnits.meters);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    var v = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    return convertAcceleration(2 * (d - v * t) / (t * t), AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, final speed and timespan. Formula: a = 2* (v2 - v1)/t
	 * @param initialSpeed The initial speed.
	 * @param finalSpeed The final speed.
	 * @param timespan The timespan that was travelled.
	 * @param speedUnits The units of the speed information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, final speed and timespan.
	 */
	function getAccelerationFromSpeeds(initialSpeed, finalSpeed, timespan, speedUnits, timeUnits, accelerationUnits, decimals) {
	    var v1 = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var v2 = convertSpeed(finalSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    return convertAcceleration((v2 - v1) / t, AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration between two point features that have a timestamp property and optionally a speed property.
	 * if speeds are provided, ignore distance between points as the path may not have been straight and calculate: a = (v2 - v1)/(t2 - t1)
	 * if speeds not provided or only provided on first point, calculate straight line distance between points and calculate: a = 2*(d - v*t)/t^2
	 * @param origin The initial point in which the acceleration is calculated from.
	 * @param destination The final point in which the acceleration is calculated from.
	 * @param timestampProperty The name of the property on the features that contains the timestamp information.
	 * @param speedProperty The name of the property on the features that contains a speed information.
	 * @param speedUnits The units of the speed information. If not specified m/s is used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration between two point features that have a timestamp property and optionally a speed property. Returns NaN if unable to parse timestamp.
	 */
	function getAccelerationFromFeatures(origin, destination, timestampProperty, speedProperty, speedUnits, accelerationUnits, decimals) {
	    if (typeof timestampProperty === "string" && origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            var v = 0;
	            if (speedProperty && typeof speedProperty === "string") {
	                var v1 = origin.properties[speedProperty];
	                var v2 = destination.properties[speedProperty];
	                if (typeof v1 === "number") {
	                    v = v1;
	                    if (typeof v2 === "number") {
	                        return getAccelerationFromSpeeds(v1, v2, timespan, speedUnits, TimeUnits.seconds, accelerationUnits, decimals);
	                    }
	                }
	            }
	            var d = getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return getAcceleration(v, d, timespan, speedUnits, DistanceUnits.meters, TimeUnits.seconds, accelerationUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the approximate area of a geometry in the specified units
	 * @param coordinates The coordinates of the polyon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @param areaUnits Unit of area measurement. Default is squareMeters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The area of a geometry in the specified units.
	 */
	function getArea(data, areaUnits, decimals) {
	    // https://github.com/Turfjs/turf/blob/master/packages/turf-area/index.ts#L68-L75
	    if (data) {
	        var area = 0;
	        data = data instanceof Shape ? data.toJson() : data;
	        switch (data.type) {
	            case "Feature":
	                var f = data;
	                if (f.geometry) {
	                    return getArea(f.geometry, areaUnits, decimals);
	                }
	                break;
	            case "Polygon":
	                var p = data;
	                if (p.coordinates) {
	                    area = _calculatePolygonArea(p.coordinates);
	                }
	                break;
	            case "MultiPolygon":
	                var mp = data;
	                if (mp.coordinates) {
	                    for (var i = 0, len = mp.coordinates.length; i < len; i++) {
	                        area += _calculatePolygonArea(mp.coordinates[i]);
	                    }
	                }
	                break;
	            case "Point":
	            case "MultiPoint":
	            case "LineString":
	            case "MultiLineString":
	            default:
	                break;
	        }
	        return convertArea(area, AreaUnits.squareMeters, areaUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two points based on the provided amount of time.
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param time The time take to travel between the start and end points.
	 * @param timeUnits The units of the time value. If not specified seconds are used.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The average speed of travel between two points based on the provided amount of time.
	 */
	function getSpeed(origin, destination, timespan, timeUnits, speedUnits, decimals) {
	    var org = getPosition(origin);
	    var dest = getPosition(destination);
	    if (org && dest) {
	        // Convert the time value to seconds.
	        var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	        // Calculate the distance`between the points in meters.
	        var d = getDistanceTo(org, dest, DistanceUnits.meters);
	        // Calculate the speed and convert it into the requested units.
	        return convertSpeed(d / t, SpeedUnits.metersPerSecond, speedUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two point features that have a property containing a timestamp.
	 * The timestamp can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param timestampProperty The name of the property on the features which has the timestamp information.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The speed in the specified units or NaN if valid timestamps are not found.
	 */
	function getSpeedFromFeatures(origin, destination, timestampProperty, speedUnits, decimals) {
	    if (typeof timestampProperty === "string" &&
	        origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = this.getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            // Calculate the distance`between the points in meters.
	            var d = this.getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return this.convertSpeed(d / timespan, SpeedUnits.metersPerSecond, speedUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the timespan between two dates or timestamps.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param startTime The start date or time.
	 * @param endTime The end date or time.
	 * @param units The units to return the time value in. If not specified seconds are used.
	 * @returns A timespan between two dates or timestamps. Returns NaN if unable to parse timestamps.
	 */
	function getTimespan(startTime, endTime, units, decimals) {
	    var st = parseTimestamp(startTime);
	    var et = parseTimestamp(endTime);
	    // Ensure that the start and end point features have the specified timeStamp
	    if (st != null && et != null) {
	        // Calculate timespan between the time stamps in seconds.
	        return convertTimespan(et.getTime() - st.getTime(), TimeUnits.ms, units, decimals);
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance traveled for a specified timespan, speed and optionally an acceleration.
	 * Formula: d = v*t + 0.5*a*t^2
	 * @param distanceUnits The distance units in which to return the distance in.
	 * @param timespan The timespan to calculate the distance for.
	 * @param speed The initial or constant speed.
	 * @param acceleration Optional. An acceleration which increases the speed over time.
	 * @param timeUnits The units of the timespan. If not specified seconds are used.
	 * @param speedUnits The units of the speed value. If not specified m/s are used.
	 * @param accelerationUnits Optional. The units of the acceleration value. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The distance traveled for a specified timespan, speed and optionally an acceleration.
	 */
	function getTravelDistance(distanceUnits, timespan, speed, acceleration, timeUnits, speedUnits, accelerationUnits, decimals) {
	    // Convert timespan to seconds.
	    timespan = this.convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    // Convert speed to meters per second.
	    speed = this.convertSpeed(speed, speedUnits, SpeedUnits.metersPerSecond);
	    var distance = speed * timespan;
	    if (typeof acceleration === "number") {
	        // Convert acceleration to meters per second squared.
	        distance += 0.5 * this.convertAcceleration(acceleration, accelerationUnits, AccelerationUnits.metersPerSecondSquared) * timespan * timespan;
	    }
	    return this.convertDistance(distance, DistanceUnits.meters, distanceUnits, decimals);
	}
	/**
	 * Parses a timestamp into a JavaScript Date object.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param timestamp The timestamp value to parse.
	 * @returns A Date object that represents the timestamp or null if the timestamp could not be parsed.
	 */
	function parseTimestamp(timestamp) {
	    if (Object.prototype.toString.call(timestamp) === "[object Date]") {
	        return timestamp;
	    }
	    if (typeof timestamp === "string") {
	        // ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	        // RFC282 / IETF date syntax (section 3.3)
	        var d = Date.parse(timestamp);
	        if (!isNaN(d)) {
	            return new Date(d);
	        }
	        // OData Date format "/Date(1235764800000)/"
	        if (timestamp.indexOf("Date(") >= 0) {
	            timestamp = timestamp.replace("/Date(", "").replace(")/", "");
	            var ms = 0; // number of milliseconds since midnight Jan 1, 1970
	            if (timestamp.indexOf("+") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("+")), 10);
	            }
	            else if (timestamp.indexOf("-") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("-")), 10);
	            }
	            else {
	                ms = parseInt(timestamp, 10);
	            }
	            return new Date(ms);
	        }
	    }
	    else if (typeof timestamp === "number") {
	        // Assume the number is the number of milliseconds from Jan 1st, 1970.
	        return new Date(timestamp);
	    }
	    return null;
	}
	/**
	 * Calculates a Convex Hull from an array of positions, geometries or features.
	 * @param data The array of positions, geometries or features to calculate a convex hull for.
	 * @returns A Convex Hull from an array of positions, geometries or features.
	 */
	function getConvexHull(data) {
	    // Uses a Monotone chain algorithm for convex hulls:
	    // https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	    var positions = getPositions(data).map(function (pos) {
	        return [normalizeLongitude(pos[0]), normalizeLatitude(pos[1])];
	    });
	    positions.sort(function (a, b) {
	        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
	    });
	    var lower = [];
	    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
	        var position = positions_1[_i];
	        while (lower.length >= 2 && _cross(lower[lower.length - 2], lower[lower.length - 1], position) <= 0) {
	            lower.pop();
	        }
	        lower.push(position);
	    }
	    var upper = [];
	    for (var i = positions.length - 1; i >= 0; i--) {
	        while (upper.length >= 2 && _cross(upper[upper.length - 2], upper[upper.length - 1], positions[i]) <= 0) {
	            upper.pop();
	        }
	        upper.push(positions[i]);
	    }
	    return new Polygon([lower.concat(upper)]);
	}
	/**
	 * Retrieves an array of all positions in the provided geometry, feature or array of geometries/features.
	 * @param data The geometries or features to retrieve the positions from.
	 * @returns An array of all positions in the provided geometry, feature or array of geometries/features.
	 */
	function getPositions(data) {
	    var loc = [];
	    var loc2d = null;
	    var loc3d = null;
	    if (Array.isArray(data) && data.length > 0) {
	        if (Array.isArray(data[0]) && typeof data[0][0] === "number") {
	            loc = data;
	        }
	        else {
	            var len = data.length;
	            for (var i = 0; i < len; i++) {
	                loc = loc.concat(getPositions(data[i]));
	            }
	        }
	    }
	    else if (data["type"]) {
	        switch (data["type"]) {
	            case "Point":
	                loc = [data.coordinates];
	                break;
	            case "LineString":
	                loc = data.coordinates;
	                break;
	            case "Polygon":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPoint":
	                loc = data.coordinates;
	                break;
	            case "MultiLineString":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPolygon":
	                loc3d = data.coordinates;
	                break;
	            case "Feature":
	                var f = data;
	                if (Shape._isCircle(f)) {
	                    loc = Shape._getCirclePositions(f);
	                }
	                else {
	                    loc = getPositions(f.geometry);
	                }
	                break;
	            case "FeatureCollection":
	                loc = getPositions(data.features);
	                break;
	            case "GeometryCollection":
	                loc = getPositions(data.geometries);
	                break;
	            default:
	                break;
	        }
	    }
	    else if (data instanceof Shape) {
	        return getPositions(data.toJson());
	    }
	    if (loc2d) {
	        var len = loc2d.length;
	        for (var i = 0; i < len; i++) {
	            loc = loc.concat(loc2d[i]);
	        }
	    }
	    else if (loc3d) {
	        var outerLen = loc3d.length;
	        for (var i = 0; i < outerLen; i++) {
	            var innerLen = loc3d[i].length;
	            for (var j = 0; j < innerLen; j++) {
	                loc = loc.concat(loc3d[i][j]);
	            }
	        }
	    }
	    return loc;
	}
	/**
	 * Gets the position of an object that is a position, point, point feature, or circle. If it is a circle, its center coordinate will be returned.
	 * @param data The data object to extract the position from.
	 * @returns The position of an object that is a position, point, or point feature. Returns null if invalid data passed in.
	 */
	function getPosition(data) {
	    if (Array.isArray(data) && typeof data[0] === "number") {
	        return data;
	    }
	    else if (data["type"]) {
	        if (data["type"] === "Point") {
	            return data.coordinates;
	        }
	        else if (data["type"] === "Feature" && data["geometry"]["type"] === "Point") {
	            return data.geometry.coordinates;
	        }
	    }
	    else if (data instanceof Shape && data.getType() === "Point") {
	        return data.getCoordinates();
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced positions along a path.
	 * @param path The path to get the positions from.
	 * @param numPositions The number of positions to get.
	 * @returns An array of evenly spaced positions along a path.
	 */
	function getPositionsAlongPath(path, numPositions) {
	    if (numPositions < 2) {
	        return [];
	    }
	    var positions = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the positions. There is one less gap than there are positions.
	    var dx = len / (numPositions - 1);
	    for (var i = 0; i < numPositions; i++) {
	        var p = getPositionAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            positions.push(p);
	        }
	    }
	    return positions;
	}
	/**
	 * Gets a point with heading a specified distance along a path.
	 * @param path The path to get the point from.
	 * @param distance The distance along the path to get the point at.
	 * @param units The distance units.
	 * @returns A point with heading a specified distance along a path.
	 */
	function getPointWithHeadingAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                var p = getDestination(locs[i - 1], heading, distance - travelled, units);
	                return new Feature(new Point(p), {
	                    heading: heading
	                });
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return new Feature(new Point(locs[len - 1]), {
	                heading: getHeading(locs[len - 2], locs[len - 1])
	            });
	        }
	        return new Feature(new Point(locs[0]), {
	            heading: getHeading(locs[0], locs[1])
	        });
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced points with headings along a path.
	 * @param path The path to get the positions from.
	 * @param numPoints The number of points to get.
	 * @returns An array of evenly spaced points with headings along a path.
	 */
	function getPointsWithHeadingsAlongPath(path, numPoints) {
	    if (numPoints <= 0) {
	        return [];
	    }
	    var points = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the points. There is one less gap than there are points.
	    var dx = len / (numPoints - 1);
	    for (var i = 0; i < numPoints; i++) {
	        var p = getPointWithHeadingAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            points.push(p);
	        }
	    }
	    return points;
	}
	/**
	 * Calculates the closest point on the edge of a geometry to a specified point or position.
	 * The returned point feature will have a `distance` property that specifies the distance between the two points in the specified units.
	 * If the geometry is a Point, that points position will be used for the result.
	 * If the geometry is a MultiPoint, the distances to the individual positions will be used.
	 * If the geometry is a Polygon or MultiPolygon, the point closest to any edge will be returned regardless of if the point intersects the geometry or not.
	 * @param pt The point or position to find the closest point on the edge of the geometry.
	 * @param geom The geometry to find the closest point on.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns
	 */
	function getClosestPointOnGeometry(pt, geom, units, decimals) {
	    // Does not support geometries that cross the antimerdian.
	    var pos = getPosition(pt);
	    var px = mercatorPositionsToPixels([pos], 22)[0];
	    var result = null;
	    var paths;
	    var minDis = Infinity;
	    geom = geom instanceof Shape ? geom.toJson() : geom;
	    switch (geom.type) {
	        case "Feature":
	            return getClosestPointOnGeometry(pt, geom.geometry, units);
	        case "Point":
	            paths = [[geom.coordinates]];
	            break;
	        case "MultiPoint":
	            var d = void 0;
	            var mp = geom.coordinates;
	            for (var i = 0, len = mp.length; i < len; i++) {
	                d = getDistanceTo(pos, mp[i]);
	                if (d < minDis) {
	                    minDis = d;
	                    result = new Feature(new Point(mp[i]), {
	                        distance: d
	                    });
	                }
	            }
	            break;
	        case "LineString":
	            paths = [geom.coordinates];
	            break;
	        case "Polygon":
	        case "MultiLineString":
	            paths = geom.coordinates;
	            break;
	        case "MultiPolygon":
	            var mPaths = geom.coordinates;
	            if (mPaths.length > 0) {
	                paths = mPaths[0];
	                for (var i = 1, len = mPaths.length; i < len; i++) {
	                    paths = paths.concat(mPaths[i]);
	                }
	            }
	            break;
	        default:
	            break;
	    }
	    if (paths) {
	        var temp = void 0;
	        for (var i = 0, len = paths.length; i < len; i++) {
	            temp = _closestPointOnPath(pos, px, paths[i]);
	            if (temp && temp.properties.distance < minDis) {
	                minDis = temp.properties.distance;
	                result = temp;
	            }
	        }
	    }
	    if (result) {
	        result.properties.distance = convertDistance(result.properties.distance, "meters", units, decimals);
	    }
	    return result;
	}

	/**
	 * A GeoJSON Position object - an array that specifies the longitude and latitude of a location. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.1}.
	 */
	var Position = /** @class */ (function (_super) {
	    __extends(Position, _super);
	    /**
	     * Constructs a Position.
	     * @param longitude The position's longitude.
	     * @param latitude The position's latitude.
	     * @param elevation The position's elevation.
	     */
	    function Position(longitude, latitude, elevation) {
	        var _this = this;
	        if (elevation) {
	            _this = _super.call(this, longitude, latitude, elevation) || this;
	        }
	        else {
	            _this = _super.call(this, longitude, latitude) || this;
	        }
	        return _this;
	    }
	    /**
	     * Clones a position.
	     * @param position The position to clone.
	     */
	    Position.fromPosition = function (position) {
	        if (position.length === 2) {
	            return new Position(position[0], position[1]);
	        }
	        else if (position.length > 2) {
	            return new Position(position[0], position[1], position[2]);
	        }
	        return null;
	    };
	    /**
	     * Compares the longitude and latitude values of two positions to see if they are equal at an accuracy of 6 decimal places.
	     * @param pos1 First position to compare.
	     * @param pos2 Second position to compare.
	     * @param precision The number of decimal places to compare to. Default: 6.
	     * @returns A boolean indicating if two positions to see if they are equal at an accuracy of the specified precision or 6 decimal places.
	     */
	    Position.areEqual = function (pos1, pos2, precision) {
	        if (typeof (precision) === "undefined") {
	            precision = 6;
	        }
	        if (pos1 && pos1.length >= 2 && pos2 && pos2.length >= 2) {
	            var offset = Math.pow(10, precision);
	            var lat1 = normalizeLatitude(pos1[1]);
	            var lat2 = normalizeLatitude(pos2[1]);
	            var lon1 = normalizeLongitude(pos1[0]);
	            var lon2 = normalizeLongitude(pos2[0]);
	            var latDiff = Math.round((lat1 - lat2) * offset) / offset;
	            if (latDiff !== 0) {
	                return false;
	            }
	            // A diff of 360 is also allowed because -180 and 180 are the same longitude
	            var lonDiff = Math.round((lon1 - lon2) * offset) / offset;
	            if (lonDiff !== 0 && lonDiff !== 360) {
	                return false;
	            }
	            return true;
	        }
	        return false;
	    };
	    Position.fromLatLng = function (y, x, z) {
	        var position = [];
	        if (typeof y === "number") {
	            position.push(y);
	            if (typeof x === "number") {
	                position.push(x);
	            }
	            if (typeof z === "number") {
	                position.push(z);
	            }
	        }
	        else if (Array.isArray(y)) {
	            // Assume array is in the form [lat, lng] or [lat, lng, elv]
	            if (y.length >= 2 && typeof y[0] === "number" && typeof y[1] === "number") {
	                if (y.length >= 3 && typeof y[2] === "number") {
	                    position.push(y[0], y[1], y[2]);
	                }
	                else {
	                    position.push(y[0], y[1]);
	                }
	            }
	        }
	        else if (typeof y === "object") {
	            // Consider pulling these out into static variable so that we don't constantly create instances of these.
	            var latNames_1 = ["lat", "latitude", "y"];
	            var lngNames_1 = ["lng", "longitude", "lon", "x"];
	            var elvNames_1 = ["elv", "elevation", "alt", "altitude", "z"];
	            var lat_1 = NaN;
	            var lng_1 = NaN;
	            var elv_1 = NaN;
	            // Do a case insensitive search through the object properties.
	            Object.keys(y).forEach(function (key, idx, arr) {
	                var smallKey = key.toLowerCase();
	                if (isNaN(lat_1) && latNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lat_1 = y[key];
	                }
	                else if (isNaN(lng_1) && lngNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lng_1 = y[key];
	                }
	                else if (isNaN(elv_1) && elvNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    elv_1 = y[key];
	                }
	            });
	            if (!isNaN(lat_1) && !isNaN(lng_1)) {
	                position.push(lng_1, lat_1);
	                if (!isNaN(elv_1)) {
	                    position.push(elv_1);
	                }
	            }
	        }
	        if (position.length >= 2) {
	            return position;
	        }
	        return null;
	    };
	    /**
	     * Converts an array of objects that contain coordinate information into an array of Positions. Objects that can't be converted are discarded.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns An array of Position objects that contain all the provided coordinate information.
	     */
	    Position.fromLatLngs = function (latLngs) {
	        var positions = [];
	        if (Array.isArray(latLngs)) {
	            for (var i = 0, len = latLngs.length; i < len; i++) {
	                var p = Position.fromLatLng(latLngs[i]);
	                // skip undetermined positions.
	                if (p) {
	                    positions.push(p);
	                }
	            }
	        }
	        return positions;
	    };
	    /**
	     * Returns the number of dimensions in the specified coordinates.
	     * Does not include the extra dimension form the Position type.
	     * @param coords The coordinates to get the dimension count for.
	     * @private
	     */
	    Position._getDimensions = function (coords) {
	        var count = 0;
	        while (Array.isArray(coords)) {
	            coords = coords[0];
	            count++;
	        }
	        // If the inner most array has a number for it's first
	        // element it is a position and the count must be reduced by 1.
	        if (typeof coords === "number") {
	            count--;
	        }
	        return count;
	    };
	    return Position;
	}(Array));

	/**
	 * A GeoJSON Polygon object - a JSON object that represents a geographic polygon. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.6}.
	 */
	var Polygon = /** @class */ (function () {
	    /**
	     * Constructs a Polygon.
	     * @param coordinates The array of linear ring coordinate arrays defining the polygon.
	     * @param bbox The bounding box of the polygon.
	     */
	    function Polygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "Polygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Polygon";
	        this.type = Polygon.TYPE;
	        // check if it has only one ring
	        if (Position._getDimensions(coordinates) === 1) {
	            this.coordinates = [coordinates];
	        }
	        else {
	            this.coordinates = coordinates;
	        }
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Polygon class to be used in runtime comparisons.
	     */
	    Polygon.TYPE = "Polygon";
	    return Polygon;
	}());

	/**
	 * An internal abstract class that can be extended to provide event listening/firing.
	 * This class is for internal use only, and users will find little use with it.
	 * Not to be used by the Map class. MapCallbackHandler implements the more complex logic for handling map events.
	 */
	var EventEmitter = /** @class */ (function () {
	    function EventEmitter() {
	        // Event listeners.
	        this.listeners = new Dictionary();
	    }
	    EventEmitter.prototype._addEventListener = function (eventType, callback, once) {
	        if (!this.listeners.has(eventType)) {
	            this.listeners.set(eventType, new Dictionary());
	        }
	        this.listeners.get(eventType).set(callback, once);
	    };
	    EventEmitter.prototype._removeEventListener = function (eventType, callback) {
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).delete(callback);
	        }
	    };
	    /**
	     * Invokes a given event type.
	     * @param eventType The event name.
	     * @param eventData The data to pass to the listener callbacks.
	     */
	    EventEmitter.prototype._invokeEvent = function (eventType, eventData) {
	        var _this = this;
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).forEach(function (once, callback) {
	                if (once) {
	                    _this._removeEventListener(eventType, callback);
	                }
	                try {
	                    callback(eventData);
	                }
	                catch (error) {
	                    // tslint:disable-next-line:no-console
	                    console.error(error);
	                }
	            });
	        }
	    };
	    return EventEmitter;
	}());



	var index$1 = /*#__PURE__*/Object.freeze({
		EventEmitter: EventEmitter
	});

	/**
	 * An Affine Transform class generated from a set of reference points.
	 */
	var AffineTransform = /** @class */ (function () {
	    /**
	     * An Affine Transform class generated from a set of reference points.
	     * @param source A set of reference points from the source reference system to transform from.
	     * @param target A set of reference points from the target reference system to transform to.
	     */
	    function AffineTransform(source, target) {
	        this.M = AffineTransform._calculateAffineTransform(source, target);
	        this.inverseM = AffineTransform._calculateAffineTransform(target, source);
	    }
	    /**
	     * Converts an array of points from the source reference system to the target reference system.
	     * @param sourcePoints An array of points from the source reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the target reference system.
	     */
	    AffineTransform.prototype.toTarget = function (sourcePoints, decimals) {
	        if (typeof sourcePoints !== undefined) {
	            return this.transformArray(sourcePoints, this.M, decimals);
	        }
	        throw new Error("Invalid sourcePoints specified.");
	    };
	    /**
	     * Converts an array of points from the target reference system to the source reference system.
	     * @param targetPoints An array of points from the target reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the source reference system.
	     */
	    AffineTransform.prototype.toSource = function (targetPoints, decimals) {
	        if (typeof targetPoints !== undefined) {
	            return this.transformArray(targetPoints, this.inverseM, decimals);
	        }
	        throw new Error("Invalid targetPoints specified.");
	    };
	    /**
	     * Applies a transform matrix over a set of points and optionally rounds off the values to a specified number of decimals.
	     * @param points The array of points to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transformArray = function (points, transformMatrix, decimals) {
	        if (points && Array.isArray(points) && Array.isArray(points[0])) {
	            var pos = [];
	            for (var _a = 0, points_1 = points; _a < points_1.length; _a++) {
	                var subPoints = points_1[_a];
	                pos.push(this.transform(subPoints, transformMatrix, decimals));
	            }
	            return pos;
	        }
	        return null;
	    };
	    /**
	     * Applies a transform matrix on a point and optionally rounds off the values to a specified number of decimals.
	     * @param point The point to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transform = function (point, transformMatrix, decimals) {
	        var x = point[0] * transformMatrix[0][3] + point[1] * transformMatrix[1][3] + transformMatrix[2][3];
	        var y = point[0] * transformMatrix[0][4] + point[1] * transformMatrix[1][4] + transformMatrix[2][4];
	        return typeof decimals === "number" && decimals >= 0 ?
	            [_precision(x, decimals), _precision(y, decimals)] :
	            [_precision(x, 6), _precision(y, 6)];
	    };
	    /**
	     * Takes in a set of source and target points can calculates an approximate Affine Transform matrix that best fits the data.
	     * Modified version of this code: https://github.com/commenthol/affinefit
	     * @param sourcePoints A set of source points to transform from.
	     * @param targetPoints A set of target points to transform to.
	     * @returns An Affine Tranform matrix.
	     */
	    AffineTransform._calculateAffineTransform = function (sourcePoints, targetPoints) {
	        if (sourcePoints.length !== targetPoints.length || sourcePoints.length < 1) {
	            throw new Error("Error: source and target arrays must have the same length.");
	        }
	        // Use the smallest dimension of the input.
	        var dim = Math.min(sourcePoints[0].length, targetPoints[0].length);
	        var dimPlusOne = dim + 1;
	        if (sourcePoints.length < dim) {
	            throw new Error("Erorr: At least " + dim + " reference points required.");
	        }
	        // Create an empty (dim + 1) x (dim) matrix and fill it.
	        var c = [];
	        var transformMatrix = [];
	        for (var i = 0; i < dimPlusOne; i++) {
	            transformMatrix[i] = [];
	            for (var j = 0; j < dimPlusOne; j++) {
	                if (j < dim) {
	                    c[j] = 0;
	                }
	                transformMatrix[i][j] = 0;
	                for (var k = 0; k < sourcePoints.length; k++) {
	                    if (j < dim) {
	                        if (i < dim) {
	                            c[j] += sourcePoints[k][i] * targetPoints[k][j];
	                        }
	                        else {
	                            c[j] += targetPoints[k][j];
	                        }
	                    }
	                    if (i >= dim && j >= dim) {
	                        transformMatrix[i][j] += 1;
	                    }
	                    else if (i >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][j];
	                    }
	                    else if (j >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][i];
	                    }
	                    else {
	                        transformMatrix[i][j] += sourcePoints[k][i] * sourcePoints[k][j];
	                    }
	                }
	            }
	            transformMatrix[i] = transformMatrix[i].concat(c);
	        }
	        if (!this._gaussJordanElimination(transformMatrix)) {
	            throw new Error("Error: Singular matrix. Points are likely coplanar.");
	        }
	        return transformMatrix;
	    };
	    /**
	     * Puts a given matrix (2D array) into the Reduced Row Echelon Form.
	     * Returns True if successful, False if the transformMatrix is singular.
	     * Code from: https://github.com/commenthol/affinefit
	     */
	    AffineTransform._gaussJordanElimination = function (transformMatrix) {
	        var eps = 1e-10; // 1.0 / Math.pow(10, 10)
	        var dimPlusOne = transformMatrix.length;
	        var w = 2 * dimPlusOne - 1;
	        var tempNum;
	        var tempArray;
	        for (var j = 0; j < dimPlusOne; j++) {
	            var maxrow = j;
	            for (var i = j + 1; i < dimPlusOne; i++) {
	                // Find max pivot.
	                if (Math.abs(transformMatrix[i][j]) > Math.abs(transformMatrix[maxrow][j])) {
	                    maxrow = i;
	                }
	            }
	            tempArray = transformMatrix[maxrow];
	            transformMatrix[maxrow] = transformMatrix[j];
	            transformMatrix[j] = tempArray;
	            if (Math.abs(transformMatrix[j][j]) <= eps) {
	                // Is Singular?
	                return false;
	            }
	            for (var _j = j + 1; _j < dimPlusOne; _j++) {
	                // Eliminate column y.
	                tempNum = transformMatrix[_j][j] / transformMatrix[j][j];
	                for (var _i = j; _i < w; _i++) {
	                    transformMatrix[_j][_i] -= transformMatrix[j][_i] * tempNum;
	                }
	            }
	        }
	        for (var j = dimPlusOne - 1; j > -1; j--) {
	            // Backsubstitute.
	            tempNum = transformMatrix[j][j];
	            for (var i = 0; i < j; i++) {
	                for (var _x = w - 1; _x > j - 1; _x--) {
	                    transformMatrix[i][_x] -= transformMatrix[j][_x] * transformMatrix[i][j] / tempNum;
	                }
	            }
	            transformMatrix[j][j] /= tempNum;
	            for (var _x2 = dimPlusOne; _x2 < w; _x2++) {
	                // Normalize row y.
	                transformMatrix[j][_x2] /= tempNum;
	            }
	        }
	        return true;
	    };
	    return AffineTransform;
	}());



	var index$2 = /*#__PURE__*/Object.freeze({
		AffineTransform: AffineTransform,
		_precision: _precision,
		get AreaUnits () { return AreaUnits; },
		get DistanceUnits () { return DistanceUnits; },
		get TimeUnits () { return TimeUnits; },
		get SpeedUnits () { return SpeedUnits; },
		get AccelerationUnits () { return AccelerationUnits; },
		boundingBoxToPolygon: boundingBoxToPolygon,
		convertDistance: convertDistance,
		getCardinalSpline: getCardinalSpline,
		getDestination: getDestination,
		getDistanceTo: getDistanceTo,
		getEarthRadius: getEarthRadius,
		getGeodesicPath: getGeodesicPath,
		getHeading: getHeading,
		getLengthOfPath: getLengthOfPath,
		getPositionAlongPath: getPositionAlongPath,
		getRegularPolygonPath: getRegularPolygonPath,
		interpolate: interpolate,
		normalizeLatitude: normalizeLatitude,
		normalizeLongitude: normalizeLongitude,
		rotatePositions: rotatePositions,
		getPixelHeading: getPixelHeading,
		mercatorPixelsToPositions: mercatorPixelsToPositions,
		mercatorPositionsToPixels: mercatorPositionsToPixels,
		convertAcceleration: convertAcceleration,
		convertArea: convertArea,
		convertSpeed: convertSpeed,
		convertTimespan: convertTimespan,
		getAcceleration: getAcceleration,
		getAccelerationFromSpeeds: getAccelerationFromSpeeds,
		getAccelerationFromFeatures: getAccelerationFromFeatures,
		getArea: getArea,
		getSpeed: getSpeed,
		getSpeedFromFeatures: getSpeedFromFeatures,
		getTimespan: getTimespan,
		getTravelDistance: getTravelDistance,
		parseTimestamp: parseTimestamp,
		getConvexHull: getConvexHull,
		getPositions: getPositions,
		getPosition: getPosition,
		getPositionsAlongPath: getPositionsAlongPath,
		getPointWithHeadingAlongPath: getPointWithHeadingAlongPath,
		getPointsWithHeadingsAlongPath: getPointsWithHeadingsAlongPath,
		getClosestPointOnGeometry: getClosestPointOnGeometry
	});

	/**
	 * A helper class that wraps a Geometry or Feature and makes it easy to update and maintain.
	 */
	var Shape = /** @class */ (function (_super) {
	    __extends(Shape, _super);
	    function Shape(data, id, properties) {
	        var _this = _super.call(this) || this;
	        var geometry;
	        if (data.type === "Feature") {
	            var feature = data;
	            geometry = cloneDeep_1(feature.geometry);
	            properties = feature.properties ? cloneDeep_1(feature.properties) : {};
	            id = feature.id == null || feature.id === "" ? uuidRandom() : feature.id;
	        }
	        else {
	            geometry = cloneDeep_1(data);
	            id = id == null || id === "" ? uuidRandom() : id;
	            properties = properties ? cloneDeep_1(properties) : {};
	        }
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = id;
	        // Always create a new feature to guarantee the data matches our definition of a Feature.
	        _this.data = new Feature(geometry, properties, id);
	        _this._handleCircle();
	        return _this;
	    }
	    /**
	     * Adds or updates an existing property value in the shape.
	     * @param key
	     * @param value
	     */
	    Shape.prototype.addProperty = function (key, value) {
	        // Only add the property if it is a new value.
	        if (!isEqual_1(this.data.properties[key], value)) {
	            this.data.properties[key] = cloneDeep_1(value);
	            if (key === "subType" || key === "radius") {
	                this._handleCircle();
	            }
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Gets the bounding box of the shape
	     */
	    Shape.prototype.getBounds = function () {
	        var positions = this.getCoordinates();
	        var bbox;
	        var geoType = this.getType();
	        if (geoType === "Point") {
	            if (this.circlePolygon) { // If a circle from the extended GeoJSON spec.
	                var pos = this.circlePolygon.geometry.coordinates;
	                bbox = BoundingBox.fromPositions(pos[0]);
	            }
	            else {
	                var pos = positions;
	                bbox = new BoundingBox(pos, pos);
	            }
	        }
	        else if (geoType === "MultiPoint" || geoType === "LineString") {
	            var pos = positions;
	            bbox = BoundingBox.fromPositions(pos);
	        }
	        else if (geoType === "Polygon") {
	            var pos = positions;
	            // only need to check the exterior ring of Polygon
	            bbox = BoundingBox.fromPositions(pos[0]);
	        }
	        else if (geoType === "MultiLineString") {
	            var pos = positions;
	            for (var _i = 0, pos_1 = pos; _i < pos_1.length; _i++) {
	                var p = pos_1[_i];
	                bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p));
	            }
	        }
	        else if (geoType === "MultiPolygon") {
	            var pos = positions;
	            for (var _a = 0, pos_2 = pos; _a < pos_2.length; _a++) {
	                var p1 = pos_2[_a];
	                // only need to check the exterior ring of Polygon
	                bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p1[0]));
	            }
	        }
	        return bbox;
	    };
	    /**
	     * Gets the coordinates of the shape.
	     */
	    Shape.prototype.getCoordinates = function () {
	        return cloneDeep_1(this.data.geometry.coordinates);
	    };
	    /**
	     * If the shape is a circle, this gets its coordinates. Otherwise returns null.
	     */
	    Shape.prototype.getCircleCoordinates = function () {
	        if (this.circlePolygon) {
	            return cloneDeep_1(this.circlePolygon.geometry.coordinates[0]);
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * Gets the id of the shape.
	     */
	    Shape.prototype.getId = function () {
	        return this.data.id;
	    };
	    /**
	     * Gets the properties of the shape.
	     */
	    Shape.prototype.getProperties = function () {
	        return cloneDeep_1(this.data.properties);
	    };
	    /**
	     * Returns a string indicating the type of geometry this shape contains.
	     */
	    Shape.prototype.getType = function () {
	        return this.data.geometry.type;
	    };
	    /**
	     * Indicates if the contained shape is a Circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isCircle = function () {
	        return Shape._isCircle(this.data);
	    };
	    /**
	     * Indicates if the contained shape is a Rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isRectangle = function () {
	        return Shape._isRectangle(this.data);
	    };
	    /**
	     * Updates the coordinates of the shape
	     * @param coords Point: Position, LineString: Position[], Polygon: Position[][],
	     * MultiPoint: Position[], MultiLineString: Position[][], MultiPolygon: Position[][]
	     */
	    Shape.prototype.setCoordinates = function (coords) {
	        // If a Position[] is supplied for a polygon wrap it in an array.
	        var newCoords;
	        if (this.getType() === "Polygon" &&
	            Position._getDimensions(coords) === 1) {
	            newCoords = [coords];
	        }
	        else {
	            newCoords = coords;
	        }
	        // Only update the coordinates if they've actually changed.
	        if (!isEqual_1(this.data.geometry.coordinates, newCoords)) {
	            this.data.geometry.coordinates = cloneDeep_1(newCoords);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Sets the properties on the shape. Overwrites all existing properties.
	     * @param properties
	     */
	    Shape.prototype.setProperties = function (properties) {
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = this.data.id;
	        // Only update the properties if they've actually changed.
	        if (!isEqual_1(this.data.properties, properties)) {
	            this.data.properties = cloneDeep_1(properties);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Returns a GeoJSON feature that represents the shape.
	     */
	    Shape.prototype.toJson = function () {
	        return JSON.parse(JSON.stringify(this.data));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape.prototype._toJson = function () {
	        return this.circlePolygon || this.data;
	    };
	    /**
	     * @internal
	     */
	    Shape.prototype._setDataSource = function (dataSource) {
	        if (dataSource === undefined || dataSource == null) {
	            delete this.dataSource;
	        }
	        else {
	            this.dataSource = dataSource;
	        }
	    };
	    /**
	     * Check if the shape's wrapped feature is a circle form the extended GeoJSON spec.
	     * If so it will calculate a polygon feature that approximates the specified circle.
	     * @private
	     */
	    Shape.prototype._handleCircle = function () {
	        if (this.isCircle()) {
	            var coords = Shape._getCirclePositions(this.data);
	            this.circlePolygon = new Feature(new Polygon([coords]), this.data.properties, this.data.id);
	            // Set the subType to "Circle" to make sure the case is correct.
	            this.data.properties.subType = "Circle";
	        }
	        else {
	            delete this.circlePolygon;
	        }
	    };
	    /**
	     * Indicates if the specified feature is a circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isCircle = function (data) {
	        return data.geometry.type === "Point" &&
	            data.geometry.coordinates &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "circle" &&
	            typeof data.properties.radius === "number";
	    };
	    /**
	     * Indicates if the specified feature is a rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isRectangle = function (data) {
	        if (data.geometry.type === "Polygon" &&
	            data.geometry.coordinates &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "rectangle") {
	            // If type is Polygon we can assume the coordinates are a Position[][].
	            var coords = data.geometry.coordinates;
	            if (coords.length === 1) {
	                var ring = coords[0];
	                if (ring.length === 5) {
	                    return ring[0][0] === ring[4][0] &&
	                        ring[0][1] === ring[4][1];
	                }
	                else if (ring.length === 4) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    /**
	     * Calculates to positions that should be used to approximate the specified circle feature.
	     * @internal
	     */
	    Shape._getCirclePositions = function (data) {
	        return getRegularPolygonPath(data.geometry.coordinates, data.properties.radius, 72, "meters");
	    };
	    /**
	     * Represents the feature property name that the shape's id will be assigned to.
	     * This is a workaround for the Mapbox bug preventing non-numerical ids from being returned by some functions.
	     * TODO Remove once this issue if fixed.
	     * {@link https://github.com/mapbox/mapbox-gl-js/issues/2716}
	     * @internal
	     */
	    // tslint:disable-next-line: variable-name
	    Shape._shapeIdPropName = "_azureMapsShapeId";
	    return Shape;
	}(EventEmitter));

	/**
	 * A GeoJSON BoundingBox object - an array that defines a shape whose edges follow lines of constant longitude,
	 * latitude, and elevation. All axes of the most southwesterly point are followed by all axes of the more northeasterly
	 * point. The axes order of the BoundingBox follows the axes order of geometries. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-5}.
	 */
	var BoundingBox = /** @class */ (function (_super) {
	    __extends(BoundingBox, _super);
	    function BoundingBox(southwestPositionOrPositions, northeastPosition) {
	        var _this = this;
	        if (southwestPositionOrPositions && northeastPosition) {
	            var southwestPosition = southwestPositionOrPositions;
	            if (southwestPosition[2] && northeastPosition[2]) {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], southwestPosition[2] || 0, northeastPosition[0], northeastPosition[1], northeastPosition[2] || 0) || this;
	            }
	            else {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], northeastPosition[0], northeastPosition[1]) || this;
	            }
	        }
	        else if (southwestPositionOrPositions) {
	            var positions = southwestPositionOrPositions;
	            if (positions) {
	                if (positions.length === 4) {
	                    // [west, south, east, north]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3]) || this;
	                }
	                else if (positions.length >= 6) {
	                    // [west, south, elevation1, east, north, elevation2]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3], positions[4], positions[5]) || this;
	                }
	            }
	        }
	        return _this;
	    }
	    /**
	     * Clones a bounding box.
	     * @param boundingBox The bounding box to clone.
	     */
	    BoundingBox.fromBoundingBox = function (boundingBox) {
	        var west = BoundingBox.getWest(boundingBox);
	        var south = BoundingBox.getSouth(boundingBox);
	        var east = BoundingBox.getEast(boundingBox);
	        var north = BoundingBox.getNorth(boundingBox);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified dimensions.
	     * @param center The center position of the bounding box.
	     * @param width The width of the bounding box.
	     * @param height The height of the bounding box.
	     */
	    BoundingBox.fromDimensions = function (center, width, height) {
	        var lon = center[0];
	        var lat = center[1];
	        var north = Math.min(Math.max(lat + height / 2, -85.5), 85.5);
	        var south = Math.min(Math.max(lat - height / 2, -85.5), 85.5);
	        var east = normalizeLongitude(lon + width / 2);
	        var west = normalizeLongitude(lon - width / 2);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified edges.
	     * @param west The west edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param north The north edge of the bounding box.
	     */
	    BoundingBox.fromEdges = function (west, south, east, north) {
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Determines if a position is within a bounding box.
	     * @param bounds The bounding box to see if the position is in.
	     * @param position The position to see if it is in the bounding box.
	     * @returns True if the position is within the bounding box.
	     */
	    BoundingBox.containsPosition = function (bounds, position) {
	        // Allow a small difference to account for arithmetic accuracy errors.
	        // This is important for points on the edge of the bounding box which is the case when using BoundingBox.fromLocations
	        var accuracyAllowance = 0.00000001;
	        // Use the distance between the position and center of the bounding box to determine if they intersect.
	        var center = BoundingBox.getCenter(bounds);
	        var diffLatitude = Math.abs(center[1] - position[1]);
	        var diffLongitude = Math.abs(center[0] - position[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height = BoundingBox.getHeight(bounds);
	        var width = BoundingBox.getWidth(bounds);
	        return (diffLatitude <= (height / 2) + accuracyAllowance) && (diffLongitude <= (width / 2) + accuracyAllowance);
	    };
	    /**
	     * Returns a boolean indicating if the bounding box crosses the antimeridian or not.
	     * @param bounds The bounding box to check.
	     * @returns A boolean indicating if the bounding box crosses the antimeridian or not.
	     */
	    BoundingBox.crossesAntimeridian = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        return (east - west) < 0;
	    };
	    /**
	     * Calculates the center of a bounding box.
	     * @param bounds A bounding box to calculate the center of.
	     * @returns A position that represents the center of the bounding box.
	     */
	    BoundingBox.getCenter = function (bounds) {
	        // [west, south, east, north]
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        if (west > east) {
	            east += 360.0;
	        }
	        var centerLongitude = normalizeLongitude((west + east) / 2.0);
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var centerLatitude = normalizeLatitude((south + north) / 2.0);
	        return [centerLongitude, centerLatitude];
	    };
	    /**
	     * Gets the height of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The height of the bounding box in degrees.
	     */
	    BoundingBox.getHeight = function (bounds) {
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var height = north - south;
	        return isNaN(height) ? 0 : height;
	    };
	    /**
	     * Gets the width of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The width of the bounding box in degrees.
	     */
	    BoundingBox.getWidth = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        var width = east - west;
	        // Check to see if bounds crosses antimeridian
	        return isNaN(width) ? 0 : width < 0 ? width += 360 : width;
	    };
	    /**
	     * Returns the south west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south west position of the bounding box.
	     */
	    BoundingBox.getSouthWest = function (bounds) {
	        var south = this.getSouth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(south) || isNaN(west)) ? null : [west, south];
	    };
	    /**
	     * Returns the north east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north east position of the bounding box.
	     */
	    BoundingBox.getNorthEast = function (bounds) {
	        var north = this.getNorth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(north) || isNaN(east)) ? null : [east, north];
	    };
	    /**
	     * Returns the north west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north west position of the bounding box.
	     */
	    BoundingBox.getNorthWest = function (bounds) {
	        var north = this.getNorth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(north) || isNaN(west)) ? null : [west, north];
	    };
	    /**
	     * Returns the south east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south east position of the bounding box.
	     */
	    BoundingBox.getSouthEast = function (bounds) {
	        var south = this.getSouth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(south) || isNaN(east)) ? null : [east, south];
	    };
	    /**
	     * Returns the south position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south position value of the bounding box.
	     */
	    BoundingBox.getSouth = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[1]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the west position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The west position value of the bounding box.
	     */
	    BoundingBox.getWest = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[0]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the north position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north position value of the bounding box.
	     */
	    BoundingBox.getNorth = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[3]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[4]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Returns the east position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The east position value of the bounding box.
	     */
	    BoundingBox.getEast = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[2]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[3]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Determines is two bounding boxes intersect.
	     * @param bounds1 The first bounding box to compare with.
	     * @param bounds2 The second bounding box to compare with.
	     * @returns true if the provided bounding boxes intersect.
	     */
	    BoundingBox.intersect = function (bounds1, bounds2) {
	        var center1 = BoundingBox.getCenter(bounds1);
	        var center2 = BoundingBox.getCenter(bounds2);
	        // Use the distance between the 2 centers to determine if they intersect.
	        var diffLatitude = Math.abs(center1[1] - center2[1]);
	        var diffLongitude = Math.abs(center1[0] - center2[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height1 = BoundingBox.getHeight(bounds1);
	        var width1 = BoundingBox.getWidth(bounds1);
	        var height2 = BoundingBox.getHeight(bounds2);
	        var width2 = BoundingBox.getWidth(bounds2);
	        return (diffLatitude <= (height1 / 2 + height2 / 2) && diffLongitude <= (width1 / 2 + width2 / 2));
	    };
	    /**
	     * Merges two bounding boxes together.
	     * @param bounds1 The first bounding box to merge with.
	     * @param bounds2 The second bounding box to merge with.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.merge = function (bounds1, bounds2) {
	        var bb1Valid = bounds1 && bounds1.length === 4;
	        var bb2Valid = bounds2 && bounds2.length === 4;
	        if (bb1Valid && !bb2Valid) {
	            return bounds1;
	        }
	        else if (bb2Valid && !bb1Valid) {
	            return bounds2;
	        }
	        else if (!bb1Valid && !bb2Valid) {
	            return null;
	        }
	        var north = Math.max(normalizeLatitude(BoundingBox.getNorth(bounds1)), normalizeLatitude(BoundingBox.getNorth(bounds2)));
	        var south = Math.min(normalizeLatitude(BoundingBox.getSouth(bounds1)), normalizeLatitude(BoundingBox.getSouth(bounds2)));
	        // Find out the longitude spans of the two bounding boxes.
	        var boundingBoxes = [bounds1, bounds2];
	        var longIntervals = [];
	        var i = 0;
	        for (i = 0; i < boundingBoxes.length; i++) {
	            var b = boundingBoxes[i];
	            var w = normalizeLongitude(BoundingBox.getWest(b));
	            var e = normalizeLongitude(BoundingBox.getEast(b));
	            if (BoundingBox.crossesAntimeridian(b)) {
	                longIntervals.push([w, 180]);
	                longIntervals.push([-180, e]);
	            }
	            else {
	                longIntervals.push([w, e]);
	            }
	        }
	        // sort and merge (overlaped intervals) these intervals
	        // after the sort and merge we should have a list of intervals that don't overlap with each other.
	        longIntervals.sort(function (a, b) { return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]; });
	        var mergedIntervals = [];
	        var currentInterval = longIntervals[0];
	        i = 1;
	        while (i < longIntervals.length) {
	            var nextInterval = longIntervals[i];
	            if (currentInterval[1] >= nextInterval[0]) {
	                currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);
	            }
	            else {
	                mergedIntervals.push(currentInterval);
	                currentInterval = nextInterval;
	            }
	            i++;
	        }
	        mergedIntervals.push(currentInterval);
	        // find out the biggest gap between these intervals. suppose this gap is [A, B], then A will be the east bound and B will be the west bound of the merged rectangle.
	        var length = mergedIntervals.length;
	        var maxGapSpan = mergedIntervals[0][0] + 360 - mergedIntervals[length - 1][1];
	        var maxGap = [mergedIntervals[length - 1][1], mergedIntervals[0][0]];
	        for (i = 1; i < length; i++) {
	            var thisGapSpan = mergedIntervals[i][0] - mergedIntervals[i - 1][1];
	            if (thisGapSpan > maxGapSpan) {
	                maxGapSpan = thisGapSpan;
	                maxGap = [mergedIntervals[i - 1][1], mergedIntervals[i][0]];
	            }
	        }
	        // now we have all the edges of the rectangle
	        return new BoundingBox([maxGap[1], south], [maxGap[0], north]);
	    };
	    /**
	     * Creates a BoundingBox that contains all provided Position objects.
	     * @param positions An array of locations to use to generate the bounding box.
	     * @returns A bounding box that contains all given positions.
	     */
	    BoundingBox.fromPositions = function (positions) {
	        var north = NaN;
	        var south = NaN;
	        var west = NaN;
	        var east = NaN;
	        var position;
	        var i = positions.length;
	        var longitudes = new Array(i);
	        var longCount = 0;
	        while (i--) {
	            position = positions[i];
	            if (position && position.length >= 2) {
	                var normalizedPosition1 = normalizeLatitude(position[1]);
	                north = isNaN(north) ? normalizedPosition1 : Math.max(north, normalizedPosition1);
	                south = isNaN(south) ? normalizedPosition1 : Math.min(south, normalizedPosition1);
	                longitudes[longCount++] = normalizeLongitude(position[0]);
	            }
	        }
	        if (longCount) {
	            // Find largest gap between longitudes
	            longitudes.length = longCount;
	            longitudes.sort(function (a, b) { return a - b; });
	            var maxGap = (longitudes[0] + 360) - longitudes[longCount - 1];
	            var maxGapIndex = 0;
	            for (i = 1; i < longCount; i++) {
	                var gap = longitudes[i] - longitudes[i - 1];
	                if (gap > maxGap) {
	                    maxGap = gap;
	                    maxGapIndex = i;
	                }
	            }
	            west = longitudes[maxGapIndex];
	            east = longitudes[(maxGapIndex || longCount) - 1];
	        }
	        if (isNaN(west) || isNaN(south) || isNaN(east) || isNaN(north)) {
	            return null;
	        }
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Creates a BoundingBox from any array of objects that contain coordinate information.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns A BoundingBox that contains all the provided coordinate information.
	     */
	    BoundingBox.fromLatLngs = function (latLngs) {
	        return BoundingBox.fromPositions(Position.fromLatLngs(latLngs));
	    };
	    /**
	     * Calculates the bounding box of a FeatureCollection, Feature, Geometry, Shape or array of these objects.
	     * @param data The FeatureCollection, Feature, Geometry, Shape or array of these objects to calculate the bounding box for.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.fromData = function (data) {
	        var tempBounds;
	        var bounds = null;
	        if (Array.isArray(data) && data.length > 0) {
	            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
	                var datum = data_1[_i];
	                tempBounds = BoundingBox.fromData(datum);
	                if (tempBounds != null) {
	                    if (bounds === null) {
	                        bounds = tempBounds;
	                    }
	                    else {
	                        bounds = BoundingBox.merge(bounds, tempBounds);
	                    }
	                }
	            }
	            return bounds;
	        }
	        else if (data instanceof Shape) {
	            return data.getBounds();
	        }
	        else if (data["type"]) {
	            // Data is a GeoJson object.
	            var geoJsonObj = data;
	            // Check to see if the GeoJSON object has a bbox, property, and if it does, use that.
	            if (geoJsonObj["bbox"] && geoJsonObj["bbox"].length === 4) {
	                return geoJsonObj["bbox"];
	            }
	            else {
	                switch (geoJsonObj.type) {
	                    case "FeatureCollection":
	                        // features: Array<Feature<Geometry>>
	                        return BoundingBox.fromData(geoJsonObj.features);
	                    case "Feature":
	                        // geometry: G
	                        if (Shape._isCircle(geoJsonObj)) {
	                            return BoundingBox.fromPositions(Shape._getCirclePositions(geoJsonObj));
	                        }
	                        else {
	                            return BoundingBox.fromData(geoJsonObj.geometry);
	                        }
	                    case "GeometryCollection":
	                        // geometries: Geometry[]
	                        return BoundingBox.fromData(geoJsonObj.geometries);
	                    case "Point":
	                        // coordinates: Position
	                        var p = geoJsonObj.coordinates;
	                        if (p && p.length >= 2) {
	                            return [p[0], p[1], p[0], p[1]];
	                        }
	                        break;
	                    case "LineString":
	                    case "MultiPoint":
	                        // coordinates: Position[]
	                        return BoundingBox.fromPositions(geoJsonObj.coordinates);
	                    case "Polygon":
	                    case "MultiLineString":
	                        // coordinates: Position[][]
	                        var ml = geoJsonObj.coordinates;
	                        if (ml && ml.length > 0) {
	                            for (var i = 0, len = ml.length; i < len; i++) {
	                                tempBounds = BoundingBox.fromPositions(ml[i]);
	                                if (tempBounds != null) {
	                                    if (bounds === null) {
	                                        bounds = tempBounds;
	                                    }
	                                    else {
	                                        bounds = BoundingBox.merge(bounds, tempBounds);
	                                    }
	                                }
	                            }
	                            if (bounds != null) {
	                                return bounds;
	                            }
	                        }
	                        break;
	                    case "MultiPolygon":
	                        // coordinates: Position[][][]
	                        var mp = geoJsonObj.coordinates;
	                        if (mp && mp.length > 0) {
	                            for (var i = 0, len = mp.length; i < len; i++) {
	                                for (var j = 0, cnt = mp[i].length; j < cnt; j++) {
	                                    tempBounds = BoundingBox.fromPositions(mp[i][j]);
	                                    if (tempBounds != null) {
	                                        if (bounds === null) {
	                                            bounds = tempBounds;
	                                        }
	                                        else {
	                                            bounds = BoundingBox.merge(bounds, tempBounds);
	                                        }
	                                    }
	                                }
	                            }
	                            return bounds;
	                        }
	                        break;
	                }
	            }
	        }
	        return null;
	    };
	    /**
	     * Splits a BoundingBox that crosses the Antimeridian into two BoundingBox's. One entirely west of the Antimerdian and another entirely east of the Antimerdian.
	     * @param bounds
	     */
	    BoundingBox.splitOnAntimeridian = function (bounds) {
	        var bboxes = [];
	        if (BoundingBox.crossesAntimeridian(bounds)) {
	            var bbox1 = void 0;
	            var bbox2 = void 0;
	            var west = normalizeLongitude(BoundingBox.getWest(bounds));
	            var east = normalizeLongitude(BoundingBox.getEast(bounds));
	            var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	            var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	            // has elevations
	            if (bounds.length >= 6) {
	                bbox1 = new BoundingBox([west, south, bounds[2], 180, north, bounds[5]]);
	                bbox2 = new BoundingBox([-180, south, bounds[2], east, north, bounds[5]]);
	            }
	            else {
	                bbox1 = new BoundingBox([west, south, 180, north]);
	                bbox2 = new BoundingBox([-180, south, east, north]);
	            }
	            bboxes.push(bbox1, bbox2);
	        }
	        else {
	            bboxes.push(new BoundingBox(bounds));
	        }
	        return bboxes;
	    };
	    return BoundingBox;
	}(Array));

	/**
	 * A GeoJSON FeatureCollection object - a JSON object that contains a collection of GeoJSON features. The full
	 * description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.3}.
	 */
	var FeatureCollection = /** @class */ (function () {
	    /**
	     * Constructs a FeatureCollection.
	     * @param features The collection of features that make up the feature collection.
	     */
	    function FeatureCollection(features) {
	        /**
	         * A GeoJSON type descriptor with value "FeatureCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "FeatureCollection";
	        this.type = FeatureCollection.TYPE;
	        this.features = features;
	    }
	    /**
	     * A static GeoJSON type descriptor for the FeatureCollection class to be used in runtime comparisons.
	     */
	    FeatureCollection.TYPE = "FeatureCollection";
	    return FeatureCollection;
	}());

	/**
	 * A GeoJSON GeometryCollection object - a JSON object that contains a collection of a GeoJSON Geometry objects. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.8}.
	 */
	var GeometryCollection = /** @class */ (function () {
	    /**
	     * Constructs a GeometryCollection.
	     * @param geometries The collection of geometries that make up the geometry collection.
	     */
	    function GeometryCollection(geometries) {
	        /**
	         * A GeoJSON type descriptor with value "GeometryCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "GeometryCollection";
	        this.type = GeometryCollection.TYPE;
	        this.geometries = geometries;
	    }
	    /**
	     * A static GeoJSON type descriptor for the GeometryCollection class to be used in runtime comparisons.
	     */
	    GeometryCollection.TYPE = "GeometryCollection";
	    return GeometryCollection;
	}());

	/**
	 * A GeoJSON LineString object - a JSON object that represents a geographic curve. The full description is detailed
	 * in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.4}.
	 */
	var LineString = /** @class */ (function () {
	    /**
	     * Constructs a LineString.
	     * @param coordinates The ordered list of positions defining the linestring.
	     * @param bbox The bounding box of the linestring.
	     */
	    function LineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "LineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "LineString";
	        this.type = LineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the LineString class to be used in runtime comparisons.
	     */
	    LineString.TYPE = "LineString";
	    return LineString;
	}());

	/**
	 * A GeoJSON MultiLineString object - a JSON object that represents multiple geographic curves. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.5}.
	 */
	var MultiLineString = /** @class */ (function () {
	    /**
	     * Constructs a MultiLineString.
	     * @param coordinates The array of LineString coordinate arrays defining the multilinestring.
	     * @param bbox The bounding box of the multilinestring.
	     */
	    function MultiLineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliLineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiLineString";
	        this.type = MultiLineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiLineString class to be used in runtime comparisons.
	     */
	    MultiLineString.TYPE = "MultiLineString";
	    return MultiLineString;
	}());

	/**
	 * A GeoJSON MultiPoint object - a JSON object that represents multiple geographic positions. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.3}.
	 */
	var MultiPoint = /** @class */ (function () {
	    /**
	     * Constructs a MultiPoint.
	     * @param coordinates The array of multiple positions defining the multipoint.
	     * @param bbox The bounding box of the multipoint.
	     */
	    function MultiPoint(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPoint".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPoint";
	        this.type = MultiPoint.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPoint class to be used in runtime comparisons.
	     */
	    MultiPoint.TYPE = "MultiPoint";
	    return MultiPoint;
	}());

	/**
	 * A GeoJSON MultiPolygon object - a JSON object that represents multiple geographic polygons. The full description is
	 * detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.7}.
	 */
	var MultiPolygon = /** @class */ (function () {
	    /**
	     * Constructs a MultiPolygon.
	     * @param coordinates The array of polygon coordinate arrays defining the multipolygon.
	     * @param bbox The bounding box of the multipolygon.
	     */
	    function MultiPolygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPolygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPolygon";
	        this.type = MultiPolygon.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPolygon class to be used in runtime comparisons.
	     */
	    MultiPolygon.TYPE = "MultiPolygon";
	    return MultiPolygon;
	}());



	var index$3 = /*#__PURE__*/Object.freeze({
		Feature: Feature,
		FeatureCollection: FeatureCollection,
		LineString: LineString,
		Point: Point,
		Polygon: Polygon,
		Position: Position,
		BoundingBox: BoundingBox,
		MultiLineString: MultiLineString,
		MultiPoint: MultiPoint,
		MultiPolygon: MultiPolygon,
		GeometryCollection: GeometryCollection
	});

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$2 = 1,
	    CLONE_SYMBOLS_FLAG$2 = 4;

	/**
	 * This method is like `_.cloneWith` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.cloneWith
	 * @example
	 *
	 * function customizer(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * }
	 *
	 * var el = _.cloneDeepWith(document.body, customizer);
	 *
	 * console.log(el === document.body);
	 * // => false
	 * console.log(el.nodeName);
	 * // => 'BODY'
	 * console.log(el.childNodes.length);
	 * // => 20
	 */
	function cloneDeepWith(value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return _baseClone(value, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$2, customizer);
	}

	var cloneDeepWith_1 = cloneDeepWith;

	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `DataSourceOptions`.
	 * @module Object Definitions
	 */
	var DataSourceOptions = /** @class */ (function (_super) {
	    __extends(DataSourceOptions, _super);
	    function DataSourceOptions() {
	        /*
	         * TODO:
	         * (P3) The size of the buffer around each tile.
	         * A buffer value of 0 will provide better performance but will be more likely to generate artifacts when rendering.
	         * Larger buffers will produce left artifacts but will result in slower performance.
	         *
	         * public buffer?: number = 128;
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels).
	         * default `18`
	         * @default 18
	         */
	        _this.maxZoom = 18;
	        /**
	         * A boolean indicating if Point features in the source should be clustered or not.
	         * If set to true, points will be clustered together into groups by radius.
	         * default `false`
	         * @default false
	         */
	        _this.cluster = false;
	        /**
	         * The radius of each cluster in pixels.
	         * default `50`
	         * @default 50
	         */
	        _this.clusterRadius = 50;
	        /**
	         * The maximum zoom level in which to cluster points.
	         * Defaults to one zoom less than `maxZoom` so that last zoom features are not clustered.
	         */
	        _this.clusterMaxZoom = undefined;
	        /**
	         * Defines custom properties that are calculated using expressions against all the points within each cluster and added to the properties of each cluster point.
	         */
	        _this.clusterProperties = undefined;
	        /**
	         * Specifies whether to calculate line distance metrics.
	         * This is required for line layers that specify `lineGradient` values.
	         * default `false`
	         * @default false
	         */
	        _this.lineMetrics = false;
	        /**
	         * The Douglas-Peucker simplification tolerance that is applied to the data when rendering (higher means simpler geometries and faster performance).
	         * default `0.375`
	         * @default 0.375
	         */
	        _this.tolerance = 0.375;
	        return _this;
	    }
	    return DataSourceOptions;
	}(Options));

	/**
	 * A base abstract class in which all other source objects extend.
	 * A source must be added to a layer before it is visible on the map.
	 */
	var Source = /** @class */ (function (_super) {
	    __extends(Source, _super);
	    function Source(id) {
	        var _this = _super.call(this) || this;
	        _this.id = id || uuidRandom();
	        return _this;
	    }
	    /**
	     * Gets the id of the data source
	     */
	    Source.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Get reference to Mapbox Map
	     * @internal
	     */
	    Source.prototype._setMap = function (map) {
	        if (map == null || map === undefined) {
	            var temp = this.map;
	            delete this.map;
	            this._invokeEvent("sourceremoved", this);
	            if (temp) {
	                temp.events.invoke("sourceremoved", this);
	            }
	        }
	        else {
	            this.map = map;
	            this._invokeEvent("sourceadded", this);
	            this.map.events.invoke("sourceadded", this);
	        }
	    };
	    return Source;
	}(EventEmitter));

	/**
	 * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * The DataSource class may be used with the SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, and HeatMapLayer.
	 */
	var DataSource = /** @class */ (function (_super) {
	    __extends(DataSource, _super);
	    /**
	     * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	     * A data source must be added to a layer before it is visible on the map.
	     * The `DataSource` class may be used with the `SymbolLayer`, `LineLayer`, `PolygonLayer`, `BubbleLayer`, and `HeatMapLayer`.
	     * @param id a unique id that the user assigns to the data source. If this is not specified, then the data source will automatically be assigned an id.
	     * @param options the options for the data source.
	     */
	    function DataSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.requestId = undefined;
	        _this.options = new DataSourceOptions().merge(cloneDeep_1(options));
	        _this.shapes = [];
	        _this.shapesMap = new Dictionary();
	        return _this;
	    }
	    /**
	     * Adds shapes to the data source.
	     * GeoJSON objects will be wrapped within a Shape class to make them easier to manage.
	     * Optionally specify an index to insert the feature between other shapes/features in the layers.
	     * @param data
	     * @param index
	     */
	    DataSource.prototype.add = function (data, index) {
	        this._addNoUpdate(data, index);
	        this._updateSource();
	    };
	    /**
	     * Removes all data in the data source.
	     */
	    DataSource.prototype.clear = function () {
	        this._clearNoUpdate();
	        this._updateSource();
	    };
	    /**
	     * Cleans up any resources this object is consuming.
	     */
	    DataSource.prototype.dispose = function () {
	        this.options = null;
	        this.shapes = null;
	        this.shapesMap = null;
	        this.map = null;
	    };
	    /*
	     * (P3) Gets the bounding box the encloses all data in the data source.
	     * public getBounds() {}
	     */
	    /**
	     * Calculates a zoom level at which the cluster will start expanding or break apart.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterExpansionZoom = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterExpansionZoom(clusterId, function (error, zoom) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                    if (typeof zoom === "number") {
	                        resolve(zoom);
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves the children of the given cluster on the next zoom level. This may be a combination of shapes and sub-clusters.
	     * The sub-clusters will be features with properties matching ClusteredProperties.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterChildren = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterChildren(clusterId, function (error, features) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves shapes that are within the cluster.
	     * @param clusterId
	     * @param limit The maximum number of features to return. Set to Infinity to return all shapes.
	     * @param offset The number of shapes to skip. Allows you to page through the shapes in the cluster.
	     */
	    DataSource.prototype.getClusterLeaves = function (clusterId, limit, offset) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterLeaves(clusterId, limit, offset, function (error, features) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Gets the options used by the data source.
	     */
	    DataSource.prototype.getOptions = function () {
	        return cloneDeep_1(this.options);
	    };
	    /**
	     * Returns all shapes that are in the DataSource.
	     */
	    DataSource.prototype.getShapes = function () {
	        return Array.from(this.shapes);
	    };
	    /**
	     * Downloads a GeoJSON document and imports its data into the data source.
	     * The GeoJSON document must be on the same domain or accessible using CORS.
	     * @param url
	     */
	    DataSource.prototype.importDataFromUrl = function (url) {
	        var _this = this;
	        return fetch(url, {
	            method: "GET",
	            mode: "cors"
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP " + response.status + ": " + response.statusText);
	            }
	        }).then(function (geoJson) {
	            _this.add(geoJson);
	        });
	    };
	    /**
	     * Retrieves a shape with the specified id.
	     * If no shape with the specified id is contained in the data source, null will be return.
	     * @param id The id of the shape to return.
	     */
	    DataSource.prototype.getShapeById = function (id) {
	        return this.shapes[this.shapesMap.get(id)] || null;
	    };
	    /**
	     * Removes one or more shapes from the data source.
	     * If a string is passed in, it is assumed to be an id.
	     * If a number is passed in, removes the shape at that index.
	     * @param shape The shape(s), shape id(s), or feature(s) to be removed
	     */
	    DataSource.prototype.remove = function (shape) {
	        var shapes = Array.isArray(shape) ? shape : [shape];
	        for (var _i = 0, shapes_1 = shapes; _i < shapes_1.length; _i++) {
	            var s = shapes_1[_i];
	            if (typeof s === "number") {
	                this._removeByIndex(s);
	            }
	            else {
	                this._removeById(s);
	            }
	        }
	        this._updateSource();
	    };
	    /**
	     * Removes one or more shapes from the datasource based on its id.
	     * @param shape shape id
	     */
	    DataSource.prototype.removeById = function (id) {
	        var ids = Array.isArray(id) ? id : [id];
	        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
	            var i = ids_1[_i];
	            this._removeById(i);
	        }
	        this._updateSource();
	    };
	    /**
	     * Sets the data source options.
	     * The data source will retain its current values for any option not specified in the supplied options.
	     * @param options the DataSourceOptions to be set
	     */
	    DataSource.prototype.setOptions = function (options) {
	        var newOptions = new DataSourceOptions().merge(this.options, cloneDeep_1(options));
	        // Only rebuild the map's style if a options has actually changed.
	        if (!isEqual_1(this.options, newOptions)) {
	            this._invokeEvent("datasourceupdated", this);
	            // Update the options before rebuilding.
	            this.options = newOptions;
	            if (this.map) {
	                this.map._rebuildStyle();
	            }
	        }
	    };
	    /**
	     * Overwrites all shapes in the data source with the new array of shapes.
	     * @param shape the new shapes to update
	     */
	    DataSource.prototype.setShapes = function (shape) {
	        this._clearNoUpdate();
	        this.add(shape);
	    };
	    /**
	     * Returns a GeoJSON FeatureCollection which contains all the shape data that is in the data source.
	     */
	    DataSource.prototype.toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape.toJson(); }));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    DataSource.prototype._toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape._toJson(); }));
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._buildSource = function () {
	        var geoJsonSource = {
	            type: "geojson",
	            data: this._toJson(),
	            maxzoom: this.options.maxZoom,
	            cluster: this.options.cluster,
	            clusterRadius: this.options.clusterRadius,
	            tolerance: this.options.tolerance,
	            lineMetrics: this.options.lineMetrics,
	            clusterProperties: this.options.clusterProperties
	        };
	        if (typeof this.options.clusterMaxZoom === "number") {
	            geoJsonSource.clusterMaxZoom = this.options.clusterMaxZoom;
	        }
	        return geoJsonSource;
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._addNoUpdate = function (data, index) {
	        var newShapes;
	        if (data instanceof Shape) {
	            this._addToSources(data, index);
	            newShapes = [data];
	        }
	        else if (Array.isArray(data)) {
	            newShapes = data.map(function (ele) { return ele instanceof Shape ? ele : new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "FeatureCollection") {
	            newShapes = data.features.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "GeometryCollection") {
	            newShapes = data.geometries.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else {
	            // Either a Feature or Geometry.
	            // The Shape constructor can handle either.
	            var shape = new Shape(data);
	            this._addToSources(shape, index);
	            newShapes = [shape];
	        }
	        // Invoke the dataadded event once all the new features have been wrapped with shapes.
	        this._invokeEvent("dataadded", newShapes);
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._clearNoUpdate = function () {
	        var oldShapes = this.shapes;
	        this.shapes = [];
	        this.shapesMap = new Dictionary();
	        // If any shapes were removed fire the dataremoved event.
	        if (oldShapes && oldShapes.length > 0) {
	            this._invokeEvent("dataremoved", oldShapes);
	        }
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._updateSource = function () {
	        var _this = this;
	        // throttling logic that makes DataSource waits a small amount of time before rerendering the map, so the browser won't get frozen
	        // when there is too much data
	        if (this.requestId !== undefined) {
	            return;
	        }
	        else {
	            this.requestId = requestAnimationFrame(function () {
	                _this._updateMboxSource();
	                _this.requestId = undefined;
	            });
	        }
	    };
	    DataSource.prototype._addToSources = function (data, index) {
	        data = Array.isArray(data) ? data : [data];
	        if (typeof index !== "number") {
	            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
	                var d = data_1[_i];
	                this.shapes.push(d);
	                this.shapesMap.set(d.getId(), this.shapes.length - 1);
	            }
	        }
	        else {
	            for (var i = data.length - 1; i >= 0; i--) {
	                this.shapes.splice(index, 0, data[i]);
	                this._updateShapesMap(index);
	            }
	        }
	        for (var _a = 0, data_2 = data; _a < data_2.length; _a++) {
	            var d = data_2[_a];
	            d._setDataSource(this);
	        }
	    };
	    DataSource.prototype._removeById = function (shape) {
	        var oldShape;
	        var i = shape instanceof Shape ? shape.getId() : typeof shape === "string" || typeof shape === "number" ? shape : shape.id;
	        oldShape = this.shapes[this.shapesMap.get(i)];
	        oldShape._setDataSource(null);
	        this.shapes.splice(this.shapesMap.get(i), 1);
	        this._updateShapesMap(this.shapesMap.get(i));
	        this.shapesMap.delete(i);
	        // Invoke the dataremoved event with the single shape removed.
	        this._invokeEvent("dataremoved", [oldShape]);
	    };
	    DataSource.prototype._removeByIndex = function (i) {
	        var oldShape;
	        if (i >= this.shapes.length) {
	            throw new Error("The specified remove index '" + i + "' " +
	                ("is greater than the maximum possible index '" + (this.shapes.length - 1) + "'"));
	        }
	        oldShape = this.shapes[i];
	        this.shapesMap.delete(oldShape.getId());
	        oldShape._setDataSource(null);
	        this.shapes.splice(i, 1);
	        this._updateShapesMap(i);
	        // Invoke the dataremoved event with the single shape removed.
	        this._invokeEvent("dataremoved", [oldShape]);
	    };
	    DataSource.prototype._updateShapesMap = function (index) {
	        for (var i = index; i < this.shapes.length; i++) {
	            this.shapesMap.set(this.shapes[i].getId(), i);
	        }
	    };
	    DataSource.prototype._updateMboxSource = function () {
	        if (this.map && this.map._getMap()) {
	            var mbSource = this.map._getMap().getSource(this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.setData(this._toJson());
	            }
	        }
	    };
	    return DataSource;
	}(Source));

	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `VectorTileSource`.
	 * @module Object Definitions
	 */
	var VectorTileSourceOptions = /** @class */ (function (_super) {
	    __extends(VectorTileSourceOptions, _super);
	    function VectorTileSourceOptions() {
	        /*
	         * TODO:
	         * (P4) An attribute to display to the user when this data source is visible.
	         *
	         * public attribute?: string;
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         */
	        _this.bounds = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * default `0`
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * default `22`
	         * @default 22
	         */
	        _this.maxZoom = 22;
	        /**
	         * Specifies is the tile systems y coordinate uses the OSGeo Tile Map Services which reverses the Y coordinate axis.
	         * default `false`
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of one or more tile source URLs. Supported URL parameters:
	         *  <ul>
	         *      <li>`{x}` - X position of tile. Tile URL usually also needs {y} and {z}.</li>
	         *      <li>`{y}` - Y position of tile. Tile URL usually also needs {x} and {z}.</li>
	         *      <li>`{z}` - Zoom level of tile. Tile URL usually also needs {x} and {y}.</li>
	         *      <li>`{quadkey}` - Tile quadkey id based on the Bing Maps tile system naming convention.</li>
	         *      <li>`{bbox-epsg-3857}` - A bounding box string with the format "{west},{south},{east},{north}" with coordinates in the EPSG 3857 Spatial Reference System also commonly known as WGS84 Web Mercator. This is useful when working with WMS imagery services.</li>
	         *  <ul>
	         */
	        _this.tiles = undefined;
	        /**
	         * An integer value that specifies the width and height dimensions of the map tiles.
	         * For a seamless experience, the tile size must by a multiplier of 2. (i.e. 256, 512, 1024…).
	         * default `512`
	         * @default 512
	         */
	        _this.tileSize = 512;
	        /**
	         * A URL to a TileJSON resource.
	         * Supported protocols are `http:` and `https:`.
	         */
	        _this.url = undefined;
	        return _this;
	    }
	    return VectorTileSourceOptions;
	}(Options));

	/**
	 * A vector tile source describes how to access a vector tile layer.
	 * Vector tile sources can be used with; SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, HeatmapLayer and VectorTileLayer.
	 */
	var VectorTileSource = /** @class */ (function (_super) {
	    __extends(VectorTileSource, _super);
	    function VectorTileSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new VectorTileSourceOptions().merge(cloneDeep_1(options));
	        return _this;
	    }
	    /**
	     * Gets the options of the VectorTileSource.
	     */
	    VectorTileSource.prototype.getOptions = function () {
	        return cloneDeep_1(this.options);
	    };
	    /**
	     * Returns all GeoJSON features that are in the VectorTileSource and which satisfy the specified filter expression.
	     * @param sourceLayer Required if the source is a VectorTileSource. Specifies the layer within the VectorTileSource to query.
	     * @param filter A filter that will limit the query.
	     */
	    VectorTileSource.prototype.getShape = function (sourceLayer, filter) {
	        return this.map._getMap().querySourceFeatures(this.getId(), { sourceLayer: sourceLayer, filter: filter });
	    };
	    /**
	     * @internal
	     */
	    VectorTileSource.prototype._buildSource = function () {
	        var vectorSource = {
	            type: "vector",
	        };
	        if (this.options.bounds) {
	            vectorSource["bounds"] = this.options.bounds;
	        }
	        if (this.options.tiles) {
	            vectorSource["tiles"] = this.options.tiles;
	            vectorSource["minzoom"] = this.options.minZoom;
	            vectorSource["maxzoom"] = this.options.maxZoom;
	        }
	        else if (this.options.url) {
	            vectorSource["url"] = this.options.url;
	        }
	        if (this.options.isTMS) {
	            vectorSource["scheme"] = "tms";
	        }
	        if (this.options.tileSize) {
	            vectorSource["tileSize"] = this.options.tileSize;
	        }
	        return vectorSource;
	    };
	    return VectorTileSource;
	}(Source));



	var index$4 = /*#__PURE__*/Object.freeze({
		Source: Source,
		DataSource: DataSource,
		VectorTileSource: VectorTileSource
	});

	/**
	 * Abstract class for other layer classes to extend.
	 */
	var Layer = /** @class */ (function (_super) {
	    __extends(Layer, _super);
	    function Layer(id) {
	        var _this = 
	        // Assign an random id using a UUID if none was specified.
	        _super.call(this) || this;
	        _this.id = id || uuidRandom();
	        return _this;
	    }
	    /**
	     * Gets the id of the layer
	     */
	    Layer.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Gets the map that the layer is currently added to, or null.
	     */
	    Layer.prototype.getMap = function () {
	        return this.map || null;
	    };
	    /**
	     * Initialization method for the layer which is called when added to the map.
	     * @param map The map the layer has been added to.
	     */
	    Layer.prototype.onAdd = function (map) {
	        this.map = map;
	        this._invokeEvent("layeradded", this);
	        this.map.events.invoke("layeradded", this);
	    };
	    /**
	     * Method that is called when the layer is removed from the map.
	     * Should perform any necessary cleanup for the layer.
	     */
	    Layer.prototype.onRemove = function () {
	        var temp = this.map;
	        delete this.map;
	        this._invokeEvent("layerremoved", this);
	        if (temp) {
	            temp.events.invoke("layerremoved", this);
	        }
	    };
	    /**
	     * Returns if an event is one specified by Mapbox.
	     * False means we have defined that event.
	     * @internal
	     */
	    Layer._isMBoxEvent = function (eventType) {
	        return !this.LayerEvents.hasOwnProperty(eventType);
	    };
	    /**
	     * Updates the base layout and paint properties.
	     * Covers the follow properties: minZoom, maxZoom, filter, and visible.
	     * @param newOptions The new base layer options.
	     * @internal
	     */
	    Layer.prototype._updateBaseProperties = function (newOptions, oldOptions) {
	        this._updateFilter(newOptions.filter, oldOptions.filter);
	        this._updateZoomRange(newOptions.minZoom, oldOptions.minZoom, newOptions.maxZoom, oldOptions.maxZoom);
	        this._updateLayoutProperty("visibility", newOptions.visible, oldOptions.visible, newOptions.visible ? "visible" : "none");
	    };
	    /**
	     * Updates the filter for the layer in the maps its attached to.
	     * @param newFilter The new filter.
	     * @param oldFilter The old filter.
	     * Will be checked against newFilter to determine if an update is necessary.
	     * @param subFilter Optional filter to substitute for newFilter if updating is necessary.
	     * Useful when the option value doesn't exactly match the paint property.
	     * @internal
	     */
	    Layer.prototype._updateFilter = function (newFilter, oldFilter) {
	        if (!(isEqual_1(newFilter, oldFilter))) {
	            this.map._getMap().setFilter(this.id, newFilter);
	        }
	    };
	    Layer.prototype._updatePaintProperty = function (name, newValue, oldValue, subValue) {
	        // Only update if attached to a map and the values are changed.
	        if (!(isEqual_1(newValue, oldValue))) {
	            this.map._getMap().setPaintProperty(this.id, name, subValue || newValue);
	        }
	    };
	    Layer.prototype._updateLayoutProperty = function (name, newValue, oldValue, subValue) {
	        if (!(isEqual_1(newValue, oldValue))) {
	            this.map._getMap().setLayoutProperty(this.id, name, subValue || newValue);
	        }
	    };
	    /**
	     * Sets the zoom range for the layer in the attached map.
	     * @param minZoom The new minimum zoom value.
	     * @param maxZoom The new maximum zoom value.
	     * @internal
	     */
	    Layer.prototype._updateZoomRange = function (newMin, oldMin, newMax, oldMax) {
	        if ((newMin !== oldMin) || (oldMax !== newMax)) {
	            this.map._getMap().setLayerZoomRange(this.id, newMin, newMax);
	        }
	    };
	    // This object is accessible at runtime (unlike interfaces)
	    // and can be used to determine which events are ours vs Mapbox's.
	    Layer.LayerEvents = {
	        layeradded: undefined,
	        layerremoved: undefined
	    };
	    return Layer;
	}(EventEmitter));

	/**
	 * A base class which all other layer options inherit from.
	 */
	var LayerOptions = /** @class */ (function (_super) {
	    __extends(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * An expression specifying conditions on source features.
	         * Only features that match the filter are displayed.
	         */
	        _this.filter = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * This value is inclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * This value is exclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `24`.
	         * @default 24
	         */
	        _this.maxZoom = 24;
	        /**
	         * Specifies if the layer is visible or not.
	         * Default `true`.
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    LayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	    };
	    return LayerOptions;
	}(Options));

	/**
	 * Options used when rendering Point objects in a BubbleLayer.
	 */
	var BubbleLayerOptions = /** @class */ (function (_super) {
	    __extends(BubbleLayerOptions, _super);
	    function BubbleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the circle symbol with.
	         * Default `"#1A73AA"`.
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * The amount to blur the circles.
	         * A value of 1 blurs the circles such that only the center point if at full opacity.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The color of the circles' outlines.
	         * Default `"#FFFFFF"`.
	         * @default "#FFFFFF"
	         */
	        _this.strokeColor = "#FFFFFF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles' outlines will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The width of the circles' outlines in pixels.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        /**
	         * Specifies the orientation of circle when map is pitched.
	         * <p>`"map"`: The circle is aligned to the plane of the map.</p>
	         * <p>`"viewport"`: The circle is aligned to the plane of the viewport.</p>
	         * Default: `"viewport"`
	         * @default "viewport"
	         */
	        _this.pitchAlignment = "viewport";
	        /**
	         * The radius of the circle symbols in pixels.
	         * Must be greater than or equal to 0.
	         * Default `8`.
	         * @default 8
	         */
	        _this.radius = 8;
	        return _this;
	    }
	    return BubbleLayerOptions;
	}(LayerOptions));

	/**
	 * Renders Point objects as scalable circles (bubbles).
	 */
	var BubbleLayer = /** @class */ (function (_super) {
	    __extends(BubbleLayer, _super);
	    /**
	     * Constructs a new BubbleLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the bubble layer.
	     */
	    function BubbleLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new BubbleLayerOptions().merge(cloneDeepWith_1(options, BubbleLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the bubble layer.
	     */
	    BubbleLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, BubbleLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    BubbleLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the bubble layer.
	     * @param newOptions The new options of the bubble layer.
	     */
	    BubbleLayer.prototype.setOptions = function (options) {
	        var newOptions = new BubbleLayerOptions().merge(this.options, cloneDeepWith_1(options, BubbleLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("circle-blur", newOptions.blur, this.options.blur);
	            this._updatePaintProperty("circle-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("circle-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("circle-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("circle-stroke-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("circle-stroke-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("circle-stroke-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("circle-pitch-alignment", newOptions.pitchAlignment, this.options.pitchAlignment);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "circle",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "circle-color": this.options.color,
	                "circle-blur": this.options.blur,
	                "circle-opacity": this.options.opacity,
	                "circle-stroke-color": this.options.strokeColor,
	                "circle-stroke-opacity": this.options.strokeOpacity,
	                "circle-stroke-width": this.options.strokeWidth,
	                "circle-pitch-alignment": this.options.pitchAlignment,
	                "circle-radius": this.options.radius
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return BubbleLayer;
	}(Layer));

	/**
	 * Options used when rendering Point objects in a HeatMapLayer.
	 */
	var HeatMapLayerOptions = /** @class */ (function (_super) {
	    __extends(HeatMapLayerOptions, _super);
	    function HeatMapLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies the color gradient used to colorize the pixels in the heatmap.
	         * This is defined using an expression that uses `["heatmap-density"]` as input.
	         * Default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         * @default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         */
	        _this.color = ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0,0, 255,0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"];
	        /**
	         * Similar to `heatmap-weight` but specifies the global heatmap intensity.
	         * The higher this value is, the more ‘weight’ each point will contribute to the appearance.
	         * Default `1`
	         * @default 1
	         */
	        _this.intensity = 1;
	        /**
	         * The opacity at which the heatmap layer will be rendered defined as a number between 0 and 1.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The radius in pixels used to render a data point on the heatmap.
	         * The radius must be a number greater or equal to 1.
	         * Default `30`.
	         * @default 30
	         */
	        _this.radius = 30;
	        /**
	         * Specifies how much an individual data point contributes to the heatmap.
	         * Must be a number greater than 0. A value of 5 would be equivalent to having 5 points of weight 1 in the same spot.
	         * This is useful when clustering points to allow heatmap rendering or large datasets.
	         * Default `1`
	         * @default 1
	         */
	        _this.weight = 1;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HeatMapLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	    };
	    return HeatMapLayerOptions;
	}(LayerOptions));

	/**
	 * Represent the density of data using different colors (HeatMap).
	 */
	var HeatMapLayer = /** @class */ (function (_super) {
	    __extends(HeatMapLayer, _super);
	    /**
	     * Constructs a new HeatMapLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the heat map layer.
	     */
	    function HeatMapLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new HeatMapLayerOptions().merge(cloneDeepWith_1(options, HeatMapLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the heat map layer.
	     */
	    HeatMapLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, HeatMapLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    HeatMapLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the heat map layer.
	     * @param newOptions The new options of the heat map layer.
	     */
	    HeatMapLayer.prototype.setOptions = function (options) {
	        var newOptions = new HeatMapLayerOptions().merge(this.options, cloneDeepWith_1(options, HeatMapLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("heatmap-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("heatmap-intensity", newOptions.intensity, this.options.intensity);
	            this._updatePaintProperty("heatmap-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("heatmap-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("heatmap-weight", newOptions.weight, this.options.weight);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "heatmap",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "heatmap-color": this.options.color,
	                "heatmap-intensity": this.options.intensity,
	                "heatmap-opacity": this.options.opacity,
	                "heatmap-radius": this.options.radius,
	                "heatmap-weight": this.options.weight,
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return HeatMapLayer;
	}(Layer));

	/**
	 * Options used when rendering canvas, image, raster tile, and video layers
	 */
	var MediaLayerOptions = /** @class */ (function (_super) {
	    __extends(MediaLayerOptions, _super);
	    function MediaLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A number between -1 and 1 that increases or decreases the contrast of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.contrast = 0;
	        /**
	         * The duration in milliseconds of a fade transition when a new tile is added.
	         * Must be greater or equal to 0.
	         * Default `300`.
	         * @default 300
	         */
	        _this.fadeDuration = 300;
	        /**
	         * Rotates hues around the color wheel.
	         * A number in degrees.
	         * Default `0`.
	         * @default 0
	         */
	        _this.hueRotation = 0;
	        /**
	         * A number between 0 and 1 that increases or decreases the maximum brightness of the overlay.
	         * Default `1`.
	         * @default 1
	         */
	        _this.maxBrightness = 1;
	        /**
	         * A number between 0 and 1 that increases or decreases the minimum brightness of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minBrightness = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the overlay will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * A number between -1 and 1 that increases or decreases the saturation of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.saturation = 0;
	        return _this;
	    }
	    return MediaLayerOptions;
	}(LayerOptions));

	/**
	 * Options used when rendering Point objects in a ImageLayer.
	 */
	var ImageLayerOptions = /** @class */ (function (_super) {
	    __extends(ImageLayerOptions, _super);
	    function ImageLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * URL to an image to overlay. Images hosted on other domains must have CORs enabled.
	         */
	        _this.url = undefined;
	        /**
	         * An array of positions for the corners of the image listed in clockwise order: [top left, top right, bottom right, bottom left].
	         */
	        _this.coordinates = undefined;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ImageLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	    };
	    return ImageLayerOptions;
	}(MediaLayerOptions));

	/**
	 * Abstract class for other layer classes which have to build sources.
	 * @internal
	 */
	var SourceBuildingLayer = /** @class */ (function (_super) {
	    __extends(SourceBuildingLayer, _super);
	    function SourceBuildingLayer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @internal
	     */
	    SourceBuildingLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        ids.add(this._getSourceId());
	        return ids;
	    };
	    return SourceBuildingLayer;
	}(Layer));

	/**
	 * Overlays an image on the map with each corner anchored to a coordinate on the map. Also known as a ground or image overlay.
	 */
	var ImageLayer = /** @class */ (function (_super) {
	    __extends(ImageLayer, _super);
	    /**
	     * Constructs a new ImageLayer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the image layer.
	     */
	    function ImageLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        _this.isLoading = false;
	        _this.options = new ImageLayerOptions().merge(cloneDeepWith_1(options, ImageLayerOptions._cloneCustomizer));
	        _this.img = new Image();
	        _this.reloadImage();
	        return _this;
	    }
	    /**
	     * Gets the options of the image layer.
	     */
	    ImageLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, ImageLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the image layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    ImageLayer.prototype.setOptions = function (options) {
	        var newOptions = new ImageLayerOptions().merge(this.options, cloneDeepWith_1(options, ImageLayerOptions._cloneCustomizer));
	        var reloadImageTransform = (typeof options.url === "string" && options.url !== this.getOptions().url);
	        var coordChanged = (typeof options.coordinates !== "undefined" && options.coordinates !== this.getOptions().coordinates);
	        if (this.map) {
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	            // TODO: the mapbox typing file doesn't support mapboxgl.ImageSource.updateImage()
	            // update "as any" to "as mapboxgl.ImageSource" after the typing file is updated
	            var source = this.map._getMap().getSource(this._getSourceId());
	            if (source) {
	                source.updateImage(newOptions);
	            }
	        }
	        this.options = newOptions;
	        // Modified to update transform if image url or coordinates change
	        if (reloadImageTransform) {
	            this.reloadImage();
	        }
	        else if (coordChanged) {
	            this.updateTransform();
	        }
	    };
	    /**
	     * Calculates the approximate positions that align with the provided pixels from the source image.
	     * @param pixels the provided pixels from the source image used to calculate the positions
	     */
	    ImageLayer.prototype.getPositions = function (pixels) {
	        return this.transform.then(function (t) {
	            return t.toTarget(pixels);
	        });
	    };
	    /**
	     * Calculates the approximate pixels on the source image that align with the provided positions.
	     * @param positions the provided positions from the source image used to calculate the pixels
	     */
	    ImageLayer.prototype.getPixels = function (positions) {
	        return this.transform.then(function (t) {
	            return t.toSource(positions);
	        });
	    };
	    /**
	     * Calculates the approximate corner coordinates for an image based on the image width, height and by calculating an affine transform from a set of source pixels in the image and a set of target positions that are related.
	     * The same number of source and target values must be provided as reference points. It is recommended to provide atleast 3 reference points.
	     * @param imgWidth image width
	     * @param imgHeight image height
	     * @param source a set of source pixels
	     * @param target target positions
	     */
	    ImageLayer.getCoordinatesFromRefPoints = function (imgWidth, imgHeight, source, target) {
	        var transform = new AffineTransform(source, target);
	        return transform.toTarget([
	            [0, 0],
	            [imgWidth, 0],
	            [imgWidth, imgHeight],
	            [0, imgHeight]
	        ]);
	    };
	    /**
	     * Calculates coordinates for a rotated image layer when provided with the bounding box edges and rotation value.
	     * Note: If your rotation value is from a KML Ground Overlay it will need to be converted to a clockwise rotation using the following formula: `rotation = 360 – KmlRotation`
	     * @param north The north edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param west The west edge of the bounding box.
	     * @param rotation Clockwise rotation in degrees
	     */
	    ImageLayer.getCoordinatesFromEdges = function (north, south, east, west, rotation) {
	        if (typeof rotation !== "number") {
	            rotation = 0;
	        }
	        // [minLon, minLat, maxLon, maxLat]
	        var bounds = [
	            Math.min(west, east),
	            south,
	            Math.max(west, east),
	            north
	        ];
	        // Calculate the center of the bounding box and use that as the rotation origin.
	        var origin = BoundingBox.getCenter(bounds);
	        // Calculate the corner coordinates of the bounding box.
	        var topLeft = BoundingBox.getNorthWest(bounds);
	        var topRight = BoundingBox.getNorthEast(bounds);
	        var bottomRight = BoundingBox.getSouthEast(bounds);
	        var bottomLeft = BoundingBox.getSouthWest(bounds);
	        // Calcuate to rotated corners of the bounding box.
	        return rotatePositions([
	            topLeft,
	            topRight,
	            bottomRight,
	            bottomLeft
	        ], origin, rotation);
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "raster",
	            source: this._getSourceId(),
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "raster-opacity": this.options.opacity,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-saturation": this.options.saturation,
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the imge source to include with the layer.
	     * @internal
	     */
	    ImageLayer.prototype._buildSource = function () {
	        return {
	            type: "image",
	            url: this.options.url,
	            coordinates: this.options.coordinates
	        };
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    ImageLayer.prototype._getSourceId = function () {
	        return this.getId() + "-ImageSource";
	    };
	    ImageLayer.prototype.reloadImage = function () {
	        var _this = this;
	        if (this.options.url) {
	            this.transform = new Promise(function (resolve, reject) {
	                _this.img.onload = function () {
	                    var corners = [[0, 0], [_this.img.width, 0], [_this.img.width, _this.img.height], [0, _this.img.height]];
	                    resolve(new AffineTransform(corners, _this.options.coordinates));
	                    _this.isLoading = false;
	                };
	                _this.img.onerror = _this.img.onabort = function () {
	                    reject("Failed to load image");
	                };
	                _this.isLoading = true;
	                _this.img.src = _this.options.url;
	            });
	        }
	    };
	    ImageLayer.prototype.updateTransform = function () {
	        if (!this.isLoading) {
	            var corners = [[0, 0], [this.img.width, 0], [this.img.width, this.img.height], [0, this.img.height]];
	            this.transform = Promise.resolve(new AffineTransform(corners, this.options.coordinates));
	        }
	    };
	    return ImageLayer;
	}(SourceBuildingLayer));

	/**
	 * Options used when rendering SimpleLine, SimplePolygon, CirclePolygon,
	 * LineString, MultiLineString, Polygon, and MultiPolygon objects in a line layer.
	 */
	var LineLayerOptions = /** @class */ (function (_super) {
	    __extends(LineLayerOptions, _super);
	    function LineLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies how the ends of the lines are rendered.
	         * <p>`"butt"`: A cap with a squared-off end which is drawn to the exact endpoint of the line.</p>
	         * <p>`"round"`: A cap with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.</p>
	         * <p>`"square"`: A cap with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the line width.</p>
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineCap = "round";
	        /**
	         * Specifies how the joints in the lines are rendered.
	         * <p>`"bevel"`: A join with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the lines width.</p>
	         * <p>`"round"`: A join with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.</p>
	         * <p>`"miter"`: A join with a sharp, angled corner which is drawn with the outer sides
	         * beyond the endpoint of the path until they meet.</p>
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineJoin = "round";
	        /**
	         * The amount of blur to apply to the line in pixels.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * Specifies the color of the line.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.strokeColor = "#1E90FF";
	        /**
	         * Specifies the lengths of the alternating dashes and gaps that form the dash pattern.
	         * Numbers must be equal or greater than 0. The lengths are scaled by the strokeWidth.
	         * To convert a dash length to pixels, multiply the length by the current stroke width.
	         */
	        _this.strokeDashArray = undefined;
	        /**
	         * Defines a gradient with which to color the lines.
	         * Requires the DataSource lineMetrics option to be set to true.
	         * Disabled if strokeDashArray is set.
	         */
	        _this.strokeGradient = undefined;
	        /**
	         * The line's offset.
	         * A positive value offsets the line to the right, relative to the direction of the line.
	         * A negative value offsets to the left.
	         * Default `0`.
	         * @default 0
	         */
	        _this.offset = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the line will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The amount of offset in pixels to render the line relative to where it would render normally.
	         * Negative values indicate left and up.
	         * Default: `[0,0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.
	         * <p>`"map"`: Lines are translated relative to the map.</p>
	         * <p>`"viewport"`: Lines are translated relative to the viewport</p>
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * The width of the line in pixels. Must be a value greater or equal to 0.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        return _this;
	    }
	    return LineLayerOptions;
	}(LayerOptions));

	/**
	 * Renders line data on the map. Can be used with SimpleLine, SimplePolygon,
	 * CirclePolygon, LineString, MultiLineString, Polygon, and MultiPolygon objects.
	 */
	var LineLayer = /** @class */ (function (_super) {
	    __extends(LineLayer, _super);
	    /**
	     * Constructs a new LineLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the line layer.
	     */
	    function LineLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new LineLayerOptions().merge(cloneDeepWith_1(options, LineLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the line layer.
	     */
	    LineLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, LineLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    LineLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the line layer.
	     * @param options The new options of the line layer.
	     */
	    LineLayer.prototype.setOptions = function (options) {
	        var newOptions = new LineLayerOptions().merge(this.options, cloneDeepWith_1(options, LineLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("line-blur", newOptions.blur, this.options.blur);
	            this._updateLayoutProperty("line-cap", newOptions.lineCap, this.options.lineCap);
	            this._updateLayoutProperty("line-join", newOptions.lineJoin, this.options.lineJoin);
	            this._updatePaintProperty("line-offset", newOptions.offset, this.options.offset);
	            this._updatePaintProperty("line-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("line-dasharray", newOptions.strokeDashArray, this.options.strokeDashArray);
	            this._updatePaintProperty("line-gradient", newOptions.strokeGradient, this.options.strokeGradient);
	            this._updatePaintProperty("line-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("line-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("line-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("line-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign(__assign(__assign({ id: this.id, type: "line" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	                "line-cap": this.options.lineCap,
	                "line-join": this.options.lineJoin
	            }, paint: __assign(__assign(__assign({ "line-blur": this.options.blur, "line-color": this.options.strokeColor }, (this.options.strokeDashArray && { "line-dasharray": this.options.strokeDashArray })), (this.options.strokeGradient && { "line-gradient": this.options.strokeGradient })), { "line-offset": this.options.offset, "line-opacity": this.options.strokeOpacity, "line-translate": this.options.translate, "line-translate-anchor": this.options.translateAnchor, "line-width": this.options.strokeWidth }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return LineLayer;
	}(Layer));

	/**
	 * Options used when rendering `Polygon` and `MultiPolygon` objects in a `PolygonExtrusionLayer`.
	 */
	var PolygonExtrusionLayerOptions = /** @class */ (function (_super) {
	    __extends(PolygonExtrusionLayerOptions, _super);
	    function PolygonExtrusionLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The height in meters to extrude the base of this layer.
	         * This height is relative to the ground.
	         * Must be greater or equal to 0 and less than or equal to `height`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.base = 0;
	        /**
	         * The color to fill the polygons with.
	         * Ignored if `fillPattern` is set.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * The height in meters to extrude this layer.
	         * This height is relative to the ground.
	         * Must be a number greater or equal to 0.
	         * Default `0`
	         * @default 0
	         */
	        _this.height = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.fillOpacity = 1;
	        /**
	         * Name of image in sprite to use for drawing image fills.
	         * For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        /**
	         * The polygons' pixel offset.
	         * Values are [x, y] where negatives indicate left and up, respectively.
	         * Default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.
	         * <p>`"map"`: Polygons are translated relative to the map.</p>
	         * <p>`"viewport"`: Polygons are translated relative to the viewport.</p>
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * Specifies if the polygon should have a vertical gradient on the sides of the extrusion.
	         * Default: `true`
	         * @default true
	         */
	        _this.verticalGradient = true;
	        return _this;
	    }
	    return PolygonExtrusionLayerOptions;
	}(LayerOptions));

	/**
	 * Renders extruded filled `Polygon` and `MultiPolygon` objects on the map.
	 */
	var PolygonExtrusionLayer = /** @class */ (function (_super) {
	    __extends(PolygonExtrusionLayer, _super);
	    /**
	     * Constructs a new PolygonExtrusionLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon extrusion layer.
	     */
	    function PolygonExtrusionLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonExtrusionLayerOptions().merge(cloneDeepWith_1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, PolygonExtrusionLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonExtrusionLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonExtrusionLayerOptions().merge(this.options, cloneDeepWith_1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-extrusion-base", newOptions.base, this.options.base);
	            this._updatePaintProperty("fill-extrusion-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-extrusion-height", newOptions.height, this.options.height);
	            this._updatePaintProperty("fill-extrusion-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-extrusion-pattern", newOptions.fillPattern, this.options.fillPattern);
	            this._updatePaintProperty("fill-extrusion-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("fill-extrusion-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	            this._updatePaintProperty("fill-extrusion-vertical-gradient", newOptions.verticalGradient, this.options.verticalGradient);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign(__assign(__assign({ id: this.id, type: "fill-extrusion" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	            }, paint: __assign(__assign({ "fill-extrusion-base": this.options.base, "fill-extrusion-height": this.options.height, "fill-extrusion-opacity": this.options.fillOpacity }, (this.options.fillPattern ?
	                { "fill-extrusion-pattern": this.options.fillPattern } :
	                { "fill-extrusion-color": this.options.fillColor })), { "fill-extrusion-translate": this.options.translate, "fill-extrusion-translate-anchor": this.options.translateAnchor, "fill-extrusion-vertical-gradient": this.options.verticalGradient }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonExtrusionLayer;
	}(Layer));

	/**
	 * Options used when rendering Polygon and MultiPolygon objects in a PolygonLayer.
	 */
	var PolygonLayerOptions = /** @class */ (function (_super) {
	    __extends(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the polygons with.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `0.5`.
	         * @default 0.5
	         */
	        _this.fillOpacity = 0.5;
	        /**
	         * Name of image in sprite to use for drawing image fills. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to set fillPattern and fillColor to be mutually exclusive
	     * @internal
	     */
	    PolygonLayerOptions.prototype.merge = function () {
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var isNewColorSet = false;
	        var isNewPatternSet = false;
	        for (var _a = 0, valueList_1 = valueList; _a < valueList_1.length; _a++) {
	            var value = valueList_1[_a];
	            if (value) {
	                if (value.hasOwnProperty("fillColor")) {
	                    isNewColorSet = true;
	                    isNewPatternSet = false;
	                }
	                else if (value.hasOwnProperty("fillPattern")) {
	                    isNewPatternSet = true;
	                    isNewColorSet = false;
	                }
	            }
	        }
	        // Then execute the standard merge behavior.
	        var merged = _super.prototype.merge.apply(this, valueList);
	        if (isNewColorSet) {
	            merged.fillPattern = undefined;
	        }
	        else if (isNewPatternSet) {
	            merged.fillColor = undefined;
	        }
	        return merged;
	    };
	    return PolygonLayerOptions;
	}(LayerOptions));

	/**
	 * Renders filled Polygon and MultiPolygon objects on the map.
	 */
	var PolygonLayer = /** @class */ (function (_super) {
	    __extends(PolygonLayer, _super);
	    /**
	     * Constructs a new PolygonLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function PolygonLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonLayerOptions().merge(cloneDeepWith_1(options, PolygonLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, PolygonLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonLayerOptions().merge(this.options, cloneDeepWith_1(options, PolygonLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-pattern", newOptions.fillPattern, this.options.fillPattern);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "fill",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "fill-opacity": this.options.fillOpacity
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        // The property fill-pattern should only be set if there is a value for fillPattern.
	        // The property fill-color should only be set if fill-pattern isn't.
	        if (this.options.fillPattern) {
	            layer.paint["fill-pattern"] = this.options.fillPattern;
	        }
	        else {
	            layer.paint["fill-color"] = this.options.fillColor;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonLayer;
	}(Layer));

	/**
	 * Options used to customize the icons in a SymbolLayer
	 */
	var IconOptions = /** @class */ (function (_super) {
	    __extends(IconOptions, _super);
	    function IconOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the symbol icon can overlay other symbols on the map.
	         * If `true` the icon will be visible even if it collides with other previously drawn symbols.
	         * Tip: Set this to true if animating an symbol to ensure smooth rendering.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.
	         * <p>`"center"`: The center of the icon is placed closest to the anchor.</p>
	         * <p>`"left"`: The left side of the icon is placed closest to the anchor.</p>
	         * <p>`"right"`: The right side of the icon is placed closest to the anchor.</p>
	         * <p>`"top"`: The top of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom"`: The bottom of the icon is placed closest to the anchor.</p>
	         * <p>`"top-left"`: The top left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"top-right"`: The top right corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.</p>
	         * Default `"bottom"`.
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * Specifies if other symbols can overlap this symbol.
	         * If true, other symbols can be visible even if they collide with the icon.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * The name of the image in the map's image sprite to use for drawing the icon.
	         * Available built-in images are: `marker-black`, `marker-blue`, `marker-darkblue`,
	         * `marker-red`, `marker-yellow`, `pin-blue`, `pin-darkblue`, `pin-red`, `pin-round-blue`,
	         * `pin-round-darkblue`, `pin-round-red`.
	         * Default `"marker-blue"`.
	         * @default "marker-blue"
	         */
	        _this.image = "marker-blue";
	        /**
	         * Specifies an offset distance of the icon from its anchor in pixels.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Each component is multiplied by the value of size to obtain the final offset in pixels.
	         * When combined with rotation the offset will be as if the rotated direction was up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if a symbols icon can be hidden but its text displayed if it is overlapped with another symbol.
	         * If true, text will display without their corresponding icons
	         * when the icon collides with other symbols and the text does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Specifies the orientation of the icon when the map is pitched.
	         * <p>`"auto"`: Automatically matches the value of `rotationAlignment`.</p>
	         * <p>`"map"`: The icon is aligned to the plane of the map.</p>
	         * <p>`"viewport"`: The icon is aligned to the plane of the viewport</p>
	         * Default `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * The amount to rotate the icon clockwise in degrees
	         * Default `0`.
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the placement property of a SymbolLayerOptions
	         * this determines the rotation behavior of icons.
	         * <p>`"auto"`: When placement is "point" this is equivalent to "viewport".
	         * When placement is "line" this is equivalent to "map".</p>
	         * <p>`"map"`: When placement is "point" aligns icons east-west.
	         * When placement is "line" aligns the icons' x-axes with the line.</p>
	         * <p>`"viewport"`: Icons' x-axes will align with the x-axis of the viewport.</p>
	         * Default `"auto"`.
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * Scales the original size of the icon by the provided factor.
	         * Must be greater or equal to 0.
	         * Default `1`.
	         * @default 1
	         */
	        _this.size = 1;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the icon will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return IconOptions;
	}(Options));

	/**
	 * Options used to customize the text in a SymbolLayer
	 */
	var TextOptions = /** @class */ (function (_super) {
	    __extends(TextOptions, _super);
	    function TextOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the text will be visible if it collides with other symbols.
	         * If true, the text will be visible even if it collides with other previously drawn symbols.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.
	         * <p>`"center"`: The center of the icon is placed closest to the anchor.</p>
	         * <p>`"left"`: The left side of the icon is placed closest to the anchor.</p>
	         * <p>`"right"`: The right side of the icon is placed closest to the anchor.</p>
	         * <p>`"top"`: The top of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom"`: The bottom of the icon is placed closest to the anchor.</p>
	         * <p>`"top-left"`: The top left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"top-right"`: The top right corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.</p>
	         * <p>`"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.</p>
	         * Default `"center"`.
	         * @default "center"
	         */
	        _this.anchor = "center";
	        /**
	         * Specifies the name of a property on the features to use for a text label.
	         */
	        _this.textField = undefined;
	        /**
	         * The font stack to use for displaying text.
	         * Possible values: `"SegoeFrutigerHelveticaMYingHei-Bold"`, `"SegoeFrutigerHelveticaMYingHei-Medium"`,
	         * `"SegoeFrutigerHelveticaMYingHei-Regular"`, `"SegoeUi-Bold"`, `"SegoeUi-Light"`, `"SegoeUi-Regular"`,
	         * `"SegoeUi-SemiBold"`, `"SegoeUi-SemiLight"`, `"SegoeUi-SymbolRegular"`, `"StandardCondensedSegoeUi-Black"`,
	         * `"StandardCondensedSegoeUi-Bold"`, `"StandardCondensedSegoeUi-Light"`, `"StandardCondensedSegoeUi-Regular"`,
	         * `"StandardFont-Black"`, `"StandardFont-Bold"`, `"StandardFont-Light"`, `"StandardFont-Regular"`,
	         * `"StandardFontCondensed-Black"`, `"StandardFontCondensed-Bold"`, `"StandardFontCondensed-Light"`,
	         * `"StandardFontCondensed-Regular"`.
	         * Default `["StandardFont-Regular"]`.
	         * @default ["StandardFont-Regular"]
	         */
	        _this.font = ["StandardFont-Regular"];
	        /**
	         * Specifies if the other symbols are allowed to collide with the text.
	         * If true, other symbols can be visible even if they collide with the text.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * Specifies an offset distance of the icon from its anchor in ems.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if the text can be hidden if it is overlapped by another symbol.
	         * If true, icons will display without their corresponding text
	         * when the text collides wit other symbols and the icon does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Specifies the orientation of the text when the map is pitched.
	         * <p>`"auto"`: Automatically matches the value of `rotationAlignment`.</p>
	         * <p>`"map"`: The text is aligned to the plane of the map.</p>
	         * <p>`"viewport"`: The text is aligned to the plane of the viewport.</p>
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * The amount to rotate the text clockwise in degrees.
	         * Default `0`
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the `placement` property of the `SymbolLayerOptions`,
	         * specifies the rotation behavior of the individual glyphs forming the text.
	         * <p>`"auto"`: When the `placement` is set to `"point"`, this is equivalent to `"map"`.
	         * When the `placement` is set to `"line"` this is equivalent to `"map"`.</p>
	         * <p>`"map"`: When the `placement` is set to `"point"`, aligns text east-west.
	         * When the `placement` is set to `"line"`, aligns text x-axes with the line.</p>
	         * <p>`"viewport"`: Produces glyphs whose x-axes are aligned with the x-axis of the viewport,
	         * regardless of the value of `placement`.</p>
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * The size of the font in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `16`.
	         * @default 16
	         */
	        _this.size = 16;
	        /**
	         * The color of the text.
	         * Default `"#000000"`.
	         * @default "#000000"
	         */
	        _this.color = "#000000";
	        /**
	         * The halo's fadeout distance towards the outside in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloBlur = 0;
	        /**
	         * The color of the text's halo, which helps it stand out from backgrounds.
	         * Default `"rgba(0,0,0,0)"`.
	         * @default "rgba(0,0,0,0)"
	         */
	        _this.haloColor = "rgba(0,0,0,0)";
	        /**
	         * The distance of the halo to the font outline in pixels.
	         * Must be a number greater or equal to 0.
	         * The maximum text halo width is 1/4 of the font size.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloWidth = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the text will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return TextOptions;
	}(Options));

	/**
	 * Options used when rendering geometries in a SymbolLayer.
	 */
	var SymbolLayerOptions = /** @class */ (function (_super) {
	    __extends(SymbolLayerOptions, _super);
	    function SymbolLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Options used to customize the icons of the symbols.
	         * @see IconOptions for defaults.
	         */
	        _this.iconOptions = new IconOptions();
	        /**
	         * Options used to customize the text of the symbols.
	         * @see TextOptions for defaults.
	         */
	        _this.textOptions = new TextOptions();
	        /**
	         * Specifies the label placement relative to its geometry.
	         * <p>`"point"`: The label is placed at the point where the geometry is located.</p>
	         * <p>`"line"`: The label is placed along the line of the geometry.
	         * Can only be used on LineString and Polygon geometries.</p>
	         * <p> `"line-center"`: The label is placed at the center of the line of the geometry.
	         * Can only be used on `LineString` and `Polygon` geometries </p>
	         * Default `"point"`.
	         * @default "point"
	         */
	        _this.placement = "point";
	        /**
	         * Distance in pixels between two symbol anchors along a line. Must be greater or equal to 1.
	         * Default `250`.
	         * @default 250
	         */
	        _this.lineSpacing = 250;
	        return _this;
	    }
	    return SymbolLayerOptions;
	}(LayerOptions));

	/**
	 * Renders point based data as symbols on the map using text and/or icons.
	 * Symbols can also be created for line and polygon data as well.
	 */
	var SymbolLayer = /** @class */ (function (_super) {
	    __extends(SymbolLayer, _super);
	    /**
	     * Constructs a new SymbolLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function SymbolLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new SymbolLayerOptions().merge(cloneDeepWith_1(options, SymbolLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the symbol layer.
	     */
	    SymbolLayer.prototype.getOptions = function () {
	        return cloneDeepWith_1(this.options, SymbolLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    SymbolLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the symbol layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    SymbolLayer.prototype.setOptions = function (options) {
	        var newOptions = new SymbolLayerOptions().merge(this.options, cloneDeepWith_1(options, SymbolLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            // Symbol options.
	            this._updateBaseProperties(newOptions, this.options);
	            this._updateLayoutProperty("symbol-spacing", newOptions.lineSpacing, this.options.lineSpacing);
	            this._updateLayoutProperty("symbol-placement", newOptions.placement, this.options.placement);
	            // Icon options.
	            this._updateLayoutProperty("icon-allow-overlap", newOptions.iconOptions.allowOverlap, this.options.iconOptions.allowOverlap);
	            this._updateLayoutProperty("icon-anchor", newOptions.iconOptions.anchor, this.options.iconOptions.anchor);
	            this._updateLayoutProperty("icon-ignore-placement", newOptions.iconOptions.ignorePlacement, this.options.iconOptions.ignorePlacement);
	            this._updateLayoutProperty("icon-image", newOptions.iconOptions.image, this.options.iconOptions.image);
	            this._updateLayoutProperty("icon-offset", newOptions.iconOptions.offset, this.options.iconOptions.offset);
	            this._updatePaintProperty("icon-opacity", newOptions.iconOptions.opacity, this.options.iconOptions.opacity);
	            this._updateLayoutProperty("icon-optional", newOptions.iconOptions.optional, this.options.iconOptions.optional);
	            this._updateLayoutProperty("icon-pitch-alignment", newOptions.iconOptions.pitchAlignment, this.options.iconOptions.pitchAlignment);
	            this._updateLayoutProperty("icon-rotate", newOptions.iconOptions.rotation, this.options.iconOptions.rotation);
	            this._updateLayoutProperty("icon-rotation-alignment", newOptions.iconOptions.rotationAlignment, this.options.iconOptions.rotationAlignment);
	            this._updateLayoutProperty("icon-size", newOptions.iconOptions.size, this.options.iconOptions.size);
	            // Text options.
	            this._updateLayoutProperty("text-allow-overlap", newOptions.textOptions.allowOverlap, this.options.textOptions.allowOverlap);
	            this._updateLayoutProperty("text-anchor", newOptions.textOptions.anchor, this.options.textOptions.anchor);
	            this._updatePaintProperty("text-color", newOptions.textOptions.color, this.options.textOptions.color);
	            this._updateLayoutProperty("text-font", newOptions.textOptions.font, this.options.textOptions.font);
	            this._updateLayoutProperty("text-ignore-placement", newOptions.textOptions.ignorePlacement, this.options.textOptions.ignorePlacement);
	            this._updatePaintProperty("text-halo-blur", newOptions.textOptions.haloBlur, this.options.textOptions.haloBlur);
	            this._updatePaintProperty("text-halo-color", newOptions.textOptions.haloColor, this.options.textOptions.haloColor);
	            this._updatePaintProperty("text-halo-width", newOptions.textOptions.haloWidth, this.options.textOptions.haloWidth);
	            this._updateLayoutProperty("text-offset", newOptions.textOptions.offset, this.options.textOptions.offset);
	            this._updatePaintProperty("text-opacity", newOptions.textOptions.opacity, this.options.textOptions.opacity);
	            this._updateLayoutProperty("text-optional", newOptions.textOptions.optional, this.options.textOptions.optional);
	            this._updateLayoutProperty("text-pitch-alignment", newOptions.textOptions.pitchAlignment, this.options.textOptions.pitchAlignment);
	            this._updateLayoutProperty("text-rotate", newOptions.textOptions.rotation, this.options.textOptions.rotation);
	            this._updateLayoutProperty("text-rotation-alignment", newOptions.textOptions.rotationAlignment, this.options.textOptions.rotationAlignment);
	            this._updateLayoutProperty("text-size", newOptions.textOptions.size, this.options.textOptions.size);
	            this._updateLayoutProperty("text-field", newOptions.textOptions.textField, this.options.textOptions.textField);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign(__assign(__assign({ id: this.id, type: "symbol" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: __assign(__assign({ visibility: this.options.visible ? "visible" : "none", "symbol-placement": this.options.placement, "symbol-spacing": this.options.lineSpacing, 
	                // Text options.
	                "text-allow-overlap": this.options.textOptions.allowOverlap, "text-anchor": this.options.textOptions.anchor }, (this.options.textOptions.textField && { "text-field": this.options.textOptions.textField })), { "text-font": this.options.textOptions.font, "text-ignore-placement": this.options.textOptions.ignorePlacement, "text-offset": this.options.textOptions.offset, "text-optional": this.options.textOptions.optional, "text-pitch-alignment": this.options.textOptions.pitchAlignment, "text-rotate": this.options.textOptions.rotation, "text-rotation-alignment": this.options.textOptions.rotationAlignment, "text-size": this.options.textOptions.size, 
	                // Icon options.
	                "icon-allow-overlap": this.options.iconOptions.allowOverlap, "icon-anchor": this.options.iconOptions.anchor, "icon-ignore-placement": this.options.iconOptions.ignorePlacement, "icon-image": this.options.iconOptions.image, "icon-offset": this.options.iconOptions.offset, "icon-optional": this.options.iconOptions.optional, "icon-pitch-alignment": this.options.iconOptions.pitchAlignment, "icon-rotate": this.options.iconOptions.rotation, "icon-rotation-alignment": this.options.iconOptions.rotationAlignment, "icon-size": this.options.iconOptions.size }), paint: {
	                // Text options.
	                "text-color": this.options.textOptions.color,
	                "text-halo-blur": this.options.textOptions.haloBlur,
	                "text-halo-color": this.options.textOptions.haloColor,
	                "text-halo-width": this.options.textOptions.haloWidth,
	                "text-opacity": this.options.textOptions.opacity,
	                // Icon options.
	                "icon-opacity": this.options.iconOptions.opacity,
	            } }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return SymbolLayer;
	}(Layer));

	/**
	 * Options used when rendering raster tiled images in a TileLayer.
	 */
	var TileLayerOptions = /** @class */ (function (_super) {
	    __extends(TileLayerOptions, _super);
	    function TileLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         * Default `[-180, -85.0511, 180, 85.0511]`.
	         * @default [-180, -85.0511, 180, 85.0511]
	         */
	        _this.bounds = [-180, -85.0511, 180, 85.0511];
	        /**
	         * An integer specifying the minimum zoom level in which tiles are available from the tile source.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minSourceZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level in which tiles are available from the tile source.
	         * Default `22`.
	         * @default 22
	         */
	        _this.maxSourceZoom = 22;
	        /**
	         * An integer value that specifies the width and height dimensions of the map tiles.
	         * For a seamless experience, the tile size must be a multiplier of 2.
	         * Default `512`.
	         * @default 512
	         */
	        _this.tileSize = 512;
	        /**
	         * Specifies if the tile systems coordinates uses the Tile Map Services specification,
	         * which reverses the Y coordinate axis.
	         * Default `false`.
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of subdomain values to apply to the tile URL.
	         */
	        _this.subdomains = undefined;
	        /**
	         * A http/https URL to a TileJSON resource or a tile URL template that uses the following parameters:
	         * <p>{x}: X position of the tile. Usually also needs {y} and {z}.</p>
	         * <p>{y}: Y position of the tile. Usually also needs {x} and {z}.</p>
	         * <p>{z}: Zoom level of the tile. Usually also needs {x} and {y}.</p>
	         * <p>{quadkey}: Tile quadKey id based on the Bing Maps tile system naming convention.</p>
	         * <p>{bbox-epsg-3857}: A bounding box string with the format {west},{south},{east},{north}
	         * in the EPSG 4325 Spacial Reference System.</p>
	         * <p>{subdomain}: A placeholder where the subdomain values if specified will be added.</p>
	         */
	        _this.tileUrl = undefined;
	        return _this;
	    }
	    return TileLayerOptions;
	}(MediaLayerOptions));

	/**
	 * Renders raster tiled images on top of the map tiles.
	 */
	var TileLayer = /** @class */ (function (_super) {
	    __extends(TileLayer, _super);
	    /**
	     * Constructs a new TileLayer.
	     * @param options The options for the tile layer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     */
	    function TileLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        if (options) {
	            _this.setOptions(options);
	        }
	        return _this;
	    }
	    /**
	     * Gets the options of the tile layer.
	     */
	    TileLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, TileLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the tile layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    TileLayer.prototype.setOptions = function (options) {
	        var newOptions = new TileLayerOptions().merge(this.options, cloneDeepWith_1(options, TileLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the bounds, isTMS, max/minSourceZoom, subdomains, tileSize, or tileUrl
	            // options are changed the layer must be re-added to the map entirely.
	            if (!(isEqual_1(newOptions.bounds, this.options.bounds)) ||
	                newOptions.isTMS !== this.options.isTMS ||
	                newOptions.maxSourceZoom !== this.options.maxSourceZoom ||
	                newOptions.minSourceZoom !== this.options.minSourceZoom ||
	                !(isEqual_1(newOptions.subdomains, this.options.subdomains)) ||
	                newOptions.tileSize !== this.options.tileSize ||
	                newOptions.tileUrl !== this.options.tileUrl) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._setOptionsNoUpdate = function (options) {
	        this.options = new TileLayerOptions().merge(this.options, cloneDeepWith_1(options, TileLayerOptions._cloneCustomizer));
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._buildLayers = function () {
	        var layer = __assign(__assign({ id: this.id, type: "raster", source: this._getSourceId(), layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            }, paint: {
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-opacity": this.options.opacity,
	                "raster-saturation": this.options.saturation
	            } }, (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the raster source to include with the layer.
	     * @internal
	     */
	    TileLayer.prototype._buildSource = function () {
	        var tiles;
	        if (this.options.tileUrl) {
	            // If the tileUrl include { assume it is a formatted string and use tiles property.
	            if (this.options.tileUrl.indexOf("{") !== -1) {
	                // If the tileUrl include the subdomain placeholder
	                // we must manually assign an array of urls to the tiles property
	                // because mapbox does not support the subdomain placeholder.
	                if (this.options.tileUrl.indexOf("{subdomain}") !== -1) {
	                    // Throw an error if no subdomains were specified
	                    if (this.options.subdomains && this.options.subdomains.length > 0) {
	                        var urls = [];
	                        for (var _i = 0, _a = this.options.subdomains; _i < _a.length; _i++) {
	                            var subdomain = _a[_i];
	                            urls.push(this.options.tileUrl.replace(/{subdomain}/g, subdomain));
	                        }
	                        tiles = urls;
	                    }
	                    else {
	                        throw new Error("The {subdomain} placeholder was included in the tileUrl but no subdomains were specified");
	                    }
	                }
	                else {
	                    // Else just provide a single url.
	                    tiles = [this.options.tileUrl];
	                }
	            }
	            else {
	                // Else assume it is just a TileJSON url and use the url property.
	                // For a TileJSON url only the url needs to be specified.
	                return {
	                    type: "raster",
	                    url: this.options.tileUrl
	                };
	            }
	        }
	        return __assign({ type: "raster", bounds: this.options.bounds, maxzoom: this.options.maxSourceZoom, minzoom: this.options.minSourceZoom, scheme: this.options.isTMS ? "tms" : "xyz", tileSize: this.options.tileSize }, (tiles && { tiles: tiles }));
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    TileLayer.prototype._getSourceId = function () {
	        return this.getId() + "-RasterSource";
	    };
	    return TileLayer;
	}(SourceBuildingLayer));



	var index$5 = /*#__PURE__*/Object.freeze({
		BubbleLayer: BubbleLayer,
		Layer: Layer,
		LineLayer: LineLayer,
		PolygonExtrusionLayer: PolygonExtrusionLayer,
		PolygonLayer: PolygonLayer,
		SymbolLayer: SymbolLayer,
		TileLayer: TileLayer,
		HeatMapLayer: HeatMapLayer,
		ImageLayer: ImageLayer
	});

	var Html = /** @class */ (function () {
	    function Html() {
	    }
	    /**
	     * Converts the specified content into a div element.
	     * @param content A string to make the innerHTML of the div element.
	     * If a HTMLElement is provided it is returned unmodified.
	     */
	    Html.convertHtmlString = function (content) {
	        if (typeof content === "string") {
	            var htmlEle = document.createElement("div");
	            htmlEle.innerHTML = content;
	            return htmlEle;
	        }
	        else {
	            return content;
	        }
	    };
	    return Html;
	}());

	/** `Object#toString` result references. */
	var objectTag$4 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype,
	    objectProto$f = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$f.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString$2.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$4) {
	    return false;
	  }
	  var proto = _getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$c.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString$2.call(Ctor) == objectCtorString;
	}

	var isPlainObject_1 = isPlainObject;

	/**
	 * Checks if `value` is likely a DOM element.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	 * @example
	 *
	 * _.isElement(document.body);
	 * // => true
	 *
	 * _.isElement('<body>');
	 * // => false
	 */
	function isElement(value) {
	  return isObjectLike_1(value) && value.nodeType === 1 && !isPlainObject_1(value);
	}

	var isElement_1 = isElement;

	/**
	 * The options for a popup.
	 */
	var PopupOptions = /** @class */ (function (_super) {
	    __extends(PopupOptions, _super);
	    function PopupOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the popup's location relative to its position on the map.
	         * Optional values: `"none"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * default `"none"`
	         * @default "none"
	         */
	        _this.anchor = "none";
	        /**
	         * Specifies if the popup can be dragged away from its position.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * Specifies if the close button should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.closeButton = true;
	        /**
	         * The content to display within the popup.
	         * default `span`
	         * @default span
	         */
	        _this.content = document.createElement("span");
	        /**
	         * Specifies the fill color of the popup.
	         * default `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.fillColor = "#FFFFFF";
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the anchor of the popup should be
	         * offset. Negative numbers can be used to offset the popup left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position on the map where the popup should be anchored.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * Specifies if the pointer should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.showPointer = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    PopupOptions._cloneCustomizer = function (value) {
	        if (isElement_1(value)) {
	            return value;
	        }
	    };
	    return PopupOptions;
	}(Options));

	/**
	 * An information window anchored at a specified position on a map.
	 */
	var Popup = /** @class */ (function (_super) {
	    __extends(Popup, _super);
	    /**
	     * Constructs a Popup object and initializes it with the specified options.
	     * @param options The options for the popup.
	     */
	    function Popup(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Attaches the popup to the HTML document in a hidden state.
	         * @param map The map.
	         */
	        _this.attach = function (map) {
	            // If attaching to a different map, remove popup on current map
	            if (_this.map !== map) {
	                // If map was defined the popup was attached to another map.
	                if (_this.map) {
	                    _this.remove();
	                }
	                // Create the marker before attaching the popup and it to the map.
	                _this.map = map;
	                _this.marker = _this._createMarker(_this.options);
	                // Attach the wrapped mapbox marker to the map.
	                // When the marker is attached to the map it will attach the containerHtml to a default container.
	                // Move the containerHtml to the popup collection container after attaching the marker.
	                _this.marker.addTo(_this.map._getMap());
	                _this.map.popups._getCollectionDiv().appendChild(_this.containerDiv);
	                _this.map.popups.add(_this);
	            }
	        };
	        /**
	         * Opens the popup.
	         * @param map The map to open the popup on.
	         * Optional if already attached to a map.
	         */
	        _this.open = function (map) {
	            if (!map && !_this.map) {
	                throw new Error("Must specify a map to open on or attach to a map in advance");
	            }
	            _this.attach(map || _this.map);
	            _this.containerDiv.classList.remove(Popup.Css.hidden);
	            _this.map.events.add("move", _this._onMove);
	            _this._onMove();
	            _this._invokeEvent("open", { target: _this, type: "open" });
	        };
	        /**
	         * Closes the popup on the map. The popup remains attached to the HTML document.
	         */
	        _this.close = function () {
	            if (_this.map) {
	                _this.map.events.remove("move", _this._onMove);
	            }
	            _this.containerDiv.classList.add(Popup.Css.hidden);
	            _this._invokeEvent("close", { target: _this, type: "close" });
	        };
	        /**
	         * Closes the popup on the map and removes it from the HTML document.
	         */
	        _this.remove = function () {
	            if (_this.map) {
	                _this.marker.remove();
	                _this.containerDiv.classList.remove(_this.autoAnchor || _this.options.anchor);
	                _this.map.events.remove("move", _this._onMove);
	                _this.map.popups.remove(_this);
	                delete _this.map;
	                delete _this.marker;
	                delete _this.autoAnchor;
	            }
	        };
	        /**
	         * Returns true if the popup is currently open, otherwise false.
	         */
	        _this.isOpen = function () {
	            return _this.map && !_this.containerDiv.classList.contains(Popup.Css.hidden);
	        };
	        /**
	         * Callback for the move listener used for auto anchoring.
	         */
	        _this._onMove = function () {
	            var newAutoAnchor = _this._getAutoAnchor(_this.map, _this.options);
	            if (newAutoAnchor !== _this.autoAnchor) {
	                // When we replace the marker it adds a new move listeners.
	                // We want our listener to fire after the marker's, so we add it again.
	                // Adding the listener again means it will fire after all other previously listeners.
	                _this._replaceMarker(_this.map, _this.options, newAutoAnchor);
	                _this.map.events.add("move", _this._onMove);
	            }
	        };
	        /**
	         * Called by a mouse down or touch start event.
	         */
	        _this._onDown = function (event) {
	            _this.map.popups._addDraggedPopup(_this);
	            var anchorPixel = _this.map.positionsToPixels([_this.options.position])[0];
	            if (event.type === "mousedown") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.clientX,
	                    anchorPixel[1] - event.clientY
	                ];
	            }
	            else if (event.type === "touchstart") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.touches[0].clientX,
	                    anchorPixel[1] - event.touches[0].clientY
	                ];
	            }
	        };
	        /**
	         * Called by the container's dragstart event.
	         * Used to call preventDefault as a fix for Edge dragging issues.
	         */
	        _this._onDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new PopupOptions().merge(cloneDeepWith_1(options, PopupOptions._cloneCustomizer));
	        // Create full content container
	        _this.containerDiv = _this._createContainerDiv(_this.options);
	        // Create the container for the content specified in the options.
	        _this.contentDiv = _this._createContentDiv(_this.options);
	        _this.containerDiv.appendChild(_this.contentDiv);
	        // Create arrow tip if specified in the options.
	        if (_this.options.showPointer) {
	            _this.arrowDiv = _this._createArrowDiv();
	            _this.containerDiv.appendChild(_this.arrowDiv);
	        }
	        // Create close button if specified in the options.
	        if (_this.options.closeButton) {
	            _this.closeBtn = _this._createCloseButton();
	            _this.contentDiv.appendChild(_this.closeBtn);
	        }
	        return _this;
	    }
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     * @deprecated Use setOptions(...) instead.
	     */
	    Popup.prototype.setPopupOptions = function (options) {
	        this.setOptions(options);
	    };
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     */
	    Popup.prototype.setOptions = function (options) {
	        var newOptions = new PopupOptions().merge(this.options, cloneDeepWith_1(options, PopupOptions._cloneCustomizer));
	        if (newOptions.content !== this.options.content) {
	            // If the popup content is changed remove the old content and add the new stuff.
	            // Will also implicitly update draggability.
	            this.htmlContent.remove();
	            this.htmlContent = this._createHtmlContent(newOptions);
	            this.contentDiv.prepend(this.htmlContent);
	        }
	        else if (newOptions.draggable !== this.options.draggable) {
	            // If the content hasn't changed, check if draggable is changed.
	            this._setDraggable(this.htmlContent, newOptions.draggable);
	        }
	        // If a close button should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.closeButton && !this.closeBtn) {
	            this.closeBtn = this._createCloseButton();
	            this.contentDiv.appendChild(this.closeBtn);
	        }
	        else if (!newOptions.closeButton && this.closeBtn) {
	            this.contentDiv.removeChild(this.closeBtn);
	            delete this.closeBtn;
	        }
	        // If a pointer should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.showPointer && !this.arrowDiv) {
	            this.arrowDiv = this._createArrowDiv();
	            this.containerDiv.appendChild(this.arrowDiv);
	        }
	        else if (!newOptions.showPointer && this.arrowDiv) {
	            this.containerDiv.removeChild(this.arrowDiv);
	            delete this.arrowDiv;
	        }
	        // If the fill color is changed update the relavent elements.
	        if (newOptions.fillColor !== this.options.fillColor) {
	            this.containerDiv.style.borderColor = newOptions.fillColor;
	            this.contentDiv.style.backgroundColor = newOptions.fillColor;
	        }
	        if (this.marker) {
	            if (newOptions.anchor !== this.options.anchor) {
	                // If the anchor property has changed we need to build a new marker.
	                if (this.options.anchor === "none") {
	                    if (this.autoAnchor !== newOptions.anchor) {
	                        this._replaceMarker(this.map, newOptions);
	                    }
	                    this.map.events.remove("move", this._onMove);
	                    delete this.autoAnchor;
	                }
	                else {
	                    this._replaceMarker(this.map, newOptions);
	                    if (newOptions.anchor === "none") {
	                        this.map.events.add("move", this._onMove);
	                    }
	                }
	            }
	            else {
	                // Check if the position is changed.
	                if (!isEqual_1(newOptions.position, this.options.position)) {
	                    this.marker.setLngLat(newOptions.position);
	                }
	                // Check if the offset is changed.
	                if (!isEqual_1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                    this.marker.setOffset(newOptions.pixelOffset);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Returns the options for the popup.
	     * @deprecated Use getOptions() instead.
	     */
	    Popup.prototype.getPopupOptions = function () {
	        return this.getOptions();
	    };
	    /**
	     * Returns the options for the popup.
	     */
	    Popup.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, PopupOptions._cloneCustomizer);
	    };
	    /**
	     * Drags the popup to the specified pixel.
	     * Accounts for the pixel offset when dragging started.
	     * @internal
	     */
	    Popup.prototype._dragToPixel = function (pixel) {
	        // Wait until the popup has been dragged the first time to fire th dragstart event.
	        if (!this.dragging) {
	            this.dragging = true;
	            this.contentDiv.style.pointerEvents = "none";
	            this._invokeEvent("dragstart", { type: "dragstart", target: this });
	        }
	        var anchorPixel = [
	            pixel[0] + this.dragOffset[0],
	            pixel[1] + this.dragOffset[1]
	        ];
	        var anchorPos = this.map.pixelsToPositions([anchorPixel])[0];
	        this.options.position = anchorPos;
	        this.marker.setLngLat(this.options.position);
	        this._invokeEvent("drag", { type: "drag", target: this });
	    };
	    /**
	     * Called by a mouse up or touch end event.
	     * @internal
	     */
	    Popup.prototype._onUp = function () {
	        // Only fire the dragend event if the popup was actually dragged.
	        if (this.dragging) {
	            this.contentDiv.style.pointerEvents = "";
	            this._invokeEvent("dragend", { type: "dragend", target: this });
	            if (this.options.anchor === "none") {
	                // If automatically anchoring the popup check if the anchor should change after done dragging.
	                this._onMove();
	            }
	        }
	        // Clear the drag state tracking variables.
	        delete this.dragOffset;
	        delete this.dragging;
	    };
	    /**
	     * Creates the overall container div.
	     */
	    Popup.prototype._createContainerDiv = function (options) {
	        var _this = this;
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.container);
	        ele.classList.add(Popup.Css.hidden);
	        ele.style.borderColor = options.fillColor;
	        // Track if a key which can change the focus has been pressed.
	        var focusKeyDown = false;
	        ele.addEventListener("keydown", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = true;
	            }
	        });
	        // If the keyup event occurs before the focusout then don't close the popup.
	        ele.addEventListener("keyup", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = false;
	            }
	        });
	        // If focus comes in without the popup being open go ahead and open it.
	        ele.addEventListener("focusin", function (e) {
	            if (_this.map && !_this.isOpen()) {
	                _this.open(_this.map);
	                // Focus on the element again because it may have been removed and added back to the DOM
	                if (e.target instanceof HTMLElement) {
	                    e.target.focus();
	                }
	            }
	        });
	        // If the focus is lost after a key was pressed close the popup.
	        ele.addEventListener("focusout", function (e) {
	            if (focusKeyDown && e.relatedTarget instanceof Node && !ele.contains(e.relatedTarget)) {
	                focusKeyDown = false;
	                if (_this.isOpen()) {
	                    _this.close();
	                }
	            }
	        });
	        return ele;
	    };
	    /**
	     * Creates the content container div.
	     */
	    Popup.prototype._createContentDiv = function (options) {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.content);
	        ele.style.backgroundColor = options.fillColor;
	        ele.setAttribute("role", "dialog");
	        ele.setAttribute("aria-label", "Map Information Window");
	        ele.setAttribute("tabindex", "0");
	        this.htmlContent = this._createHtmlContent(options);
	        ele.appendChild(this.htmlContent);
	        return ele;
	    };
	    /**
	     * Creates an arrow element.
	     */
	    Popup.prototype._createArrowDiv = function () {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.arrow);
	        return ele;
	    };
	    /**
	     * Creates a close button.
	     */
	    Popup.prototype._createCloseButton = function () {
	        var ele = document.createElement("button");
	        ele.addEventListener("click", this.close);
	        ele.classList.add(Popup.Css.close);
	        ele.setAttribute("aria-label", "close");
	        ele.setAttribute("title", "close");
	        ele.setAttribute("tabindex", "0");
	        ele.innerHTML = "&times;";
	        return ele;
	    };
	    /**
	     * Creates the user content element.
	     */
	    Popup.prototype._createHtmlContent = function (options) {
	        var ele = Html.convertHtmlString(options.content);
	        if (options.draggable) {
	            this._setDraggable(ele, options.draggable);
	        }
	        return ele;
	    };
	    /**
	     * Creates the marker which wraps the popup.
	     */
	    Popup.prototype._createMarker = function (options, autoAnchor) {
	        // If a marker already exists use it's LngLat value for the new marker's position
	        // This prevent the marker from jumping around if world copies are rendered.
	        var position = this.marker ?
	            this.marker.getLngLat() :
	            options.position;
	        // Create the mapbox marker that will hold the popup.
	        var marker;
	        if (options.anchor === "none") {
	            this.autoAnchor = autoAnchor || "bottom";
	            this.containerDiv.classList.add(this.autoAnchor);
	            marker = new mapboxGl_4({
	                anchor: this.autoAnchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        else {
	            this.containerDiv.classList.add(options.anchor);
	            marker = new mapboxGl_4({
	                anchor: options.anchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        return marker;
	    };
	    /**
	     * Calculates the auto anchor value for the current marker.
	     */
	    Popup.prototype._getAutoAnchor = function (map, options) {
	        var width = this.containerDiv.offsetWidth;
	        var height = this.containerDiv.offsetHeight;
	        var posX;
	        var posY;
	        if (this.marker) {
	            var pt = map._getMap().project(this.marker.getLngLat());
	            posX = pt.x;
	            posY = pt.y;
	        }
	        else {
	            var _a = map.positionsToPixels([options.position])[0], x = _a[0], y = _a[1];
	            posX = x;
	            posY = y;
	        }
	        var autoAnchor = [];
	        if (posY < height) {
	            autoAnchor.push("top");
	        }
	        else if (posY > map.getCanvas().offsetHeight - height) {
	            autoAnchor.push("bottom");
	        }
	        if (posX < width / 2) {
	            autoAnchor.push("left");
	        }
	        else if (posX > map.getCanvas().offsetWidth - width / 2) {
	            autoAnchor.push("right");
	        }
	        return autoAnchor.length > 0 ?
	            autoAnchor.join("-") :
	            "bottom";
	    };
	    /**
	     * Replaces the current marker with a new one using the specified options.
	     */
	    Popup.prototype._replaceMarker = function (map, options, autoAnchor) {
	        // Track the next sibling before the marker is removed.
	        var next = this.containerDiv.nextElementSibling;
	        this.marker.remove();
	        this.containerDiv.classList.remove(this.autoAnchor || this.options.anchor);
	        this.marker = this._createMarker(options, autoAnchor);
	        this.marker.addTo(map._getMap());
	        // If the popup was already to the DOM place it back in the original order
	        // This keeps the tab order consistent.
	        map.popups._getCollectionDiv().insertBefore(this.containerDiv, next || null);
	    };
	    /**
	     * Called to setup or remove draggability.
	     */
	    Popup.prototype._setDraggable = function (ele, draggable) {
	        if (draggable) {
	            ele.addEventListener("mousedown", this._onDown);
	            ele.addEventListener("touchstart", this._onDown);
	            ele.addEventListener("dragstart", this._onDragStart);
	        }
	        else {
	            ele.removeEventListener("mousedown", this._onDown);
	            ele.removeEventListener("touchstart", this._onDown);
	            ele.removeEventListener("dragstart", this._onDragStart);
	        }
	    };
	    // CSS class names.
	    Popup.Css = {
	        arrow: "popup-arrow",
	        close: "popup-close",
	        container: "popup-container",
	        content: "popup-content-container",
	        hidden: "hidden-accessible-element"
	    };
	    return Popup;
	}(EventEmitter));

	/**
	 * Options for rendering an HtmlMarker object
	 */
	var HtmlMarkerOptions = /** @class */ (function (_super) {
	    __extends(HtmlMarkerOptions, _super);
	    function HtmlMarkerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the marker's location relative to its position on the map.
	         * Optional values: `"center"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * Default `"bottom"`
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * A color value that replaces any {color} placeholder property that has been included in a string htmlContent.
	         * default `"#1A73AA"`
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * Indicates if the user can drag the position of the marker using the mouse or touch controls.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * The HTML content of the marker. Can be an HTMLElement or HTML string.
	         * Add {text} and {color} to HTML strings as placeholders to make it easy to update
	         * these values in your marker by using the setOptions function of the HtmlMarker class.
	         * This allows you to create a single HTML marker string that can be used as a template for multiple markers.
	         */
	        _this.htmlContent = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24.5 36.5\" id=\"marker_" + uuidRandom() + "\" width=\"24.5\" height=\"36.5\" display=\"block\"><path d=\"M12.25.25a12.2543,12.2543,0,0,0-12,12.4937c0,6.4436,6.4879,12.1093,11.059,22.5641.5493,1.2563,1.3327,1.2563,1.882,0C17.7621,24.8529,24.25,19.1857,24.25,12.7437A12.2543,12.2543,0,0,0,12.25.25Z\"   fill=\"{color}\" stroke=\"{secondaryColor}\" stroke-width=\"0.5\"/><text style=\"font-family: Arial, Helvetica, sans-serif; font-size: 14px; fill: white;\" text-anchor=\"middle\" x=\"12\" y=\"18\">{text}</text></svg>";
	        /**
	         * An offset in pixels to move the popup relative to the markers center.
	         * Negatives indicate left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position of the marker.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * A popup that is attached to the marker.
	         */
	        _this.popup = undefined;
	        /**
	         * A color value that replaces any {secondaryColor} placeholder property that has been included in a string htmlContent.
	         * default `"white"`
	         * @default "white"
	         */
	        _this.secondaryColor = "white";
	        /**
	         * A string of text that replaces any {text} placeholder property that has been included in a string htmlContent.
	         */
	        _this.text = undefined;
	        /**
	         * Specifies if the marker is visible or not.
	         * default `true`
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Popups and HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HtmlMarkerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Popup || isElement_1(value)) {
	            return value;
	        }
	    };
	    return HtmlMarkerOptions;
	}(Options));

	/**
	 * This class wraps an HTML element that can be displayed on the map.
	 */
	var HtmlMarker = /** @class */ (function (_super) {
	    __extends(HtmlMarker, _super);
	    /**
	     * Constructs a new HtmlMarker.
	     * @param options The options for the HtmlMarker.
	     */
	    function HtmlMarker(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Called by the drag event of the mapbox marker.
	         * @private
	         */
	        _this._onDrag = function () {
	            var lngLat = _this.marker.getLngLat().wrap();
	            _this.options.position = new Position(lngLat.lng, lngLat.lat);
	            _this._invokeEvent("drag", { type: "drag", target: _this });
	        };
	        /**
	         * Called by the dragstart event of the mapbox marker.
	         * @private
	         */
	        _this._onDragStart = function () {
	            _this._invokeEvent("dragstart", { type: "dragstart", target: _this });
	        };
	        /**
	         * Called by the dragend event of the mapbox marker.
	         * @private
	         */
	        _this._onDragEnd = function () {
	            _this._invokeEvent("dragend", { type: "dragend", target: _this });
	        };
	        /**
	         * Called by the events of the marker's element.
	         * @private
	         */
	        _this._bubbleElementEvent = function (event) {
	            _this._invokeEvent(event.type, { type: event.type, target: _this });
	        };
	        /**
	         * Called by the element's dragstart event.
	         * Used to call preventDefault so Edge doesn't break dragging.
	         * @private
	         */
	        _this._onEleDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new HtmlMarkerOptions().merge(cloneDeepWith_1(options, HtmlMarkerOptions._cloneCustomizer));
	        _this._buildMarker(_this.options);
	        return _this;
	    }
	    /**
	     * Gets the HTML marker options.
	     */
	    HtmlMarker.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith_1(this.options, HtmlMarkerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the marker.
	     * @param options The options for the marker.
	     */
	    HtmlMarker.prototype.setOptions = function (options) {
	        var newOptions = new HtmlMarkerOptions().merge(this.options, cloneDeepWith_1(options, HtmlMarkerOptions._cloneCustomizer));
	        if (!isEqual_1(newOptions.htmlContent, this.options.htmlContent) ||
	            newOptions.anchor !== this.options.anchor) {
	            // If the htmlContent is new the old marker must be removed and a new one created.
	            this.marker.remove();
	            this._buildMarker(newOptions);
	            // If this marker is attached to a map the new mapbox marker should be added to it.
	            if (this.map) {
	                this.marker.addTo(this.map._getMap());
	                this._getCollectionContainer().appendChild(this.element);
	            }
	        }
	        else {
	            // Check for which options have been updated.
	            // Not necessary if a new marker was created as it will have all the new properties.
	            if (typeof newOptions.htmlContent === "string" &&
	                (newOptions.color !== this.options.color ||
	                    newOptions.text !== this.options.text ||
	                    newOptions.secondaryColor !== this.options.secondaryColor)) {
	                this.element.innerHTML = this._getSubbedHtmlString(newOptions);
	            }
	            if (newOptions.draggable !== this.options.draggable) {
	                this._setDraggable(newOptions.draggable);
	                this.marker.setDraggable(newOptions.draggable);
	            }
	            if (!isEqual_1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                this.marker.setOffset(newOptions.pixelOffset);
	            }
	            if (!isEqual_1(newOptions.position, this.options.position)) {
	                this.marker.setLngLat(newOptions.position);
	            }
	            if (newOptions.visible !== this.options.visible) {
	                if (newOptions.visible) {
	                    this.element.classList.remove(HtmlMarker.hiddenClass);
	                }
	                else {
	                    this.element.classList.add(HtmlMarker.hiddenClass);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Toggles the popup attached to the marker.
	     */
	    HtmlMarker.prototype.togglePopup = function () {
	        if (this.options.popup) {
	            if (this.options.popup.isOpen()) {
	                this.options.popup.close();
	            }
	            else if (this.map) {
	                // Set the popup position to match the marker's.
	                // Same as the mapbox behavior.
	                this.options.popup.setOptions({
	                    position: this.options.position,
	                });
	                this.options.popup.open(this.map);
	            }
	            else {
	                throw new Error("The marker must be added to a map before calling togglePopup().");
	            }
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._addToMap = function (map, position) {
	        // If already added to a different map remove it and add to the new one.
	        if (this.map && this.map !== map) {
	            this._removeFromMap();
	        }
	        if (position) {
	            this.options.position = cloneDeep_1(position);
	            this.marker.setLngLat(this.options.position);
	        }
	        // If the marker is being added to a map it already belongs to this isn't needed.
	        if (this.map !== map) {
	            this.map = map;
	            this.marker.addTo(map._getMap());
	            this._getCollectionContainer().appendChild(this.element);
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._removeFromMap = function () {
	        if (this.map) {
	            this.marker.remove();
	            delete this.map;
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._getId = function () {
	        if (this.element) {
	            if (typeof this.options.htmlContent === "string") {
	                return this.element.firstChild["id"];
	            }
	            else {
	                return this.element.id;
	            }
	        }
	        return undefined;
	    };
	    /**
	     * Builds the Mapbox marker that this HtmlMarker will wrap.
	     * @private
	     */
	    HtmlMarker.prototype._buildMarker = function (options) {
	        // Construct a mapbox marker that this class wraps.
	        // Must converts a HTML string to a HTMLElement (div with innerHTML == htmlContent).
	        // Must also handle the substitution of HTML string placeholders.
	        if (typeof options.htmlContent === "string") {
	            var subbedContent = this._getSubbedHtmlString(options);
	            this.element = Html.convertHtmlString(subbedContent);
	        }
	        else {
	            this.element = options.htmlContent;
	        }
	        this.element.classList.add(HtmlMarker.containerClass);
	        // If draggability is enabled some attributes need updated.
	        if (options.draggable) {
	            this._setDraggable(true);
	        }
	        // If visible is false the marker should still exist on the DOM so it is accessible.
	        if (!options.visible) {
	            this.element.classList.add(HtmlMarker.hiddenClass);
	        }
	        this.marker = new mapboxGl_4({
	            element: this.element,
	            offset: options.pixelOffset,
	            draggable: options.draggable,
	            anchor: options.anchor
	        }).setLngLat(options.position);
	        // Listen for marker specific events.
	        this.marker.on("drag", this._onDrag);
	        this.marker.on("dragstart", this._onDragStart);
	        this.marker.on("dragend", this._onDragEnd);
	        // Listen for HtmlElement specific events.
	        this.element.addEventListener("click", this._bubbleElementEvent);
	        this.element.addEventListener("dblclick", this._bubbleElementEvent);
	        this.element.addEventListener("contextmenu", this._bubbleElementEvent);
	        this.element.addEventListener("keydown", this._bubbleElementEvent);
	        this.element.addEventListener("keypress", this._bubbleElementEvent);
	        this.element.addEventListener("keyup", this._bubbleElementEvent);
	        this.element.addEventListener("mousedown", this._bubbleElementEvent);
	        this.element.addEventListener("mouseenter", this._bubbleElementEvent);
	        this.element.addEventListener("mouseleave", this._bubbleElementEvent);
	        this.element.addEventListener("mousemove", this._bubbleElementEvent);
	        this.element.addEventListener("mouseout", this._bubbleElementEvent);
	        this.element.addEventListener("mouseover", this._bubbleElementEvent);
	        this.element.addEventListener("mouseup", this._bubbleElementEvent);
	    };
	    /**
	     * Returns a HTML string with all place holders substituted for.
	     * @private
	     */
	    HtmlMarker.prototype._getSubbedHtmlString = function (options) {
	        if (typeof options.htmlContent === "string") {
	            return options.htmlContent
	                .replace(/{color}/ig, options.color || "")
	                .replace(/{secondaryColor}/ig, options.secondaryColor || "")
	                .replace(/{text}/ig, options.text || "");
	        }
	    };
	    /**
	     * Returns the element that should contain all the markers.
	     * Creates it if it doesn't already exist.
	     * @private
	     */
	    HtmlMarker.prototype._getCollectionContainer = function () {
	        var collectionContainer = this.map.getCanvasContainer()
	            .querySelector("." + HtmlMarker.collectionContainerClass);
	        if (!collectionContainer) {
	            collectionContainer = document.createElement("div");
	            collectionContainer.classList.add(HtmlMarker.collectionContainerClass);
	            this.map.getCanvasContainer().appendChild(collectionContainer);
	        }
	        return collectionContainer;
	    };
	    /**
	     * Called to set the element dragstart listener, needed for proper draggability on Edge.
	     */
	    HtmlMarker.prototype._setDraggable = function (draggable) {
	        if (draggable) {
	            this.element.addEventListener("dragstart", this._onEleDragStart);
	        }
	        else {
	            this.element.removeEventListener("dragstart", this._onEleDragStart);
	        }
	    };
	    HtmlMarker.collectionContainerClass = "marker-collection-container";
	    HtmlMarker.hiddenClass = "hidden-accessible-element";
	    HtmlMarker.containerClass = "marker-container";
	    return HtmlMarker;
	}(EventEmitter));

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq_1(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignMergeValue = assignMergeValue;

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	var _createBaseFor = createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = _createBaseFor();

	var _baseFor = baseFor;

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike_1(value) && isArrayLike_1(value);
	}

	var isArrayLikeObject_1 = isArrayLikeObject;

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	var _safeGet = safeGet;

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return _copyObject(value, keysIn_1(value));
	}

	var toPlainObject_1 = toPlainObject;

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = _safeGet(object, key),
	      srcValue = _safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    _assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray_1(srcValue),
	        isBuff = !isArr && isBuffer_1(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray_1(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject_1(objValue)) {
	        newValue = _copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = _cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = _cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
	      newValue = objValue;
	      if (isArguments_1(objValue)) {
	        newValue = toPlainObject_1(objValue);
	      }
	      else if (!isObject_1(objValue) || isFunction_1(objValue)) {
	        newValue = _initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  _assignMergeValue(object, key, newValue);
	}

	var _baseMergeDeep = baseMergeDeep;

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  _baseFor(source, function(srcValue, key) {
	    stack || (stack = new _Stack);
	    if (isObject_1(srcValue)) {
	      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      _assignMergeValue(object, key, newValue);
	    }
	  }, keysIn_1);
	}

	var _baseMerge = baseMerge;

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	var identity_1 = identity;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	var _apply = apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return _apply(func, this, otherArgs);
	  };
	}

	var _overRest = overRest;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	var constant_1 = constant;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
	  return _defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant_1(string),
	    'writable': true
	  });
	};

	var _baseSetToString = baseSetToString;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	var _shortOut = shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = _shortOut(_baseSetToString);

	var _setToString = setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return _setToString(_overRest(func, start, identity_1), func + '');
	}

	var _baseRest = baseRest;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject_1(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike_1(object) && _isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq_1(object[index], value);
	  }
	  return false;
	}

	var _isIterateeCall = isIterateeCall;

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return _baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	var _createAssigner = createAssigner;

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = _createAssigner(function(object, source, srcIndex) {
	  _baseMerge(object, source, srcIndex);
	});

	var merge_1 = merge;

	/**
	 * A helper class that will parses and splits a culture code into its language and region parts.
	 */
	var CultureCode = /** @class */ (function () {
	    function CultureCode() {
	    }
	    /**
	     * Parses and splits the specified culture code.
	     * Splits based on the last index of "-".
	     * If a split can not be made the specified code will be considered just the language leaving region undefined.
	     * All string properties will be in lowercase for simplified string matching.
	     * @param code The culture code.
	     */
	    CultureCode.parse = function (code) {
	        code = code.toLowerCase();
	        var index = code.lastIndexOf("-");
	        if (index !== -1) {
	            return {
	                code: code,
	                language: code.substring(0, index),
	                region: code.substring(index + 1)
	            };
	        }
	        return {
	            code: code,
	            language: code,
	        };
	    };
	    return CultureCode;
	}());

	/**
	 * A specific implementation of the LocaleIndex interface.
	 * Contains real information about the available/supported locales.
	 */
	var localeIndex = {
	    localizationsPath: "locs/mapcontrol/2019-3-12",
	    sensitiveUserRegions: ["il", "kr", "pk", "in", "cn", "ar", "bh", "eg", "jo", "sa", "kw", "om", "qa", "ma", "ae"],
	    locales: {
	        defaultLanguage: {
	            defaultRegion: {
	                code: "NGT",
	                strings: "en/resource.json"
	            }
	        },
	        ar: {
	            defaultRegion: {
	                code: "ar",
	                strings: "ar-SA/resource.json"
	            }
	        },
	        bg: {
	            defaultRegion: {
	                code: "bg-BG",
	                strings: "bg-BG/resource.json"
	            }
	        },
	        cs: {
	            defaultRegion: {
	                code: "cs-CZ",
	                strings: "cs-cz/resource.json"
	            }
	        },
	        da: {
	            defaultRegion: {
	                code: "da-DK",
	                strings: "da-DK/resource.json"
	            }
	        },
	        de: {
	            defaultRegion: {
	                code: "de-DE",
	                strings: "de-de/resource.json"
	            }
	        },
	        el: {
	            defaultRegion: {
	                code: "el-GR",
	                strings: "el-GR/resource.json"
	            }
	        },
	        en: {
	            defaultRegion: {
	                code: "en",
	                strings: "en/resource.json"
	            },
	            us: {
	                code: "en-US",
	                strings: "en/resource.json"
	            }
	        },
	        es: {
	            defaultRegion: {
	                code: "es-ES",
	                strings: "es-es/resource.json"
	            },
	            mx: {
	                code: "es-MX",
	                strings: "es-MX/resource.json"
	            }
	        },
	        fi: {
	            defaultRegion: {
	                code: "fi-FI",
	                strings: "fi-FI/resource.json"
	            }
	        },
	        fr: {
	            defaultRegion: {
	                code: "fr-FR",
	                strings: "fr-fr/resource.json"
	            }
	        },
	        hu: {
	            defaultRegion: {
	                code: "hu-HU",
	                strings: "hu-hu/resource.json"
	            }
	        },
	        id: {
	            defaultRegion: {
	                code: "id-ID",
	                strings: "id-ID/resource.json"
	            }
	        },
	        it: {
	            defaultRegion: {
	                code: "it-IT",
	                strings: "it-it/resource.json"
	            }
	        },
	        ko: {
	            defaultRegion: {
	                code: "ko-KR",
	                strings: "ko-kr/resource.json"
	            }
	        },
	        lt: {
	            defaultRegion: {
	                code: "lt-LT",
	                strings: "lt-LT/resource.json"
	            }
	        },
	        ms: {
	            defaultRegion: {
	                code: "ms-MY",
	                strings: "ms-MY/resource.json"
	            }
	        },
	        nb: {
	            defaultRegion: {
	                code: "nb-NO",
	                strings: "nb-NO/resource.json"
	            }
	        },
	        nl: {
	            defaultRegion: {
	                code: "nl-NL",
	                strings: "nl-nl/resource.json"
	            }
	        },
	        pl: {
	            defaultRegion: {
	                code: "pl-PL",
	                strings: "pl-pl/resource.json"
	            }
	        },
	        pt: {
	            defaultRegion: {
	                code: "pt-PT",
	                strings: "pt-pt/resource.json"
	            },
	            br: {
	                code: "pt-BR",
	                strings: "pt-br/resource.json"
	            }
	        },
	        ru: {
	            defaultRegion: {
	                code: "ru-RU",
	                strings: "ru-ru/resource.json"
	            }
	        },
	        sk: {
	            defaultRegion: {
	                code: "sk-SK",
	                strings: "sk-SK/resource.json"
	            }
	        },
	        sl: {
	            defaultRegion: {
	                code: "sl-SL",
	                strings: "sl-SL/resource.json"
	            }
	        },
	        sv: {
	            defaultRegion: {
	                code: "sv-SE",
	                strings: "sv-se/resource.json"
	            }
	        },
	        th: {
	            defaultRegion: {
	                code: "th-TH",
	                strings: "th-TH/resource.json"
	            }
	        },
	        tr: {
	            defaultRegion: {
	                code: "tr-TR",
	                strings: "tr-tr/resource.json"
	            }
	        },
	        zh: {
	            defaultRegion: {
	                code: "zh-Hant",
	                strings: "zh-tw/resource.json"
	            }
	        },
	        "zh-hant": {
	            defaultRegion: {
	                code: "zh-Hant",
	                strings: "zh-tw/resource.json"
	            }
	        }
	    }
	};

	/**
	 * An interface defining the contents of a specific localized strings json.
	 */
	var LocalizedStrings = /** @class */ (function () {
	    function LocalizedStrings() {
	        /**
	         * A localized version of `"Unknown"`.
	         */
	        this.Unknown = "Unknown";
	        /**
	         * A localized version of `"Accident"`.
	         */
	        this.Accident = "Accident";
	        /**
	         * A localized version of `"Fog"`.
	         */
	        this.Fog = "Fog";
	        /**
	         * A localized version of `"Danger"`.
	         */
	        this.Danger = "Danger";
	        /**
	         * A localized version of `"Rain"`.
	         */
	        this.Rain = "Rain";
	        /**
	         * A localized version of `"Ice"`.
	         */
	        this.Ice = "Ice";
	        /**
	         * A localized version of `"Jam"`.
	         */
	        this.Jam = "Jam";
	        /**
	         * A localized version of `"Lane Closed"`.
	         */
	        this.LaneClosed = "Lane Closed";
	        /**
	         * A localized version of `"Road Closed"`.
	         */
	        this.RoadClosed = "Road Closed";
	        /**
	         * A localized version of `"Road Works"`.
	         */
	        this.RoadWorks = "Road Works";
	        /**
	         * A localized version of `"Wind"`.
	         */
	        this.Wind = "Wind";
	        /**
	         * A localized version of `"Flood"`.
	         */
	        this.Flood = "Flood";
	        /**
	         * A localized version of `"Detour"`.
	         */
	        this.Detour = "Detour";
	    }
	    return LocalizedStrings;
	}());

	/**
	 * A static class used for fetching localized strings and validating supported language codes.
	 */
	var Localizer = /** @class */ (function () {
	    function Localizer() {
	    }
	    /**
	     * Returns a supported culture code that best fits the requested one.
	     * @param locale The requested culture code.
	     */
	    Localizer.getCode = function (locale) {
	        var code = CultureCode.parse(locale);
	        // If the requested culture code includes a sensitive region simply return the original code.
	        // This is to hopefully reduce the risk or providing bad content to users in a sensitive region.
	        return (localeIndex.sensitiveUserRegions.indexOf(code.region) === -1) ?
	            this.getLocaleData(code).code :
	            locale;
	    };
	    /**
	     * Returns a collection of localized strings that best fits the requested culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getStrings = function (locale) {
	        var localeData = this.getLocaleData(locale);
	        // Start a GET request
	        var request = new Url({
	            domain: env.staticAssetsDomain,
	            path: localeIndex.localizationsPath + "/" + localeData.strings
	        }).get();
	        // Return the response as a LocalizedStrings object.
	        return request.then(function (response) {
	            return response;
	        }, function () {
	            // If the request for the localized strings json fails return a default localization in English.
	            return new LocalizedStrings();
	        });
	    };
	    /**
	     * Gets the best fit locale data based on the specified culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getLocaleData = function (locale) {
	        // Convert the locale to a culture code if one wasn't already provided.
	        if (typeof locale === "string") {
	            locale = CultureCode.parse(locale);
	        }
	        // Check if the locale could be just the language.
	        // If so return the default locale data for that language.
	        if (localeIndex.locales[locale.code]) {
	            return localeIndex.locales[locale.code].defaultRegion;
	        }
	        // Check if the language is supported.
	        // If not use the default language.
	        var regionIndex;
	        if (localeIndex.locales[locale.language]) {
	            regionIndex = localeIndex.locales[locale.language];
	        }
	        else if (locale.language.indexOf("-") !== -1) {
	            // If the current language can't be matched but there is another "-"
	            // Try to use the language as if it is a full culture code.
	            return this.getLocaleData(locale.language);
	        }
	        else {
	            regionIndex = localeIndex.locales.defaultLanguage;
	        }
	        // Check if the region is supported for the chosen language.
	        // If not use the default region for the chosen language.
	        if (locale.region && regionIndex[locale.region]) {
	            return regionIndex[locale.region];
	        }
	        else {
	            return regionIndex.defaultRegion;
	        }
	    };
	    return Localizer;
	}());

	var UserAgent = /** @class */ (function () {
	    function UserAgent() {
	    }
	    /**
	     * Returns the Edge or IE browser version number.
	     * Edge will be version 12 or greater.
	     * IE will be version 11 or less.
	     * If the browser is not Edge or IE -1 will be returned.
	     */
	    UserAgent.getEdgeOrIEVersion = function () {
	        var ua = window.navigator.userAgent;
	        var msie = ua.indexOf("MSIE ");
	        if (msie > 0) {
	            // IE 10 or older
	            return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
	        }
	        var trident = ua.indexOf("Trident/");
	        if (trident > 0) {
	            // IE 11
	            var rv = ua.indexOf("rv:");
	            return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
	        }
	        var edge = ua.indexOf("Edge/");
	        if (edge > 0) {
	            // Edge (IE 12+)
	            return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
	        }
	        // other browser
	        return -1;
	    };
	    /**
	     * Detects if the browser is IE or Edge.
	     */
	    UserAgent.isEdgeOrIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1;
	    };
	    /**
	     * Detects if the browser is IE but not Edge.
	     */
	    UserAgent.isIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1 && version <= 11;
	    };
	    return UserAgent;
	}());

	(function (AuthenticationType) {
	    /**
	     * The subscription key authentication mechanism.
	     * Literal value `"subscriptionKey"`
	     */
	    AuthenticationType["subscriptionKey"] = "subscriptionKey";
	    /**
	     * The AAD implicit grant mechanism. Recommended for pages protected by a sign-in.
	     * By default the page will be redirected to the AAD login when the map control initializes.
	     * Specify a logged-in `AuthenticationContext` in the `AuthenticationOptions`
	     * for greater control over when/how the users signs in.
	     * Literal value `"aad"`
	     */
	    AuthenticationType["aad"] = "aad";
	    /**
	     * The anonymous authentication mechanism. Recommended for public pages.
	     * Allows a callback responsible for acquiring an authentication token to be provided.
	     * Literal value `"anonymous"`
	     */
	    AuthenticationType["anonymous"] = "anonymous";
	})(exports.AuthenticationType || (exports.AuthenticationType = {}));
	/**
	 * Options for specifying how the map control should authenticate with the Azure Maps services.
	 */
	var AuthenticationOptions = /** @class */ (function (_super) {
	    __extends(AuthenticationOptions, _super);
	    function AuthenticationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication mechanism to be used.
	         */
	        _this.authType = undefined;
	        /**
	         * Subscription key from your Azure Maps account.
	         * Must be specified for subscription key authentication type.
	         */
	        _this.subscriptionKey = undefined;
	        /**
	         * The Azure Maps client ID, This is an unique identifier used to identify the maps account.
	         * Preferred to always be specified, but must be specified for AAD and anonymous authentication types.
	         */
	        _this.clientId = undefined;
	        /**
	         * The Azure AD registered app ID. This is the app ID of an app registered in your Azure AD tenant.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadAppId = undefined;
	        /**
	         * The AAD tenant that owns the registered app specified by `aadAppId`.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadTenant = undefined;
	        /**
	         * The AAD instance to use for logging in.
	         * Can be optionally specified when using the AAD authentication type.
	         * By default the `https://login.microsoftonline.com/` instance will be used.
	         */
	        _this.aadInstance = undefined;
	        /**
	         * A callback to use with the anonymous authentication mechanism.
	         * This callback will be responsible for resolving to a authentication token.
	         * E.g. fetching a CORS protected token from an endpoint.
	         */
	        _this.getToken = undefined;
	        /**
	         * Optionally provide an existing `AuthenticationContext` from the ADAL.js library.
	         * This authentication context will be used to acquire the AAD token.
	         * Only used with the AAD authentication type.
	         * This auth context must be configured to use the same AAD app ID as `this.aadAppId`.
	         * If this is not provided all map instances will share their own private auth context.
	         */
	        _this.authContext = undefined;
	        return _this;
	    }
	    /**
	     * Sets the required options to configure the subscription key authentication mechanism.
	     * @param subscriptionKey Subscription Key from your azure maps account
	     */
	    AuthenticationOptions.prototype.setSubscriptionKey = function (key) {
	        this.authType = exports.AuthenticationType.subscriptionKey;
	        this.subscriptionKey = key;
	    };
	    /**
	     * Sets the required authentication options to configure the AAD implicit grant mechanism.
	     * @param clientId Client ID from your azure maps account
	     * @param aadAppId Azure AD App ID
	     * @param aadTenant Azure AD Tenant Name
	     * @param aadInstance An optional Azure AD Instance
	     * @param authContext An optional `AuthenticationContext` from the ADAL.js library
	     */
	    AuthenticationOptions.prototype.setAadProperties = function (clientId, aadAppId, aadTenant, aadInstance, authContext) {
	        this.authType = exports.AuthenticationType.aad;
	        this.authContext = authContext || this.authContext;
	        this.aadInstance = aadInstance || this.aadInstance;
	        this.clientId = clientId;
	        this.aadAppId = aadAppId;
	        this.aadTenant = aadTenant;
	    };
	    /**
	     * Sets the required options to configure the anonymous authentication method.
	     * @param getTokenCallback Callback function responsible for resolving to an authentication token.
	     */
	    AuthenticationOptions.prototype.setTokenCallbackFunction = function (getTokenCallback) {
	        this.authType = exports.AuthenticationType.anonymous;
	        this.getToken = getTokenCallback;
	    };
	    /**
	     * Override the standard merge behavior to handle mutually exclusive options.
	     * @internal
	     */
	    AuthenticationOptions.prototype.merge = function () {
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var merged = _super.prototype.merge.apply(this, valueList);
	        if (merged.authType === exports.AuthenticationType.subscriptionKey) {
	            merged.authContext = merged.aadAppId = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.aad) {
	            merged.subscriptionKey = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.anonymous) {
	            merged.subscriptionKey = merged.authContext = merged.aadAppId = undefined;
	        }
	        return merged;
	    };
	    return AuthenticationOptions;
	}(Options));

	var defaultView;
	var defaultLanguage = "NGT";
	var defaultSessionId = uuidRandom();
	var defaultDomain = env.domain;
	var defaultAuthOptions = new AuthenticationOptions();
	var hasSetView = false;
	var hasSetDomain = false;
	var hasSetLanguage = false;
	var hasSetSessionId = false;
	var hasSetAuthenticationOptions = false;
	/**
	 * Gets the default authentication options that were provided.
	 * If not previously set all properties will be undefined.
	 */
	function getAuthenticationOptions() {
	    return Object.assign({}, defaultAuthOptions);
	}
	/**
	 * Gets the default domain that was provided.
	 * If not previously set the default value is `"atlas.microsoft.com"`.
	 */
	function getDomain() {
	    return defaultDomain;
	}
	/**
	 * Gets the default language that was provided.
	 * If not previously set the default value is `"NGT"`.
	 */
	function getLanguage() {
	    return defaultLanguage;
	}
	/**
	 * Gets the default session id that was provided.
	 * If not previously set the default value is a random UUID.
	 */
	function getSessionId() {
	    return defaultSessionId;
	}
	/**
	 * Gets the default Azure Maps subscription key that was provided.
	 */
	function getSubscriptionKey() {
	    return defaultAuthOptions.authType === exports.AuthenticationType.subscriptionKey ?
	        defaultAuthOptions.subscriptionKey : undefined;
	}
	/**
	 * @deprecated use atlas.getView() instead
	 */
	function getUserRegion() {
	    return defaultView;
	}
	/**
	 * Gets the default view setting of the map control.
	 * If not previously set the default value is `undefined`.
	 */
	function getView() {
	    return defaultView;
	}
	/**
	 * Current API version number based on build number.
	 */
	function getVersion() {
	    return Version.getFullVersion();
	}
	/**
	 * Checks to see if the user's browser is supported by the map control.
	 * @param failIfMajorPerformanceCaveat If true the function will return false
	 * if the performance of the map control would be dramatically worse than expected
	 * (e.g. a software WebGL renderer would be used).
	 */
	function isSupported(failIfMajorPerformanceCaveat) {
	    // Always return false for IE since we don't support it ourselves.
	    if (UserAgent.isIE()) {
	        return false;
	    }
	    return mapboxGl.supported({
	        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
	    });
	}
	/**
	 * Sets your authentication options as the default options in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the authentication options explicitly defined and
	 * setAuthenticationOptions hasn't previously been called it will automatically be called by the Map constructor.
	 * @param options The new default authentication options.
	 */
	function setAuthenticationOptions(options) {
	    defaultAuthOptions = new AuthenticationOptions().merge(defaultAuthOptions, options);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * Sets the default domain used by the map and service modules unless the
	 * domain is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the domain explicitly defined and
	 * setDomain hasn't previously been called it will automatically be called by the Map constructor.
	 * If the protocol is not specified `https` is assumed.
	 * @param domain The new default domain.
	 */
	function setDomain(domain) {
	    defaultDomain = domain;
	    hasSetDomain = true;
	}
	/**
	 * Sets the default language used by the map and service modules unless the
	 * language is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the language explicitly defined and
	 * setLanguage hasn't previously been called it will automatically be called by the Map constructor.
	 * @param language The new default language.
	 */
	function setLanguage(language) {
	    // Find the best fit supported language.
	    defaultLanguage = Localizer.getCode(language);
	    hasSetLanguage = true;
	}
	/**
	 * Sets the default session id used by the map and service modules unless the
	 * session id is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the session ID explicitly defined and
	 * setSessionId hasn't previously been called it will automatically be called by the Map constructor.
	 * @param id The new default session id.
	 */
	function setSessionId(id) {
	    defaultSessionId = id;
	    hasSetSessionId = true;
	}
	/**
	 * Sets your Azure Maps subscription key as the default subscription key in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the subscription key explicitly defined and
	 * setSubscriptionKey hasn't previously been called it will automatically be called by the Map constructor.
	 * @param key The new default subscription key.
	 */
	function setSubscriptionKey(key) {
	    defaultAuthOptions.setSubscriptionKey(key);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * @deprecated use atlas.setView(view: string) instead.
	 */
	function setUserRegion(userRegion) {
	    defaultView = userRegion;
	    hasSetView = true;
	}
	/**
	 * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	 * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews }.
	 * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	 * @param view The new default view
	 */
	function setView(view) {
	    defaultView = view;
	    hasSetView = true;
	}
	/**
	 * Adds an image template to the atlas namespace.
	 * @param templateName The name of the template.
	 * @param template The SVG template to add. Supports {color}, {secondaryColor}, {scale}, {text}.
	 * @param override Specifies if it should override existing templates if one with the same name already exists.
	 */
	function addImageTemplate(templateName, template, override) {
	    if (override || !imageTemplates[templateName.toLowerCase()]) {
	        imageTemplates[templateName.toLowerCase()] = template;
	    }
	}
	/**
	 * Retrieves an SVG template by name.
	 * @param templateName The name of the template to retrieve.
	 * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	 */
	function getImageTemplate(templateName, scale) {
	    scale = Math.abs(scale || 1);
	    if (typeof templateName === "string" && imageTemplates[templateName.toLowerCase()]) {
	        var template = imageTemplates[templateName.toLowerCase()];
	        // Firefox/Edge don't support calc for inline SVG's. Need to manually calculate this.
	        var pattern = /calc\(([0-9.]+)[px]*\s*\*\s*\{scale\}\)/gi;
	        var t = template;
	        var match = pattern.exec(template);
	        while (match) {
	            t = t.replace(match[0], parseFloat(match[1]) * scale + "");
	            match = pattern.exec(template);
	        }
	        // Just for good measure incase the pattern doesn't match.
	        t = t.replace("{scale}", scale + "");
	        return t;
	    }
	    else {
	        throw new Error("Invalid templateName.");
	    }
	}
	/**
	 * Retrieves an array of names for all image templates that are available in the atlas namespace.
	 */
	function getAllImageTemplateNames() {
	    return Object.keys(imageTemplates);
	}
	/**
	 * Returns if authentication options are set.
	 * @internal
	 */
	function _hasSetAuthenticationOptions() {
	    return hasSetAuthenticationOptions;
	}
	/**
	 * Returns if the default domain has been set yet.
	 * @internal
	 */
	function _hasSetDomain() {
	    return hasSetDomain;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetLanguage() {
	    return hasSetLanguage;
	}
	/**
	 * Returns is a default session id has been set yet.
	 * @internal
	 */
	function _hasSetSessionId() {
	    return hasSetSessionId;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetView() {
	    return hasSetView;
	}
	/**
	 * Gets the base domain used for asset retrieval.
	 * @internal
	 */
	function _getAssetDomain() {
	    return env.domain;
	}
	/**
	 * Gets the base domain used for general map services.
	 * @internal
	 */
	// TODO Remove once all internal dependencies of this function are gone.
	function _getDomain() {
	    return getDomain();
	}
	var imageTemplates = {
	    /**********************
	     * Marker templates
	     **********************/
	    // Default built in marker. Supports {color} and {secondaryColor}
	    "marker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 26 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><text x="12.5" y="17.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:2"/><text x="12.5" y="18.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-circle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><circle cx="12.5" cy="12.5" r="9" fill="{secondaryColor}"/><text x="12" y="17.5" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(24 * {scale})" height="calc(28 * {scale})" viewBox="0 0 24 28"><path d="m11.988 16.615a5.15 5.15 0 0 1-2.268-.525 4.909 4.909 0 0 1-2.805-4.442 5.019 5.019 0 0 1 5.072-4.936h.012a5.03 5.03 0 0 1 5.085 4.961 4.907 4.907 0 0 1-.549 2.224 5.114 5.114 0 0 1-4.548 2.718zm0-8.06a3.173 3.173 0 0 0-3.226 3.099 3.081 3.081 0 0 0 1.77 2.782 3.299 3.299 0 0 0 4.365-1.386 3.049 3.049 0 0 0 .342-1.381 3.184 3.184 0 0 0-3.239-3.114h-.012z" fill="{secondaryColor}"/><path d="m11.999.922a10.908 10.908 0 0 0-11.076 10.732 10.639 10.639 0 0 0 4.418 8.598l6.658 6.464 6.658-6.463a10.537 10.537 0 0 0 2.198-15.041 11.182 11.182 0 0 0-8.856-4.289zm1.873 14.341a4.221 4.221 0 0 1-5.589-1.789 3.945 3.945 0 0 1-.445-1.8 4.164 4.164 0 0 1 8.323-.037 4.028 4.028 0 0 1-2.289 3.626Z" fill="{color}"/><path d="m11.999 28-7.256-7.044a11.611 11.611 0 0 1-4.743-9.303 11.844 11.844 0 0 1 11.988-11.652.102 .102 0 0 1 .02 0 12.164 12.164 0 0 1 9.577 4.647 11.357 11.357 0 0 1 2.299 8.614 11.521 11.521 0 0 1-4.63 7.695zm-.01-26.157a9.997 9.997 0 0 0-10.143 9.812 9.769 9.769 0 0 0 4.04 7.853l.099.083 6.014 5.838 6.113-5.922a9.7 9.7 0 0 0 3.945-6.505 9.533 9.533 0 0 0-1.933-7.229 10.305 10.305 0 0 0-8.116-3.931h-.021zm.021 14.772a5.11 5.11 0 0 1-4.547-2.718 4.868 4.868 0 0 1 .932-5.743 5.118 5.118 0 0 1 3.58-1.46h.024a5.031 5.031 0 0 1 5.084 4.938 4.92 4.92 0 0 1-2.805 4.457h0a5.152 5.152 0 0 1-2.269.525zm-.011-8.079h-.015a3.277 3.277 0 0 0-2.295.933 3.029 3.029 0 0 0-.587 3.58 3.297 3.297 0 0 0 4.364 1.386h0a3.092 3.092 0 0 0 1.772-2.795 3.185 3.185 0 0 0-3.239-3.105z" fill="{secondaryColor}"/><text x="12" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin-round style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin-round": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25 * {scale})" height="calc(25 * {scale})" viewBox="0 0 25 25"><g transform="translate(0 1)"><circle cx="12.25" cy="11.5833" r="11" fill="{color}"/><path d="m12.25 23.583a12 12 0 1 1 12-12 12 12 0 0 1-12 12zm0-22a10 10 0 1 0 10 10 10 10 0 0 0-10-10z" fill="{secondaryColor}"/><circle cx="12.25" cy="11.5833" r="4.2386" fill="{secondaryColor}"/></g><text x="12.5" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-flat": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(42.8 * {scale})"  viewBox="0 0 1600 2570"><g fill="{color}"><path d="M691 2419c-409-575-641-1086-683-1504-10-106-10-136 5-224 31-188 105-330 241-458 129-124 270-190 453-214 69-9 113-10 182-1 373 46 655 326 703 698 40 308-120 801-424 1309-134 224-348 535-369 535-4 0-53-63-108-141z"/></g><g fill="rgba(0,0,0,0.15)" style="transform:scale(-1,1);transform-origin:center"><path d="M691 2419c-407-571-639-1083-682-1498-14-139-3-249 37-371 69-208 254-402 459-481 68-27 217-59 271-59h24v160 180 940 635c0 349-2 635-5 635-2 0-49-63-104-141z"/></g><circle cx="800" cy="800" r="600" fill="{secondaryColor}"/><text x="800" y="1100" style="font-size:800px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-arrow": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25.47 * {scale})" height="calc(35.18 * {scale})" viewBox="0 0 4330 5980"><g fill="{color}"><path d="m2080 5969c-49-20-93-63-115-113-25-55-1928-5486-1953-5573-40-138 67-282 210-283 36 0 246 73 987 345 518 190 947 345 955 345 8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29-33 0-71-5-85-10z"/></g><g fill="{secondaryColor}"><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z"/><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z" style="transform:scale(-1,1);transform-origin:center"/></g><g fill="rgba(0,0,0,0.2)" ><path d="m2165 685c8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29z"/></g><text x="2165" y="3300" style="font-size:2500px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-ball-pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15.67 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 235 452"><g transform="translate(-135 10)"><path fill="{secondaryColor}" d="m256 442 0 0c-13 0-18-11-18-24l-6-323c0-13 11-24 24-24h0c13 0 24 11 24 24l-6 323c0 13-5 24-18 24z"/><circle style="fill:{color};stroke-width:10;stroke:{secondaryColor}" cx="256" cy="112" r="111"/><ellipse transform="matrix(0.834 0.5518 -0.5518 0.834 65.7916 -97.18)" fill="rgba(255,255,255,0.3)" cx="194.399" cy="60.749" rx="19.076" ry="32.428"/></g><text x="117.5" y="160" style="font-size:160px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.67 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2000 2420"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M845 2152c-22-37-58-95-80-129-22-35-62-99-90-143l-50-80-312 0-313 0 0-900 0-900 900 0 900 0 0 900 0 900-313 0-313 0-34 58c-19 31-38 59-42 60-5 2-8 8-8 12 0 9-69 123-88 145-5 6-11 15-13 21-16 39-77 123-89 124-8 0-33-31-55-68z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(38.8 * {scale})" viewBox="0 0 2500 2910"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m866 2652c-17-31-37-68-46-82-9-14-32-54-51-90-19-36-50-92-70-125l-36-60-332-3-331-2 0-905 0-905 660 0 660 0 0-38c0-71 50-196 102-258 71-85 189-164 244-164 12 0 26-4 29-10 8-13 222-13 230 0 3 6 17 10 30 10 25 0 117 45 154 76 130 107 191 232 191 392 0 155-63 284-190 386-36 29-129 76-150 76-11 0-22 5-25 10-3 6-31 10-61 10l-54 0 0 660 0 660-332 2-332 3-29 50c-17 28-48 84-70 125-22 41-47 86-56 100-9 14-30 51-46 83-17 32-36 57-45 57-8 0-28-25-44-58z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.8 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2010 2410"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M856 2155c-20-30-36-59-36-65 0-5-4-10-10-10-5 0-10-5-10-11 0-5-18-37-40-69-22-32-40-64-40-69 0-6-4-11-10-11-5 0-10-5-10-10 0-6-15-33-32-60l-33-50-127 0c-74 0-129-4-133-10-3-5-17-10-30-10-25 0-116-45-155-76-87-69-142-151-178-265-15-46-17-1075-2-1084 5-3 10-17 10-30 0-13 5-27 10-30 6-3 10-13 10-22 0-22 83-135 122-168 57-46 62-50 112-75l50-25 585 0 586 0 63 34c84 46 169 133 212 218l35 68 0 565 0 565-28 59c-32 69-100 157-139 180-15 9-33 22-40 29-23 22-99 57-123 57-13 0-27 5-30 10-4 6-60 10-135 10l-128 0-128 205c-84 136-133 205-144 205-10 0-33-24-54-55z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(32.13 * {scale})" viewBox="0 0 2500 2900"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m874 2669c-9-18-26-49-37-68-11-20-30-55-43-78-13-24-36-64-51-90-14-27-38-69-52-95l-26-48-142 0c-84 0-144-4-148-10-3-5-17-10-30-10-25 0-118-46-154-76-91-76-136-142-175-254-13-38-16-119-16-554 0-358 3-520 12-545 40-125 106-219 195-278 127-84 116-83 646-83l467 0 0-42c0-46 11-87 45-163 54-121 169-220 306-264 46-14 232-14 278 0 165 53 284 175 340 350 19 61 14 204-10 273-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-3 6-28 10-56 10l-49 0 0 462c0 446-1 464-21 522-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-4 6-65 10-149 10-138 0-143 1-154 23-12 23-62 114-112 202-16 28-44 79-63 115-42 77-67 88-93 39z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(23.5 * {scale})" height="calc(40 * {scale})" viewBox="34 28 198 308"><path style="stroke:{secondaryColor};stroke-width:15;stroke-linecap:round;" d="M42 327l0 -291"/><path style="fill:{color};stroke:{secondaryColor};stroke-width:10;stroke-linejoin:round;" d="M49 50c70 30 104 28 178 2-21 42-21 74 0 116-72 25-101 25-178 0l0-118z"/><text x="130" y="165" style="font-size:100px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag-triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(35.33 * {scale})" viewBox="0 0 40.5 53"><g transform="translate(-31 -20)"><path fill="{secondaryColor}" d="M34.7,73.3V48.4l34.6-10.1c0.7-0.2,1.2-0.8,1.2-1.5s-0.4-1.4-1-1.7L33.7,20.5c-0.5-0.2-1.1-0.2-1.6,0.2 c-0.5,0.3-0.7,0.8-0.7,1.4v51.2H34.7z"/><polygon points="34.7,24.5 66,36.5 34.7,45 34.7,10" fill="{color}"/></g><text x="11" y="21" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(34 * {scale})" height="calc(34 * {scale})" viewBox="0 0 34 34"><g transform="translate(2 2)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17" y="22" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(38 * {scale})" height="calc(38 * {scale})" viewBox="0 0 38 38"><g transform="translate(4 4)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19" y="24" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(36 * {scale})" height="calc(36 * {scale})" viewBox="0 0 36 36"><g transform="translate(2 2)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="30" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><g transform="translate(4 4)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="32" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(35 * {scale})" height="calc(40 * {scale})" viewBox="0 0 35 40"><g transform="translate(2 2)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="25" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(39 * {scale})" height="calc(44 * {scale})" viewBox="0 0 39 44"><g transform="translate(4 4)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="27" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1100 1100"><g transform="translate(50 50)"><path style="stroke:{secondaryColor};stroke-width:50;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="550" y="700" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1200 1200"><g transform="translate(100 100)"><path style="stroke:{secondaryColor};stroke-width:100;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="600" y="750" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="12,0 0,24 12,17 24,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="17" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-left": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="24,12 0,0 7,12 0,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="16.5" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(12.16 * {scale})" height="calc(30.1 * {scale})" viewBox="0 0 902 364"><g fill="{color}" transform="matrix(0,2.4,-2.4,0,897,-930)"><polygon points="902,222 233,222 233,364 0,182 233,0 233,141 902,141 902,222"/></g><text x="450" y="700" style="font-size:900px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "arrow-up-thin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 12 25"><g transform="translate(-136.91823 -751.91998)"><path fill="{color}" d="m148.271 760.71c-1.641-.547-3.186-1.47-4.633-2.769l0 18.07-1.675 0 0-18.07c-1.447 1.299-2.986 2.222-4.616 2.769l0-1.231c2.325-1.596 4.006-3.812 5.043-6.65l.838 0c1.037 2.838 2.718 5.055 5.043 6.65l0 1.231z"/></g><text x="6" y="20" style="font-size:10px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "car": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(21.93 * {scale})" height="calc(40.9 * {scale})" viewBox="0 0 6580 12270"><g transform="translate(0 12270) rotate(-90)"><path fill="{secondaryColor}" d="M7045 6566c-42-13-105-44-105-51 0-2 23-105 50-228 28-123 50-230 50-236 0-8-241-11-907-11-855 0-1145 6-1513 30-85 6-189 13-230 15-41 3-133 10-205 15-286 21-430 32-705 50-953 63-1459 18-2335-205-304-77-746-209-799-238-131-72-221-408-285-1062-34-345-42-532-48-1130-16-1557 108-2532 336-2649 32-17 469-149 676-205 409-110 819-191 1205-238 116-14 224-18 540-18 395 1 494 5 1140 50 1124 79 1224 82 2496 78l641-3-53-237c-29-131-52-238-51-239 1-1 31-14 66-29 56-23 76-26 142-23 67 3 83 7 120 33 23 17 50 41 61 55 10 14 51 117 91 230l73 205 674 3 675 2 90-39c98-43 198-72 315-93 122-21 829-18 990 5 321 45 626 143 849 270 293 168 516 378 704 662 266 402 416 893 467 1527 15 174 8 882-9 998-6 41-18 127-27 190-69 502-253 969-523 1325-79 105-262 284-381 374-189 142-355 229-574 300-336 110-526 139-952 148-457 9-685-23-887-124l-47-24-678-6-678-6-64 179c-79 224-92 253-121 284-67 70-177 97-274 66zm-2752-5073c-23-2-64-2-90 0-26 2-7 3 42 3 50 0 71-1 48-3zm395 0c-21-2-55-2-75 0-21 2-4 4 37 4 41 0 58-2 38-4z"/><path fill="{color}" d="M7043 6498c-13-6-23-19-23-28 0-9 23-117 50-240 28-123 50-230 50-237 0-22-2126-13-2465 10-132 10-400 28-595 42-661 47-824 55-1160 62-435 7-656-8-1040-73-415-70-865-183-1447-365-168-53-272-556-325-1569-16-319-16-1311 0-1630 45-872 129-1366 257-1518 22-26 51-39 172-77 557-177 1122-310 1563-369 271-36 351-40 690-40 361 1 463 6 1165 54 1122 78 1288 83 2337 79 460-2 840-7 843-11 4-4-17-117-47-252l-55-245 39-16c76-30 180-8 224 47 10 13 54 124 98 246l79 222 709 0 709 0 47-24c74-37 219-83 322-101 122-22 606-32 802-16 374 29 658 102 933 238 124 62 271 155 361 230l61 51 6 100c19 278 103 497 247 643 88 89 173 136 278 152l70 11 41 131c116 369 159 673 168 1170 10 584-38 984-167 1397l-40 126-70 12c-193 33-348 175-441 405-56 139-89 302-89 445 0 43-3 47-58 91-290 235-644 384-1068 450-191 29-796 39-974 16-135-18-263-54-368-102l-75-35-701 0-701 0-79 223c-82 232-102 267-163 293-38 16-138 17-170 2zm-2023-820c332-15 1155-12 1835 6 308 8 563 12 566 8 4-4 10-21 13-38 7-30 6-31-92-77-518-244-1197-396-2112-474-295-25-1282-25-1579 0-231 20-473 46-479 51-6 7 49 110 93 171 160 226 416 335 855 365 142 10 539 5 900-12zm3304-263c525-111 899-887 934-1935 19-557-37-1023-172-1435-186-563-521-900-896-899-81 0-158 14-525 92-426 91-431 92-540 146-195 96-287 207-306 368-12 104-11 2985 1 3078 22 170 135 291 365 389 49 21 191 55 480 115 226 47 419 87 430 89 45 10 164 6 229-8zm-5570-485c112-43 197-156 216-291 12-83 13-2623 1-2706-23-158-125-273-270-304-44-9-100-1-542 75-272 47-514 91-539 98-266 68-487 424-594 958-56 280-70 548-40 800 56 484 207 878 414 1081 115 114 122 116 702 218 277 49 524 90 550 90 26 1 72-8 102-19zm2111-3440c1023-44 1884-213 2462-486l113-53-7-33c-3-18-8-35-10-37-2-3-236 1-521 7-993 24-1271 26-1708 11-541-18-1128-18-1249-1-377 56-588 181-734 437-32 55-41 79-32 84 12 8 246 32 491 51 356 28 815 36 1195 20z"/></g><text x="3250" y="8250" style="font-size:3000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    /**********************
	     * Fill Patterns
	     **********************/
	    "checker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 16 16"><pattern id="p" x="0" y="0" width="16" height="16" patternUnits="userSpaceOnUse"><rect fill="{color}" x="0" width="8" height="8" y="0"/><rect fill="{color}" x="8" width="8" height="8" y="8"/></pattern><rect x="0" y="0" width="16" height="16" fill="{secondaryColor}"/><rect x="0" y="0" width="16" height="16" fill="url(#p)"/></svg>',
	    "checker-rotated": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 60 60"><rect width="60" height="60" fill="{secondaryColor}"/><rect width="42.42" height="42.42" transform="translate(30 0) rotate(45)" fill="{color}"/></svg>',
	    "zig-zag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 120 60 120 90 90 120 60 120 0 120 0 60 60 0 0 0 60 30 90 60 120 120 120"/></svg>',
	    "zig-zag-vertical": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 0 120 60 90 30 60 0 0 0 0 0 60 60 0 120 60 120 90 90 120 60 120 0"/></svg>',
	    "circles-spaced": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="2" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "circles": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(7 * {scale})" height="calc(7 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="6" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "diagonal-lines-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-lines-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-stripes-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "diagonal-stripes-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(14 * {scale})" height="calc(14 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(45 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}" transform="rotate(-45 3 3)"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-stripes": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "x-fill": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="45.3" height="45.3" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z"/></g></svg>',
	    "dots": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(13 * {scale})" height="calc(13 * {scale})" viewBox="0 0 20 20"><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><g fill="{color}"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>'
	};

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	/**
	* Type of storage to differentiate between local storage and session storage
	*/
	var StorageType;
	(function (StorageType) {
	    StorageType[StorageType["LocalStorage"] = 0] = "LocalStorage";
	    StorageType[StorageType["SessionStorage"] = 1] = "SessionStorage";
	})(StorageType || (StorageType = {}));
	/**
	 * Enum is used in aiDataContract to describe how fields are serialized.
	 * For instance: (Fieldtype.Required | FieldType.Array) will mark the field as required and indicate it's an array
	 */
	var FieldType;
	(function (FieldType) {
	    FieldType[FieldType["Default"] = 0] = "Default";
	    FieldType[FieldType["Required"] = 1] = "Required";
	    FieldType[FieldType["Array"] = 2] = "Array";
	    FieldType[FieldType["Hidden"] = 4] = "Hidden";
	})(FieldType || (FieldType = {}));
	var DistributedTracingModes;
	(function (DistributedTracingModes) {
	    /**
	     * (Default) Send Application Insights correlation headers
	     */
	    DistributedTracingModes[DistributedTracingModes["AI"] = 0] = "AI";
	    /**
	     * Send both W3C Trace Context headers and back-compatibility Application Insights headers
	     */
	    DistributedTracingModes[DistributedTracingModes["AI_AND_W3C"] = 1] = "AI_AND_W3C";
	    /**
	     * Send W3C Trace Context headers
	     */
	    DistributedTracingModes[DistributedTracingModes["W3C"] = 2] = "W3C";
	})(DistributedTracingModes || (DistributedTracingModes = {}));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	/**
	 * The EventsDiscardedReason enumeration contains a set of values that specify the reason for discarding an event.
	 */
	var EventsDiscardedReason = {
	    /**
	     * Unknown.
	     */
	    Unknown: 0,
	    /**
	     * Status set to non-retryable.
	     */
	    NonRetryableStatus: 1,
	    /**
	     * The event is invalid.
	     */
	    InvalidEvent: 2,
	    /**
	     * The size of the event is too large.
	     */
	    SizeLimitExceeded: 3,
	    /**
	     * The server is not accepting events from this instrumentation key.
	     */
	    KillSwitch: 4,
	    /**
	     * The event queue is full.
	     */
	    QueueFull: 5,
	};

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var CoreUtils = /** @class */ (function () {
	    function CoreUtils() {
	    }
	    CoreUtils.isNullOrUndefined = function (input) {
	        return input === null || input === undefined;
	    };
	    /**
	* Creates a new GUID.
	* @return {string} A GUID.
	*/
	    CoreUtils.disableCookies = function () {
	        CoreUtils._canUseCookies = false;
	    };
	    CoreUtils.newGuid = function () {
	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(GuidRegex, function (c) {
	            // tslint:disable-next-line:insecure-random
	            var r = (Math.random() * 16 | 0), v = (c === 'x' ? r : r & 0x3 | 0x8);
	            return v.toString(16);
	        });
	    };
	    return CoreUtils;
	}());
	var GuidRegex = /[xy]/g;

	/**
	 * Class to manage sending notifications to all the listeners.
	 */
	var NotificationManager = /** @class */ (function () {
	    function NotificationManager() {
	        this.listeners = [];
	    }
	    /**
	     * Adds a notification listener.
	     * @param {INotificationListener} listener - The notification listener to be added.
	     */
	    NotificationManager.prototype.addNotificationListener = function (listener) {
	        this.listeners.push(listener);
	    };
	    /**
	     * Removes all instances of the listener.
	     * @param {INotificationListener} listener - AWTNotificationListener to remove.
	     */
	    NotificationManager.prototype.removeNotificationListener = function (listener) {
	        var index = this.listeners.indexOf(listener);
	        while (index > -1) {
	            this.listeners.splice(index, 1);
	            index = this.listeners.indexOf(listener);
	        }
	    };
	    /**
	     * Notification for events sent.
	     * @param {ITelemetryItem[]} events - The array of events that have been sent.
	     */
	    NotificationManager.prototype.eventsSent = function (events) {
	        var _this = this;
	        var _loop_1 = function (i) {
	            if (this_1.listeners[i].eventsSent) {
	                setTimeout(function () { return _this.listeners[i].eventsSent(events); }, 0);
	            }
	        };
	        var this_1 = this;
	        for (var i = 0; i < this.listeners.length; ++i) {
	            _loop_1(i);
	        }
	    };
	    /**
	     * Notification for events being discarded.
	     * @param {ITelemetryItem[]} events - The array of events that have been discarded by the SDK.
	     * @param {number} reason           - The reason for which the SDK discarded the events. The EventsDiscardedReason
	     * constant should be used to check the different values.
	     */
	    NotificationManager.prototype.eventsDiscarded = function (events, reason) {
	        var _this = this;
	        var _loop_2 = function (i) {
	            if (this_2.listeners[i].eventsDiscarded) {
	                setTimeout(function () { return _this.listeners[i].eventsDiscarded(events, reason); }, 0);
	            }
	        };
	        var this_2 = this;
	        for (var i = 0; i < this.listeners.length; ++i) {
	            _loop_2(i);
	        }
	    };
	    return NotificationManager;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var LoggingSeverity;
	(function (LoggingSeverity) {
	    /**
	     * Error will be sent as internal telemetry
	     */
	    LoggingSeverity[LoggingSeverity["CRITICAL"] = 1] = "CRITICAL";
	    /**
	     * Error will NOT be sent as internal telemetry, and will only be shown in browser console
	     */
	    LoggingSeverity[LoggingSeverity["WARNING"] = 2] = "WARNING";
	})(LoggingSeverity || (LoggingSeverity = {}));
	/**
	 * Internal message ID. Please create a new one for every conceptually different message. Please keep alphabetically ordered
	 */
	var _InternalMessageId = {
	    // Non user actionable
	    BrowserDoesNotSupportLocalStorage: 0,
	    BrowserCannotReadLocalStorage: 1,
	    BrowserCannotReadSessionStorage: 2,
	    BrowserCannotWriteLocalStorage: 3,
	    BrowserCannotWriteSessionStorage: 4,
	    BrowserFailedRemovalFromLocalStorage: 5,
	    BrowserFailedRemovalFromSessionStorage: 6,
	    CannotSendEmptyTelemetry: 7,
	    ClientPerformanceMathError: 8,
	    ErrorParsingAISessionCookie: 9,
	    ErrorPVCalc: 10,
	    ExceptionWhileLoggingError: 11,
	    FailedAddingTelemetryToBuffer: 12,
	    FailedMonitorAjaxAbort: 13,
	    FailedMonitorAjaxDur: 14,
	    FailedMonitorAjaxOpen: 15,
	    FailedMonitorAjaxRSC: 16,
	    FailedMonitorAjaxSend: 17,
	    FailedMonitorAjaxGetCorrelationHeader: 18,
	    FailedToAddHandlerForOnBeforeUnload: 19,
	    FailedToSendQueuedTelemetry: 20,
	    FailedToReportDataLoss: 21,
	    FlushFailed: 22,
	    MessageLimitPerPVExceeded: 23,
	    MissingRequiredFieldSpecification: 24,
	    NavigationTimingNotSupported: 25,
	    OnError: 26,
	    SessionRenewalDateIsZero: 27,
	    SenderNotInitialized: 28,
	    StartTrackEventFailed: 29,
	    StopTrackEventFailed: 30,
	    StartTrackFailed: 31,
	    StopTrackFailed: 32,
	    TelemetrySampledAndNotSent: 33,
	    TrackEventFailed: 34,
	    TrackExceptionFailed: 35,
	    TrackMetricFailed: 36,
	    TrackPVFailed: 37,
	    TrackPVFailedCalc: 38,
	    TrackTraceFailed: 39,
	    TransmissionFailed: 40,
	    FailedToSetStorageBuffer: 41,
	    FailedToRestoreStorageBuffer: 42,
	    InvalidBackendResponse: 43,
	    FailedToFixDepricatedValues: 44,
	    InvalidDurationValue: 45,
	    TelemetryEnvelopeInvalid: 46,
	    CreateEnvelopeError: 47,
	    // User actionable
	    CannotSerializeObject: 48,
	    CannotSerializeObjectNonSerializable: 49,
	    CircularReferenceDetected: 50,
	    ClearAuthContextFailed: 51,
	    ExceptionTruncated: 52,
	    IllegalCharsInName: 53,
	    ItemNotInArray: 54,
	    MaxAjaxPerPVExceeded: 55,
	    MessageTruncated: 56,
	    NameTooLong: 57,
	    SampleRateOutOfRange: 58,
	    SetAuthContextFailed: 59,
	    SetAuthContextFailedAccountName: 60,
	    StringValueTooLong: 61,
	    StartCalledMoreThanOnce: 62,
	    StopCalledWithoutStart: 63,
	    TelemetryInitializerFailed: 64,
	    TrackArgumentsNotSpecified: 65,
	    UrlTooLong: 66,
	    SessionStorageBufferFull: 67,
	    CannotAccessCookie: 68,
	    IdTooLong: 69,
	    InvalidEvent: 70,
	    FailedMonitorAjaxSetRequestHeader: 71
	};

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var _InternalLogMessage = /** @class */ (function () {
	    function _InternalLogMessage(msgId, msg, isUserAct, properties) {
	        if (isUserAct === void 0) { isUserAct = false; }
	        this.messageId = msgId;
	        this.message =
	            (isUserAct ? _InternalLogMessage.AiUserActionablePrefix : _InternalLogMessage.AiNonUserActionablePrefix) +
	                msgId;
	        var diagnosticText = (msg ? " message:" + _InternalLogMessage.sanitizeDiagnosticText(msg) : "") +
	            (properties ? " props:" + _InternalLogMessage.sanitizeDiagnosticText(JSON.stringify(properties)) : "");
	        this.message += diagnosticText;
	    }
	    _InternalLogMessage.sanitizeDiagnosticText = function (text) {
	        return "\"" + text.replace(/\"/g, "") + "\"";
	    };
	    _InternalLogMessage.dataType = "MessageData";
	    /**
	     * For user non actionable traces use AI Internal prefix.
	     */
	    _InternalLogMessage.AiNonUserActionablePrefix = "AI (Internal): ";
	    /**
	     * Prefix of the traces in portal.
	     */
	    _InternalLogMessage.AiUserActionablePrefix = "AI: ";
	    return _InternalLogMessage;
	}());
	var DiagnosticLogger = /** @class */ (function () {
	    function DiagnosticLogger(config) {
	        /**
	        *  Session storage key for the prefix for the key indicating message type already logged
	        */
	        this.AIInternalMessagePrefix = "AITR_";
	        /**
	         * When this is true the SDK will throw exceptions to aid in debugging.
	         */
	        this.enableDebugExceptions = function () { return false; };
	        /**
	         * 0: OFF (default)
	         * 1: CRITICAL
	         * 2: >= WARNING
	         */
	        this.consoleLoggingLevel = function () { return 0; };
	        /**
	         * 0: OFF
	         * 1: CRITICAL (default)
	         * 2: >= WARNING
	         */
	        this.telemetryLoggingLevel = function () { return 1; };
	        /**
	         * The maximum number of internal messages allowed to be sent per page view
	         */
	        this.maxInternalMessageLimit = function () { return 25; };
	        /**
	         * The internal logging queue
	         */
	        this.queue = [];
	        /**
	         * Count of internal messages sent
	         */
	        this._messageCount = 0;
	        /**
	         * Holds information about what message types were already logged to console or sent to server.
	         */
	        this._messageLogged = {};
	        if (CoreUtils.isNullOrUndefined(config)) {
	            // TODO: Use default config
	            // config = AppInsightsCore.defaultConfig;
	            // For now, use defaults specified in DiagnosticLogger members;
	            return;
	        }
	        if (!CoreUtils.isNullOrUndefined(config.loggingLevelConsole)) {
	            this.consoleLoggingLevel = function () { return config.loggingLevelConsole; };
	        }
	        if (!CoreUtils.isNullOrUndefined(config.loggingLevelTelemetry)) {
	            this.telemetryLoggingLevel = function () { return config.loggingLevelTelemetry; };
	        }
	        if (!CoreUtils.isNullOrUndefined(config.maxMessageLimit)) {
	            this.maxInternalMessageLimit = function () { return config.maxMessageLimit; };
	        }
	        if (!CoreUtils.isNullOrUndefined(config.enableDebugExceptions)) {
	            this.enableDebugExceptions = function () { return config.enableDebugExceptions; };
	        }
	    }
	    /**
	     * This method will throw exceptions in debug mode or attempt to log the error as a console warning.
	     * @param severity {LoggingSeverity} - The severity of the log message
	     * @param message {_InternalLogMessage} - The log message.
	     */
	    DiagnosticLogger.prototype.throwInternal = function (severity, msgId, msg, properties, isUserAct) {
	        if (isUserAct === void 0) { isUserAct = false; }
	        var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
	        if (this.enableDebugExceptions()) {
	            throw message;
	        }
	        else {
	            if (typeof (message) !== "undefined" && !!message) {
	                if (typeof (message.message) !== "undefined") {
	                    if (isUserAct) {
	                        // check if this message type was already logged to console for this page view and if so, don't log it again
	                        var messageKey = +message.messageId;
	                        if (!this._messageLogged[messageKey] || this.consoleLoggingLevel() >= LoggingSeverity.WARNING) {
	                            this.warnToConsole(message.message);
	                            this._messageLogged[messageKey] = true;
	                        }
	                    }
	                    else {
	                        // don't log internal AI traces in the console, unless the verbose logging is enabled
	                        if (this.consoleLoggingLevel() >= LoggingSeverity.WARNING) {
	                            this.warnToConsole(message.message);
	                        }
	                    }
	                    this.logInternalMessage(severity, message);
	                }
	            }
	        }
	    };
	    /**
	     * This will write a warning to the console if possible
	     * @param message {string} - The warning message
	     */
	    DiagnosticLogger.prototype.warnToConsole = function (message) {
	        if (typeof console !== "undefined" && !!console) {
	            if (typeof console.warn === "function") {
	                console.warn(message);
	            }
	            else if (typeof console.log === "function") {
	                console.log(message);
	            }
	        }
	    };
	    /**
	     * Resets the internal message count
	     */
	    DiagnosticLogger.prototype.resetInternalMessageCount = function () {
	        this._messageCount = 0;
	        this._messageLogged = {};
	    };
	    /**
	     * Logs a message to the internal queue.
	     * @param severity {LoggingSeverity} - The severity of the log message
	     * @param message {_InternalLogMessage} - The message to log.
	     */
	    DiagnosticLogger.prototype.logInternalMessage = function (severity, message) {
	        if (this._areInternalMessagesThrottled()) {
	            return;
	        }
	        // check if this message type was already logged for this session and if so, don't log it again
	        var logMessage = true;
	        var messageKey = this.AIInternalMessagePrefix + message.messageId;
	        // if the session storage is not available, limit to only one message type per page view
	        if (this._messageLogged[messageKey]) {
	            logMessage = false;
	        }
	        else {
	            this._messageLogged[messageKey] = true;
	        }
	        if (logMessage) {
	            // Push the event in the internal queue
	            if (severity <= this.telemetryLoggingLevel()) {
	                this.queue.push(message);
	                this._messageCount++;
	            }
	            // When throttle limit reached, send a special event
	            if (this._messageCount == this.maxInternalMessageLimit()) {
	                var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
	                var throttleMessage = new _InternalLogMessage(_InternalMessageId.MessageLimitPerPVExceeded, throttleLimitMessage, false);
	                this.queue.push(throttleMessage);
	                this.warnToConsole(throttleLimitMessage);
	            }
	        }
	    };
	    /**
	     * Indicates whether the internal events are throttled
	     */
	    DiagnosticLogger.prototype._areInternalMessagesThrottled = function () {
	        return this._messageCount >= this.maxInternalMessageLimit();
	    };
	    return DiagnosticLogger;
	}());

	var ChannelControllerPriority = 500;
	var ChannelValidationMessage = "Channel has invalid priority";
	var ChannelController = /** @class */ (function () {
	    function ChannelController() {
	        this.identifier = "ChannelControllerPlugin";
	        this.priority = ChannelControllerPriority; // in reserved range 100 to 200
	    }
	    ChannelController.prototype.processTelemetry = function (item) {
	        this.channelQueue.forEach(function (queues) {
	            // pass on to first item in queue
	            if (queues.length > 0) {
	                queues[0].processTelemetry(item);
	            }
	        });
	    };
	    Object.defineProperty(ChannelController.prototype, "ChannelControls", {
	        get: function () {
	            return this.channelQueue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ChannelController.prototype.initialize = function (config, core, extensions) {
	        var _this = this;
	        if (config.isCookieUseDisabled) {
	            CoreUtils.disableCookies();
	        }
	        this.channelQueue = new Array();
	        if (config.channels) {
	            var invalidChannelIdentifier_1 = undefined;
	            config.channels.forEach(function (queue) {
	                if (queue && queue.length > 0) {
	                    queue = queue.sort(function (a, b) {
	                        return a.priority - b.priority;
	                    });
	                    for (var i = 1; i < queue.length; i++) {
	                        queue[i - 1].setNextPlugin(queue[i]); // setup processing chain
	                    }
	                    // Initialize each plugin
	                    queue.forEach(function (queueItem) {
	                        if (queueItem.priority < ChannelControllerPriority) {
	                            invalidChannelIdentifier_1 = queueItem.identifier;
	                        }
	                        queueItem.initialize(config, core, extensions);
	                    });
	                    if (invalidChannelIdentifier_1) {
	                        throw Error(ChannelValidationMessage + invalidChannelIdentifier_1);
	                    }
	                    _this.channelQueue.push(queue);
	                }
	            });
	        }
	        var arr = new Array();
	        for (var i = 0; i < extensions.length; i++) {
	            var plugin = extensions[i];
	            if (plugin.priority > ChannelControllerPriority) {
	                arr.push(plugin);
	            }
	        }
	        if (arr.length > 0) {
	            // sort if not sorted
	            arr = arr.sort(function (a, b) {
	                return a.priority - b.priority;
	            });
	            // setup next plugin
	            for (var i = 1; i < arr.length; i++) {
	                arr[i - 1].setNextPlugin(arr[i]);
	            }
	            // Initialize each plugin
	            arr.forEach(function (queueItem) { return queueItem.initialize(config, core, extensions); });
	            this.channelQueue.push(arr);
	        }
	    };
	    return ChannelController;
	}());

	var validationError = "Extensions must provide callback to initialize";
	var AppInsightsCore = /** @class */ (function () {
	    function AppInsightsCore() {
	        this._isInitialized = false;
	        this._extensions = new Array();
	        this._channelController = new ChannelController();
	    }
	    AppInsightsCore.prototype.initialize = function (config, extensions) {
	        var _this = this;
	        // Make sure core is only initialized once
	        if (this._isInitialized) {
	            throw Error("Core should not be initialized more than once");
	        }
	        if (!config || CoreUtils.isNullOrUndefined(config.instrumentationKey)) {
	            throw Error("Please provide instrumentation key");
	        }
	        this.config = config;
	        this._notificationManager = new NotificationManager();
	        this.config.extensions = CoreUtils.isNullOrUndefined(this.config.extensions) ? [] : this.config.extensions;
	        // add notification to the extensions in the config so other plugins can access it
	        this.config.extensionConfig = CoreUtils.isNullOrUndefined(this.config.extensionConfig) ? {} : this.config.extensionConfig;
	        this.config.extensionConfig.NotificationManager = this._notificationManager;
	        this.logger = new DiagnosticLogger(config);
	        // Concat all available extensions 
	        (_a = this._extensions).push.apply(_a, extensions.concat(this.config.extensions));
	        // Initial validation 
	        this._extensions.forEach(function (extension) {
	            var isValid = true;
	            if (CoreUtils.isNullOrUndefined(extension) || CoreUtils.isNullOrUndefined(extension.initialize)) {
	                isValid = false;
	            }
	            if (!isValid) {
	                throw Error(validationError);
	            }
	        });
	        // Initial validation complete
	        this._extensions.push(this._channelController);
	        // Sort by priority
	        this._extensions = this._extensions.sort(function (a, b) {
	            var extA = a;
	            var extB = b;
	            var typeExtA = typeof extA.processTelemetry;
	            var typeExtB = typeof extB.processTelemetry;
	            if (typeExtA === 'function' && typeExtB === 'function') {
	                return extA.priority - extB.priority;
	            }
	            if (typeExtA === 'function' && typeExtB !== 'function') {
	                // keep non telemetryplugin specific extensions at start
	                return 1;
	            }
	            if (typeExtA !== 'function' && typeExtB === 'function') {
	                return -1;
	            }
	        });
	        // sort complete
	        // Check if any two extensions have the same priority, then warn to console
	        var priority = {};
	        this._extensions.forEach(function (ext) {
	            var t = ext;
	            if (t && t.priority) {
	                if (!CoreUtils.isNullOrUndefined(priority[t.priority])) {
	                    _this.logger.warnToConsole("Two extensions have same priority" + priority[t.priority] + ", " + t.identifier);
	                }
	                else {
	                    priority[t.priority] = t.identifier; // set a value
	                }
	            }
	        });
	        var c = -1;
	        // Set next plugin for all until channel controller
	        for (var idx = 0; idx < this._extensions.length - 1; idx++) {
	            var curr = (this._extensions[idx]);
	            if (curr && typeof curr.processTelemetry !== 'function') {
	                // these are initialized only, allowing an entry point for extensions to be initialized when SDK initializes
	                continue;
	            }
	            if (curr.priority === this._channelController.priority) {
	                c = idx + 1;
	                break; // channel controller will set remaining pipeline
	            }
	            this._extensions[idx].setNextPlugin(this._extensions[idx + 1]); // set next plugin
	        }
	        // initialize channel controller first, this will initialize all channel plugins
	        this._channelController.initialize(this.config, this, this._extensions);
	        // initialize remaining regular plugins
	        this._extensions.forEach(function (ext) {
	            var e = ext;
	            if (e && e.priority < _this._channelController.priority) {
	                ext.initialize(_this.config, _this, _this._extensions); // initialize
	            }
	        });
	        // Remove sender channels from main list
	        if (c < this._extensions.length) {
	            this._extensions.splice(c);
	        }
	        if (this.getTransmissionControls().length === 0) {
	            throw new Error("No channels available");
	        }
	        this._isInitialized = true;
	        var _a;
	    };
	    AppInsightsCore.prototype.getTransmissionControls = function () {
	        return this._channelController.ChannelControls;
	    };
	    AppInsightsCore.prototype.track = function (telemetryItem) {
	        if (telemetryItem === null) {
	            this._notifyInvalidEvent(telemetryItem);
	            // throw error
	            throw Error("Invalid telemetry item");
	        }
	        if (!telemetryItem.iKey) {
	            // setup default iKey if not passed in
	            telemetryItem.iKey = this.config.instrumentationKey;
	        }
	        if (!telemetryItem.time) {
	            // add default timestamp if not passed in
	            telemetryItem.time = new Date().toISOString();
	        }
	        if (CoreUtils.isNullOrUndefined(telemetryItem.ver)) {
	            // CommonSchema 4.0
	            telemetryItem.ver = "4.0";
	        }
	        // do basic validation before sending it through the pipeline
	        this._validateTelmetryItem(telemetryItem);
	        // invoke any common telemetry processors before sending through pipeline
	        if (this._extensions.length == 0) {
	            this._channelController.processTelemetry(telemetryItem); // Pass to Channel controller so data is sent to correct channel queues
	        }
	        var i = 0;
	        while (i < this._extensions.length) {
	            if (this._extensions[i].processTelemetry) {
	                this._extensions[i].processTelemetry(telemetryItem); // pass on to first extension that can support processing
	                break;
	            }
	            i++;
	        }
	    };
	    /**
	     * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.
	     * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be
	     * called.
	     * @param {INotificationListener} listener - An INotificationListener object.
	     */
	    AppInsightsCore.prototype.addNotificationListener = function (listener) {
	        this._notificationManager.addNotificationListener(listener);
	    };
	    /**
	     * Removes all instances of the listener.
	     * @param {INotificationListener} listener - INotificationListener to remove.
	     */
	    AppInsightsCore.prototype.removeNotificationListener = function (listener) {
	        this._notificationManager.removeNotificationListener(listener);
	    };
	    /**
	     * Periodically check logger.queue for
	     */
	    AppInsightsCore.prototype.pollInternalLogs = function (eventName) {
	        var _this = this;
	        var interval = this.config.diagnosticLogInterval;
	        if (!(interval > 0)) {
	            interval = 10000;
	        }
	        return setInterval(function () {
	            var queue = _this.logger.queue;
	            queue.forEach(function (logMessage) {
	                var item = {
	                    name: eventName ? eventName : "InternalMessageId: " + logMessage.messageId,
	                    iKey: _this.config.instrumentationKey,
	                    time: new Date().toISOString(),
	                    baseType: _InternalLogMessage.dataType,
	                    baseData: { message: logMessage.message }
	                };
	                _this.track(item);
	            });
	            queue.length = 0;
	        }, interval);
	    };
	    AppInsightsCore.prototype._validateTelmetryItem = function (telemetryItem) {
	        if (CoreUtils.isNullOrUndefined(telemetryItem.name)) {
	            this._notifyInvalidEvent(telemetryItem);
	            throw Error("telemetry name required");
	        }
	        if (CoreUtils.isNullOrUndefined(telemetryItem.time)) {
	            this._notifyInvalidEvent(telemetryItem);
	            throw Error("telemetry timestamp required");
	        }
	        if (CoreUtils.isNullOrUndefined(telemetryItem.iKey)) {
	            this._notifyInvalidEvent(telemetryItem);
	            throw Error("telemetry instrumentationKey required");
	        }
	    };
	    AppInsightsCore.prototype._notifyInvalidEvent = function (telemetryItem) {
	        this._notificationManager.eventsDiscarded([telemetryItem], EventsDiscardedReason.InvalidEvent);
	    };
	    return AppInsightsCore;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var RequestHeaders = /** @class */ (function () {
	    function RequestHeaders() {
	    }
	    /**
	     * Request-Context header
	     */
	    RequestHeaders.requestContextHeader = "Request-Context";
	    /**
	     * Target instrumentation header that is added to the response and retrieved by the
	     * calling application when processing incoming responses.
	     */
	    RequestHeaders.requestContextTargetKey = "appId";
	    /**
	     * Request-Context appId format
	     */
	    RequestHeaders.requestContextAppIdFormat = "appId=cid-v1:";
	    /**
	     * Request-Id header
	     */
	    RequestHeaders.requestIdHeader = "Request-Id";
	    /**
	     * W3C distributed tracing protocol header
	     */
	    RequestHeaders.traceParentHeader = "traceparent";
	    /**
	     * Sdk-Context header
	     * If this header passed with appId in content then appId will be returned back by the backend.
	     */
	    RequestHeaders.sdkContextHeader = "Sdk-Context";
	    /**
	     * String to pass in header for requesting appId back from the backend.
	     */
	    RequestHeaders.sdkContextHeaderAppIdRequest = "appId";
	    RequestHeaders.requestContextHeaderLowerCase = "request-context";
	    return RequestHeaders;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var DataSanitizer = /** @class */ (function () {
	    function DataSanitizer() {
	    }
	    DataSanitizer.sanitizeKeyAndAddUniqueness = function (logger, key, map) {
	        var origLength = key.length;
	        var field = DataSanitizer.sanitizeKey(logger, key);
	        // validation truncated the length.  We need to add uniqueness
	        if (field.length !== origLength) {
	            var i = 0;
	            var uniqueField = field;
	            while (map[uniqueField] !== undefined) {
	                i++;
	                uniqueField = field.substring(0, DataSanitizer.MAX_NAME_LENGTH - 3) + DataSanitizer.padNumber(i);
	            }
	            field = uniqueField;
	        }
	        return field;
	    };
	    DataSanitizer.sanitizeKey = function (logger, name) {
	        var nameTrunc;
	        if (name) {
	            // Remove any leading or trailing whitepace
	            name = DataSanitizer.trim(name.toString());
	            // truncate the string to 150 chars
	            if (name.length > DataSanitizer.MAX_NAME_LENGTH) {
	                nameTrunc = name.substring(0, DataSanitizer.MAX_NAME_LENGTH);
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.NameTooLong, "name is too long.  It has been truncated to " + DataSanitizer.MAX_NAME_LENGTH + " characters.", { name: name }, true);
	            }
	        }
	        return nameTrunc || name;
	    };
	    DataSanitizer.sanitizeString = function (logger, value, maxLength) {
	        if (maxLength === void 0) { maxLength = DataSanitizer.MAX_STRING_LENGTH; }
	        var valueTrunc;
	        if (value) {
	            maxLength = maxLength ? maxLength : DataSanitizer.MAX_STRING_LENGTH; // in case default parameters dont work
	            value = DataSanitizer.trim(value);
	            if (value.toString().length > maxLength) {
	                valueTrunc = value.toString().substring(0, maxLength);
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.StringValueTooLong, "string value is too long. It has been truncated to " + maxLength + " characters.", { value: value }, true);
	            }
	        }
	        return valueTrunc || value;
	    };
	    DataSanitizer.sanitizeUrl = function (logger, url) {
	        return DataSanitizer.sanitizeInput(logger, url, DataSanitizer.MAX_URL_LENGTH, _InternalMessageId.UrlTooLong);
	    };
	    DataSanitizer.sanitizeMessage = function (logger, message) {
	        var messageTrunc;
	        if (message) {
	            if (message.length > DataSanitizer.MAX_MESSAGE_LENGTH) {
	                messageTrunc = message.substring(0, DataSanitizer.MAX_MESSAGE_LENGTH);
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.MessageTruncated, "message is too long, it has been truncated to " + DataSanitizer.MAX_MESSAGE_LENGTH + " characters.", { message: message }, true);
	            }
	        }
	        return messageTrunc || message;
	    };
	    DataSanitizer.sanitizeException = function (logger, exception) {
	        var exceptionTrunc;
	        if (exception) {
	            if (exception.length > DataSanitizer.MAX_EXCEPTION_LENGTH) {
	                exceptionTrunc = exception.substring(0, DataSanitizer.MAX_EXCEPTION_LENGTH);
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.ExceptionTruncated, "exception is too long, it has been truncated to " + DataSanitizer.MAX_EXCEPTION_LENGTH + " characters.", { exception: exception }, true);
	            }
	        }
	        return exceptionTrunc || exception;
	    };
	    DataSanitizer.sanitizeProperties = function (logger, properties) {
	        if (properties) {
	            var tempProps = {};
	            for (var prop in properties) {
	                var value = properties[prop];
	                if (typeof value === "object" && typeof JSON !== "undefined") {
	                    // Stringify any part C properties
	                    try {
	                        value = JSON.stringify(value);
	                    }
	                    catch (e) {
	                        logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CannotSerializeObjectNonSerializable, "custom property is not valid", { exception: e }, true);
	                    }
	                }
	                value = DataSanitizer.sanitizeString(logger, value, DataSanitizer.MAX_PROPERTY_LENGTH);
	                prop = DataSanitizer.sanitizeKeyAndAddUniqueness(logger, prop, tempProps);
	                tempProps[prop] = value;
	            }
	            properties = tempProps;
	        }
	        return properties;
	    };
	    DataSanitizer.sanitizeMeasurements = function (logger, measurements) {
	        if (measurements) {
	            var tempMeasurements = {};
	            for (var measure in measurements) {
	                var value = measurements[measure];
	                measure = DataSanitizer.sanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements);
	                tempMeasurements[measure] = value;
	            }
	            measurements = tempMeasurements;
	        }
	        return measurements;
	    };
	    DataSanitizer.sanitizeId = function (logger, id) {
	        return id ? DataSanitizer.sanitizeInput(logger, id, DataSanitizer.MAX_ID_LENGTH, _InternalMessageId.IdTooLong).toString() : id;
	    };
	    DataSanitizer.sanitizeInput = function (logger, input, maxLength, _msgId) {
	        var inputTrunc;
	        if (input) {
	            input = DataSanitizer.trim(input);
	            if (input.length > maxLength) {
	                inputTrunc = input.substring(0, maxLength);
	                logger.throwInternal(LoggingSeverity.WARNING, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
	            }
	        }
	        return inputTrunc || input;
	    };
	    DataSanitizer.padNumber = function (num) {
	        var s = "00" + num;
	        return s.substr(s.length - 3);
	    };
	    /**
	     * helper method to trim strings (IE8 does not implement String.prototype.trim)
	     */
	    DataSanitizer.trim = function (str) {
	        if (typeof str !== "string")
	            return str;
	        return str.replace(/^\s+|\s+$/g, "");
	    };
	    /**
	    * Max length allowed for custom names.
	    */
	    DataSanitizer.MAX_NAME_LENGTH = 150;
	    /**
	     * Max length allowed for Id field in page views.
	     */
	    DataSanitizer.MAX_ID_LENGTH = 128;
	    /**
	     * Max length allowed for custom values.
	     */
	    DataSanitizer.MAX_PROPERTY_LENGTH = 8192;
	    /**
	     * Max length allowed for names
	     */
	    DataSanitizer.MAX_STRING_LENGTH = 1024;
	    /**
	     * Max length allowed for url.
	     */
	    DataSanitizer.MAX_URL_LENGTH = 2048;
	    /**
	     * Max length allowed for messages.
	     */
	    DataSanitizer.MAX_MESSAGE_LENGTH = 32768;
	    /**
	     * Max length allowed for exceptions.
	     */
	    DataSanitizer.MAX_EXCEPTION_LENGTH = 32768;
	    return DataSanitizer;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Util = /** @class */ (function () {
	    function Util() {
	    }
	    Util.createDomEvent = function (eventName) {
	        var event = null;
	        if (typeof Event === "function") {
	            event = new Event(eventName);
	        }
	        else {
	            event = document.createEvent("Event");
	            event.initEvent(eventName, true, true);
	        }
	        return event;
	    };
	    /*
	     * Force the SDK not to use local and session storage
	    */
	    Util.disableStorage = function () {
	        Util._canUseLocalStorage = false;
	        Util._canUseSessionStorage = false;
	    };
	    /**
	     * Gets the localStorage object if available
	     * @return {Storage} - Returns the storage object if available else returns null
	     */
	    Util._getLocalStorageObject = function () {
	        if (Util.canUseLocalStorage()) {
	            return Util._getVerifiedStorageObject(StorageType.LocalStorage);
	        }
	        return null;
	    };
	    /**
	     * Tests storage object (localStorage or sessionStorage) to verify that it is usable
	     * More details here: https://mathiasbynens.be/notes/localstorage-pattern
	     * @param storageType Type of storage
	     * @return {Storage} Returns storage object verified that it is usable
	     */
	    Util._getVerifiedStorageObject = function (storageType) {
	        var storage = null;
	        var fail;
	        var uid;
	        try {
	            if (typeof window === 'undefined') {
	                return null;
	            }
	            uid = new Date;
	            storage = storageType === StorageType.LocalStorage ? window.localStorage : window.sessionStorage;
	            storage.setItem(uid, uid);
	            fail = storage.getItem(uid) != uid;
	            storage.removeItem(uid);
	            if (fail) {
	                storage = null;
	            }
	        }
	        catch (exception) {
	            storage = null;
	        }
	        return storage;
	    };
	    /**
	     *  Checks if endpoint URL is application insights internal injestion service URL.
	     *
	     *  @param endpointUrl Endpoint URL to check.
	     *  @returns {boolean} True if if endpoint URL is application insights internal injestion service URL.
	     */
	    Util.isInternalApplicationInsightsEndpoint = function (endpointUrl) {
	        return Util._internalEndpoints.indexOf(endpointUrl.toLowerCase()) !== -1;
	    };
	    /**
	     *  Check if the browser supports local storage.
	     *
	     *  @returns {boolean} True if local storage is supported.
	     */
	    Util.canUseLocalStorage = function () {
	        if (Util._canUseLocalStorage === undefined) {
	            Util._canUseLocalStorage = !!Util._getVerifiedStorageObject(StorageType.LocalStorage);
	        }
	        return Util._canUseLocalStorage;
	    };
	    /**
	     *  Get an object from the browser's local storage
	     *
	     *  @param {string} name - the name of the object to get from storage
	     *  @returns {string} The contents of the storage object with the given name. Null if storage is not supported.
	     */
	    Util.getStorage = function (logger, name) {
	        var storage = Util._getLocalStorageObject();
	        if (storage !== null) {
	            try {
	                return storage.getItem(name);
	            }
	            catch (e) {
	                Util._canUseLocalStorage = false;
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotReadLocalStorage, "Browser failed read of local storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        return null;
	    };
	    /**
	     *  Set the contents of an object in the browser's local storage
	     *
	     *  @param {string} name - the name of the object to set in storage
	     *  @param {string} data - the contents of the object to set in storage
	     *  @returns {boolean} True if the storage object could be written.
	     */
	    Util.setStorage = function (logger, name, data) {
	        var storage = Util._getLocalStorageObject();
	        if (storage !== null) {
	            try {
	                storage.setItem(name, data);
	                return true;
	            }
	            catch (e) {
	                Util._canUseLocalStorage = false;
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotWriteLocalStorage, "Browser failed write to local storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        return false;
	    };
	    /**
	     *  Remove an object from the browser's local storage
	     *
	     *  @param {string} name - the name of the object to remove from storage
	     *  @returns {boolean} True if the storage object could be removed.
	     */
	    Util.removeStorage = function (logger, name) {
	        var storage = Util._getLocalStorageObject();
	        if (storage !== null) {
	            try {
	                storage.removeItem(name);
	                return true;
	            }
	            catch (e) {
	                Util._canUseLocalStorage = false;
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserFailedRemovalFromLocalStorage, "Browser failed removal of local storage item. " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        return false;
	    };
	    /**
	     * Gets the sessionStorage object if available
	     * @return {Storage} - Returns the storage object if available else returns null
	     */
	    Util._getSessionStorageObject = function () {
	        if (Util.canUseSessionStorage()) {
	            return Util._getVerifiedStorageObject(StorageType.SessionStorage);
	        }
	        return null;
	    };
	    /**
	     *  Check if the browser supports session storage.
	     *
	     *  @returns {boolean} True if session storage is supported.
	     */
	    Util.canUseSessionStorage = function () {
	        if (Util._canUseSessionStorage === undefined) {
	            Util._canUseSessionStorage = !!Util._getVerifiedStorageObject(StorageType.SessionStorage);
	        }
	        return Util._canUseSessionStorage;
	    };
	    /**
	     *  Gets the list of session storage keys
	     *
	     *  @returns {string[]} List of session storage keys
	     */
	    Util.getSessionStorageKeys = function () {
	        var keys = [];
	        if (Util.canUseSessionStorage()) {
	            for (var key in window.sessionStorage) {
	                keys.push(key);
	            }
	        }
	        return keys;
	    };
	    /**
	     *  Get an object from the browser's session storage
	     *
	     *  @param {string} name - the name of the object to get from storage
	     *  @returns {string} The contents of the storage object with the given name. Null if storage is not supported.
	     */
	    Util.getSessionStorage = function (logger, name) {
	        var storage = Util._getSessionStorageObject();
	        if (storage !== null) {
	            try {
	                return storage.getItem(name);
	            }
	            catch (e) {
	                Util._canUseSessionStorage = false;
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotReadSessionStorage, "Browser failed read of session storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        return null;
	    };
	    /**
	     *  Set the contents of an object in the browser's session storage
	     *
	     *  @param {string} name - the name of the object to set in storage
	     *  @param {string} data - the contents of the object to set in storage
	     *  @returns {boolean} True if the storage object could be written.
	     */
	    Util.setSessionStorage = function (logger, name, data) {
	        var storage = Util._getSessionStorageObject();
	        if (storage !== null) {
	            try {
	                storage.setItem(name, data);
	                return true;
	            }
	            catch (e) {
	                Util._canUseSessionStorage = false;
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotWriteSessionStorage, "Browser failed write to session storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        return false;
	    };
	    /**
	     *  Remove an object from the browser's session storage
	     *
	     *  @param {string} name - the name of the object to remove from storage
	     *  @returns {boolean} True if the storage object could be removed.
	     */
	    Util.removeSessionStorage = function (logger, name) {
	        var storage = Util._getSessionStorageObject();
	        if (storage !== null) {
	            try {
	                storage.removeItem(name);
	                return true;
	            }
	            catch (e) {
	                Util._canUseSessionStorage = false;
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserFailedRemovalFromSessionStorage, "Browser failed removal of session storage item. " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        return false;
	    };
	    /*
	     * Force the SDK not to store and read any data from cookies
	     */
	    Util.disableCookies = function () {
	        CoreUtils.disableCookies();
	    };
	    /*
	     * helper method to tell if document.cookie object is available
	     */
	    Util.canUseCookies = function (logger) {
	        if (CoreUtils._canUseCookies === undefined) {
	            CoreUtils._canUseCookies = false;
	            try {
	                CoreUtils._canUseCookies = Util.document.cookie !== undefined;
	            }
	            catch (e) {
	                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CannotAccessCookie, "Cannot access document.cookie - " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        return CoreUtils._canUseCookies;
	    };
	    /**
	     * helper method to set userId and sessionId cookie
	     */
	    Util.setCookie = function (logger, name, value, domain) {
	        var domainAttrib = "";
	        var secureAttrib = "";
	        if (domain) {
	            domainAttrib = ";domain=" + domain;
	        }
	        if (Util.document.location && Util.document.location.protocol === "https:") {
	            secureAttrib = ";secure";
	        }
	        if (Util.canUseCookies(logger)) {
	            Util.document.cookie = name + "=" + value + domainAttrib + ";path=/" + secureAttrib;
	        }
	    };
	    Util.stringToBoolOrDefault = function (str, defaultValue) {
	        if (defaultValue === void 0) { defaultValue = false; }
	        if (str === undefined || str === null) {
	            return defaultValue;
	        }
	        return str.toString().toLowerCase() === "true";
	    };
	    /**
	     * helper method to access userId and sessionId cookie
	     */
	    Util.getCookie = function (logger, name) {
	        if (!Util.canUseCookies(logger)) {
	            return;
	        }
	        var value = "";
	        if (name && name.length) {
	            var cookieName = name + "=";
	            var cookies = Util.document.cookie.split(";");
	            for (var i = 0; i < cookies.length; i++) {
	                var cookie = cookies[i];
	                cookie = Util.trim(cookie);
	                if (cookie && cookie.indexOf(cookieName) === 0) {
	                    value = cookie.substring(cookieName.length, cookies[i].length);
	                    break;
	                }
	            }
	        }
	        return value;
	    };
	    /**
	     * Deletes a cookie by setting it's expiration time in the past.
	     * @param name - The name of the cookie to delete.
	     */
	    Util.deleteCookie = function (logger, name) {
	        if (Util.canUseCookies(logger)) {
	            // Setting the expiration date in the past immediately removes the cookie
	            Util.document.cookie = name + "=;path=/;expires=Thu, 01 Jan 1970 00:00:01 GMT;";
	        }
	    };
	    /**
	     * helper method to trim strings (IE8 does not implement String.prototype.trim)
	     */
	    Util.trim = function (str) {
	        if (typeof str !== "string")
	            return str;
	        return str.replace(/^\s+|\s+$/g, "");
	    };
	    /**
	     * generate random id string
	     */
	    Util.newId = function () {
	        var base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	        var result = "";
	        // tslint:disable-next-line:insecure-random
	        var random = Math.random() * 1073741824; //5 symbols in base64, almost maxint
	        while (random > 0) {
	            var char = base64chars.charAt(random % 64);
	            result += char;
	            random = Math.floor(random / 64);
	        }
	        return result;
	    };
	    /**
	     * generate a random 32bit number (-0x80000000..0x7FFFFFFF).
	     */
	    Util.random32 = function () {
	        return (0x100000000 * Math.random()) | 0;
	    };
	    /**
	     * generate W3C trace id
	     */
	    Util.generateW3CId = function () {
	        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
	        // rfc4122 version 4 UUID without dashes and with lowercase letters
	        var oct = "", tmp;
	        for (var a = 0; a < 4; a++) {
	            tmp = Util.random32();
	            oct +=
	                hexValues[tmp & 0xF] +
	                    hexValues[tmp >> 4 & 0xF] +
	                    hexValues[tmp >> 8 & 0xF] +
	                    hexValues[tmp >> 12 & 0xF] +
	                    hexValues[tmp >> 16 & 0xF] +
	                    hexValues[tmp >> 20 & 0xF] +
	                    hexValues[tmp >> 24 & 0xF] +
	                    hexValues[tmp >> 28 & 0xF];
	        }
	        // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
	        var clockSequenceHi = hexValues[8 + (Math.random() * 4) | 0];
	        return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
	    };
	    /**
	     * Check if an object is of type Array
	     */
	    Util.isArray = function (obj) {
	        return Object.prototype.toString.call(obj) === "[object Array]";
	    };
	    /**
	     * Check if an object is of type Error
	     */
	    Util.isError = function (obj) {
	        return Object.prototype.toString.call(obj) === "[object Error]";
	    };
	    /**
	     * Check if an object is of type Date
	     */
	    Util.isDate = function (obj) {
	        return Object.prototype.toString.call(obj) === "[object Date]";
	    };
	    /**
	     * Convert a date to I.S.O. format in IE8
	     */
	    Util.toISOStringForIE8 = function (date) {
	        if (Util.isDate(date)) {
	            if (Date.prototype.toISOString) {
	                return date.toISOString();
	            }
	            else {
	                var pad = function (num) {
	                    var r = String(num);
	                    if (r.length === 1) {
	                        r = "0" + r;
	                    }
	                    return r;
	                };
	                return date.getUTCFullYear()
	                    + "-" + pad(date.getUTCMonth() + 1)
	                    + "-" + pad(date.getUTCDate())
	                    + "T" + pad(date.getUTCHours())
	                    + ":" + pad(date.getUTCMinutes())
	                    + ":" + pad(date.getUTCSeconds())
	                    + "." + String((date.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5)
	                    + "Z";
	            }
	        }
	    };
	    /**
	     * Gets IE version if we are running on IE, or null otherwise
	     */
	    Util.getIEVersion = function (userAgentStr) {
	        if (userAgentStr === void 0) { userAgentStr = null; }
	        var myNav = userAgentStr ? userAgentStr.toLowerCase() : navigator.userAgent.toLowerCase();
	        return (myNav.indexOf('msie') != -1) ? parseInt(myNav.split('msie')[1]) : null;
	    };
	    /**
	     * Convert ms to c# time span format
	     */
	    Util.msToTimeSpan = function (totalms) {
	        if (isNaN(totalms) || totalms < 0) {
	            totalms = 0;
	        }
	        totalms = Math.round(totalms);
	        var ms = "" + totalms % 1000;
	        var sec = "" + Math.floor(totalms / 1000) % 60;
	        var min = "" + Math.floor(totalms / (1000 * 60)) % 60;
	        var hour = "" + Math.floor(totalms / (1000 * 60 * 60)) % 24;
	        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
	        ms = ms.length === 1 ? "00" + ms : ms.length === 2 ? "0" + ms : ms;
	        sec = sec.length < 2 ? "0" + sec : sec;
	        min = min.length < 2 ? "0" + min : min;
	        hour = hour.length < 2 ? "0" + hour : hour;
	        return (days > 0 ? days + "." : "") + hour + ":" + min + ":" + sec + "." + ms;
	    };
	    /**
	    * Checks if error has no meaningful data inside. Ususally such errors are received by window.onerror when error
	    * happens in a script from other domain (cross origin, CORS).
	    */
	    Util.isCrossOriginError = function (message, url, lineNumber, columnNumber, error) {
	        return (message === "Script error." || message === "Script error") && !error;
	    };
	    /**
	    * Returns string representation of an object suitable for diagnostics logging.
	    */
	    Util.dump = function (object) {
	        var objectTypeDump = Object.prototype.toString.call(object);
	        var propertyValueDump = JSON.stringify(object);
	        if (objectTypeDump === "[object Error]") {
	            propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
	        }
	        return objectTypeDump + propertyValueDump;
	    };
	    /**
	    * Returns the name of object if it's an Error. Otherwise, returns empty string.
	    */
	    Util.getExceptionName = function (object) {
	        var objectTypeDump = Object.prototype.toString.call(object);
	        if (objectTypeDump === "[object Error]") {
	            return object.name;
	        }
	        return "";
	    };
	    /**
	     * Adds an event handler for the specified event
	     * @param eventName {string} - The name of the event
	     * @param callback {any} - The callback function that needs to be executed for the given event
	     * @return {boolean} - true if the handler was successfully added
	     */
	    Util.addEventHandler = function (eventName, callback) {
	        if (typeof window === 'undefined' || !window || typeof eventName !== 'string' || typeof callback !== 'function') {
	            return false;
	        }
	        // Create verb for the event
	        var verbEventName = 'on' + eventName;
	        // check if addEventListener is available
	        if (window.addEventListener) {
	            window.addEventListener(eventName, callback, false);
	        }
	        else if (window["attachEvent"]) {
	            window["attachEvent"](verbEventName, callback);
	        }
	        else {
	            return false;
	        }
	        return true;
	    };
	    /**
	     * Tells if a browser supports a Beacon API
	     */
	    Util.IsBeaconApiSupported = function () {
	        return ('sendBeacon' in navigator && navigator.sendBeacon);
	    };
	    Util.getExtension = function (extensions, identifier) {
	        var extension = null;
	        var extIx = 0;
	        while (!extension && extIx < extensions.length) {
	            if (extensions[extIx] && extensions[extIx].identifier === identifier) {
	                extension = extensions[extIx];
	            }
	            extIx++;
	        }
	        return extension;
	    };
	    Util.document = typeof document !== "undefined" ? document : {};
	    Util._canUseLocalStorage = undefined;
	    Util._canUseSessionStorage = undefined;
	    // listing only non-geo specific locations
	    Util._internalEndpoints = [
	        "https://dc.services.visualstudio.com/v2/track",
	        "https://breeze.aimon.applicationinsights.io/v2/track",
	        "https://dc-int.services.visualstudio.com/v2/track"
	    ];
	    Util.NotSpecified = "not_specified";
	    return Util;
	}());
	var UrlHelper = /** @class */ (function () {
	    function UrlHelper() {
	    }
	    UrlHelper.parseUrl = function (url) {
	        if (!UrlHelper.htmlAnchorElement) {
	            UrlHelper.htmlAnchorElement = !!UrlHelper.document.createElement ? UrlHelper.document.createElement('a') : { host: UrlHelper.parseHost(url) }; // fill host field in the fallback case as that is the only externally required field from this fn
	        }
	        UrlHelper.htmlAnchorElement.href = url;
	        return UrlHelper.htmlAnchorElement;
	    };
	    UrlHelper.getAbsoluteUrl = function (url) {
	        var result;
	        var a = UrlHelper.parseUrl(url);
	        if (a) {
	            result = a.href;
	        }
	        return result;
	    };
	    UrlHelper.getPathName = function (url) {
	        var result;
	        var a = UrlHelper.parseUrl(url);
	        if (a) {
	            result = a.pathname;
	        }
	        return result;
	    };
	    UrlHelper.getCompleteUrl = function (method, absoluteUrl) {
	        if (method) {
	            return method.toUpperCase() + " " + absoluteUrl;
	        }
	        else {
	            return absoluteUrl;
	        }
	    };
	    // Fallback method to grab host from url if document.createElement method is not available
	    UrlHelper.parseHost = function (url) {
	        var match = url.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/i);
	        if (match != null && match.length > 2 && typeof match[2] === 'string' && match[2].length > 0) {
	            return match[2];
	        }
	        else {
	            return null;
	        }
	    };
	    UrlHelper.document = typeof document !== "undefined" ? document : {};
	    return UrlHelper;
	}());
	var CorrelationIdHelper = /** @class */ (function () {
	    function CorrelationIdHelper() {
	    }
	    /**
	    * Checks if a request url is not on a excluded domain list and if it is safe to add correlation headers
	    */
	    CorrelationIdHelper.canIncludeCorrelationHeader = function (config, requestUrl, currentHost) {
	        if (config && config.disableCorrelationHeaders) {
	            return false;
	        }
	        if (!requestUrl) {
	            return false;
	        }
	        var requestHost = UrlHelper.parseUrl(requestUrl).host.toLowerCase();
	        if ((!config || !config.enableCorsCorrelation) && requestHost !== currentHost) {
	            return false;
	        }
	        var includedDomains = config && config.correlationHeaderDomains;
	        if (includedDomains) {
	            var matchExists_1;
	            includedDomains.forEach(function (domain) {
	                var regex = new RegExp(domain.toLowerCase().replace(/\./g, "\.").replace(/\*/g, ".*"));
	                matchExists_1 = matchExists_1 || regex.test(requestHost);
	            });
	            if (!matchExists_1) {
	                return false;
	            }
	        }
	        var excludedDomains = config && config.correlationHeaderExcludedDomains;
	        if (!excludedDomains || excludedDomains.length == 0) {
	            return true;
	        }
	        for (var i = 0; i < excludedDomains.length; i++) {
	            var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\./g, "\.").replace(/\*/g, ".*"));
	            if (regex.test(requestHost)) {
	                return false;
	            }
	        }
	        return true;
	    };
	    /**
	    * Combines target appId and target role name from response header.
	    */
	    CorrelationIdHelper.getCorrelationContext = function (responseHeader) {
	        if (responseHeader) {
	            var correlationId = CorrelationIdHelper.getCorrelationContextValue(responseHeader, RequestHeaders.requestContextTargetKey);
	            if (correlationId && correlationId !== CorrelationIdHelper.correlationIdPrefix) {
	                return correlationId;
	            }
	        }
	    };
	    /**
	    * Gets key from correlation response header
	    */
	    CorrelationIdHelper.getCorrelationContextValue = function (responseHeader, key) {
	        if (responseHeader) {
	            var keyValues = responseHeader.split(",");
	            for (var i = 0; i < keyValues.length; ++i) {
	                var keyValue = keyValues[i].split("=");
	                if (keyValue.length == 2 && keyValue[0] == key) {
	                    return keyValue[1];
	                }
	            }
	        }
	    };
	    CorrelationIdHelper.correlationIdPrefix = "cid-v1:";
	    return CorrelationIdHelper;
	}());
	var AjaxHelper = /** @class */ (function () {
	    function AjaxHelper() {
	    }
	    AjaxHelper.ParseDependencyPath = function (logger, absoluteUrl, method, commandName) {
	        var target, name = commandName, data = commandName;
	        if (absoluteUrl && absoluteUrl.length > 0) {
	            var parsedUrl = UrlHelper.parseUrl(absoluteUrl);
	            target = parsedUrl.host;
	            if (!name) {
	                if (parsedUrl.pathname != null) {
	                    var pathName = (parsedUrl.pathname.length === 0) ? "/" : parsedUrl.pathname;
	                    if (pathName.charAt(0) !== '/') {
	                        pathName = "/" + pathName;
	                    }
	                    data = parsedUrl.pathname;
	                    name = DataSanitizer.sanitizeString(logger, method ? method + " " + pathName : pathName);
	                }
	                else {
	                    name = DataSanitizer.sanitizeString(logger, absoluteUrl);
	                }
	            }
	        }
	        else {
	            target = commandName;
	            name = commandName;
	        }
	        return {
	            target: target,
	            name: name,
	            data: data
	        };
	    };
	    return AjaxHelper;
	}());
	/**
	 * A utility class that helps getting time related parameters
	 */
	var DateTimeUtils = /** @class */ (function () {
	    function DateTimeUtils() {
	    }
	    /**
	     * Get the number of milliseconds since 1970/01/01 in local timezone
	     */
	    DateTimeUtils.Now = (typeof window === 'undefined') ? function () { return new Date().getTime(); } :
	        (window.performance && window.performance.now && window.performance.timing) ?
	            function () {
	                return window.performance.now() + window.performance.timing.navigationStart;
	            }
	            :
	                function () {
	                    return new Date().getTime();
	                };
	    /**
	     * Gets duration between two timestamps
	     */
	    DateTimeUtils.GetDuration = function (start, end) {
	        var result = null;
	        if (start !== 0 && end !== 0 && !CoreUtils.isNullOrUndefined(start) && !CoreUtils.isNullOrUndefined(end)) {
	            result = end - start;
	        }
	        return result;
	    };
	    return DateTimeUtils;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
	var SampleRate = "sampleRate";
	var ProcessLegacy = "ProcessLegacy";
	var HttpMethod = "http.method";

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	// THIS FILE WAS AUTOGENERATED
	/**
	     * Data struct to contain only C section with custom fields.
	     */
	var Base = /** @class */ (function () {
	    function Base() {
	    }
	    return Base;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * Data struct to contain both B and C sections.
	 */
	var Data = /** @class */ (function (_super) {
	    __extends(Data, _super);
	    function Data() {
	        return _super.call(this) || this;
	    }
	    return Data;
	}(Base));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	/**
	 * System variables for a telemetry item.
	 */
	var Envelope = /** @class */ (function () {
	    function Envelope() {
	        this.ver = 1;
	        this.sampleRate = 100.0;
	        this.tags = {};
	    }
	    return Envelope;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Envelope$1 = /** @class */ (function (_super) {
	    __extends(Envelope, _super);
	    /**
	     * Constructs a new instance of telemetry data.
	     */
	    function Envelope(logger, data, name) {
	        var _this = _super.call(this) || this;
	        _this.name = DataSanitizer.sanitizeString(logger, name) || Util.NotSpecified;
	        _this.data = data;
	        _this.time = Util.toISOStringForIE8(new Date());
	        _this.aiDataContract = {
	            time: FieldType.Required,
	            iKey: FieldType.Required,
	            name: FieldType.Required,
	            sampleRate: function () {
	                return (_this.sampleRate == 100) ? FieldType.Hidden : FieldType.Required;
	            },
	            tags: FieldType.Required,
	            data: FieldType.Required
	        };
	        return _this;
	    }
	    return Envelope;
	}(Envelope));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	// THIS FILE WAS AUTOGENERATED
	/**
	 * The abstract common base of all domains.
	 */
	var Domain = /** @class */ (function () {
	    function Domain() {
	    }
	    return Domain;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * Instances of Event represent structured event records that can be grouped and searched by their properties. Event data item also creates a metric of event count by name.
	 */
	var EventData = /** @class */ (function (_super) {
	    __extends(EventData, _super);
	    function EventData() {
	        var _this = _super.call(this) || this;
	        _this.ver = 2;
	        _this.properties = {};
	        _this.measurements = {};
	        return _this;
	    }
	    return EventData;
	}(Domain));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Event$1 = /** @class */ (function (_super) {
	    __extends(Event, _super);
	    /**
	     * Constructs a new instance of the EventTelemetry object
	     */
	    function Event(logger, name, properties, measurements) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: FieldType.Required,
	            name: FieldType.Required,
	            properties: FieldType.Default,
	            measurements: FieldType.Default
	        };
	        _this.name = DataSanitizer.sanitizeString(logger, name) || Util.NotSpecified;
	        _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
	        _this.measurements = DataSanitizer.sanitizeMeasurements(logger, measurements);
	        return _this;
	    }
	    Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
	    Event.dataType = "EventData";
	    return Event;
	}(EventData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	// THIS FILE WAS AUTOGENERATED
	/**
	 * Stack frame information.
	 */
	var StackFrame = /** @class */ (function () {
	    function StackFrame() {
	    }
	    return StackFrame;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * An instance of Exception represents a handled or unhandled exception that occurred during execution of the monitored application.
	 */
	var ExceptionData = /** @class */ (function (_super) {
	    __extends(ExceptionData, _super);
	    function ExceptionData() {
	        var _this = _super.call(this) || this;
	        _this.ver = 2;
	        _this.exceptions = [];
	        _this.properties = {};
	        _this.measurements = {};
	        return _this;
	    }
	    return ExceptionData;
	}(Domain));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	/**
	 * Exception details of the exception in a chain.
	 */
	var ExceptionDetails = /** @class */ (function () {
	    function ExceptionDetails() {
	        this.hasFullStack = true;
	        this.parsedStack = [];
	    }
	    return ExceptionDetails;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Exception = /** @class */ (function (_super) {
	    __extends(Exception, _super);
	    /**
	    * Constructs a new instance of the ExceptionTelemetry object
	    */
	    function Exception(logger, exception, properties, measurements, severityLevel, id) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: FieldType.Required,
	            exceptions: FieldType.Required,
	            severityLevel: FieldType.Default,
	            properties: FieldType.Default,
	            measurements: FieldType.Default
	        };
	        if (exception instanceof Error) {
	            _this.exceptions = [new _ExceptionDetails(logger, exception)];
	            _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
	            _this.measurements = DataSanitizer.sanitizeMeasurements(logger, measurements);
	            if (severityLevel)
	                _this.severityLevel = severityLevel;
	            if (id)
	                _this.id = id;
	        }
	        else {
	            _this.exceptions = exception.exceptions;
	            _this.properties = exception.properties;
	            _this.measurements = exception.measurements;
	            if (exception.severityLevel)
	                _this.severityLevel = exception.severityLevel;
	            if (exception.id)
	                _this.id = exception.id;
	            if (exception.problemGroup)
	                _this.problemGroup = exception.problemGroup;
	            // bool/int types, use isNullOrUndefined
	            if (!CoreUtils.isNullOrUndefined(exception.ver))
	                _this.ver = exception.ver;
	            if (!CoreUtils.isNullOrUndefined(exception.isManual))
	                _this.isManual = exception.isManual;
	        }
	        return _this;
	    }
	    Exception.CreateFromInterface = function (logger, exception) {
	        var exceptions = exception.exceptions
	            && exception.exceptions.map(function (ex) { return _ExceptionDetails.CreateFromInterface(logger, ex); });
	        var exceptionData = new Exception(logger, __assign({}, exception, { exceptions: exceptions }));
	        return exceptionData;
	    };
	    Exception.prototype.toInterface = function () {
	        var _a = this, exceptions = _a.exceptions, properties = _a.properties, measurements = _a.measurements, severityLevel = _a.severityLevel, ver = _a.ver, problemGroup = _a.problemGroup, id = _a.id, isManual = _a.isManual;
	        var exceptionDetailsInterface = exceptions instanceof Array
	            && exceptions.map(function (exception) { return exception.toInterface(); })
	            || undefined;
	        return {
	            ver: ver,
	            exceptions: exceptionDetailsInterface,
	            severityLevel: severityLevel,
	            properties: properties,
	            measurements: measurements,
	            problemGroup: problemGroup,
	            id: id,
	            isManual: isManual
	        };
	    };
	    /**
	    * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.
	    */
	    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
	        return {
	            exceptions: [
	                {
	                    hasFullStack: true,
	                    message: message,
	                    stack: details,
	                    typeName: typeName
	                }
	            ]
	        };
	    };
	    Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
	    Exception.dataType = "ExceptionData";
	    return Exception;
	}(ExceptionData));
	var _ExceptionDetails = /** @class */ (function (_super) {
	    __extends(_ExceptionDetails, _super);
	    function _ExceptionDetails(logger, exception) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            id: FieldType.Default,
	            outerId: FieldType.Default,
	            typeName: FieldType.Required,
	            message: FieldType.Required,
	            hasFullStack: FieldType.Default,
	            stack: FieldType.Default,
	            parsedStack: FieldType.Array
	        };
	        if (exception instanceof Error) {
	            _this.typeName = DataSanitizer.sanitizeString(logger, exception.name) || Util.NotSpecified;
	            _this.message = DataSanitizer.sanitizeMessage(logger, exception.message) || Util.NotSpecified;
	            var stack = exception.stack;
	            _this.parsedStack = _ExceptionDetails.parseStack(stack);
	            _this.stack = DataSanitizer.sanitizeException(logger, stack);
	            _this.hasFullStack = Util.isArray(_this.parsedStack) && _this.parsedStack.length > 0;
	        }
	        else {
	            _this.typeName = exception.typeName;
	            _this.message = exception.message;
	            _this.stack = exception.stack;
	            _this.parsedStack = exception.parsedStack;
	            _this.hasFullStack = exception.hasFullStack;
	        }
	        return _this;
	    }
	    _ExceptionDetails.prototype.toInterface = function () {
	        var parsedStack = this.parsedStack instanceof Array
	            && this.parsedStack.map(function (frame) { return frame.toInterface(); });
	        var exceptionDetailsInterface = {
	            id: this.id,
	            outerId: this.outerId,
	            typeName: this.typeName,
	            message: this.message,
	            hasFullStack: this.hasFullStack,
	            stack: this.stack,
	            parsedStack: parsedStack || undefined
	        };
	        return exceptionDetailsInterface;
	    };
	    _ExceptionDetails.CreateFromInterface = function (logger, exception) {
	        var parsedStack = (exception.parsedStack instanceof Array
	            && exception.parsedStack.map(function (frame) { return _StackFrame.CreateFromInterface(frame); }))
	            || exception.parsedStack;
	        var exceptionDetails = new _ExceptionDetails(logger, __assign({}, exception, { parsedStack: parsedStack }));
	        return exceptionDetails;
	    };
	    _ExceptionDetails.parseStack = function (stack) {
	        var parsedStack = undefined;
	        if (typeof stack === "string") {
	            var frames = stack.split('\n');
	            parsedStack = [];
	            var level = 0;
	            var totalSizeInBytes = 0;
	            for (var i = 0; i <= frames.length; i++) {
	                var frame = frames[i];
	                if (_StackFrame.regex.test(frame)) {
	                    var parsedFrame = new _StackFrame(frames[i], level++);
	                    totalSizeInBytes += parsedFrame.sizeInBytes;
	                    parsedStack.push(parsedFrame);
	                }
	            }
	            // DP Constraint - exception parsed stack must be < 32KB
	            // remove frames from the middle to meet the threshold
	            var exceptionParsedStackThreshold = 32 * 1024;
	            if (totalSizeInBytes > exceptionParsedStackThreshold) {
	                var left = 0;
	                var right = parsedStack.length - 1;
	                var size = 0;
	                var acceptedLeft = left;
	                var acceptedRight = right;
	                while (left < right) {
	                    // check size
	                    var lSize = parsedStack[left].sizeInBytes;
	                    var rSize = parsedStack[right].sizeInBytes;
	                    size += lSize + rSize;
	                    if (size > exceptionParsedStackThreshold) {
	                        // remove extra frames from the middle
	                        var howMany = acceptedRight - acceptedLeft + 1;
	                        parsedStack.splice(acceptedLeft, howMany);
	                        break;
	                    }
	                    // update pointers
	                    acceptedLeft = left;
	                    acceptedRight = right;
	                    left++;
	                    right--;
	                }
	            }
	        }
	        return parsedStack;
	    };
	    return _ExceptionDetails;
	}(ExceptionDetails));
	var _StackFrame = /** @class */ (function (_super) {
	    __extends(_StackFrame, _super);
	    function _StackFrame(sourceFrame, level) {
	        var _this = _super.call(this) || this;
	        _this.sizeInBytes = 0;
	        _this.aiDataContract = {
	            level: FieldType.Required,
	            method: FieldType.Required,
	            assembly: FieldType.Default,
	            fileName: FieldType.Default,
	            line: FieldType.Default,
	        };
	        if (typeof sourceFrame === "string") {
	            var frame = sourceFrame;
	            _this.level = level;
	            _this.method = "<no_method>";
	            _this.assembly = Util.trim(frame);
	            _this.fileName = "";
	            _this.line = 0;
	            var matches = frame.match(_StackFrame.regex);
	            if (matches && matches.length >= 5) {
	                _this.method = Util.trim(matches[2]) || _this.method;
	                _this.fileName = Util.trim(matches[4]);
	                _this.line = parseInt(matches[5]) || 0;
	            }
	        }
	        else {
	            _this.level = sourceFrame.level;
	            _this.method = sourceFrame.method;
	            _this.assembly = sourceFrame.assembly;
	            _this.fileName = sourceFrame.fileName;
	            _this.line = sourceFrame.line;
	            _this.sizeInBytes = 0;
	        }
	        _this.sizeInBytes += _this.method.length;
	        _this.sizeInBytes += _this.fileName.length;
	        _this.sizeInBytes += _this.assembly.length;
	        // todo: these might need to be removed depending on how the back-end settles on their size calculation
	        _this.sizeInBytes += _StackFrame.baseSize;
	        _this.sizeInBytes += _this.level.toString().length;
	        _this.sizeInBytes += _this.line.toString().length;
	        return _this;
	    }
	    _StackFrame.CreateFromInterface = function (frame) {
	        return new _StackFrame(frame, null /* level is available in frame interface */);
	    };
	    _StackFrame.prototype.toInterface = function () {
	        return {
	            level: this.level,
	            method: this.method,
	            assembly: this.assembly,
	            fileName: this.fileName,
	            line: this.line
	        };
	    };
	    // regex to match stack frames from ie/chrome/ff
	    // methodName=$2, fileName=$4, lineNo=$5, column=$6
	    _StackFrame.regex = /^([\s]+at)?(.*?)(\@|\s\(|\s)([^\(\@\n]+):([0-9]+):([0-9]+)(\)?)$/;
	    _StackFrame.baseSize = 58; //'{"method":"","level":,"assembly":"","fileName":"","line":}'.length
	    return _StackFrame;
	}(StackFrame));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * An instance of the Metric item is a list of measurements (single data points) and/or aggregations.
	 */
	var MetricData = /** @class */ (function (_super) {
	    __extends(MetricData, _super);
	    function MetricData() {
	        var _this = _super.call(this) || this;
	        _this.ver = 2;
	        _this.metrics = [];
	        _this.properties = {};
	        return _this;
	    }
	    return MetricData;
	}(Domain));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	// THIS FILE WAS AUTOGENERATED
	/**
	 * Type of the metric data measurement.
	 */
	var DataPointType;
	(function (DataPointType) {
	    DataPointType[DataPointType["Measurement"] = 0] = "Measurement";
	    DataPointType[DataPointType["Aggregation"] = 1] = "Aggregation";
	})(DataPointType || (DataPointType = {}));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * Metric data single measurement.
	 */
	var DataPoint = /** @class */ (function () {
	    function DataPoint() {
	        this.kind = DataPointType.Measurement;
	    }
	    return DataPoint;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var DataPoint$1 = /** @class */ (function (_super) {
	    __extends(DataPoint, _super);
	    function DataPoint() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The data contract for serializing this object.
	         */
	        _this.aiDataContract = {
	            name: FieldType.Required,
	            kind: FieldType.Default,
	            value: FieldType.Required,
	            count: FieldType.Default,
	            min: FieldType.Default,
	            max: FieldType.Default,
	            stdDev: FieldType.Default
	        };
	        return _this;
	    }
	    return DataPoint;
	}(DataPoint));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Metric = /** @class */ (function (_super) {
	    __extends(Metric, _super);
	    /**
	     * Constructs a new instance of the MetricTelemetry object
	     */
	    function Metric(logger, name, value, count, min, max, properties) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: FieldType.Required,
	            metrics: FieldType.Required,
	            properties: FieldType.Default
	        };
	        var dataPoint = new DataPoint$1();
	        dataPoint.count = count > 0 ? count : undefined;
	        dataPoint.max = isNaN(max) || max === null ? undefined : max;
	        dataPoint.min = isNaN(min) || min === null ? undefined : min;
	        dataPoint.name = DataSanitizer.sanitizeString(logger, name) || Util.NotSpecified;
	        dataPoint.value = value;
	        _this.metrics = [dataPoint];
	        _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
	        return _this;
	    }
	    Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
	    Metric.dataType = "MetricData";
	    return Metric;
	}(MetricData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * An instance of PageView represents a generic action on a page like a button click. It is also the base type for PageView.
	 */
	var PageViewData = /** @class */ (function (_super) {
	    __extends(PageViewData, _super);
	    function PageViewData() {
	        var _this = _super.call(this) || this;
	        _this.ver = 2;
	        _this.properties = {};
	        _this.measurements = {};
	        return _this;
	    }
	    return PageViewData;
	}(EventData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var PageView = /** @class */ (function (_super) {
	    __extends(PageView, _super);
	    /**
	     * Constructs a new instance of the PageEventTelemetry object
	     */
	    function PageView(logger, name, url, durationMs, properties, measurements, id) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: FieldType.Required,
	            name: FieldType.Default,
	            url: FieldType.Default,
	            duration: FieldType.Default,
	            properties: FieldType.Default,
	            measurements: FieldType.Default,
	            id: FieldType.Default
	        };
	        _this.id = DataSanitizer.sanitizeId(logger, id);
	        _this.url = DataSanitizer.sanitizeUrl(logger, url);
	        _this.name = DataSanitizer.sanitizeString(logger, name) || Util.NotSpecified;
	        if (!isNaN(durationMs)) {
	            _this.duration = Util.msToTimeSpan(durationMs);
	        }
	        _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
	        _this.measurements = DataSanitizer.sanitizeMeasurements(logger, measurements);
	        return _this;
	    }
	    PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
	    PageView.dataType = "PageviewData";
	    return PageView;
	}(PageViewData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * An instance of Remote Dependency represents an interaction of the monitored component with a remote component/service like SQL or an HTTP endpoint.
	 */
	var RemoteDependencyData = /** @class */ (function (_super) {
	    __extends(RemoteDependencyData, _super);
	    function RemoteDependencyData() {
	        var _this = _super.call(this) || this;
	        _this.ver = 2;
	        _this.success = true;
	        _this.properties = {};
	        _this.measurements = {};
	        return _this;
	    }
	    return RemoteDependencyData;
	}(Domain));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var RemoteDependencyData$1 = /** @class */ (function (_super) {
	    __extends(RemoteDependencyData, _super);
	    /**
	     * Constructs a new instance of the RemoteDependencyData object
	     */
	    function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
	        if (requestAPI === void 0) { requestAPI = "Ajax"; }
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            id: FieldType.Required,
	            ver: FieldType.Required,
	            name: FieldType.Default,
	            resultCode: FieldType.Default,
	            duration: FieldType.Default,
	            success: FieldType.Default,
	            data: FieldType.Default,
	            target: FieldType.Default,
	            type: FieldType.Default,
	            properties: FieldType.Default,
	            measurements: FieldType.Default,
	            kind: FieldType.Default,
	            value: FieldType.Default,
	            count: FieldType.Default,
	            min: FieldType.Default,
	            max: FieldType.Default,
	            stdDev: FieldType.Default,
	            dependencyKind: FieldType.Default,
	            dependencySource: FieldType.Default,
	            commandName: FieldType.Default,
	            dependencyTypeName: FieldType.Default,
	        };
	        _this.id = id;
	        _this.duration = Util.msToTimeSpan(value);
	        _this.success = success;
	        _this.resultCode = resultCode + "";
	        _this.type = DataSanitizer.sanitizeString(logger, requestAPI);
	        var dependencyFields = AjaxHelper.ParseDependencyPath(logger, absoluteUrl, method, commandName);
	        _this.data = DataSanitizer.sanitizeUrl(logger, commandName) || dependencyFields.data; // get a value from hosturl if commandName not available
	        _this.target = DataSanitizer.sanitizeString(logger, dependencyFields.target);
	        if (correlationContext) {
	            _this.target = _this.target + " | " + correlationContext;
	        }
	        _this.name = DataSanitizer.sanitizeString(logger, dependencyFields.name);
	        _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
	        _this.measurements = DataSanitizer.sanitizeMeasurements(logger, measurements);
	        return _this;
	    }
	    RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
	    RemoteDependencyData.dataType = "RemoteDependencyData";
	    return RemoteDependencyData;
	}(RemoteDependencyData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * Instances of Message represent printf-like trace statements that are text-searched. Log4Net, NLog and other text-based log file entries are translated into intances of this type. The message does not have measurements.
	 */
	var MessageData = /** @class */ (function (_super) {
	    __extends(MessageData, _super);
	    function MessageData() {
	        var _this = _super.call(this) || this;
	        _this.ver = 2;
	        _this.properties = {};
	        return _this;
	    }
	    return MessageData;
	}(Domain));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Trace = /** @class */ (function (_super) {
	    __extends(Trace, _super);
	    /**
	     * Constructs a new instance of the TraceTelemetry object
	     */
	    function Trace(logger, message, severityLevel, properties) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: FieldType.Required,
	            message: FieldType.Required,
	            severityLevel: FieldType.Default,
	            properties: FieldType.Default
	        };
	        message = message || Util.NotSpecified;
	        _this.message = DataSanitizer.sanitizeMessage(logger, message);
	        _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
	        if (severityLevel) {
	            _this.severityLevel = severityLevel;
	        }
	        return _this;
	    }
	    Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
	    Trace.dataType = "MessageData";
	    return Trace;
	}(MessageData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * An instance of PageViewPerf represents: a page view with no performance data, a page view with performance data, or just the performance data of an earlier page request.
	 */
	var PageViewPerfData = /** @class */ (function (_super) {
	    __extends(PageViewPerfData, _super);
	    function PageViewPerfData() {
	        var _this = _super.call(this) || this;
	        _this.ver = 2;
	        _this.properties = {};
	        _this.measurements = {};
	        return _this;
	    }
	    return PageViewPerfData;
	}(PageViewData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var PageViewPerformance = /** @class */ (function (_super) {
	    __extends(PageViewPerformance, _super);
	    /**
	     * Constructs a new instance of the PageEventTelemetry object
	     */
	    function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
	        var _this = _super.call(this) || this;
	        _this.aiDataContract = {
	            ver: FieldType.Required,
	            name: FieldType.Default,
	            url: FieldType.Default,
	            duration: FieldType.Default,
	            perfTotal: FieldType.Default,
	            networkConnect: FieldType.Default,
	            sentRequest: FieldType.Default,
	            receivedResponse: FieldType.Default,
	            domProcessing: FieldType.Default,
	            properties: FieldType.Default,
	            measurements: FieldType.Default
	        };
	        _this.url = DataSanitizer.sanitizeUrl(logger, url);
	        _this.name = DataSanitizer.sanitizeString(logger, name) || Util.NotSpecified;
	        _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
	        _this.measurements = DataSanitizer.sanitizeMeasurements(logger, measurements);
	        if (cs4BaseData) {
	            _this.domProcessing = cs4BaseData.domProcessing;
	            _this.duration = cs4BaseData.duration;
	            _this.networkConnect = cs4BaseData.networkConnect;
	            _this.perfTotal = cs4BaseData.perfTotal;
	            _this.receivedResponse = cs4BaseData.receivedResponse;
	            _this.sentRequest = cs4BaseData.sentRequest;
	        }
	        return _this;
	    }
	    PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
	    PageViewPerformance.dataType = "PageviewPerformanceData";
	    return PageViewPerformance;
	}(PageViewPerfData));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Data$1 = /** @class */ (function (_super) {
	    __extends(Data, _super);
	    /**
	     * Constructs a new instance of telemetry data.
	     */
	    function Data(baseType, data) {
	        var _this = _super.call(this) || this;
	        /**
	         * The data contract for serializing this object.
	         */
	        _this.aiDataContract = {
	            baseType: FieldType.Required,
	            baseData: FieldType.Required
	        };
	        _this.baseType = baseType;
	        _this.baseData = data;
	        return _this;
	    }
	    return Data;
	}(Data));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	// THIS FILE WAS AUTOGENERATED
	/**
	* Defines the level of severity for the event.
	*/
	var SeverityLevel;
	(function (SeverityLevel) {
	    SeverityLevel[SeverityLevel["Verbose"] = 0] = "Verbose";
	    SeverityLevel[SeverityLevel["Information"] = 1] = "Information";
	    SeverityLevel[SeverityLevel["Warning"] = 2] = "Warning";
	    SeverityLevel[SeverityLevel["Error"] = 3] = "Error";
	    SeverityLevel[SeverityLevel["Critical"] = 4] = "Critical";
	})(SeverityLevel || (SeverityLevel = {}));

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var ConfigurationManager = /** @class */ (function () {
	    function ConfigurationManager() {
	    }
	    ConfigurationManager.getConfig = function (config, field, identifier, defaultValue) {
	        if (defaultValue === void 0) { defaultValue = false; }
	        var configValue;
	        if (identifier && config.extensionConfig && config.extensionConfig[identifier] && !CoreUtils.isNullOrUndefined(config.extensionConfig[identifier][field])) {
	            configValue = config.extensionConfig[identifier][field];
	        }
	        else {
	            configValue = config[field];
	        }
	        return !CoreUtils.isNullOrUndefined(configValue) ? configValue : defaultValue;
	    };
	    return ConfigurationManager;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	// THIS FILE WAS AUTOGENERATED
	var ContextTagKeys = /** @class */ (function () {
	    function ContextTagKeys() {
	        this.applicationVersion = "ai.application.ver";
	        this.applicationBuild = "ai.application.build";
	        this.applicationTypeId = "ai.application.typeId";
	        this.applicationId = "ai.application.applicationId";
	        this.applicationLayer = "ai.application.layer";
	        this.deviceId = "ai.device.id";
	        this.deviceIp = "ai.device.ip";
	        this.deviceLanguage = "ai.device.language";
	        this.deviceLocale = "ai.device.locale";
	        this.deviceModel = "ai.device.model";
	        this.deviceFriendlyName = "ai.device.friendlyName";
	        this.deviceNetwork = "ai.device.network";
	        this.deviceNetworkName = "ai.device.networkName";
	        this.deviceOEMName = "ai.device.oemName";
	        this.deviceOS = "ai.device.os";
	        this.deviceOSVersion = "ai.device.osVersion";
	        this.deviceRoleInstance = "ai.device.roleInstance";
	        this.deviceRoleName = "ai.device.roleName";
	        this.deviceScreenResolution = "ai.device.screenResolution";
	        this.deviceType = "ai.device.type";
	        this.deviceMachineName = "ai.device.machineName";
	        this.deviceVMName = "ai.device.vmName";
	        this.deviceBrowser = "ai.device.browser";
	        this.deviceBrowserVersion = "ai.device.browserVersion";
	        this.locationIp = "ai.location.ip";
	        this.locationCountry = "ai.location.country";
	        this.locationProvince = "ai.location.province";
	        this.locationCity = "ai.location.city";
	        this.operationId = "ai.operation.id";
	        this.operationName = "ai.operation.name";
	        this.operationParentId = "ai.operation.parentId";
	        this.operationRootId = "ai.operation.rootId";
	        this.operationSyntheticSource = "ai.operation.syntheticSource";
	        this.operationCorrelationVector = "ai.operation.correlationVector";
	        this.sessionId = "ai.session.id";
	        this.sessionIsFirst = "ai.session.isFirst";
	        this.sessionIsNew = "ai.session.isNew";
	        this.userAccountAcquisitionDate = "ai.user.accountAcquisitionDate";
	        this.userAccountId = "ai.user.accountId";
	        this.userAgent = "ai.user.userAgent";
	        this.userId = "ai.user.id";
	        this.userStoreRegion = "ai.user.storeRegion";
	        this.userAuthUserId = "ai.user.authUserId";
	        this.userAnonymousUserAcquisitionDate = "ai.user.anonUserAcquisitionDate";
	        this.userAuthenticatedUserAcquisitionDate = "ai.user.authUserAcquisitionDate";
	        this.cloudName = "ai.cloud.name";
	        this.cloudRole = "ai.cloud.role";
	        this.cloudRoleVer = "ai.cloud.roleVer";
	        this.cloudRoleInstance = "ai.cloud.roleInstance";
	        this.cloudEnvironment = "ai.cloud.environment";
	        this.cloudLocation = "ai.cloud.location";
	        this.cloudDeploymentUnit = "ai.cloud.deploymentUnit";
	        this.internalNodeName = "ai.internal.nodeName";
	        this.internalSdkVersion = "ai.internal.sdkVersion";
	        this.internalAgentVersion = "ai.internal.agentVersion";
	    }
	    return ContextTagKeys;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var TelemetryItemCreator = /** @class */ (function () {
	    function TelemetryItemCreator() {
	    }
	    /**
	     * Create a telemetry item that the 1DS channel understands
	     * @param item domain specific properties; part B
	     * @param baseType telemetry item type. ie PageViewData
	     * @param envelopeName name of the envelope. ie Microsoft.ApplicationInsights.<instrumentation key>.PageView
	     * @param customProperties user defined custom properties; part C
	     * @param systemProperties system properties that are added to the context; part A
	     * @returns ITelemetryItem that is sent to channel
	     */
	    TelemetryItemCreator.create = function (item, baseType, envelopeName, logger, customProperties, systemProperties) {
	        envelopeName = DataSanitizer.sanitizeString(logger, envelopeName) || Util.NotSpecified;
	        if (CoreUtils.isNullOrUndefined(item) ||
	            CoreUtils.isNullOrUndefined(baseType) ||
	            CoreUtils.isNullOrUndefined(envelopeName)) {
	            throw Error("Input doesn't contain all required fields");
	        }
	        var telemetryItem = {
	            name: envelopeName,
	            time: new Date().toISOString(),
	            iKey: "",
	            ext: systemProperties ? systemProperties : {},
	            tags: [],
	            data: {},
	            baseType: baseType,
	            baseData: item // Part B
	        };
	        // Part C
	        if (!CoreUtils.isNullOrUndefined(customProperties)) {
	            for (var prop in customProperties) {
	                if (customProperties.hasOwnProperty(prop)) {
	                    telemetryItem.data[prop] = customProperties[prop];
	                }
	            }
	        }
	        return telemetryItem;
	    };
	    return TelemetryItemCreator;
	}());

	var Extensions = /** @class */ (function () {
	    function Extensions() {
	    }
	    Extensions.UserExt = "user";
	    Extensions.DeviceExt = "device";
	    Extensions.TraceExt = "trace";
	    Extensions.WebExt = "web";
	    Extensions.AppExt = "app";
	    Extensions.OSExt = "os";
	    Extensions.SessionExt = "ses";
	    Extensions.SDKExt = "sdk";
	    return Extensions;
	}());
	var CtxTagKeys = new ContextTagKeys();

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin";
	var BreezeChannelIdentifier = "AppInsightsChannelPlugin";

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	* Class encapsulates sending page views and page view performance telemetry.
	*/
	var PageViewManager = /** @class */ (function () {
	    function PageViewManager(appInsights, overridePageViewDuration, core, pageViewPerformanceManager) {
	        this.pageViewPerformanceSent = false;
	        this.overridePageViewDuration = false;
	        this.overridePageViewDuration = overridePageViewDuration;
	        this.appInsights = appInsights;
	        this._pageViewPerformanceManager = pageViewPerformanceManager;
	        if (core) {
	            this._channel = function () { return (core.getTransmissionControls()); };
	            this._logger = core.logger;
	        }
	    }
	    /**
	    * Currently supported cases:
	    * 1) (default case) track page view called with default parameters, overridePageViewDuration = false. Page view is sent with page view performance when navigation timing data is available.
	    *    a. If navigation timing is not supported then page view is sent right away with undefined duration. Page view performance is not sent.
	    * 2) overridePageViewDuration = true, custom duration provided. Custom duration is used, page view sends right away.
	    * 3) overridePageViewDuration = true, custom duration NOT provided. Page view is sent right away, duration is time spent from page load till now (or undefined if navigation timing is not supported).
	    * 4) overridePageViewDuration = false, custom duration is provided. Page view is sent right away with custom duration.
	    *
	    * In all cases page view performance is sent once (only for the 1st call of trackPageView), or not sent if navigation timing is not supported.
	    */
	    PageViewManager.prototype.trackPageView = function (pageView, customProperties) {
	        var _this = this;
	        var name = pageView.name;
	        if (CoreUtils.isNullOrUndefined(name) || typeof name !== "string") {
	            pageView.name = window.document && window.document.title || "";
	        }
	        var uri = pageView.uri;
	        if (CoreUtils.isNullOrUndefined(uri) || typeof uri !== "string") {
	            pageView.uri = window.location && window.location.href || "";
	        }
	        // case 1a. if performance timing is not supported by the browser, send the page view telemetry with the duration provided by the user. If the user
	        // do not provide the duration, set duration to undefined
	        // Also this is case 4
	        if (!this._pageViewPerformanceManager.isPerformanceTimingSupported()) {
	            this.appInsights.sendPageViewInternal(pageView, customProperties);
	            this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
	            // no navigation timing (IE 8, iOS Safari 8.4, Opera Mini 8 - see http://caniuse.com/#feat=nav-timing)
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.NavigationTimingNotSupported, "trackPageView: navigation timing API used for calculation of page duration is not supported in this browser. This page view will be collected without duration and timing info.");
	            return;
	        }
	        var pageViewSent = false;
	        var customDuration = undefined;
	        // if the performance timing is supported by the browser, calculate the custom duration
	        var start = this._pageViewPerformanceManager.getPerformanceTiming().navigationStart;
	        customDuration = DateTimeUtils.GetDuration(start, +new Date);
	        if (!this._pageViewPerformanceManager.shouldCollectDuration(customDuration)) {
	            customDuration = undefined;
	        }
	        // if the user has provided duration, send a page view telemetry with the provided duration. Otherwise, if
	        // overridePageViewDuration is set to true, send a page view telemetry with the custom duration calculated earlier
	        var duration = undefined;
	        if (!CoreUtils.isNullOrUndefined(customProperties) &&
	            !CoreUtils.isNullOrUndefined(customProperties.duration)) {
	            duration = customProperties.duration;
	        }
	        if (this.overridePageViewDuration || !isNaN(duration)) {
	            if (isNaN(duration)) {
	                // case 3
	                if (!customProperties) {
	                    customProperties = {};
	                }
	                customProperties["duration"] = customDuration;
	            }
	            // case 2
	            this.appInsights.sendPageViewInternal(pageView, customProperties);
	            this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
	            pageViewSent = true;
	        }
	        // now try to send the page view performance telemetry
	        var maxDurationLimit = 60000;
	        if (!customProperties) {
	            customProperties = {};
	        }
	        var handle = setInterval((function () {
	            try {
	                if (_this._pageViewPerformanceManager.isPerformanceTimingDataReady()) {
	                    clearInterval(handle);
	                    var pageViewPerformance = {
	                        name: name,
	                        uri: uri
	                    };
	                    _this._pageViewPerformanceManager.populatePageViewPerformanceEvent(pageViewPerformance);
	                    if (!pageViewPerformance.isValid && !pageViewSent) {
	                        // If navigation timing gives invalid numbers, then go back to "override page view duration" mode.
	                        // That's the best value we can get that makes sense.
	                        customProperties["duration"] = customDuration;
	                        _this.appInsights.sendPageViewInternal(pageView, customProperties);
	                        _this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
	                    }
	                    else {
	                        if (!pageViewSent) {
	                            customProperties["duration"] = pageViewPerformance.durationMs;
	                            _this.appInsights.sendPageViewInternal(pageView, customProperties);
	                        }
	                        if (!_this.pageViewPerformanceSent) {
	                            _this.appInsights.sendPageViewPerformanceInternal(pageViewPerformance, customProperties);
	                            _this.pageViewPerformanceSent = true;
	                        }
	                        _this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
	                    }
	                }
	                else if (DateTimeUtils.GetDuration(start, +new Date) > maxDurationLimit) {
	                    // if performance timings are not ready but we exceeded the maximum duration limit, just log a page view telemetry
	                    // with the maximum duration limit. Otherwise, keep waiting until performance timings are ready
	                    clearInterval(handle);
	                    if (!pageViewSent) {
	                        customProperties["duration"] = maxDurationLimit;
	                        _this.appInsights.sendPageViewInternal(pageView, customProperties);
	                        _this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
	                    }
	                }
	            }
	            catch (e) {
	                _this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailedCalc, "trackPageView failed on page load calculation: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }), 100);
	    };
	    return PageViewManager;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * Used to track page visit durations
	 */
	var PageVisitTimeManager = /** @class */ (function () {
	    /**
	     * Creates a new instance of PageVisitTimeManager
	     * @param pageVisitTimeTrackingHandler Delegate that will be called to send telemetry data to AI (when trackPreviousPageVisit is called)
	     * @returns {}
	     */
	    function PageVisitTimeManager(logger, pageVisitTimeTrackingHandler) {
	        this.prevPageVisitDataKeyName = "prevPageVisitData";
	        this.pageVisitTimeTrackingHandler = pageVisitTimeTrackingHandler;
	        this._logger = logger;
	    }
	    /**
	    * Tracks the previous page visit time telemetry (if exists) and starts timing of new page visit time
	    * @param currentPageName Name of page to begin timing for visit duration
	    * @param currentPageUrl Url of page to begin timing for visit duration
	    */
	    PageVisitTimeManager.prototype.trackPreviousPageVisit = function (currentPageName, currentPageUrl) {
	        try {
	            // Restart timer for new page view
	            var prevPageVisitTimeData = this.restartPageVisitTimer(currentPageName, currentPageUrl);
	            // If there was a page already being timed, track the visit time for it now.
	            if (prevPageVisitTimeData) {
	                this.pageVisitTimeTrackingHandler(prevPageVisitTimeData.pageName, prevPageVisitTimeData.pageUrl, prevPageVisitTimeData.pageVisitTime);
	            }
	        }
	        catch (e) {
	            this._logger.warnToConsole("Auto track page visit time failed, metric will not be collected: " + Util.dump(e));
	        }
	    };
	    /**
	     * Stops timing of current page (if exists) and starts timing for duration of visit to pageName
	     * @param pageName Name of page to begin timing visit duration
	     * @returns {PageVisitData} Page visit data (including duration) of pageName from last call to start or restart, if exists. Null if not.
	     */
	    PageVisitTimeManager.prototype.restartPageVisitTimer = function (pageName, pageUrl) {
	        try {
	            var prevPageVisitData = this.stopPageVisitTimer();
	            this.startPageVisitTimer(pageName, pageUrl);
	            return prevPageVisitData;
	        }
	        catch (e) {
	            this._logger.warnToConsole("Call to restart failed: " + Util.dump(e));
	            return null;
	        }
	    };
	    /**
	     * Starts timing visit duration of pageName
	     * @param pageName
	     * @returns {}
	     */
	    PageVisitTimeManager.prototype.startPageVisitTimer = function (pageName, pageUrl) {
	        try {
	            if (Util.canUseSessionStorage()) {
	                if (Util.getSessionStorage(this._logger, this.prevPageVisitDataKeyName) != null) {
	                    throw new Error("Cannot call startPageVisit consecutively without first calling stopPageVisit");
	                }
	                var currPageVisitData = new PageVisitData(pageName, pageUrl);
	                var currPageVisitDataStr = JSON.stringify(currPageVisitData);
	                Util.setSessionStorage(this._logger, this.prevPageVisitDataKeyName, currPageVisitDataStr);
	            }
	        }
	        catch (e) {
	            //TODO: Remove this catch in next phase, since if start is called twice in a row the exception needs to be propagated out
	            this._logger.warnToConsole("Call to start failed: " + Util.dump(e));
	        }
	    };
	    /**
	     * Stops timing of current page, if exists.
	     * @returns {PageVisitData} Page visit data (including duration) of pageName from call to start, if exists. Null if not.
	     */
	    PageVisitTimeManager.prototype.stopPageVisitTimer = function () {
	        try {
	            if (Util.canUseSessionStorage()) {
	                // Define end time of page's visit
	                var pageVisitEndTime = Date.now();
	                // Try to retrieve  page name and start time from session storage
	                var pageVisitDataJsonStr = Util.getSessionStorage(this._logger, this.prevPageVisitDataKeyName);
	                if (pageVisitDataJsonStr) {
	                    // if previous page data exists, set end time of visit
	                    var prevPageVisitData = JSON.parse(pageVisitDataJsonStr);
	                    prevPageVisitData.pageVisitTime = pageVisitEndTime - prevPageVisitData.pageVisitStartTime;
	                    // Remove data from storage since we already used it
	                    Util.removeSessionStorage(this._logger, this.prevPageVisitDataKeyName);
	                    // Return page visit data
	                    return prevPageVisitData;
	                }
	                else {
	                    return null;
	                }
	            }
	            return null;
	        }
	        catch (e) {
	            this._logger.warnToConsole("Stop page visit timer failed: " + Util.dump(e));
	            return null;
	        }
	    };
	    return PageVisitTimeManager;
	}());
	var PageVisitData = /** @class */ (function () {
	    function PageVisitData(pageName, pageUrl) {
	        this.pageVisitStartTime = Date.now();
	        this.pageName = pageName;
	        this.pageUrl = pageUrl;
	    }
	    return PageVisitData;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	* Class encapsulates sending page view performance telemetry.
	*/
	var PageViewPerformanceManager = /** @class */ (function () {
	    function PageViewPerformanceManager(core) {
	        this.MAX_DURATION_ALLOWED = 3600000; // 1h
	        if (core) {
	            this._logger = core.logger;
	        }
	    }
	    PageViewPerformanceManager.prototype.populatePageViewPerformanceEvent = function (pageViewPerformance) {
	        pageViewPerformance.isValid = false;
	        /*
	         * http://www.w3.org/TR/navigation-timing/#processing-model
	         *  |-navigationStart
	         *  |             |-connectEnd
	         *  |             ||-requestStart
	         *  |             ||             |-responseStart
	         *  |             ||             |              |-responseEnd
	         *  |             ||             |              |
	         *  |             ||             |              |         |-loadEventEnd
	         *  |---network---||---request---|---response---|---dom---|
	         *  |--------------------------total----------------------|
	         */
	        var timing = this.getPerformanceTiming();
	        if (timing) {
	            var total = DateTimeUtils.GetDuration(timing.navigationStart, timing.loadEventEnd);
	            var network = DateTimeUtils.GetDuration(timing.navigationStart, timing.connectEnd);
	            var request = DateTimeUtils.GetDuration(timing.requestStart, timing.responseStart);
	            var response = DateTimeUtils.GetDuration(timing.responseStart, timing.responseEnd);
	            var dom = DateTimeUtils.GetDuration(timing.responseEnd, timing.loadEventEnd);
	            if (total == 0) {
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.ErrorPVCalc, "error calculating page view performance.", { total: total, network: network, request: request, response: response, dom: dom });
	            }
	            else if (!this.shouldCollectDuration(total, network, request, response, dom)) {
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.InvalidDurationValue, "Invalid page load duration value. Browser perf data won't be sent.", { total: total, network: network, request: request, response: response, dom: dom });
	            }
	            else if (total < Math.floor(network) + Math.floor(request) + Math.floor(response) + Math.floor(dom)) {
	                // some browsers may report individual components incorrectly so that the sum of the parts will be bigger than total PLT
	                // in this case, don't report client performance from this page
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.ClientPerformanceMathError, "client performance math error.", { total: total, network: network, request: request, response: response, dom: dom });
	            }
	            else {
	                pageViewPerformance.durationMs = total;
	                // // convert to timespans
	                pageViewPerformance.perfTotal = pageViewPerformance.duration = Util.msToTimeSpan(total);
	                pageViewPerformance.networkConnect = Util.msToTimeSpan(network);
	                pageViewPerformance.sentRequest = Util.msToTimeSpan(request);
	                pageViewPerformance.receivedResponse = Util.msToTimeSpan(response);
	                pageViewPerformance.domProcessing = Util.msToTimeSpan(dom);
	                pageViewPerformance.isValid = true;
	            }
	        }
	    };
	    PageViewPerformanceManager.prototype.getPerformanceTiming = function () {
	        if (this.isPerformanceTimingSupported()) {
	            return window.performance.timing;
	        }
	        return null;
	    };
	    /**
	    * Returns true is window performance timing API is supported, false otherwise.
	    */
	    PageViewPerformanceManager.prototype.isPerformanceTimingSupported = function () {
	        return typeof window != "undefined" && window.performance && window.performance.timing;
	    };
	    /**
	    * As page loads different parts of performance timing numbers get set. When all of them are set we can report it.
	    * Returns true if ready, false otherwise.
	    */
	    PageViewPerformanceManager.prototype.isPerformanceTimingDataReady = function () {
	        var timing = window.performance.timing;
	        return timing.domainLookupStart > 0
	            && timing.navigationStart > 0
	            && timing.responseStart > 0
	            && timing.requestStart > 0
	            && timing.loadEventEnd > 0
	            && timing.responseEnd > 0
	            && timing.connectEnd > 0
	            && timing.domLoading > 0;
	    };
	    /**
	    * This method tells if given durations should be excluded from collection.
	    */
	    PageViewPerformanceManager.prototype.shouldCollectDuration = function () {
	        var durations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            durations[_i] = arguments[_i];
	        }
	        // a full list of Google crawlers user agent strings - https://support.google.com/webmasters/answer/1061943?hl=en
	        var botAgentNames = ['googlebot', 'adsbot-google', 'apis-google', 'mediapartners-google'];
	        var userAgent = navigator.userAgent;
	        var isGoogleBot = false;
	        if (userAgent) {
	            for (var i_1 = 0; i_1 < botAgentNames.length; i_1++) {
	                isGoogleBot = isGoogleBot || userAgent.toLowerCase().indexOf(botAgentNames[i_1]) !== -1;
	            }
	        }
	        if (isGoogleBot) {
	            // Don't report durations for GoogleBot, it is returning invalid values in performance.timing API.
	            return false;
	        }
	        else {
	            // for other page views, don't report if it's outside of a reasonable range
	            for (var i = 0; i < durations.length; i++) {
	                if (durations[i] >= this.MAX_DURATION_ALLOWED) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    };
	    return PageViewPerformanceManager;
	}());

	/**
	 * ApplicationInsights.ts
	 * @copyright Microsoft 2018
	 */
	var durationProperty = "duration";
	var ApplicationInsights = /** @class */ (function () {
	    function ApplicationInsights() {
	        this.identifier = "ApplicationInsightsAnalytics"; // do not change name or priority
	        this.priority = 180; // take from reserved priority range 100- 200
	        this.autoRoutePVDelay = 500; // ms; Time to wait after a route change before triggering a pageview to allow DOM changes to take place
	        this._isInitialized = false;
	        // Counts number of trackAjax invokations.
	        // By default we only monitor X ajax call per view to avoid too much load.
	        // Default value is set in config.
	        // This counter keeps increasing even after the limit is reached.
	        this._trackAjaxAttempts = 0;
	        // array with max length of 2 that store current url and previous url for SPA page route change trackPageview use.
	        this._prevUri = typeof window === "object" && window.location && window.location.href || "";
	        this.initialize = this._initialize.bind(this);
	    }
	    ApplicationInsights.getDefaultConfig = function (config) {
	        if (!config) {
	            config = {};
	        }
	        // set default values
	        config.sessionRenewalMs = 30 * 60 * 1000;
	        config.sessionExpirationMs = 24 * 60 * 60 * 1000;
	        config.disableExceptionTracking = Util.stringToBoolOrDefault(config.disableExceptionTracking);
	        config.autoTrackPageVisitTime = Util.stringToBoolOrDefault(config.autoTrackPageVisitTime);
	        config.overridePageViewDuration = Util.stringToBoolOrDefault(config.overridePageViewDuration);
	        if (isNaN(config.samplingPercentage) || config.samplingPercentage <= 0 || config.samplingPercentage >= 100) {
	            config.samplingPercentage = 100;
	        }
	        config.isCookieUseDisabled = Util.stringToBoolOrDefault(config.isCookieUseDisabled);
	        config.isStorageUseDisabled = Util.stringToBoolOrDefault(config.isStorageUseDisabled);
	        config.isBrowserLinkTrackingEnabled = Util.stringToBoolOrDefault(config.isBrowserLinkTrackingEnabled);
	        config.enableAutoRouteTracking = Util.stringToBoolOrDefault(config.enableAutoRouteTracking);
	        config.namePrefix = config.namePrefix || "";
	        return config;
	    };
	    ApplicationInsights.prototype.processTelemetry = function (env) {
	        var doNotSendItem = false;
	        var telemetryInitializersCount = this._telemetryInitializers.length;
	        for (var i = 0; i < telemetryInitializersCount; ++i) {
	            var telemetryInitializer = this._telemetryInitializers[i];
	            if (telemetryInitializer) {
	                try {
	                    if (telemetryInitializer.apply(null, [env]) === false) {
	                        doNotSendItem = true;
	                        break;
	                    }
	                }
	                catch (e) {
	                    // log error but dont stop executing rest of the telemetry initializers
	                    // doNotSendItem = true;
	                    this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryInitializerFailed, "One of telemetry initializers failed, telemetry item will not be sent: " + Util.getExceptionName(e), { exception: Util.dump(e) }, true);
	                }
	            }
	        }
	        if (!doNotSendItem && !CoreUtils.isNullOrUndefined(this._nextPlugin)) {
	            this._nextPlugin.processTelemetry(env);
	        }
	    };
	    ApplicationInsights.prototype.setNextPlugin = function (next) {
	        this._nextPlugin = next;
	    };
	    ApplicationInsights.prototype.trackEvent = function (event, customProperties) {
	        try {
	            var telemetryItem = TelemetryItemCreator.create(event, Event$1.dataType, Event$1.envelopeType, this._logger, customProperties);
	            this.core.track(telemetryItem);
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TrackTraceFailed, "trackTrace failed, trace will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	      * Start timing an extended event. Call `stopTrackEvent` to log the event when it ends.
	      * @param   name    A string that identifies this event uniquely within the document.
	    */
	    ApplicationInsights.prototype.startTrackEvent = function (name) {
	        try {
	            this._eventTracking.start(name);
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StartTrackEventFailed, "startTrackEvent failed, event will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * Log an extended event that you started timing with `startTrackEvent`.
	     * @param   name    The string you used to identify this event in `startTrackEvent`.
	     * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
	     * @param   measurements    map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
	     */
	    ApplicationInsights.prototype.stopTrackEvent = function (name, properties, measurements) {
	        try {
	            this._eventTracking.stop(name, undefined, properties); // Todo: Fix to pass measurements once type is updated
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StopTrackEventFailed, "stopTrackEvent failed, event will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * @description Log a diagnostic message
	     * @param {ITraceTelemetry} trace
	     * @param ICustomProperties.
	     * @memberof ApplicationInsights
	     */
	    ApplicationInsights.prototype.trackTrace = function (trace, customProperties) {
	        try {
	            var telemetryItem = TelemetryItemCreator.create(trace, Trace.dataType, Trace.envelopeType, this._logger, customProperties);
	            this.core.track(telemetryItem);
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TrackTraceFailed, "trackTrace failed, trace will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * @description Log a numeric value that is not associated with a specific event. Typically
	     * used to send regular reports of performance indicators. To send single measurement, just
	     * use the name and average fields of {@link IMetricTelemetry}. If you take measurements
	     * frequently, you can reduce the telemetry bandwidth by aggregating multiple measurements
	     * and sending the resulting average at intervals
	     * @param {IMetricTelemetry} metric input object argument. Only name and average are mandatory.
	     * @param {{[key: string]: any}} customProperties additional data used to filter metrics in the
	     * portal. Defaults to empty.
	     * @memberof ApplicationInsights
	     */
	    ApplicationInsights.prototype.trackMetric = function (metric, customProperties) {
	        try {
	            var telemetryItem = TelemetryItemCreator.create(metric, Metric.dataType, Metric.envelopeType, this._logger, customProperties);
	            this.core.track(telemetryItem);
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackMetricFailed, "trackMetric failed, metric will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * Logs that a page or other item was viewed.
	     * @param IPageViewTelemetry The string you used as the name in startTrackPage. Defaults to the document title.
	     * @param customProperties Additional data used to filter events and metrics. Defaults to empty.
	     * If a user wants to provide duration for pageLoad, it'll have to be in pageView.properties.duration
	     */
	    ApplicationInsights.prototype.trackPageView = function (pageView, customProperties) {
	        try {
	            var inPv = pageView || {};
	            this._pageViewManager.trackPageView(inPv, __assign({}, inPv.properties, inPv.measurements, customProperties));
	            if (this.config.autoTrackPageVisitTime) {
	                this._pageVisitTimeManager.trackPreviousPageVisit(inPv.name, inPv.uri);
	            }
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailed, "trackPageView failed, page view will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * Create a page view telemetry item and send it to the SDK pipeline through the core.track API
	     * @param pageView Page view item to be sent
	     * @param properties Custom properties (Part C) that a user can add to the telemetry item
	     * @param systemProperties System level properties (Part A) that a user can add to the telemetry item
	     */
	    ApplicationInsights.prototype.sendPageViewInternal = function (pageView, properties, systemProperties) {
	        if (typeof document !== "undefined") {
	            pageView.refUri = pageView.refUri === undefined ? document.referrer : pageView.refUri;
	        }
	        var telemetryItem = TelemetryItemCreator.create(pageView, PageView.dataType, PageView.envelopeType, this._logger, properties, systemProperties);
	        this.core.track(telemetryItem);
	        // reset ajaxes counter
	        this._trackAjaxAttempts = 0;
	    };
	    /**
	     * @ignore INTERNAL ONLY
	     * @param pageViewPerformance
	     * @param properties
	     */
	    ApplicationInsights.prototype.sendPageViewPerformanceInternal = function (pageViewPerformance, properties, systemProperties) {
	        var telemetryItem = TelemetryItemCreator.create(pageViewPerformance, PageViewPerformance.dataType, PageViewPerformance.envelopeType, this._logger, properties, systemProperties);
	        this.core.track(telemetryItem);
	    };
	    /**
	     * Send browser performance metrics.
	     * @param pageViewPerformance
	     * @param customProperties
	     */
	    ApplicationInsights.prototype.trackPageViewPerformance = function (pageViewPerformance, customProperties) {
	        try {
	            this._pageViewPerformanceManager.populatePageViewPerformanceEvent(pageViewPerformance);
	            this.sendPageViewPerformanceInternal(pageViewPerformance, customProperties);
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailed, "trackPageViewPerformance failed, page view will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * Starts the timer for tracking a page load time. Use this instead of `trackPageView` if you want to control when the page view timer starts and stops,
	     * but don't want to calculate the duration yourself. This method doesn't send any telemetry. Call `stopTrackPage` to log the end of the page view
	     * and send the event.
	     * @param name A string that idenfities this item, unique within this HTML document. Defaults to the document title.
	     */
	    ApplicationInsights.prototype.startTrackPage = function (name) {
	        try {
	            if (typeof name !== "string") {
	                name = window.document && window.document.title || "";
	            }
	            this._pageTracking.start(name);
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StartTrackFailed, "startTrackPage failed, page view may not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * Stops the timer that was started by calling `startTrackPage` and sends the pageview load time telemetry with the specified properties and measurements.
	     * The duration of the page view will be the time between calling `startTrackPage` and `stopTrackPage`.
	     * @param   name  The string you used as the name in startTrackPage. Defaults to the document title.
	     * @param   url   String - a relative or absolute URL that identifies the page or other item. Defaults to the window location.
	     * @param   properties  map[string, string] - additional data used to filter pages and metrics in the portal. Defaults to empty.
	     * @param   measurements    map[string, number] - metrics associated with this page, displayed in Metrics Explorer on the portal. Defaults to empty.
	     */
	    ApplicationInsights.prototype.stopTrackPage = function (name, url, properties, measurement) {
	        try {
	            if (typeof name !== "string") {
	                name = window.document && window.document.title || "";
	            }
	            if (typeof url !== "string") {
	                url = window.location && window.location.href || "";
	            }
	            this._pageTracking.stop(name, url, properties, measurement);
	            if (this.config.autoTrackPageVisitTime) {
	                this._pageVisitTimeManager.trackPreviousPageVisit(name, url);
	            }
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.StopTrackFailed, "stopTrackPage failed, page view will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	    * @ignore INTERNAL ONLY
	    * @param exception
	    * @param properties
	    * @param systemProperties
	    */
	    ApplicationInsights.prototype.sendExceptionInternal = function (exception, customProperties, systemProperties) {
	        var exceptionPartB = new Exception(this._logger, exception.exception || new Error(Util.NotSpecified), exception.properties, exception.measurements, exception.severityLevel, exception.id).toInterface();
	        var telemetryItem = TelemetryItemCreator.create(exceptionPartB, Exception.dataType, Exception.envelopeType, this._logger, customProperties, systemProperties);
	        this.core.track(telemetryItem);
	    };
	    /**
	     * Log an exception you have caught.
	     *
	     * @param {IExceptionTelemetry} exception   Object which contains exception to be sent
	     * @param {{[key: string]: any}} customProperties   Additional data used to filter pages and metrics in the portal. Defaults to empty.
	     *
	     * Any property of type double will be considered a measurement, and will be treated by Application Insights as a metric.
	     * @memberof ApplicationInsights
	     */
	    ApplicationInsights.prototype.trackException = function (exception, customProperties) {
	        try {
	            this.sendExceptionInternal(exception, customProperties);
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackExceptionFailed, "trackException failed, exception will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    /**
	     * @description Custom error handler for Application Insights Analytics
	     * @param {IAutoExceptionTelemetry} exception
	     * @memberof ApplicationInsights
	     */
	    ApplicationInsights.prototype._onerror = function (exception) {
	        try {
	            var properties_1 = {
	                url: (exception && exception.url) || document.URL,
	                lineNumber: exception.lineNumber,
	                columnNumber: exception.columnNumber,
	                message: exception.message
	            };
	            if (Util.isCrossOriginError(exception.message, exception.url, exception.lineNumber, exception.columnNumber, exception.error)) {
	                this._sendCORSException(properties_1.url);
	            }
	            else {
	                if (!Util.isError(exception.error)) {
	                    var stack = "window.onerror@" + properties_1.url + ":" + exception.lineNumber + ":" + (exception.columnNumber || 0);
	                    exception.error = new Error(exception.message);
	                    exception.error.stack = stack;
	                }
	                this.trackException({ exception: exception.error, severityLevel: SeverityLevel.Error }, properties_1);
	            }
	        }
	        catch (e) {
	            var errorString = exception.error ?
	                (exception.error.name + ", " + exception.error.message)
	                : "null";
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.ExceptionWhileLoggingError, "_onError threw exception while logging error, error will not be collected: "
	                + Util.getExceptionName(e), { exception: Util.dump(e), errorString: errorString });
	        }
	    };
	    ApplicationInsights.prototype.addTelemetryInitializer = function (telemetryInitializer) {
	        this._telemetryInitializers.push(telemetryInitializer);
	    };
	    ApplicationInsights.prototype._initialize = function (config, core, extensions) {
	        var _this = this;
	        if (this._isInitialized) {
	            return;
	        }
	        if (CoreUtils.isNullOrUndefined(core)) {
	            throw Error("Error initializing");
	        }
	        this.core = core;
	        this._logger = core.logger;
	        this._globalconfig = {
	            instrumentationKey: config.instrumentationKey,
	            endpointUrl: config.endpointUrl || "https://dc.services.visualstudio.com/v2/track"
	        };
	        this.config = config.extensionConfig && config.extensionConfig[this.identifier] ? config.extensionConfig[this.identifier] : {};
	        // load default values if specified
	        var defaults = ApplicationInsights.getDefaultConfig();
	        if (defaults !== undefined) {
	            for (var field in defaults) {
	                // for each unspecified field, set the default value
	                this.config[field] = ConfigurationManager.getConfig(config, field, this.identifier, defaults[field]);
	            }
	            if (this._globalconfig) {
	                for (var field in defaults) {
	                    if (this._globalconfig[field] === undefined) {
	                        this._globalconfig[field] = defaults[field];
	                    }
	                }
	            }
	        }
	        // Todo: move this out of static state
	        if (this.config.isCookieUseDisabled) {
	            Util.disableCookies();
	        }
	        // Todo: move this out of static state
	        if (this.config.isStorageUseDisabled) {
	            Util.disableStorage();
	        }
	        var configGetters = {
	            instrumentationKey: function () { return config.instrumentationKey; },
	            accountId: function () { return _this.config.accountId || config.accountId; },
	            sessionRenewalMs: function () { return _this.config.sessionRenewalMs || config.sessionRenewalMs; },
	            sessionExpirationMs: function () { return _this.config.sessionExpirationMs || config.sessionExpirationMs; },
	            sampleRate: function () { return _this.config.samplingPercentage || config.samplingPercentage; },
	            cookieDomain: function () { return _this.config.cookieDomain || config.cookieDomain; },
	            sdkExtension: function () { return _this.config.sdkExtension || config.sdkExtension; },
	            isBrowserLinkTrackingEnabled: function () { return _this.config.isBrowserLinkTrackingEnabled || config.isBrowserLinkTrackingEnabled; },
	            appId: function () { return _this.config.appId || config.appId; }
	        };
	        this._pageViewPerformanceManager = new PageViewPerformanceManager(this.core);
	        this._pageViewManager = new PageViewManager(this, this.config.overridePageViewDuration, this.core, this._pageViewPerformanceManager);
	        this._pageVisitTimeManager = new PageVisitTimeManager(this._logger, function (pageName, pageUrl, pageVisitTime) { return _this.trackPageVisitTime(pageName, pageUrl, pageVisitTime); });
	        this._telemetryInitializers = [];
	        this._addDefaultTelemetryInitializers(configGetters);
	        this._eventTracking = new Timing(this._logger, "trackEvent");
	        this._eventTracking.action =
	            function (name, url, duration, properties) {
	                if (!properties) {
	                    properties = {};
	                }
	                properties[durationProperty] = duration.toString();
	                _this.trackEvent({ name: name, properties: properties });
	            };
	        // initialize page view timing
	        this._pageTracking = new Timing(this._logger, "trackPageView");
	        this._pageTracking.action = function (name, url, duration, properties, measurements) {
	            // duration must be a custom property in order for the collector to extract it
	            if (CoreUtils.isNullOrUndefined(properties)) {
	                properties = {};
	            }
	            properties[durationProperty] = duration.toString();
	            var pageViewItem = {
	                name: name,
	                uri: url,
	                properties: properties,
	                measurements: measurements
	            };
	            _this.sendPageViewInternal(pageViewItem);
	        };
	        var instance = this;
	        if (this.config.disableExceptionTracking === false &&
	            !this.config.autoExceptionInstrumented) {
	            // We want to enable exception auto collection and it has not been done so yet
	            var onerror_1 = "onerror";
	            var originalOnError_1 = window[onerror_1];
	            window.onerror = function (message, url, lineNumber, columnNumber, error) {
	                var handled = originalOnError_1 && originalOnError_1(message, url, lineNumber, columnNumber, error);
	                if (handled !== true) {
	                    instance._onerror({
	                        message: message,
	                        url: url,
	                        lineNumber: lineNumber,
	                        columnNumber: columnNumber,
	                        error: error
	                    });
	                }
	                return handled;
	            };
	            this.config.autoExceptionInstrumented = true;
	        }
	        /**
	         * Create a custom "locationchange" event which is triggered each time the history object is changed
	         */
	        if (this.config.enableAutoRouteTracking === true
	            && typeof history === "object" && typeof history.pushState === "function" && typeof history.replaceState === "function"
	            && typeof window === "object"
	            && typeof Event !== "undefined") {
	            var _self_1 = this;
	            // Find the properties plugin
	            extensions.forEach(function (extension) {
	                if (extension.identifier === PropertiesPluginIdentifier) {
	                    _this._properties = extension;
	                }
	            });
	            history.pushState = (function (f) { return function pushState() {
	                var ret = f.apply(this, arguments);
	                window.dispatchEvent(Util.createDomEvent(_self_1.config.namePrefix + "pushState"));
	                window.dispatchEvent(Util.createDomEvent(_self_1.config.namePrefix + "locationchange"));
	                return ret;
	            }; })(history.pushState);
	            history.replaceState = (function (f) { return function replaceState() {
	                var ret = f.apply(this, arguments);
	                window.dispatchEvent(Util.createDomEvent(_self_1.config.namePrefix + "replaceState"));
	                window.dispatchEvent(Util.createDomEvent(_self_1.config.namePrefix + "locationchange"));
	                return ret;
	            }; })(history.replaceState);
	            window.addEventListener(_self_1.config.namePrefix + "popstate", function () {
	                window.dispatchEvent(Util.createDomEvent(_self_1.config.namePrefix + "locationchange"));
	            });
	            window.addEventListener(_self_1.config.namePrefix + "locationchange", function () {
	                if (_self_1._properties && _self_1._properties.context && _self_1._properties.context.telemetryTrace) {
	                    _self_1._properties.context.telemetryTrace.traceID = Util.generateW3CId();
	                    _self_1._properties.context.telemetryTrace.name = window.location && window.location.pathname || "_unknown_";
	                }
	                if (_this._currUri) {
	                    _this._prevUri = _this._currUri;
	                    _this._currUri = window.location && window.location.href || "";
	                }
	                else {
	                    _this._currUri = window.location && window.location.href || "";
	                }
	                setTimeout((function (uri) {
	                    // todo: override start time so that it is not affected by autoRoutePVDelay
	                    _self_1.trackPageView({ refUri: uri, properties: { duration: 0 } }); // SPA route change loading durations are undefined, so send 0
	                }).bind(_this, _this._prevUri), _self_1.autoRoutePVDelay);
	            });
	        }
	        this._isInitialized = true;
	    };
	    /**
	     * Log a page visit time
	     * @param    pageName    Name of page
	     * @param    pageVisitDuration Duration of visit to the page in milleseconds
	     */
	    ApplicationInsights.prototype.trackPageVisitTime = function (pageName, pageUrl, pageVisitTime) {
	        var properties = { PageName: pageName, PageUrl: pageUrl };
	        this.trackMetric({
	            name: "PageVisitTime",
	            average: pageVisitTime,
	            max: pageVisitTime,
	            min: pageVisitTime,
	            sampleCount: 1
	        }, properties);
	    };
	    ApplicationInsights.prototype._addDefaultTelemetryInitializers = function (configGetters) {
	        if (!configGetters.isBrowserLinkTrackingEnabled()) {
	            var browserLinkPaths_1 = ['/browserLinkSignalR/', '/__browserLink/'];
	            var dropBrowserLinkRequests = function (envelope) {
	                if (envelope.baseType === RemoteDependencyData$1.dataType) {
	                    var remoteData = envelope.baseData;
	                    if (remoteData) {
	                        for (var i = 0; i < browserLinkPaths_1.length; i++) {
	                            if (remoteData.target && remoteData.target.indexOf(browserLinkPaths_1[i]) >= 0) {
	                                return false;
	                            }
	                        }
	                    }
	                }
	                return true;
	            };
	            this._addTelemetryInitializer(dropBrowserLinkRequests);
	        }
	    };
	    ApplicationInsights.prototype._addTelemetryInitializer = function (telemetryInitializer) {
	        this._telemetryInitializers.push(telemetryInitializer);
	    };
	    ApplicationInsights.prototype._sendCORSException = function (url) {
	        var exception = {
	            message: "Script error: The browser's same-origin policy prevents us from getting the details of this exception. Consider using the 'crossorigin' attribute.",
	            url: url,
	            lineNumber: 0,
	            columnNumber: 0,
	            error: undefined
	        };
	        var telemetryItem = TelemetryItemCreator.create(exception, Exception.dataType, Exception.envelopeType, this._logger, { url: url });
	        this.core.track(telemetryItem);
	    };
	    ApplicationInsights.Version = "2.2.2"; // Not currently used anywhere
	    return ApplicationInsights;
	}());
	/**
	 * Used to record timed events and page views.
	 */
	var Timing = /** @class */ (function () {
	    function Timing(logger, name) {
	        this._name = name;
	        this._events = {};
	        this._logger = logger;
	    }
	    Timing.prototype.start = function (name) {
	        if (typeof this._events[name] !== "undefined") {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.StartCalledMoreThanOnce, "start was called more than once for this event without calling stop.", { name: this._name, key: name }, true);
	        }
	        this._events[name] = +new Date;
	    };
	    Timing.prototype.stop = function (name, url, properties, measurements) {
	        var start = this._events[name];
	        if (isNaN(start)) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.StopCalledWithoutStart, "stop was called without a corresponding start.", { name: this._name, key: name }, true);
	        }
	        else {
	            var end = +new Date;
	            var duration = DateTimeUtils.GetDuration(start, end);
	            this.action(name, url, duration, properties, measurements);
	        }
	        delete this._events[name];
	        this._events[name] = undefined;
	    };
	    return Timing;
	}());

	/*
	 * An array based send buffer.
	 */
	var ArraySendBuffer = /** @class */ (function () {
	    function ArraySendBuffer(config) {
	        this._config = config;
	        this._buffer = [];
	    }
	    ArraySendBuffer.prototype.enqueue = function (payload) {
	        this._buffer.push(payload);
	    };
	    ArraySendBuffer.prototype.count = function () {
	        return this._buffer.length;
	    };
	    ArraySendBuffer.prototype.clear = function () {
	        this._buffer.length = 0;
	    };
	    ArraySendBuffer.prototype.getItems = function () {
	        return this._buffer.slice(0);
	    };
	    ArraySendBuffer.prototype.batchPayloads = function (payload) {
	        if (payload && payload.length > 0) {
	            var batch = this._config.emitLineDelimitedJson() ?
	                payload.join("\n") :
	                "[" + payload.join(",") + "]";
	            return batch;
	        }
	        return null;
	    };
	    ArraySendBuffer.prototype.markAsSent = function (payload) {
	        this.clear();
	    };
	    ArraySendBuffer.prototype.clearSent = function (payload) {
	        // not supported
	    };
	    return ArraySendBuffer;
	}());
	/*
	 * Session storege buffer holds a copy of all unsent items in the browser session storage.
	 */
	var SessionStorageSendBuffer = /** @class */ (function () {
	    function SessionStorageSendBuffer(logger, config) {
	        this._bufferFullMessageSent = false;
	        this._logger = logger;
	        this._config = config;
	        var bufferItems = this.getBuffer(SessionStorageSendBuffer.BUFFER_KEY);
	        var notDeliveredItems = this.getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
	        this._buffer = bufferItems.concat(notDeliveredItems);
	        // If the buffer has too many items, drop items from the end.
	        if (this._buffer.length > SessionStorageSendBuffer.MAX_BUFFER_SIZE) {
	            this._buffer.length = SessionStorageSendBuffer.MAX_BUFFER_SIZE;
	        }
	        // update DataLossAnalyzer with the number of recovered items
	        // Uncomment if you want to use DataLossanalyzer
	        // DataLossAnalyzer.itemsRestoredFromSessionBuffer = this._buffer.length;
	        this.setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, []);
	        this.setBuffer(SessionStorageSendBuffer.BUFFER_KEY, this._buffer);
	    }
	    SessionStorageSendBuffer.prototype.enqueue = function (payload) {
	        if (this._buffer.length >= SessionStorageSendBuffer.MAX_BUFFER_SIZE) {
	            // sent internal log only once per page view
	            if (!this._bufferFullMessageSent) {
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SessionStorageBufferFull, "Maximum buffer size reached: " + this._buffer.length, true);
	                this._bufferFullMessageSent = true;
	            }
	            return;
	        }
	        this._buffer.push(payload);
	        this.setBuffer(SessionStorageSendBuffer.BUFFER_KEY, this._buffer);
	    };
	    SessionStorageSendBuffer.prototype.count = function () {
	        return this._buffer.length;
	    };
	    SessionStorageSendBuffer.prototype.clear = function () {
	        this._buffer.length = 0;
	        this.setBuffer(SessionStorageSendBuffer.BUFFER_KEY, []);
	        this.setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, []);
	        this._bufferFullMessageSent = false;
	    };
	    SessionStorageSendBuffer.prototype.getItems = function () {
	        return this._buffer.slice(0);
	    };
	    SessionStorageSendBuffer.prototype.batchPayloads = function (payload) {
	        if (payload && payload.length > 0) {
	            var batch = this._config.emitLineDelimitedJson() ?
	                payload.join("\n") :
	                "[" + payload.join(",") + "]";
	            return batch;
	        }
	        return null;
	    };
	    SessionStorageSendBuffer.prototype.markAsSent = function (payload) {
	        this._buffer = this.removePayloadsFromBuffer(payload, this._buffer);
	        this.setBuffer(SessionStorageSendBuffer.BUFFER_KEY, this._buffer);
	        var sentElements = this.getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
	        if (sentElements instanceof Array && payload instanceof Array) {
	            sentElements = sentElements.concat(payload);
	            if (sentElements.length > SessionStorageSendBuffer.MAX_BUFFER_SIZE) {
	                // We send telemetry normally. If the SENT_BUFFER is too big we don't add new elements
	                // until we receive a response from the backend and the buffer has free space again (see clearSent method)
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.SessionStorageBufferFull, "Sent buffer reached its maximum size: " + sentElements.length, true);
	                sentElements.length = SessionStorageSendBuffer.MAX_BUFFER_SIZE;
	            }
	            this.setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, sentElements);
	        }
	    };
	    SessionStorageSendBuffer.prototype.clearSent = function (payload) {
	        var sentElements = this.getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
	        sentElements = this.removePayloadsFromBuffer(payload, sentElements);
	        this.setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, sentElements);
	    };
	    SessionStorageSendBuffer.prototype.removePayloadsFromBuffer = function (payloads, buffer) {
	        var remaining = [];
	        for (var i in buffer) {
	            var contains = false;
	            for (var j in payloads) {
	                if (payloads[j] === buffer[i]) {
	                    contains = true;
	                    break;
	                }
	            }
	            if (!contains) {
	                remaining.push(buffer[i]);
	            }
	        }
	        return remaining;
	    };
	    SessionStorageSendBuffer.prototype.getBuffer = function (key) {
	        var prefixedKey = key;
	        try {
	            prefixedKey = this._config.namePrefix && this._config.namePrefix() ? this._config.namePrefix() + "_" + prefixedKey : prefixedKey;
	            var bufferJson = Util.getSessionStorage(this._logger, prefixedKey);
	            if (bufferJson) {
	                var buffer = JSON.parse(bufferJson);
	                if (buffer) {
	                    return buffer;
	                }
	            }
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedToRestoreStorageBuffer, " storage key: " + prefixedKey + ", " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	        return [];
	    };
	    SessionStorageSendBuffer.prototype.setBuffer = function (key, buffer) {
	        var prefixedKey = key;
	        try {
	            prefixedKey = this._config.namePrefix && this._config.namePrefix() ? this._config.namePrefix() + "_" + prefixedKey : prefixedKey;
	            var bufferJson = JSON.stringify(buffer);
	            Util.setSessionStorage(this._logger, prefixedKey, bufferJson);
	        }
	        catch (e) {
	            // if there was an error, clear the buffer
	            // telemetry is stored in the _buffer array so we won't loose any items
	            Util.setSessionStorage(this._logger, prefixedKey, JSON.stringify([]));
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedToSetStorageBuffer, " storage key: " + prefixedKey + ", " + Util.getExceptionName(e) + ". Buffer cleared", { exception: Util.dump(e) });
	        }
	    };
	    SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer";
	    SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer";
	    // Maximum number of payloads stored in the buffer. If the buffer is full, new elements will be dropped.
	    SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2000;
	    return SessionStorageSendBuffer;
	}());

	var EnvelopeCreator = /** @class */ (function () {
	    function EnvelopeCreator() {
	    }
	    EnvelopeCreator.extractProperties = function (data) {
	        var customProperties = null;
	        for (var key in data) {
	            if (data.hasOwnProperty(key)) {
	                var value = data[key];
	                if (typeof value !== "number") {
	                    if (!customProperties) {
	                        customProperties = {};
	                    }
	                    customProperties[key] = value;
	                }
	            }
	        }
	        return customProperties;
	    };
	    EnvelopeCreator.extractPropsAndMeasurements = function (data, properties, measurements) {
	        if (!CoreUtils.isNullOrUndefined(data)) {
	            for (var key in data) {
	                if (data.hasOwnProperty(key)) {
	                    var value = data[key];
	                    if (typeof value === "number") {
	                        measurements[key] = value;
	                    }
	                    else if (typeof value === "string") {
	                        properties[key] = value;
	                    }
	                    else {
	                        properties[key] = JSON.stringify(value);
	                    }
	                }
	            }
	        }
	    };
	    // TODO: Do we want this to take logger as arg or use this._logger as nonstatic?
	    EnvelopeCreator.createEnvelope = function (logger, envelopeType, telemetryItem, data) {
	        var envelope = new Envelope$1(logger, data, envelopeType);
	        envelope.iKey = telemetryItem.iKey;
	        var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
	        envelope.name = envelope.name.replace("{0}", iKeyNoDashes);
	        // extract all extensions from ctx
	        EnvelopeCreator.extractPartAExtensions(telemetryItem, envelope);
	        // loop through the envelope tags (extension of Part A) and pick out the ones that should go in outgoing envelope tags
	        if (!telemetryItem.tags) {
	            telemetryItem.tags = [];
	        }
	        return envelope;
	    };
	    /*
	     * Maps Part A data from CS 4.0
	     */
	    EnvelopeCreator.extractPartAExtensions = function (item, env) {
	        // todo: switch to keys from common in this method
	        if (!env.tags) {
	            env.tags = {};
	        }
	        if (!item.ext) {
	            item.ext = {};
	        }
	        if (!item.tags) {
	            item.tags = [];
	        }
	        if (item.ext.user) {
	            if (item.ext.user.authId) {
	                env.tags[CtxTagKeys.userAuthUserId] = item.ext.user.authId;
	            }
	            var userId = item.ext.user.id || item.ext.user.localId;
	            if (userId) {
	                env.tags[CtxTagKeys.userId] = userId;
	            }
	        }
	        if (item.ext.app) {
	            if (item.ext.app.sesId) {
	                env.tags[CtxTagKeys.sessionId] = item.ext.app.sesId;
	            }
	        }
	        if (item.ext.device) {
	            if (item.ext.device.id || item.ext.device.localId) {
	                env.tags[CtxTagKeys.deviceId] = item.ext.device.id || item.ext.device.localId;
	            }
	            if (item.ext.device.deviceClass) {
	                env.tags[CtxTagKeys.deviceType] = item.ext.device.deviceClass;
	            }
	            if (item.ext.device.ip) {
	                env.tags[CtxTagKeys.deviceIp] = item.ext.device.ip;
	            }
	        }
	        if (item.ext.web) {
	            var web = item.ext.web;
	            if (web.browserLang) {
	                env.tags[CtxTagKeys.deviceLanguage] = web.browserLang;
	            }
	            if (web.browserVer) {
	                env.tags[CtxTagKeys.deviceBrowserVersion] = web.browserVer;
	            }
	            if (web.browser) {
	                env.tags[CtxTagKeys.deviceBrowser] = web.browser;
	            }
	            env.data = env.data || {};
	            env.data.baseData = env.data.baseData || {};
	            env.data.baseData.properties = env.data.baseData.properties || {};
	            if (web.domain) {
	                env.data.baseData.properties['domain'] = web.domain;
	            }
	            if (web.isManual) {
	                env.data.baseData.properties['isManual'] = web.isManual.toString();
	            }
	            if (web.screenRes) {
	                env.data.baseData.properties['screenRes'] = web.screenRes;
	            }
	            if (web.userConsent) {
	                env.data.baseData.properties['userConsent'] = web.userConsent.toString();
	            }
	        }
	        if (item.ext.device) {
	            if (item.ext.device.model) {
	                env.tags[CtxTagKeys.deviceModel] = item.ext.device.model;
	            }
	        }
	        if (item.ext.os && item.ext.os.name) {
	            env.tags[CtxTagKeys.deviceOS] = item.ext.os.name;
	        }
	        if (item.ext.device) {
	            if (item.ext.device.deviceType) {
	                env.tags[CtxTagKeys.deviceType] = item.ext.device.deviceType;
	            }
	        }
	        // No support for mapping Trace.traceState to 2.0 as it is currently empty
	        if (item.ext.trace) {
	            if (item.ext.trace.parentID) {
	                env.tags[CtxTagKeys.operationParentId] = item.ext.trace.parentID;
	            }
	            if (item.ext.trace.name) {
	                env.tags[CtxTagKeys.operationName] = item.ext.trace.name;
	            }
	            if (item.ext.trace.traceID) {
	                env.tags[CtxTagKeys.operationId] = item.ext.trace.traceID;
	            }
	        }
	        // Sample 4.0 schema
	        //  {
	        //     "time" : "2018-09-05T22:51:22.4936Z",
	        //     "name" : "MetricWithNamespace",
	        //     "iKey" : "ABC-5a4cbd20-e601-4ef5-a3c6-5d6577e4398e",
	        //     "ext": {  "cloud": {
	        //          "role": "WATSON3",
	        //          "roleInstance": "CO4AEAP00000260"
	        //      },
	        //      "device": {}, "correlation": {} },
	        //      "tags": [
	        //        { "amazon.region" : "east2" },
	        //        { "os.expid" : "wp:02df239" }
	        //     ]
	        //   }
	        var tgs = {};
	        var _loop_1 = function (i) {
	            var tg = item.tags[i];
	            // Object.keys returns an array of keys
	            Object.keys(tg).forEach(function (key) {
	                tgs[key] = tg[key];
	            });
	            item.tags.splice(i, 1);
	        };
	        // deals with tags.push({object})
	        for (var i = item.tags.length - 1; i >= 0; i--) {
	            _loop_1(i);
	        }
	        // deals with tags[key]=value
	        for (var tg in item.tags) {
	            tgs[tg] = item.tags[tg];
	        }
	        env.tags = __assign({}, env.tags, tgs);
	        if (!env.tags[CtxTagKeys.internalSdkVersion]) {
	            // Append a version in case it is not already set
	            env.tags[CtxTagKeys.internalSdkVersion] = "javascript:" + EnvelopeCreator.Version;
	        }
	    };
	    EnvelopeCreator.Version = "2.2.2";
	    return EnvelopeCreator;
	}());
	var DependencyEnvelopeCreator = /** @class */ (function (_super) {
	    __extends(DependencyEnvelopeCreator, _super);
	    function DependencyEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    DependencyEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (CoreUtils.isNullOrUndefined(telemetryItem.baseData)) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	        var customMeasurements = telemetryItem.baseData.measurements || {};
	        var customProperties = telemetryItem.baseData.properties || {};
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements);
	        var bd = telemetryItem.baseData;
	        if (CoreUtils.isNullOrUndefined(bd)) {
	            logger.warnToConsole("Invalid input for dependency data");
	            return null;
	        }
	        var id = bd.id;
	        var absoluteUrl = bd.target;
	        var command = bd.name;
	        var duration = bd.duration;
	        var success = bd.success;
	        var resultCode = bd.responseCode;
	        var requestAPI = bd.type;
	        var correlationContext = bd.correlationContext;
	        var method = bd.properties && bd.properties[HttpMethod] ? bd.properties[HttpMethod] : "GET";
	        var baseData = new RemoteDependencyData$1(logger, id, absoluteUrl, command, duration, success, resultCode, method, requestAPI, correlationContext, customProperties, customMeasurements);
	        var data = new Data$1(RemoteDependencyData$1.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, RemoteDependencyData$1.envelopeType, telemetryItem, data);
	    };
	    DependencyEnvelopeCreator.DependencyEnvelopeCreator = new DependencyEnvelopeCreator();
	    return DependencyEnvelopeCreator;
	}(EnvelopeCreator));
	var EventEnvelopeCreator = /** @class */ (function (_super) {
	    __extends(EventEnvelopeCreator, _super);
	    function EventEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    EventEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (CoreUtils.isNullOrUndefined(telemetryItem.baseData)) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	        var customProperties = {};
	        var customMeasurements = {};
	        if (telemetryItem.baseType !== Event$1.dataType) {
	            customProperties['baseTypeSource'] = telemetryItem.baseType; // save the passed in base type as a property
	        }
	        if (telemetryItem.baseType === Event$1.dataType) {
	            customProperties = telemetryItem.baseData.properties || {};
	            customMeasurements = telemetryItem.baseData.measurements || {};
	        }
	        else {
	            if (telemetryItem.baseData) {
	                EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.baseData, customProperties, customMeasurements);
	            }
	        }
	        // Exract root level properties from part C telemetryItem.data
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements);
	        var eventName = telemetryItem.baseData.name;
	        var baseData = new Event$1(logger, eventName, customProperties, customMeasurements);
	        var data = new Data$1(Event$1.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, Event$1.envelopeType, telemetryItem, data);
	    };
	    EventEnvelopeCreator.EventEnvelopeCreator = new EventEnvelopeCreator();
	    return EventEnvelopeCreator;
	}(EnvelopeCreator));
	var ExceptionEnvelopeCreator = /** @class */ (function (_super) {
	    __extends(ExceptionEnvelopeCreator, _super);
	    function ExceptionEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ExceptionEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (CoreUtils.isNullOrUndefined(telemetryItem.baseData)) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	        var bd = telemetryItem.baseData;
	        var baseData = Exception.CreateFromInterface(logger, bd);
	        var data = new Data$1(Exception.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, Exception.envelopeType, telemetryItem, data);
	    };
	    ExceptionEnvelopeCreator.ExceptionEnvelopeCreator = new ExceptionEnvelopeCreator();
	    return ExceptionEnvelopeCreator;
	}(EnvelopeCreator));
	var MetricEnvelopeCreator = /** @class */ (function (_super) {
	    __extends(MetricEnvelopeCreator, _super);
	    function MetricEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    MetricEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (CoreUtils.isNullOrUndefined(telemetryItem.baseData)) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	        var props = telemetryItem.baseData.properties || {};
	        var customProperties = EnvelopeCreator.extractProperties(telemetryItem.data);
	        customProperties = __assign({}, props, customProperties);
	        var name = telemetryItem.baseData.name;
	        var average = telemetryItem.baseData.average;
	        var sampleCount = telemetryItem.baseData.sampleCount;
	        var min = telemetryItem.baseData.min;
	        var max = telemetryItem.baseData.max;
	        var baseData = new Metric(logger, name, average, sampleCount, min, max, customProperties);
	        var data = new Data$1(Metric.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, Metric.envelopeType, telemetryItem, data);
	    };
	    MetricEnvelopeCreator.MetricEnvelopeCreator = new MetricEnvelopeCreator();
	    return MetricEnvelopeCreator;
	}(EnvelopeCreator));
	var PageViewEnvelopeCreator = /** @class */ (function (_super) {
	    __extends(PageViewEnvelopeCreator, _super);
	    function PageViewEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    PageViewEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (CoreUtils.isNullOrUndefined(telemetryItem.baseData)) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	        // Since duration is not part of the domain properties in Common Schema, extract it from part C
	        var duration = undefined;
	        if (!CoreUtils.isNullOrUndefined(telemetryItem.baseData) &&
	            !CoreUtils.isNullOrUndefined(telemetryItem.baseData.properties) &&
	            !CoreUtils.isNullOrUndefined(telemetryItem.baseData.properties.duration)) {
	            duration = telemetryItem.baseData.properties.duration;
	            delete telemetryItem.baseData.properties.duration;
	        }
	        else if (!CoreUtils.isNullOrUndefined(telemetryItem.data) &&
	            !CoreUtils.isNullOrUndefined(telemetryItem.data["duration"])) {
	            duration = telemetryItem.data["duration"];
	            delete telemetryItem.data["duration"];
	        }
	        var bd = telemetryItem.baseData;
	        // special case: pageview.id is grabbed from current operation id. Analytics plugin is decoupled from properties plugin, so this is done here instead. This can be made a default telemetry intializer instead if needed to be decoupled from channel
	        var currentContextId;
	        if (telemetryItem.ext && telemetryItem.ext.trace && telemetryItem.ext.trace.traceID) {
	            currentContextId = telemetryItem.ext.trace.traceID;
	        }
	        var id = bd.id || currentContextId;
	        var name = bd.name;
	        var url = bd.uri;
	        var properties = bd.properties || {};
	        var measurements = bd.measurements || {};
	        // refUri is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!CoreUtils.isNullOrUndefined(bd.refUri)) {
	            properties["refUri"] = bd.refUri;
	        }
	        // pageType is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!CoreUtils.isNullOrUndefined(bd.pageType)) {
	            properties["pageType"] = bd.pageType;
	        }
	        // isLoggedIn is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!CoreUtils.isNullOrUndefined(bd.isLoggedIn)) {
	            properties["isLoggedIn"] = bd.isLoggedIn.toString();
	        }
	        // pageTags is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
	        if (!CoreUtils.isNullOrUndefined(bd.properties)) {
	            var pageTags = bd.properties;
	            for (var key in pageTags) {
	                if (pageTags.hasOwnProperty(key)) {
	                    properties[key] = pageTags[key];
	                }
	            }
	        }
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, properties, measurements);
	        var baseData = new PageView(logger, name, url, duration, properties, measurements, id);
	        var data = new Data$1(PageView.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, PageView.envelopeType, telemetryItem, data);
	    };
	    PageViewEnvelopeCreator.PageViewEnvelopeCreator = new PageViewEnvelopeCreator();
	    return PageViewEnvelopeCreator;
	}(EnvelopeCreator));
	var PageViewPerformanceEnvelopeCreator = /** @class */ (function (_super) {
	    __extends(PageViewPerformanceEnvelopeCreator, _super);
	    function PageViewPerformanceEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    PageViewPerformanceEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (CoreUtils.isNullOrUndefined(telemetryItem.baseData)) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	        var bd = telemetryItem.baseData;
	        var name = bd.name;
	        var url = bd.uri || bd.url;
	        var properties = bd.properties || {};
	        var measurements = bd.measurements || {};
	        EnvelopeCreator.extractPropsAndMeasurements(telemetryItem.data, properties, measurements);
	        var baseData = new PageViewPerformance(logger, name, url, undefined, properties, measurements, bd);
	        var data = new Data$1(PageViewPerformance.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, PageViewPerformance.envelopeType, telemetryItem, data);
	    };
	    PageViewPerformanceEnvelopeCreator.PageViewPerformanceEnvelopeCreator = new PageViewPerformanceEnvelopeCreator();
	    return PageViewPerformanceEnvelopeCreator;
	}(EnvelopeCreator));
	var TraceEnvelopeCreator = /** @class */ (function (_super) {
	    __extends(TraceEnvelopeCreator, _super);
	    function TraceEnvelopeCreator() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TraceEnvelopeCreator.prototype.Create = function (logger, telemetryItem) {
	        this._logger = logger;
	        if (CoreUtils.isNullOrUndefined(telemetryItem.baseData)) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryEnvelopeInvalid, "telemetryItem.baseData cannot be null.");
	        }
	        var message = telemetryItem.baseData.message;
	        var severityLevel = telemetryItem.baseData.severityLevel;
	        var customProperties = EnvelopeCreator.extractProperties(telemetryItem.data);
	        var props = __assign({}, customProperties, telemetryItem.baseData.properties);
	        var baseData = new Trace(logger, message, severityLevel, props);
	        var data = new Data$1(Trace.dataType, baseData);
	        return EnvelopeCreator.createEnvelope(logger, Trace.envelopeType, telemetryItem, data);
	    };
	    TraceEnvelopeCreator.TraceEnvelopeCreator = new TraceEnvelopeCreator();
	    return TraceEnvelopeCreator;
	}(EnvelopeCreator));

	var Serializer = /** @class */ (function () {
	    function Serializer(logger) {
	        this._logger = logger;
	    }
	    /**
	     * Serializes the current object to a JSON string.
	     */
	    Serializer.prototype.serialize = function (input) {
	        var output = this._serializeObject(input, "root");
	        return JSON.stringify(output);
	    };
	    Serializer.prototype._serializeObject = function (source, name) {
	        var circularReferenceCheck = "__aiCircularRefCheck";
	        var output = {};
	        if (!source) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSerializeObject, "cannot serialize object because it is null or undefined", { name: name }, true);
	            return output;
	        }
	        if (source[circularReferenceCheck]) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CircularReferenceDetected, "Circular reference detected while serializing object", { name: name }, true);
	            return output;
	        }
	        if (!source.aiDataContract) {
	            // special case for measurements/properties/tags
	            if (name === "measurements") {
	                output = this._serializeStringMap(source, "number", name);
	            }
	            else if (name === "properties") {
	                output = this._serializeStringMap(source, "string", name);
	            }
	            else if (name === "tags") {
	                output = this._serializeStringMap(source, "string", name);
	            }
	            else if (Util.isArray(source)) {
	                output = this._serializeArray(source, name);
	            }
	            else {
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CannotSerializeObjectNonSerializable, "Attempting to serialize an object which does not implement ISerializable", { name: name }, true);
	                try {
	                    // verify that the object can be stringified
	                    JSON.stringify(source);
	                    output = source;
	                }
	                catch (e) {
	                    // if serialization fails return an empty string
	                    this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSerializeObject, (e && typeof e.toString === 'function') ? e.toString() : "Error serializing object", null, true);
	                }
	            }
	            return output;
	        }
	        source[circularReferenceCheck] = true;
	        for (var field in source.aiDataContract) {
	            var contract = source.aiDataContract[field];
	            var isRequired = (typeof contract === "function") ? (contract() & FieldType.Required) : (contract & FieldType.Required);
	            var isHidden = (typeof contract === "function") ? (contract() & FieldType.Hidden) : (contract & FieldType.Hidden);
	            var isArray = contract & FieldType.Array;
	            var isPresent = source[field] !== undefined;
	            var isObject = typeof source[field] === "object" && source[field] !== null;
	            if (isRequired && !isPresent && !isArray) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.MissingRequiredFieldSpecification, "Missing required field specification. The field is required but not present on source", { field: field, name: name });
	                // If not in debug mode, continue and hope the error is permissible
	                continue;
	            }
	            if (isHidden) {
	                // Don't serialize hidden fields
	                continue;
	            }
	            var value;
	            if (isObject) {
	                if (isArray) {
	                    // special case; resurse on each object in the source array
	                    value = this._serializeArray(source[field], field);
	                }
	                else {
	                    // recurse on the source object in this field
	                    value = this._serializeObject(source[field], field);
	                }
	            }
	            else {
	                // assign the source field to the output even if undefined or required
	                value = source[field];
	            }
	            // only emit this field if the value is defined
	            if (value !== undefined) {
	                output[field] = value;
	            }
	        }
	        delete source[circularReferenceCheck];
	        return output;
	    };
	    Serializer.prototype._serializeArray = function (sources, name) {
	        var output = undefined;
	        if (!!sources) {
	            if (!Util.isArray(sources)) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.ItemNotInArray, "This field was specified as an array in the contract but the item is not an array.\r\n", { name: name }, true);
	            }
	            else {
	                output = [];
	                for (var i = 0; i < sources.length; i++) {
	                    var source = sources[i];
	                    var item = this._serializeObject(source, name + "[" + i + "]");
	                    output.push(item);
	                }
	            }
	        }
	        return output;
	    };
	    Serializer.prototype._serializeStringMap = function (map, expectedType, name) {
	        var output = undefined;
	        if (map) {
	            output = {};
	            for (var field in map) {
	                var value = map[field];
	                if (expectedType === "string") {
	                    if (value === undefined) {
	                        output[field] = "undefined";
	                    }
	                    else if (value === null) {
	                        output[field] = "null";
	                    }
	                    else if (!value.toString) {
	                        output[field] = "invalid field: toString() is not defined.";
	                    }
	                    else {
	                        output[field] = value.toString();
	                    }
	                }
	                else if (expectedType === "number") {
	                    if (value === undefined) {
	                        output[field] = "undefined";
	                    }
	                    else if (value === null) {
	                        output[field] = "null";
	                    }
	                    else {
	                        var num = parseFloat(value);
	                        if (isNaN(num)) {
	                            output[field] = "NaN";
	                        }
	                        else {
	                            output[field] = num;
	                        }
	                    }
	                }
	                else {
	                    output[field] = "invalid field: " + name + " is of unknown type.";
	                    this._logger.throwInternal(LoggingSeverity.CRITICAL, output[field], null, true);
	                }
	            }
	        }
	        return output;
	    };
	    return Serializer;
	}());

	/**
	 * @description Monitors browser for offline events
	 * @export default - Offline: Static instance of OfflineListener
	 * @class OfflineListener
	 */
	var OfflineListener = /** @class */ (function () {
	    function OfflineListener() {
	        this._onlineStatus = true;
	        try {
	            if (typeof window === 'undefined') {
	                this.isListening = false;
	            }
	            else if (window && window.addEventListener) {
	                window.addEventListener('online', this._setOnline.bind(this), false);
	                window.addEventListener('offline', this._setOffline.bind(this), false);
	                this.isListening = true;
	            }
	            else if (document && document.body) {
	                document.body.ononline = this._setOnline.bind(this);
	                document.body.onoffline = this._setOffline.bind(this);
	                this.isListening = true;
	            }
	            else if (document) {
	                document.ononline = this._setOnline.bind(this);
	                document.onoffline = this._setOffline.bind(this);
	                this.isListening = true;
	            }
	            else {
	                // Could not find a place to add event listener
	                this.isListening = false;
	            }
	        }
	        catch (e) {
	            //this makes react-native less angry
	            this.isListening = false;
	        }
	    }
	    OfflineListener.prototype._setOnline = function () {
	        this._onlineStatus = true;
	    };
	    OfflineListener.prototype._setOffline = function () {
	        this._onlineStatus = false;
	    };
	    OfflineListener.prototype.isOnline = function () {
	        if (this.isListening) {
	            return this._onlineStatus;
	        }
	        else if (navigator && !CoreUtils.isNullOrUndefined(navigator.onLine)) {
	            return navigator.onLine;
	        }
	        else {
	            // Cannot determine online status - report as online
	            return true;
	        }
	    };
	    OfflineListener.prototype.isOffline = function () {
	        return !this.isOnline();
	    };
	    OfflineListener.Offline = new OfflineListener;
	    return OfflineListener;
	}());
	var Offline = OfflineListener.Offline;

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var HashCodeScoreGenerator = /** @class */ (function () {
	    function HashCodeScoreGenerator() {
	    }
	    HashCodeScoreGenerator.prototype.getHashCodeScore = function (key) {
	        var score = this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE;
	        return score * 100;
	    };
	    HashCodeScoreGenerator.prototype.getHashCode = function (input) {
	        if (input == "") {
	            return 0;
	        }
	        while (input.length < HashCodeScoreGenerator.MIN_INPUT_LENGTH) {
	            input = input.concat(input);
	        }
	        // 5381 is a magic number: http://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function
	        var hash = 5381;
	        for (var i = 0; i < input.length; ++i) {
	            hash = ((hash << 5) + hash) + input.charCodeAt(i);
	            // 'hash' is of number type which means 53 bit integer (http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types-number-type)
	            // 'hash & hash' will keep it 32 bit integer - just to make it clearer what the result is.
	            hash = hash & hash;
	        }
	        return Math.abs(hash);
	    };
	    // We're using 32 bit math, hence max value is (2^31 - 1)
	    HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647;
	    // (Magic number) DJB algorithm can't work on shorter strings (results in poor distribution
	    HashCodeScoreGenerator.MIN_INPUT_LENGTH = 8;
	    return HashCodeScoreGenerator;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var SamplingScoreGenerator = /** @class */ (function () {
	    function SamplingScoreGenerator() {
	        this.hashCodeGeneragor = new HashCodeScoreGenerator();
	        this.keys = new ContextTagKeys();
	    }
	    SamplingScoreGenerator.prototype.getSamplingScore = function (item) {
	        var score = 0;
	        if (item.tags && item.tags[this.keys.userId]) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.tags[this.keys.userId]);
	        }
	        else if (item.ext && item.ext.user && item.ext.user.id) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.ext.user.id);
	        }
	        else if (item.tags && item.tags[this.keys.operationId]) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.tags[this.keys.operationId]);
	        }
	        else if (item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace.traceID) {
	            score = this.hashCodeGeneragor.getHashCodeScore(item.ext.telemetryTrace.traceID);
	        }
	        else {
	            // tslint:disable-next-line:insecure-random
	            score = (Math.random() * 100);
	        }
	        return score;
	    };
	    return SamplingScoreGenerator;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Sample = /** @class */ (function () {
	    function Sample(sampleRate, logger) {
	        // We're using 32 bit math, hence max value is (2^31 - 1)
	        this.INT_MAX_VALUE = 2147483647;
	        if (CoreUtils.isNullOrUndefined(logger)) {
	            this._logger = new DiagnosticLogger();
	        }
	        else {
	            this._logger = logger;
	        }
	        if (sampleRate > 100 || sampleRate < 0) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SampleRateOutOfRange, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", { samplingRate: sampleRate }, true);
	            this.sampleRate = 100;
	        }
	        this.sampleRate = sampleRate;
	        this.samplingScoreGenerator = new SamplingScoreGenerator();
	    }
	    /**
	    * Determines if an envelope is sampled in (i.e. will be sent) or not (i.e. will be dropped).
	    */
	    Sample.prototype.isSampledIn = function (envelope) {
	        var samplingPercentage = this.sampleRate; // 0 - 100
	        var isSampledIn = false;
	        if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {
	            return true;
	        }
	        else if (envelope.baseType === Metric.dataType) {
	            // exclude MetricData telemetry from sampling
	            return true;
	        }
	        isSampledIn = this.samplingScoreGenerator.getSamplingScore(envelope) < samplingPercentage;
	        return isSampledIn;
	    };
	    return Sample;
	}());

	var Sender = /** @class */ (function () {
	    function Sender() {
	        this.priority = 1001;
	        this.identifier = BreezeChannelIdentifier;
	        /**
	         * Whether XMLHttpRequest object is supported. Older version of IE (8,9) do not support it.
	         */
	        this._XMLHttpRequestSupported = false;
	    }
	    Sender.prototype.pause = function () {
	        throw new Error("Method not implemented.");
	    };
	    Sender.prototype.resume = function () {
	        throw new Error("Method not implemented.");
	    };
	    Sender.prototype.flush = function () {
	        try {
	            this.triggerSend();
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FlushFailed, "flush failed, telemetry will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	    };
	    Sender.prototype.onunloadFlush = function () {
	        if ((this._config.onunloadDisableBeacon() === false || this._config.isBeaconApiDisabled() === false) && Util.IsBeaconApiSupported()) {
	            try {
	                this.triggerSend(true, this._beaconSender);
	            }
	            catch (e) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedToSendQueuedTelemetry, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	        else {
	            this.flush();
	        }
	    };
	    Sender.prototype.teardown = function () {
	        throw new Error("Method not implemented.");
	    };
	    Sender.prototype.initialize = function (config, core, extensions) {
	        var _this = this;
	        this._logger = core.logger;
	        this._serializer = new Serializer(core.logger);
	        this._consecutiveErrors = 0;
	        this._retryAt = null;
	        this._lastSend = 0;
	        this._sender = null;
	        var defaultConfig = Sender._getDefaultAppInsightsChannelConfig();
	        this._config = Sender._getEmptyAppInsightsChannelConfig();
	        var _loop_1 = function (field) {
	            this_1._config[field] = function () { return ConfigurationManager.getConfig(config, field, _this.identifier, defaultConfig[field]()); };
	        };
	        var this_1 = this;
	        for (var field in defaultConfig) {
	            _loop_1(field);
	        }
	        this._buffer = (this._config.enableSessionStorageBuffer && Util.canUseSessionStorage())
	            ? new SessionStorageSendBuffer(this._logger, this._config) : new ArraySendBuffer(this._config);
	        this._sample = new Sample(this._config.samplingPercentage(), this._logger);
	        if (!this._config.isBeaconApiDisabled() && Util.IsBeaconApiSupported()) {
	            this._sender = this._beaconSender;
	        }
	        else {
	            if (typeof XMLHttpRequest != "undefined") {
	                var testXhr = new XMLHttpRequest();
	                if ("withCredentials" in testXhr) {
	                    this._sender = this._xhrSender;
	                    this._XMLHttpRequestSupported = true;
	                }
	                else if (typeof XDomainRequest !== "undefined") {
	                    this._sender = this._xdrSender; //IE 8 and 9
	                }
	            }
	        }
	    };
	    Sender.prototype.processTelemetry = function (telemetryItem) {
	        var _this = this;
	        try {
	            // if master off switch is set, don't send any data
	            if (this._config.disableTelemetry()) {
	                // Do not send/save data
	                return;
	            }
	            // validate input
	            if (!telemetryItem) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSendEmptyTelemetry, "Cannot send empty telemetry");
	                return;
	            }
	            // validate event
	            if (telemetryItem.baseData && !telemetryItem.baseType) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidEvent, "Cannot send telemetry without baseData and baseType");
	                return;
	            }
	            if (!telemetryItem.baseType) {
	                // Default
	                telemetryItem.baseType = "EventData";
	            }
	            // ensure a sender was constructed
	            if (!this._sender) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.SenderNotInitialized, "Sender was not initialized");
	                return;
	            }
	            // check if this item should be sampled in, else add sampleRate tag
	            if (!this._isSampledIn(telemetryItem)) {
	                // Item is sampled out, do not send it
	                this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TelemetrySampledAndNotSent, "Telemetry item was sampled out and not sent", { SampleRate: this._sample.sampleRate });
	                return;
	            }
	            else {
	                telemetryItem.tags = telemetryItem.tags || {};
	                telemetryItem.tags[SampleRate] = this._sample.sampleRate;
	            }
	            // construct an envelope that Application Insights endpoint can understand
	            var aiEnvelope_1 = Sender.constructEnvelope(telemetryItem, this._config.instrumentationKey(), this._logger);
	            if (!aiEnvelope_1) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CreateEnvelopeError, "Unable to create an AppInsights envelope");
	                return;
	            }
	            var doNotSendItem_1 = false;
	            // this is for running in legacy mode, where customer may already have a custom initializer present
	            if (telemetryItem.tags && telemetryItem.tags[ProcessLegacy]) {
	                telemetryItem.tags[ProcessLegacy].forEach(function (callBack) {
	                    try {
	                        if (callBack && callBack(aiEnvelope_1) === false) {
	                            doNotSendItem_1 = true;
	                            _this._logger.warnToConsole("Telemetry processor check returns false");
	                        }
	                    }
	                    catch (e) {
	                        // log error but dont stop executing rest of the telemetry initializers
	                        // doNotSendItem = true;
	                        _this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryInitializerFailed, "One of telemetry initializers failed, telemetry item will not be sent: " + Util.getExceptionName(e), { exception: Util.dump(e) }, true);
	                    }
	                });
	                delete telemetryItem.tags[ProcessLegacy];
	            }
	            if (doNotSendItem_1) {
	                return; // do not send, no need to execute next plugin
	            }
	            // check if the incoming payload is too large, truncate if necessary
	            var payload = this._serializer.serialize(aiEnvelope_1);
	            // flush if we would exceed the max-size limit by adding this item
	            var bufferPayload = this._buffer.getItems();
	            var batch = this._buffer.batchPayloads(bufferPayload);
	            if (batch && (batch.length + payload.length > this._config.maxBatchSizeInBytes())) {
	                this.triggerSend();
	            }
	            // enqueue the payload
	            this._buffer.enqueue(payload);
	            // ensure an invocation timeout is set
	            this._setupTimer();
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedAddingTelemetryToBuffer, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	        // hand off the telemetry item to the next plugin
	        if (!CoreUtils.isNullOrUndefined(this._nextPlugin)) {
	            this._nextPlugin.processTelemetry(telemetryItem);
	        }
	    };
	    Sender.prototype.setNextPlugin = function (next) {
	        this._nextPlugin = next;
	    };
	    /**
	     * xhr state changes
	     */
	    Sender.prototype._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {
	        if (xhr.readyState === 4) {
	            var response = null;
	            if (!this._appId) {
	                response = this._parseResponse(xhr.responseText || xhr.response);
	                if (response && response.appId) {
	                    this._appId = response.appId;
	                }
	            }
	            if ((xhr.status < 200 || xhr.status >= 300) && xhr.status !== 0) {
	                if (!this._config.isRetryDisabled() && this._isRetriable(xhr.status)) {
	                    this._resendPayload(payload);
	                    this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". " +
	                        "Response code " + xhr.status + ". Will retry to send " + payload.length + " items.");
	                }
	                else {
	                    this._onError(payload, this._formatErrorMessageXhr(xhr));
	                }
	            }
	            else if (Offline.isOffline()) {
	                // Note: Don't check for staus == 0, since adblock gives this code
	                if (!this._config.isRetryDisabled()) {
	                    var offlineBackOffMultiplier = 10; // arbritrary number
	                    this._resendPayload(payload, offlineBackOffMultiplier);
	                    this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". Offline - Response Code: " + xhr.status + ". Offline status: " + Offline.isOffline() + ". Will retry to send " + payload.length + " items.");
	                }
	            }
	            else {
	                if (xhr.status === 206) {
	                    if (!response) {
	                        response = this._parseResponse(xhr.responseText || xhr.response);
	                    }
	                    if (response && !this._config.isRetryDisabled()) {
	                        this._onPartialSuccess(payload, response);
	                    }
	                    else {
	                        this._onError(payload, this._formatErrorMessageXhr(xhr));
	                    }
	                }
	                else {
	                    this._consecutiveErrors = 0;
	                    this._onSuccess(payload, countOfItemsInPayload);
	                }
	            }
	        }
	    };
	    /**
	     * Immediately send buffered data
	     * @param async {boolean} - Indicates if the events should be sent asynchronously
	     * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed
	     */
	    Sender.prototype.triggerSend = function (async, forcedSender) {
	        if (async === void 0) { async = true; }
	        try {
	            // Send data only if disableTelemetry is false
	            if (!this._config.disableTelemetry()) {
	                if (this._buffer.count() > 0) {
	                    var payload = this._buffer.getItems();
	                    // invoke send
	                    if (forcedSender) {
	                        forcedSender.call(this, payload, async);
	                    }
	                    else {
	                        this._sender(payload, async);
	                    }
	                }
	                // update lastSend time to enable throttling
	                this._lastSend = +new Date;
	            }
	            else {
	                this._buffer.clear();
	            }
	            clearTimeout(this._timeoutHandle);
	            this._timeoutHandle = null;
	            this._retryAt = null;
	        }
	        catch (e) {
	            /* Ignore this error for IE under v10 */
	            if (!Util.getIEVersion() || Util.getIEVersion() > 9) {
	                this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TransmissionFailed, "Telemetry transmission failed, some telemetry will be lost: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	            }
	        }
	    };
	    /**
	     * error handler
	     */
	    Sender.prototype._onError = function (payload, message, event) {
	        this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.OnError, "Failed to send telemetry.", { message: message });
	        this._buffer.clearSent(payload);
	    };
	    /**
	     * partial success handler
	     */
	    Sender.prototype._onPartialSuccess = function (payload, results) {
	        var failed = [];
	        var retry = [];
	        // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.
	        var errors = results.errors.reverse();
	        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
	            var error = errors_1[_i];
	            var extracted = payload.splice(error.index, 1)[0];
	            if (this._isRetriable(error.statusCode)) {
	                retry.push(extracted);
	            }
	            else {
	                // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).
	                failed.push(extracted);
	            }
	        }
	        if (payload.length > 0) {
	            this._onSuccess(payload, results.itemsAccepted);
	        }
	        if (failed.length > 0) {
	            this._onError(failed, this._formatErrorMessageXhr(null, ['partial success', results.itemsAccepted, 'of', results.itemsReceived].join(' ')));
	        }
	        if (retry.length > 0) {
	            this._resendPayload(retry);
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, "Partial success. " +
	                "Delivered: " + payload.length + ", Failed: " + failed.length +
	                ". Will retry to send " + retry.length + " our of " + results.itemsReceived + " items");
	        }
	    };
	    /**
	     * success handler
	     */
	    Sender.prototype._onSuccess = function (payload, countOfItemsInPayload) {
	        this._buffer.clearSent(payload);
	    };
	    /**
	     * xdr state changes
	     */
	    Sender.prototype._xdrOnLoad = function (xdr, payload) {
	        if (xdr && (xdr.responseText + "" === "200" || xdr.responseText === "")) {
	            this._consecutiveErrors = 0;
	            this._onSuccess(payload, 0);
	        }
	        else {
	            var results = this._parseResponse(xdr.responseText);
	            if (results && results.itemsReceived && results.itemsReceived > results.itemsAccepted
	                && !this._config.isRetryDisabled()) {
	                this._onPartialSuccess(payload, results);
	            }
	            else {
	                this._onError(payload, this._formatErrorMessageXdr(xdr));
	            }
	        }
	    };
	    Sender.constructEnvelope = function (orig, iKey, logger) {
	        var envelope;
	        if (iKey !== orig.iKey && !CoreUtils.isNullOrUndefined(iKey)) {
	            envelope = __assign({}, orig, { iKey: iKey });
	        }
	        else {
	            envelope = orig;
	        }
	        switch (envelope.baseType) {
	            case Event$1.dataType:
	                return EventEnvelopeCreator.EventEnvelopeCreator.Create(logger, envelope);
	            case Trace.dataType:
	                return TraceEnvelopeCreator.TraceEnvelopeCreator.Create(logger, envelope);
	            case PageView.dataType:
	                return PageViewEnvelopeCreator.PageViewEnvelopeCreator.Create(logger, envelope);
	            case PageViewPerformance.dataType:
	                return PageViewPerformanceEnvelopeCreator.PageViewPerformanceEnvelopeCreator.Create(logger, envelope);
	            case Exception.dataType:
	                return ExceptionEnvelopeCreator.ExceptionEnvelopeCreator.Create(logger, envelope);
	            case Metric.dataType:
	                return MetricEnvelopeCreator.MetricEnvelopeCreator.Create(logger, envelope);
	            case RemoteDependencyData$1.dataType:
	                return DependencyEnvelopeCreator.DependencyEnvelopeCreator.Create(logger, envelope);
	            default:
	                return EventEnvelopeCreator.EventEnvelopeCreator.Create(logger, envelope);
	        }
	    };
	    Sender._getDefaultAppInsightsChannelConfig = function () {
	        // set default values
	        return {
	            endpointUrl: function () { return "https://dc.services.visualstudio.com/v2/track"; },
	            emitLineDelimitedJson: function () { return false; },
	            maxBatchInterval: function () { return 15000; },
	            maxBatchSizeInBytes: function () { return 102400; },
	            disableTelemetry: function () { return false; },
	            enableSessionStorageBuffer: function () { return true; },
	            isRetryDisabled: function () { return false; },
	            isBeaconApiDisabled: function () { return true; },
	            onunloadDisableBeacon: function () { return false; },
	            instrumentationKey: function () { return undefined; },
	            namePrefix: function () { return undefined; },
	            samplingPercentage: function () { return 100; }
	        };
	    };
	    Sender._getEmptyAppInsightsChannelConfig = function () {
	        return {
	            endpointUrl: undefined,
	            emitLineDelimitedJson: undefined,
	            maxBatchInterval: undefined,
	            maxBatchSizeInBytes: undefined,
	            disableTelemetry: undefined,
	            enableSessionStorageBuffer: undefined,
	            isRetryDisabled: undefined,
	            isBeaconApiDisabled: undefined,
	            onunloadDisableBeacon: undefined,
	            instrumentationKey: undefined,
	            namePrefix: undefined,
	            samplingPercentage: undefined
	        };
	    };
	    Sender.prototype._isSampledIn = function (envelope) {
	        return this._sample.isSampledIn(envelope);
	    };
	    /**
	     * Send Beacon API request
	     * @param payload {string} - The data payload to be sent.
	     * @param isAsync {boolean} - not used
	     * Note: Beacon API does not support custom headers and we are not able to get
	     * appId from the backend for the correct correlation.
	     */
	    Sender.prototype._beaconSender = function (payload, isAsync) {
	        var url = this._config.endpointUrl();
	        var batch = this._buffer.batchPayloads(payload);
	        // Chrome only allows CORS-safelisted values for the sendBeacon data argument
	        // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283
	        var plainTextBatch = new Blob([batch], { type: 'text/plain;charset=UTF-8' });
	        // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.
	        var queued = navigator.sendBeacon(url, plainTextBatch);
	        if (queued) {
	            this._buffer.markAsSent(payload);
	            // no response from beaconSender, clear buffer
	            this._onSuccess(payload, payload.length);
	        }
	        else {
	            this._xhrSender(payload, true);
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". " + "Failed to send telemetry with Beacon API, retried with xhrSender.");
	        }
	    };
	    /**
	     * Send XMLHttpRequest
	     * @param payload {string} - The data payload to be sent.
	     * @param isAsync {boolean} - Indicates if the request should be sent asynchronously
	     */
	    Sender.prototype._xhrSender = function (payload, isAsync) {
	        var _this = this;
	        var xhr = new XMLHttpRequest();
	        xhr[DisabledPropertyName] = true;
	        xhr.open("POST", this._config.endpointUrl(), isAsync);
	        xhr.setRequestHeader("Content-type", "application/json");
	        // append Sdk-Context request header only in case of breeze endpoint
	        if (Util.isInternalApplicationInsightsEndpoint(this._config.endpointUrl())) {
	            xhr.setRequestHeader(RequestHeaders.sdkContextHeader, RequestHeaders.sdkContextHeaderAppIdRequest);
	        }
	        xhr.onreadystatechange = function () { return _this._xhrReadyStateChange(xhr, payload, payload.length); };
	        xhr.onerror = function (event) { return _this._onError(payload, _this._formatErrorMessageXhr(xhr), event); };
	        // compose an array of payloads
	        var batch = this._buffer.batchPayloads(payload);
	        xhr.send(batch);
	        this._buffer.markAsSent(payload);
	    };
	    /**
	     * Parses the response from the backend.
	     * @param response - XMLHttpRequest or XDomainRequest response
	     */
	    Sender.prototype._parseResponse = function (response) {
	        try {
	            if (response && response !== "") {
	                var result = JSON.parse(response);
	                if (result && result.itemsReceived && result.itemsReceived >= result.itemsAccepted &&
	                    result.itemsReceived - result.itemsAccepted == result.errors.length) {
	                    return result;
	                }
	            }
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidBackendResponse, "Cannot parse the response. " + Util.getExceptionName(e), {
	                response: response
	            });
	        }
	        return null;
	    };
	    /**
	     * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).
	     * @param payload
	     */
	    Sender.prototype._resendPayload = function (payload, linearFactor) {
	        if (linearFactor === void 0) { linearFactor = 1; }
	        if (!payload || payload.length === 0) {
	            return;
	        }
	        this._buffer.clearSent(payload);
	        this._consecutiveErrors++;
	        for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
	            var item = payload_1[_i];
	            this._buffer.enqueue(item);
	        }
	        // setup timer
	        this._setRetryTime(linearFactor);
	        this._setupTimer();
	    };
	    /** Calculates the time to wait before retrying in case of an error based on
	     * http://en.wikipedia.org/wiki/Exponential_backoff
	     */
	    Sender.prototype._setRetryTime = function (linearFactor) {
	        var SlotDelayInSeconds = 10;
	        var delayInSeconds;
	        if (this._consecutiveErrors <= 1) {
	            delayInSeconds = SlotDelayInSeconds;
	        }
	        else {
	            var backOffSlot = (Math.pow(2, this._consecutiveErrors) - 1) / 2;
	            // tslint:disable-next-line:insecure-random
	            var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
	            backOffDelay = linearFactor * backOffDelay;
	            delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);
	        }
	        // TODO: Log the backoff time like the C# version does.
	        var retryAfterTimeSpan = Date.now() + (delayInSeconds * 1000);
	        // TODO: Log the retry at time like the C# version does.
	        this._retryAt = retryAfterTimeSpan;
	    };
	    /**
	     * Sets up the timer which triggers actually sending the data.
	     */
	    Sender.prototype._setupTimer = function () {
	        var _this = this;
	        if (!this._timeoutHandle) {
	            var retryInterval = this._retryAt ? Math.max(0, this._retryAt - Date.now()) : 0;
	            var timerValue = Math.max(this._config.maxBatchInterval(), retryInterval);
	            this._timeoutHandle = setTimeout(function () {
	                _this.triggerSend();
	            }, timerValue);
	        }
	    };
	    /**
	     * Checks if the SDK should resend the payload after receiving this status code from the backend.
	     * @param statusCode
	     */
	    Sender.prototype._isRetriable = function (statusCode) {
	        return statusCode == 408 // Timeout
	            || statusCode == 429 // Too many requests.
	            || statusCode == 500 // Internal server error.
	            || statusCode == 503; // Service unavailable.
	    };
	    Sender.prototype._formatErrorMessageXhr = function (xhr, message) {
	        if (xhr) {
	            return "XMLHttpRequest,Status:" + xhr.status + ",Response:" + xhr.responseText || xhr.response || "";
	        }
	        return message;
	    };
	    /**
	     * Send XDomainRequest
	     * @param payload {string} - The data payload to be sent.
	     * @param isAsync {boolean} - Indicates if the request should be sent asynchronously
	     *
	     * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added
	     * to maintain consistency with the xhrSender's contract
	     * Note: XDomainRequest does not support custom headers and we are not able to get
	     * appId from the backend for the correct correlation.
	     */
	    Sender.prototype._xdrSender = function (payload, isAsync) {
	        var _this = this;
	        var xdr = new XDomainRequest();
	        xdr.onload = function () { return _this._xdrOnLoad(xdr, payload); };
	        xdr.onerror = function (event) { return _this._onError(payload, _this._formatErrorMessageXdr(xdr), event); };
	        // XDomainRequest requires the same protocol as the hosting page.
	        // If the protocol doesn't match, we can't send the telemetry :(.
	        var hostingProtocol = window.location && window.location.protocol;
	        if (this._config.endpointUrl().lastIndexOf(hostingProtocol, 0) !== 0) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, ". " +
	                "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.");
	            this._buffer.clear();
	            return;
	        }
	        var endpointUrl = this._config.endpointUrl().replace(/^(https?:)/, "");
	        xdr.open('POST', endpointUrl);
	        // compose an array of payloads
	        var batch = this._buffer.batchPayloads(payload);
	        xdr.send(batch);
	        this._buffer.markAsSent(payload);
	    };
	    Sender.prototype._formatErrorMessageXdr = function (xdr, message) {
	        if (xdr) {
	            return "XDomainRequest,Response:" + xdr.responseText || "";
	        }
	        return message;
	    };
	    return Sender;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var Session = /** @class */ (function () {
	    function Session() {
	    }
	    return Session;
	}());
	var _SessionManager = /** @class */ (function () {
	    function _SessionManager(config, logger) {
	        var _this = this;
	        if (CoreUtils.isNullOrUndefined(logger)) {
	            this._logger = new DiagnosticLogger();
	        }
	        else {
	            this._logger = logger;
	        }
	        if (!config) {
	            config = {};
	        }
	        if (!(typeof config.sessionExpirationMs === "function")) {
	            config.sessionExpirationMs = function () { return _SessionManager.acquisitionSpan; };
	        }
	        if (!(typeof config.sessionRenewalMs === "function")) {
	            config.sessionRenewalMs = function () { return _SessionManager.renewalSpan; };
	        }
	        this.config = config;
	        this._storageNamePrefix = function () { return _this.config.namePrefix && _this.config.namePrefix() ? _SessionManager.cookieNameConst + _this.config.namePrefix() : _SessionManager.cookieNameConst; };
	        this.automaticSession = new Session();
	    }
	    _SessionManager.prototype.update = function () {
	        if (!this.automaticSession.id) {
	            this.initializeAutomaticSession();
	        }
	        var now = DateTimeUtils.Now();
	        var acquisitionExpired = now - this.automaticSession.acquisitionDate > this.config.sessionExpirationMs();
	        var renewalExpired = now - this.automaticSession.renewalDate > this.config.sessionRenewalMs();
	        // renew if acquisitionSpan or renewalSpan has ellapsed
	        if (acquisitionExpired || renewalExpired) {
	            // update automaticSession so session state has correct id
	            this.renew();
	        }
	        else {
	            // do not update the cookie more often than cookieUpdateInterval
	            if (!this.cookieUpdatedTimestamp || now - this.cookieUpdatedTimestamp > _SessionManager.cookieUpdateInterval) {
	                this.automaticSession.renewalDate = now;
	                this.setCookie(this.automaticSession.id, this.automaticSession.acquisitionDate, this.automaticSession.renewalDate);
	            }
	        }
	    };
	    /**
	     *  Record the current state of the automatic session and store it in our cookie string format
	     *  into the browser's local storage. This is used to restore the session data when the cookie
	     *  expires.
	     */
	    _SessionManager.prototype.backup = function () {
	        this.setStorage(this.automaticSession.id, this.automaticSession.acquisitionDate, this.automaticSession.renewalDate);
	    };
	    /**
	     *  Use config.namePrefix + ai_session cookie data or local storage data (when the cookie is unavailable) to
	     *  initialize the automatic session.
	     */
	    _SessionManager.prototype.initializeAutomaticSession = function () {
	        var cookie = Util.getCookie(this._logger, this._storageNamePrefix());
	        if (cookie && typeof cookie.split === "function") {
	            this.initializeAutomaticSessionWithData(cookie);
	        }
	        else {
	            // There's no cookie, but we might have session data in local storage
	            // This can happen if the session expired or the user actively deleted the cookie
	            // We only want to recover data if the cookie is missing from expiry. We should respect the user's wishes if the cookie was deleted actively.
	            // The User class handles this for us and deletes our local storage object if the persistent user cookie was removed.
	            var storage = Util.getStorage(this._logger, this._storageNamePrefix());
	            if (storage) {
	                this.initializeAutomaticSessionWithData(storage);
	            }
	        }
	        if (!this.automaticSession.id) {
	            this.renew();
	        }
	    };
	    /**
	     *  Extract id, aquisitionDate, and renewalDate from an ai_session payload string and
	     *  use this data to initialize automaticSession.
	     *
	     *  @param {string} sessionData - The string stored in an ai_session cookie or local storage backup
	     */
	    _SessionManager.prototype.initializeAutomaticSessionWithData = function (sessionData) {
	        var params = sessionData.split("|");
	        if (params.length > 0) {
	            this.automaticSession.id = params[0];
	        }
	        try {
	            if (params.length > 1) {
	                var acq = +params[1];
	                this.automaticSession.acquisitionDate = +new Date(acq);
	                this.automaticSession.acquisitionDate = this.automaticSession.acquisitionDate > 0 ? this.automaticSession.acquisitionDate : 0;
	            }
	            if (params.length > 2) {
	                var renewal = +params[2];
	                this.automaticSession.renewalDate = +new Date(renewal);
	                this.automaticSession.renewalDate = this.automaticSession.renewalDate > 0 ? this.automaticSession.renewalDate : 0;
	            }
	        }
	        catch (e) {
	            this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.ErrorParsingAISessionCookie, "Error parsing ai_session cookie, session will be reset: " + Util.getExceptionName(e), { exception: Util.dump(e) });
	        }
	        if (this.automaticSession.renewalDate == 0) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SessionRenewalDateIsZero, "AI session renewal date is 0, session will be reset.");
	        }
	    };
	    _SessionManager.prototype.renew = function () {
	        var now = DateTimeUtils.Now();
	        this.automaticSession.id = Util.newId();
	        this.automaticSession.acquisitionDate = now;
	        this.automaticSession.renewalDate = now;
	        this.setCookie(this.automaticSession.id, this.automaticSession.acquisitionDate, this.automaticSession.renewalDate);
	        // If this browser does not support local storage, fire an internal log to keep track of it at this point
	        if (!Util.canUseLocalStorage()) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserDoesNotSupportLocalStorage, "Browser does not support local storage. Session durations will be inaccurate.");
	        }
	    };
	    _SessionManager.prototype.setCookie = function (guid, acq, renewal) {
	        // Set cookie to expire after the session expiry time passes or the session renewal deadline, whichever is sooner
	        // Expiring the cookie will cause the session to expire even if the user isn't on the page
	        var acquisitionExpiry = acq + this.config.sessionExpirationMs();
	        var renewalExpiry = renewal + this.config.sessionRenewalMs();
	        var cookieExpiry = new Date();
	        var cookie = [guid, acq, renewal];
	        if (acquisitionExpiry < renewalExpiry) {
	            cookieExpiry.setTime(acquisitionExpiry);
	        }
	        else {
	            cookieExpiry.setTime(renewalExpiry);
	        }
	        var cookieDomnain = this.config.cookieDomain ? this.config.cookieDomain() : null;
	        Util.setCookie(this._logger, this._storageNamePrefix(), cookie.join('|') + ';expires=' + cookieExpiry.toUTCString(), cookieDomnain);
	        this.cookieUpdatedTimestamp = DateTimeUtils.Now();
	    };
	    _SessionManager.prototype.setStorage = function (guid, acq, renewal) {
	        // Keep data in local storage to retain the last session id, allowing us to cleanly end the session when it expires
	        // Browsers that don't support local storage won't be able to end sessions cleanly from the client
	        // The server will notice this and end the sessions itself, with loss of accurate session duration
	        Util.setStorage(this._logger, this._storageNamePrefix(), [guid, acq, renewal].join('|'));
	    };
	    _SessionManager.acquisitionSpan = 86400000; // 24 hours in ms
	    _SessionManager.renewalSpan = 1800000; // 30 minutes in ms
	    _SessionManager.cookieUpdateInterval = 60000; // 1 minute in ms
	    _SessionManager.cookieNameConst = 'ai_session';
	    return _SessionManager;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var Application = /** @class */ (function () {
	    function Application() {
	    }
	    return Application;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var Device = /** @class */ (function () {
	    /**
	     * Constructs a new instance of the Device class
	     */
	    function Device() {
	        // don't attempt to fingerprint browsers
	        this.id = "browser";
	        // Device type is a dimension in our data platform
	        // Setting it to 'Browser' allows to separate client and server dependencies/exceptions
	        this.deviceClass = "Browser";
	    }
	    return Device;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var Version$1 = "2.2.2";
	var Internal = /** @class */ (function () {
	    /**
	    * Constructs a new instance of the internal telemetry data class.
	    */
	    function Internal(config) {
	        this.sdkVersion = (config.sdkExtension && config.sdkExtension() ? config.sdkExtension() + "_" : "") + "javascript:" + Version$1;
	    }
	    return Internal;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var User = /** @class */ (function () {
	    function User(config, logger) {
	        this._logger = logger;
	        //get userId or create new one if none exists
	        var cookie = Util.getCookie(this._logger, User.userCookieName);
	        if (cookie) {
	            var params = cookie.split(User.cookieSeparator);
	            if (params.length > 0) {
	                this.id = params[0];
	            }
	        }
	        this.config = config;
	        if (!this.id) {
	            this.id = Util.newId();
	            var date = new Date();
	            var acqStr = Util.toISOStringForIE8(date);
	            this.accountAcquisitionDate = acqStr;
	            // without expiration, cookies expire at the end of the session
	            // set it to 365 days from now
	            // 365 * 24 * 60 * 60 * 1000 = 31536000000 
	            date.setTime(date.getTime() + 31536000000);
	            var newCookie = [this.id, acqStr];
	            var cookieDomain = this.config.cookieDomain ? this.config.cookieDomain() : undefined;
	            Util.setCookie(this._logger, User.userCookieName, newCookie.join(User.cookieSeparator) + ';expires=' + date.toUTCString(), cookieDomain);
	            // If we have an config.namePrefix() + ai_session in local storage this means the user actively removed our cookies.
	            // We should respect their wishes and clear ourselves from local storage
	            var name_1 = config.namePrefix && config.namePrefix() ? config.namePrefix() + 'ai_session' : 'ai_session';
	            Util.removeStorage(this._logger, name_1);
	        }
	        // We still take the account id from the ctor param for backward compatibility. 
	        // But if the the customer set the accountId through the newer setAuthenticatedUserContext API, we will override it.
	        this.accountId = config.accountId ? config.accountId() : undefined;
	        // Get the auth user id and account id from the cookie if exists
	        // Cookie is in the pattern: <authenticatedId>|<accountId>
	        var authCookie = Util.getCookie(this._logger, User.authUserCookieName);
	        if (authCookie) {
	            authCookie = decodeURI(authCookie);
	            var authCookieString = authCookie.split(User.cookieSeparator);
	            if (authCookieString[0]) {
	                this.authenticatedId = authCookieString[0];
	            }
	            if (authCookieString.length > 1 && authCookieString[1]) {
	                this.accountId = authCookieString[1];
	            }
	        }
	    }
	    /**
	    * Sets the authenticated user id and the account id in this session.
	    *
	    * @param authenticatedUserId {string} - The authenticated user id. A unique and persistent string that represents each authenticated user in the service.
	    * @param accountId {string} - An optional string to represent the account associated with the authenticated user.
	    */
	    User.prototype.setAuthenticatedUserContext = function (authenticatedUserId, accountId, storeInCookie) {
	        if (storeInCookie === void 0) { storeInCookie = false; }
	        // Validate inputs to ensure no cookie control characters.
	        var isInvalidInput = !this.validateUserInput(authenticatedUserId) || (accountId && !this.validateUserInput(accountId));
	        if (isInvalidInput) {
	            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.SetAuthContextFailedAccountName, "Setting auth user context failed. " +
	                "User auth/account id should be of type string, and not contain commas, semi-colons, equal signs, spaces, or vertical-bars.", true);
	            return;
	        }
	        // Create cookie string.
	        this.authenticatedId = authenticatedUserId;
	        var authCookie = this.authenticatedId;
	        if (accountId) {
	            this.accountId = accountId;
	            authCookie = [this.authenticatedId, this.accountId].join(User.cookieSeparator);
	        }
	        if (storeInCookie) {
	            // Set the cookie. No expiration date because this is a session cookie (expires when browser closed).
	            // Encoding the cookie to handle unexpected unicode characters.
	            Util.setCookie(this._logger, User.authUserCookieName, encodeURI(authCookie), this.config.cookieDomain());
	        }
	    };
	    /**
	     * Clears the authenticated user id and the account id from the user context.
	     * @returns {}
	     */
	    User.prototype.clearAuthenticatedUserContext = function () {
	        this.authenticatedId = null;
	        this.accountId = null;
	        Util.deleteCookie(this._logger, User.authUserCookieName);
	    };
	    User.prototype.validateUserInput = function (id) {
	        // Validate:
	        // 1. Id is a non-empty string.
	        // 2. It does not contain special characters for cookies.
	        if (typeof id !== 'string' ||
	            !id ||
	            id.match(/,|;|=| |\|/)) {
	            return false;
	        }
	        return true;
	    };
	    User.cookieSeparator = '|';
	    User.userCookieName = 'ai_user';
	    User.authUserCookieName = 'ai_authUser';
	    return User;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	// Licensed under the MIT License.
	var Location = /** @class */ (function () {
	    function Location() {
	    }
	    return Location;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var TelemetryTrace = /** @class */ (function () {
	    function TelemetryTrace(id, parentId, name) {
	        this.traceID = id || Util.generateW3CId();
	        this.parentID = parentId;
	        this.name = name;
	        if (window && window.location && window.location.pathname) {
	            this.name = window.location.pathname;
	        }
	    }
	    return TelemetryTrace;
	}());

	/**
	 * PropertiesPlugin.ts
	 * @copyright Microsoft 2018
	 */
	var TelemetryContext = /** @class */ (function () {
	    function TelemetryContext(logger, defaultConfig) {
	        if (typeof window !== 'undefined') {
	            this.sessionManager = new _SessionManager(defaultConfig, logger);
	            this.application = new Application();
	            this.device = new Device();
	            this.internal = new Internal(defaultConfig);
	            this.location = new Location();
	            this.user = new User(defaultConfig, logger);
	            this.telemetryTrace = new TelemetryTrace();
	            this.session = new Session();
	        }
	        this.appId = function () { return null; };
	    }
	    TelemetryContext.prototype.applySessionContext = function (event) {
	        var sessionContext = this.session || this.sessionManager.automaticSession;
	        if (sessionContext) {
	            if (typeof sessionContext.id === "string") {
	                event.ext.app.sesId = sessionContext.id;
	            }
	        }
	        if (this.session) {
	            // If customer set session info, apply his context; otherwise apply context automatically generated
	            if (typeof this.session.id === "string") {
	                event.ext.app.sesId = this.session.id;
	            }
	            else {
	                event.ext.app.sesId = this.sessionManager.automaticSession.id;
	            }
	        }
	    };
	    TelemetryContext.prototype.applyOperatingSystemContxt = function (event) {
	        if (this.os && this.os.name) {
	            event.ext.os = this.os;
	        }
	    };
	    TelemetryContext.prototype.applyApplicationContext = function (event) {
	        if (this.application) {
	            if (typeof this.application.ver === "string") {
	                event.tags[CtxTagKeys.applicationVersion] = this.application.ver;
	            }
	            if (typeof this.application.build === "string") {
	                event.tags[CtxTagKeys.applicationBuild] = this.application.build;
	            }
	        }
	    };
	    TelemetryContext.prototype.applyDeviceContext = function (event) {
	        if (this.device) {
	            if (typeof this.device.id === "string") {
	                event.ext.device.localId = this.device.id;
	            }
	            if (typeof this.device.ip === "string") {
	                event.ext.device.ip = this.device.ip;
	            }
	            if (typeof this.device.model === "string") {
	                event.ext.device.model = this.device.model;
	            }
	            if (typeof this.device.deviceClass === "string") {
	                event.ext.device.deviceClass = this.device.deviceClass;
	            }
	        }
	    };
	    TelemetryContext.prototype.applyInternalContext = function (event) {
	        if (this.internal) {
	            if (typeof this.internal.agentVersion === "string") {
	                event.tags[CtxTagKeys.internalAgentVersion] = this.internal.agentVersion; // not mapped in CS 4.0
	            }
	            if (typeof this.internal.sdkVersion === "string") {
	                event.tags[CtxTagKeys.internalSdkVersion] = this.internal.sdkVersion;
	            }
	        }
	    };
	    TelemetryContext.prototype.applyLocationContext = function (event) {
	        if (this.location) {
	            if (typeof this.location.ip === "string") {
	                event.tags[CtxTagKeys.locationIp] = this.location.ip;
	            }
	        }
	    };
	    TelemetryContext.prototype.applyOperationContext = function (event) {
	        if (this.telemetryTrace) {
	            var trace = event.ext.trace || { traceID: undefined, parentID: undefined };
	            if (typeof this.telemetryTrace.traceID === "string") {
	                trace.traceID = this.telemetryTrace.traceID;
	            }
	            if (typeof this.telemetryTrace.name === "string") {
	                trace.name = this.telemetryTrace.name;
	            }
	            if (typeof this.telemetryTrace.parentID === "string") {
	                trace.parentID = this.telemetryTrace.parentID;
	            }
	            event.ext.trace = trace;
	        }
	    };
	    TelemetryContext.prototype.applyWebContext = function (event) {
	        if (this.web) {
	            event.ext.web = event.ext.web || {};
	            event.ext.web = this.web;
	        }
	    };
	    TelemetryContext.prototype.applyUserContext = function (event) {
	        if (this.user) {
	            if (!event.tags) {
	                event.tags = [];
	            }
	            // stays in tags
	            if (typeof this.user.accountId === "string") {
	                event.tags[CtxTagKeys.userAccountId] = this.user.accountId;
	            }
	            // CS 4.0
	            if (typeof this.user.id === "string") {
	                event.ext.user.id = this.user.id;
	            }
	            if (typeof this.user.authenticatedId === "string") {
	                event.ext.user.authId = this.user.authenticatedId;
	            }
	        }
	    };
	    TelemetryContext.prototype.cleanUp = function (event) {
	        if (event.ext[Extensions.DeviceExt] && Object.keys(event.ext[Extensions.DeviceExt]).length === 0) {
	            delete event.ext[Extensions.DeviceExt];
	        }
	        if (event.ext[Extensions.UserExt] && Object.keys(event.ext[Extensions.UserExt]).length === 0) {
	            delete event.ext[Extensions.UserExt];
	        }
	        if (event.ext[Extensions.WebExt] && Object.keys(event.ext[Extensions.WebExt]).length === 0) {
	            delete event.ext[Extensions.WebExt];
	        }
	        if (event.ext[Extensions.OSExt] && Object.keys(event.ext[Extensions.OSExt]).length === 0) {
	            delete event.ext[Extensions.OSExt];
	        }
	        if (event.ext[Extensions.AppExt] && Object.keys(event.ext[Extensions.AppExt]).length === 0) {
	            delete event.ext[Extensions.AppExt];
	        }
	        if (event.ext[Extensions.TraceExt] && Object.keys(event.ext[Extensions.TraceExt]).length === 0) {
	            delete event.ext[Extensions.TraceExt];
	        }
	    };
	    return TelemetryContext;
	}());

	/**
	 * PropertiesPlugin.ts
	 * @copyright Microsoft 2018
	 */
	var PropertiesPlugin = /** @class */ (function () {
	    function PropertiesPlugin() {
	        this.priority = 110;
	        this.identifier = PropertiesPluginIdentifier;
	    }
	    PropertiesPlugin.getDefaultConfig = function () {
	        var defaultConfig = {
	            instrumentationKey: function () { return undefined; },
	            accountId: function () { return null; },
	            sessionRenewalMs: function () { return 30 * 60 * 1000; },
	            samplingPercentage: function () { return 100; },
	            sessionExpirationMs: function () { return 24 * 60 * 60 * 1000; },
	            cookieDomain: function () { return null; },
	            sdkExtension: function () { return null; },
	            isBrowserLinkTrackingEnabled: function () { return false; },
	            appId: function () { return null; },
	            namePrefix: function () { return undefined; }
	        };
	        return defaultConfig;
	    };
	    PropertiesPlugin.prototype.initialize = function (config, core, extensions) {
	        var _this = this;
	        var defaultConfig = PropertiesPlugin.getDefaultConfig();
	        this._extensionConfig = this._extensionConfig || PropertiesPlugin.getDefaultConfig();
	        var _loop_1 = function (field) {
	            this_1._extensionConfig[field] = function () { return ConfigurationManager.getConfig(config, field, _this.identifier, defaultConfig[field]()); };
	        };
	        var this_1 = this;
	        for (var field in defaultConfig) {
	            _loop_1(field);
	        }
	        this._logger = core.logger;
	        this.context = new TelemetryContext(core.logger, this._extensionConfig);
	        this._breezeChannel = Util.getExtension(extensions, BreezeChannelIdentifier);
	        this.context.appId = function () { return _this._breezeChannel ? _this._breezeChannel["_appId"] : null; };
	    };
	    /**
	     * Add Part A fields to the event
	     * @param event The event that needs to be processed
	     */
	    PropertiesPlugin.prototype.processTelemetry = function (event) {
	        if (CoreUtils.isNullOrUndefined(event)) ;
	        else {
	            // If the envelope is PageView, reset the internal message count so that we can send internal telemetry for the new page.
	            if (event.name === PageView.envelopeType) {
	                this._logger.resetInternalMessageCount();
	            }
	            if (this.context.session) {
	                // If customer did not provide custom session id update the session manager
	                if (typeof this.context.session.id !== "string") {
	                    this.context.sessionManager.update();
	                }
	            }
	            this._processTelemetryInternal(event);
	            if (!CoreUtils.isNullOrUndefined(this._nextPlugin)) {
	                this._nextPlugin.processTelemetry(event);
	            }
	        }
	    };
	    /**
	     * Sets the next plugin that comes after this plugin
	     * @param nextPlugin The next plugin
	     */
	    PropertiesPlugin.prototype.setNextPlugin = function (nextPlugin) {
	        this._nextPlugin = nextPlugin;
	    };
	    PropertiesPlugin.prototype._processTelemetryInternal = function (event) {
	        // set part A  fields
	        if (!event.tags) {
	            event.tags = [];
	        }
	        if (!event.ext) {
	            event.ext = {};
	        }
	        event.ext[Extensions.DeviceExt] = event.ext[Extensions.DeviceExt] || {};
	        event.ext[Extensions.WebExt] = event.ext[Extensions.WebExt] || {};
	        event.ext[Extensions.UserExt] = event.ext[Extensions.UserExt] || {};
	        event.ext[Extensions.OSExt] = event.ext[Extensions.OSExt] || {};
	        event.ext[Extensions.AppExt] = event.ext[Extensions.AppExt] || {};
	        event.ext[Extensions.TraceExt] = event.ext[Extensions.TraceExt] || {};
	        this.context.applySessionContext(event);
	        this.context.applyApplicationContext(event);
	        this.context.applyDeviceContext(event);
	        this.context.applyOperationContext(event);
	        this.context.applyUserContext(event);
	        this.context.applyOperatingSystemContxt(event);
	        this.context.applyWebContext(event);
	        this.context.applyLocationContext(event); // legacy tags
	        this.context.applyInternalContext(event); // legacy tags
	        this.context.cleanUp(event);
	    };
	    return PropertiesPlugin;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var XHRMonitoringState = /** @class */ (function () {
	    function XHRMonitoringState() {
	        this.openDone = false;
	        this.setRequestHeaderDone = false;
	        this.sendDone = false;
	        this.abortDone = false;
	        //<summary>True, if onreadyStateChangeCallback function attached to xhr, otherwise false</summary>
	        this.onreadystatechangeCallbackAttached = false;
	    }
	    return XHRMonitoringState;
	}());
	var ajaxRecord = /** @class */ (function () {
	    function ajaxRecord(traceID, spanID, logger) {
	        this.completed = false;
	        this.requestHeadersSize = null;
	        this.requestHeaders = null;
	        this.ttfb = null;
	        this.responseReceivingDuration = null;
	        this.callbackDuration = null;
	        this.ajaxTotalDuration = null;
	        this.aborted = null;
	        this.pageUrl = null;
	        this.requestUrl = null;
	        this.requestSize = 0;
	        this.method = null;
	        ///<summary>Returns the HTTP status code.</summary>
	        this.status = null;
	        //<summary>The timestamp when open method was invoked</summary>
	        this.requestSentTime = null;
	        //<summary>The timestamps when first byte was received</summary>
	        this.responseStartedTime = null;
	        //<summary>The timestamp when last byte was received</summary>
	        this.responseFinishedTime = null;
	        //<summary>The timestamp when onreadystatechange callback in readyState 4 finished</summary>
	        this.callbackFinishedTime = null;
	        //<summary>The timestamp at which ajax was ended</summary>
	        this.endTime = null;
	        //<summary>The original xhr onreadystatechange event</summary>
	        this.originalOnreadystatechage = null;
	        this.xhrMonitoringState = new XHRMonitoringState();
	        //<summary>Determines whether or not JavaScript exception occured in xhr.onreadystatechange code. 1 if occured, otherwise 0.</summary>
	        this.clientFailure = 0;
	        this.CalculateMetrics = function () {
	            var self = this;
	            // round to 3 decimal points
	            self.ajaxTotalDuration = Math.round(DateTimeUtils.GetDuration(self.requestSentTime, self.responseFinishedTime) * 1000) / 1000;
	        };
	        this.traceID = traceID;
	        this.spanID = spanID;
	        this._logger = logger;
	    }
	    ajaxRecord.prototype.getAbsoluteUrl = function () {
	        return this.requestUrl ? UrlHelper.getAbsoluteUrl(this.requestUrl) : null;
	    };
	    ajaxRecord.prototype.getPathName = function () {
	        return this.requestUrl ? DataSanitizer.sanitizeUrl(this._logger, UrlHelper.getCompleteUrl(this.method, this.requestUrl)) : null;
	    };
	    return ajaxRecord;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var EventHelper = /** @class */ (function () {
	    function EventHelper() {
	    }
	    ///<summary>Binds the specified function to an event, so that the function gets called whenever the event fires on the object</summary>
	    ///<param name="obj">Object to which </param>
	    ///<param name="eventNameWithoutOn">String that specifies any of the standard DHTML Events without "on" prefix</param>
	    ///<param name="handlerRef">Pointer that specifies the function to call when event fires</param>
	    ///<returns>True if the function was bound successfully to the event, otherwise false</returns>
	    EventHelper.AttachEvent = function (obj, eventNameWithoutOn, handlerRef) {
	        var result = false;
	        if (!CoreUtils.isNullOrUndefined(obj)) {
	            if (!CoreUtils.isNullOrUndefined(obj.attachEvent)) {
	                // IE before version 9                    
	                obj.attachEvent("on" + eventNameWithoutOn, handlerRef);
	                result = true;
	            }
	            else {
	                if (!CoreUtils.isNullOrUndefined(obj.addEventListener)) {
	                    // all browsers except IE before version 9
	                    obj.addEventListener(eventNameWithoutOn, handlerRef, false);
	                    result = true;
	                }
	            }
	        }
	        return result;
	    };
	    EventHelper.DetachEvent = function (obj, eventNameWithoutOn, handlerRef) {
	        if (!CoreUtils.isNullOrUndefined(obj)) {
	            if (!CoreUtils.isNullOrUndefined(obj.detachEvent)) {
	                obj.detachEvent("on" + eventNameWithoutOn, handlerRef);
	            }
	            else {
	                if (!CoreUtils.isNullOrUndefined(obj.removeEventListener)) {
	                    obj.removeEventListener(eventNameWithoutOn, handlerRef, false);
	                }
	            }
	        }
	    };
	    return EventHelper;
	}());

	var Traceparent = /** @class */ (function () {
	    function Traceparent(traceId, spanId) {
	        this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;
	        this.version = Traceparent.DEFAULT_VERSION;
	        if (traceId && Traceparent.isValidTraceId(traceId)) {
	            this.traceId = traceId;
	        }
	        else {
	            this.traceId = Util.generateW3CId();
	        }
	        if (spanId && Traceparent.isValidSpanId(spanId)) {
	            this.spanId = spanId;
	        }
	        else {
	            this.spanId = Util.generateW3CId().substr(0, 16);
	        }
	    }
	    Traceparent.isValidTraceId = function (id) {
	        return id.match(/^[0-9a-f]{32}$/) && id !== "00000000000000000000000000000000";
	    };
	    Traceparent.isValidSpanId = function (id) {
	        return id.match(/^[0-9a-f]{16}$/) && id !== "0000000000000000";
	    };
	    Traceparent.prototype.toString = function () {
	        return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag;
	    };
	    Traceparent.DEFAULT_TRACE_FLAG = "00";
	    Traceparent.DEFAULT_VERSION = "00";
	    return Traceparent;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var AjaxMonitor = /** @class */ (function () {
	    function AjaxMonitor() {
	        this._trackAjaxAttempts = 0;
	        this.identifier = AjaxMonitor.identifier;
	        this.priority = 120;
	        this.currentWindowHost = window && window.location && window.location.host && window.location.host.toLowerCase();
	        this.initialized = false;
	        this._fetchInitialized = false;
	    }
	    ///<summary>Verifies that particalar instance of XMLHttpRequest needs to be monitored</summary>
	    ///<param name="excludeAjaxDataValidation">Optional parameter. True if ajaxData must be excluded from verification</param>
	    ///<returns type="bool">True if instance needs to be monitored, otherwise false</returns>
	    AjaxMonitor.prototype.isMonitoredInstance = function (xhr, excludeAjaxDataValidation, request, init) {
	        var disabledProperty = false;
	        var ajaxValidation = true;
	        var initialized = false;
	        if (typeof request !== 'undefined') {
	            initialized = this._fetchInitialized;
	            // Look for DisabledPropertyName in either Request or RequestInit
	            disabledProperty = (typeof request === 'object' ? request[DisabledPropertyName] === true : false) ||
	                (init ? init[DisabledPropertyName] === true : false);
	        }
	        else if (typeof xhr !== 'undefined') {
	            initialized = this.initialized;
	            disabledProperty = xhr[DisabledPropertyName] === true;
	            ajaxValidation = excludeAjaxDataValidation === true || !CoreUtils.isNullOrUndefined(xhr.ajaxData);
	        }
	        // checking to see that all interested functions on xhr were instrumented
	        return initialized
	            // checking on ajaxData to see that it was not removed in user code
	            && ajaxValidation
	            // check that this instance is not not used by ajax call performed inside client side monitoring to send data to collector
	            && !disabledProperty;
	    };
	    ///<summary>Determines whether ajax monitoring can be enabled on this document</summary>
	    ///<returns>True if Ajax monitoring is supported on this page, otherwise false</returns>
	    AjaxMonitor.prototype.supportsAjaxMonitoring = function () {
	        var result = true;
	        if (CoreUtils.isNullOrUndefined(XMLHttpRequest) ||
	            CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype) ||
	            CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype.open) ||
	            CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype.send) ||
	            CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype.abort)) {
	            result = false;
	        }
	        // disable in IE8 or older (https://www.w3schools.com/jsref/jsref_trim_string.asp)
	        try {
	            " a ".trim();
	        }
	        catch (ex) {
	            result = false;
	        }
	        return result;
	    };
	    AjaxMonitor.prototype.instrumentOpen = function () {
	        var originalOpen = XMLHttpRequest.prototype.open;
	        var ajaxMonitorInstance = this;
	        XMLHttpRequest.prototype.open = function (method, url, async) {
	            try {
	                if (ajaxMonitorInstance.isMonitoredInstance(this, true) &&
	                    (!this.ajaxData ||
	                        !this.ajaxData.xhrMonitoringState.openDone)) {
	                    ajaxMonitorInstance.openHandler(this, method, url, async);
	                }
	            }
	            catch (e) {
	                ajaxMonitorInstance._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxOpen, "Failed to monitor XMLHttpRequest.open, monitoring data for this ajax call may be incorrect.", {
	                    ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(this),
	                    exception: Util.dump(e)
	                });
	            }
	            return originalOpen.apply(this, arguments);
	        };
	    };
	    AjaxMonitor.prototype.openHandler = function (xhr, method, url, async) {
	        var traceID = (this._context && this._context.telemetryTrace && this._context.telemetryTrace.traceID) || Util.generateW3CId();
	        var spanID = Util.generateW3CId().substr(0, 16);
	        var ajaxData = new ajaxRecord(traceID, spanID, this._core.logger);
	        ajaxData.method = method;
	        ajaxData.requestUrl = url;
	        ajaxData.xhrMonitoringState.openDone = true;
	        ajaxData.requestHeaders = {};
	        xhr.ajaxData = ajaxData;
	        this.attachToOnReadyStateChange(xhr);
	    };
	    AjaxMonitor.getFailedAjaxDiagnosticsMessage = function (xhr) {
	        var result = "";
	        try {
	            if (!CoreUtils.isNullOrUndefined(xhr) &&
	                !CoreUtils.isNullOrUndefined(xhr.ajaxData) &&
	                !CoreUtils.isNullOrUndefined(xhr.ajaxData.requestUrl)) {
	                result += "(url: '" + xhr.ajaxData.requestUrl + "')";
	            }
	        }
	        catch (e) { }
	        return result;
	    };
	    AjaxMonitor.prototype.instrumentSend = function () {
	        var originalSend = XMLHttpRequest.prototype.send;
	        var ajaxMonitorInstance = this;
	        XMLHttpRequest.prototype.send = function (content) {
	            try {
	                if (ajaxMonitorInstance.isMonitoredInstance(this) && !this.ajaxData.xhrMonitoringState.sendDone) {
	                    ajaxMonitorInstance.sendHandler(this, content);
	                }
	            }
	            catch (e) {
	                ajaxMonitorInstance._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxSend, "Failed to monitor XMLHttpRequest, monitoring data for this ajax call may be incorrect.", {
	                    ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(this),
	                    exception: Util.dump(e)
	                });
	            }
	            return originalSend.apply(this, arguments);
	        };
	    };
	    AjaxMonitor.prototype.sendHandler = function (xhr, content) {
	        xhr.ajaxData.requestSentTime = DateTimeUtils.Now();
	        xhr = this.includeCorrelationHeaders(xhr.ajaxData, undefined, undefined, xhr);
	        xhr.ajaxData.xhrMonitoringState.sendDone = true;
	    };
	    AjaxMonitor.prototype.instrumentAbort = function () {
	        var originalAbort = XMLHttpRequest.prototype.abort;
	        var ajaxMonitorInstance = this;
	        XMLHttpRequest.prototype.abort = function () {
	            try {
	                if (ajaxMonitorInstance.isMonitoredInstance(this) && !this.ajaxData.xhrMonitoringState.abortDone) {
	                    this.ajaxData.aborted = 1;
	                    this.ajaxData.xhrMonitoringState.abortDone = true;
	                }
	            }
	            catch (e) {
	                ajaxMonitorInstance._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxAbort, "Failed to monitor XMLHttpRequest.abort, monitoring data for this ajax call may be incorrect.", {
	                    ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(this),
	                    exception: Util.dump(e)
	                });
	            }
	            return originalAbort.apply(this, arguments);
	        };
	    };
	    AjaxMonitor.prototype.instrumentSetRequestHeader = function () {
	        if (!this._config.enableRequestHeaderTracking) {
	            return;
	        }
	        var originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
	        var ajaxMonitorInstance = this;
	        XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
	            try {
	                if (ajaxMonitorInstance.isMonitoredInstance(this)) {
	                    this.ajaxData.requestHeaders[header] = value;
	                }
	            }
	            catch (e) {
	                ajaxMonitorInstance._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxSetRequestHeader, "Failed to monitor XMLHttpRequest.setRequestHeader, monitoring data for this ajax call may be incorrect.", {
	                    ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(this),
	                    exception: Util.dump(e)
	                });
	            }
	            return originalSetRequestHeader.apply(this, arguments);
	        };
	    };
	    AjaxMonitor.prototype.attachToOnReadyStateChange = function (xhr) {
	        var ajaxMonitorInstance = this;
	        xhr.ajaxData.xhrMonitoringState.onreadystatechangeCallbackAttached = EventHelper.AttachEvent(xhr, "readystatechange", function () {
	            try {
	                if (ajaxMonitorInstance.isMonitoredInstance(xhr)) {
	                    if (xhr.readyState === 4) {
	                        ajaxMonitorInstance.onAjaxComplete(xhr);
	                    }
	                }
	            }
	            catch (e) {
	                var exceptionText = Util.dump(e);
	                // ignore messages with c00c023f, as this a known IE9 XHR abort issue
	                if (!exceptionText || exceptionText.toLowerCase().indexOf("c00c023f") == -1) {
	                    ajaxMonitorInstance._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxRSC, "Failed to monitor XMLHttpRequest 'readystatechange' event handler, monitoring data for this ajax call may be incorrect.", {
	                        ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(xhr),
	                        exception: Util.dump(e)
	                    });
	                }
	            }
	        });
	    };
	    AjaxMonitor.prototype.onAjaxComplete = function (xhr) {
	        xhr.ajaxData.responseFinishedTime = DateTimeUtils.Now();
	        xhr.ajaxData.status = xhr.status;
	        xhr.ajaxData.CalculateMetrics();
	        if (xhr.ajaxData.ajaxTotalDuration < 0) {
	            this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxDur, "Failed to calculate the duration of the ajax call, monitoring data for this ajax call won't be sent.", {
	                ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(xhr),
	                requestSentTime: xhr.ajaxData.requestSentTime,
	                responseFinishedTime: xhr.ajaxData.responseFinishedTime
	            });
	        }
	        else {
	            var dependency = {
	                id: "|" + xhr.ajaxData.traceID + "." + xhr.ajaxData.spanID,
	                target: xhr.ajaxData.getAbsoluteUrl(),
	                name: xhr.ajaxData.getPathName(),
	                type: "Ajax",
	                duration: xhr.ajaxData.ajaxTotalDuration,
	                success: (+(xhr.ajaxData.status)) >= 200 && (+(xhr.ajaxData.status)) < 400,
	                responseCode: +xhr.ajaxData.status,
	                method: xhr.ajaxData.method
	            };
	            // enrich dependency target with correlation context from the server
	            var correlationContext = this.getAjaxCorrelationContext(xhr);
	            if (correlationContext) {
	                dependency.correlationContext = /* dependency.target + " | " + */ correlationContext;
	            }
	            if (this._config.enableRequestHeaderTracking) {
	                if (Object.keys(xhr.ajaxData.requestHeaders).length > 0) {
	                    dependency.properties = dependency.properties || {};
	                    dependency.properties.requestHeaders = {};
	                    dependency.properties.requestHeaders = xhr.ajaxData.requestHeaders;
	                }
	            }
	            if (this._config.enableResponseHeaderTracking) {
	                var headers = xhr.getAllResponseHeaders();
	                if (headers) {
	                    // xhr.getAllResponseHeaders() method returns all the response headers, separated by CRLF, as a string or null
	                    // the regex converts the header string into an array of individual headers
	                    var arr = headers.trim().split(/[\r\n]+/);
	                    var responseHeaderMap_1 = {};
	                    arr.forEach(function (line) {
	                        var parts = line.split(': ');
	                        var header = parts.shift();
	                        var value = parts.join(': ');
	                        responseHeaderMap_1[header] = value;
	                    });
	                    if (Object.keys(responseHeaderMap_1).length > 0) {
	                        dependency.properties = dependency.properties || {};
	                        dependency.properties.responseHeaders = {};
	                        dependency.properties.responseHeaders = responseHeaderMap_1;
	                    }
	                }
	            }
	            this.trackDependencyDataInternal(dependency);
	            xhr.ajaxData = null;
	        }
	    };
	    AjaxMonitor.prototype.getAjaxCorrelationContext = function (xhr) {
	        try {
	            var responseHeadersString = xhr.getAllResponseHeaders();
	            if (responseHeadersString !== null) {
	                var index = responseHeadersString.toLowerCase().indexOf(RequestHeaders.requestContextHeaderLowerCase);
	                if (index !== -1) {
	                    var responseHeader = xhr.getResponseHeader(RequestHeaders.requestContextHeader);
	                    return CorrelationIdHelper.getCorrelationContext(responseHeader);
	                }
	            }
	        }
	        catch (e) {
	            this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, "Failed to get Request-Context correlation header as it may be not included in the response or not accessible.", {
	                ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(xhr),
	                exception: Util.dump(e)
	            });
	        }
	    };
	    /**
	     * Logs dependency call
	     * @param dependencyData dependency data object
	     */
	    AjaxMonitor.prototype.trackDependencyDataInternal = function (dependency, properties, systemProperties) {
	        if (this._config.maxAjaxCallsPerView === -1 || this._trackAjaxAttempts < this._config.maxAjaxCallsPerView) {
	            var item = TelemetryItemCreator.create(dependency, RemoteDependencyData$1.dataType, RemoteDependencyData$1.envelopeType, this._core.logger, properties, systemProperties);
	            this._core.track(item);
	        }
	        else if (this._trackAjaxAttempts === this._config.maxAjaxCallsPerView) {
	            this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.MaxAjaxPerPVExceeded, "Maximum ajax per page view limit reached, ajax monitoring is paused until the next trackPageView(). In order to increase the limit set the maxAjaxCallsPerView configuration parameter.", true);
	        }
	        ++this._trackAjaxAttempts;
	    };
	    AjaxMonitor.prototype.trackDependencyData = function (dependency, properties) {
	        this.trackDependencyDataInternal(dependency, properties);
	    };
	    AjaxMonitor.prototype.processTelemetry = function (item) {
	        if (this._nextPlugin && this._nextPlugin.processTelemetry) {
	            this._nextPlugin.processTelemetry(item);
	        }
	    };
	    AjaxMonitor.prototype.setNextPlugin = function (next) {
	        if (next) {
	            this._nextPlugin = next;
	        }
	    };
	    // Fetch Stuff
	    AjaxMonitor.prototype.instrumentFetch = function () {
	        if (!this.supportsFetch() || this._fetchInitialized) {
	            return;
	        }
	        var originalFetch = window.fetch;
	        var fetchMonitorInstance = this;
	        window.fetch = function fetch(input, init) {
	            var fetchData;
	            if (fetchMonitorInstance.isFetchInstrumented(input) && fetchMonitorInstance.isMonitoredInstance(undefined, undefined, input, init)) {
	                try {
	                    fetchData = fetchMonitorInstance.createFetchRecord(input, init);
	                    init = fetchMonitorInstance.includeCorrelationHeaders(fetchData, input, init);
	                }
	                catch (e) {
	                    fetchMonitorInstance._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxOpen, "Failed to monitor Window.fetch, monitoring data for this fetch call may be incorrect.", {
	                        ajaxDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(input),
	                        exception: Util.dump(e)
	                    });
	                }
	            }
	            return originalFetch(input, init)
	                .then(function (response) {
	                fetchMonitorInstance.onFetchComplete(response, fetchData);
	                return response;
	            })
	                .catch(function (reason) {
	                fetchMonitorInstance.onFetchFailed(input, fetchData, reason);
	                throw reason;
	            });
	        };
	        this._fetchInitialized = true;
	    };
	    AjaxMonitor.prototype.isFetchInstrumented = function (input) {
	        return this._fetchInitialized && input[DisabledPropertyName] !== true;
	    };
	    AjaxMonitor.prototype.supportsFetch = function () {
	        var result = true;
	        if (!window || CoreUtils.isNullOrUndefined(window.Request) ||
	            CoreUtils.isNullOrUndefined(window.Request.prototype) ||
	            CoreUtils.isNullOrUndefined(window.fetch)) {
	            result = false;
	        }
	        return result;
	    };
	    AjaxMonitor.prototype.createFetchRecord = function (input, init) {
	        var traceID = (this._context && this._context.telemetryTrace && this._context.telemetryTrace.traceID) || Util.generateW3CId();
	        var spanID = Util.generateW3CId().substr(0, 16);
	        var ajaxData = new ajaxRecord(traceID, spanID, this._core.logger);
	        ajaxData.requestSentTime = DateTimeUtils.Now();
	        if (input instanceof Request) {
	            ajaxData.requestUrl = input ? input.url : "";
	        }
	        else {
	            ajaxData.requestUrl = input;
	        }
	        if (init && init.method) {
	            ajaxData.method = init.method;
	        }
	        else if (input && input instanceof Request) {
	            ajaxData.method = input.method;
	        }
	        else {
	            ajaxData.method = "GET";
	        }
	        if (init && init.headers && this._config.enableRequestHeaderTracking) {
	            ajaxData.requestHeaders = init.headers;
	        }
	        else {
	            ajaxData.requestHeaders = {};
	        }
	        return ajaxData;
	    };
	    AjaxMonitor.prototype.includeCorrelationHeaders = function (ajaxData, input, init, xhr) {
	        if (input) {
	            if (CorrelationIdHelper.canIncludeCorrelationHeader(this._config, ajaxData.getAbsoluteUrl(), this.currentWindowHost)) {
	                if (!init) {
	                    init = {};
	                }
	                // init headers override original request headers
	                // so, if they exist use only them, otherwise use request's because they should have been applied in the first place
	                // not using original request headers will result in them being lost
	                init.headers = new Headers(init.headers || (input instanceof Request ? (input.headers || {}) : {}));
	                if (this._isUsingAIHeaders) {
	                    var id = "|" + ajaxData.traceID + "." + ajaxData.spanID;
	                    init.headers.set(RequestHeaders.requestIdHeader, id);
	                    if (this._config.enableRequestHeaderTracking) {
	                        ajaxData.requestHeaders[RequestHeaders.requestIdHeader] = id;
	                    }
	                }
	                var appId_1 = this._config.appId || this._context.appId();
	                if (appId_1) {
	                    init.headers.set(RequestHeaders.requestContextHeader, RequestHeaders.requestContextAppIdFormat + appId_1);
	                    if (this._config.enableRequestHeaderTracking) {
	                        ajaxData.requestHeaders[RequestHeaders.requestContextHeader] = RequestHeaders.requestContextAppIdFormat + appId_1;
	                    }
	                }
	                if (this._isUsingW3CHeaders) {
	                    var traceparent = new Traceparent(ajaxData.traceID, ajaxData.spanID);
	                    init.headers.set(RequestHeaders.traceParentHeader, traceparent.toString());
	                    if (this._config.enableRequestHeaderTracking) {
	                        ajaxData.requestHeaders[RequestHeaders.traceParentHeader] = traceparent.toString();
	                    }
	                }
	                return init;
	            }
	            return init;
	        }
	        else if (xhr) {
	            if (this.currentWindowHost && CorrelationIdHelper.canIncludeCorrelationHeader(this._config, xhr.ajaxData.getAbsoluteUrl(), this.currentWindowHost)) {
	                if (this._isUsingAIHeaders) {
	                    var id = "|" + xhr.ajaxData.traceID + "." + xhr.ajaxData.spanID;
	                    xhr.setRequestHeader(RequestHeaders.requestIdHeader, id);
	                    if (this._config.enableRequestHeaderTracking) {
	                        xhr.ajaxData.requestHeaders[RequestHeaders.requestIdHeader] = id;
	                    }
	                }
	                var appId = this._config.appId || this._context.appId();
	                if (appId) {
	                    xhr.setRequestHeader(RequestHeaders.requestContextHeader, RequestHeaders.requestContextAppIdFormat + appId);
	                    if (this._config.enableRequestHeaderTracking) {
	                        xhr.ajaxData.requestHeaders[RequestHeaders.requestContextHeader] = RequestHeaders.requestContextAppIdFormat + appId;
	                    }
	                }
	                if (this._isUsingW3CHeaders) {
	                    var traceparent = new Traceparent(xhr.ajaxData.traceID, xhr.ajaxData.spanID);
	                    xhr.setRequestHeader(RequestHeaders.traceParentHeader, traceparent.toString());
	                    if (this._config.enableRequestHeaderTracking) {
	                        xhr.ajaxData.requestHeaders[RequestHeaders.traceParentHeader] = traceparent.toString();
	                    }
	                }
	            }
	            return xhr;
	        }
	        return undefined;
	    };
	    AjaxMonitor.prototype.getFailedFetchDiagnosticsMessage = function (input) {
	        var result = "";
	        try {
	            if (!CoreUtils.isNullOrUndefined(input)) {
	                if (typeof (input) === "string") {
	                    result += "(url: '" + input + "')";
	                }
	                else {
	                    result += "(url: '" + input.url + "')";
	                }
	            }
	        }
	        catch (e) {
	            this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxOpen, "Failed to grab failed fetch diagnostics message", { exception: Util.dump(e) });
	        }
	        return result;
	    };
	    AjaxMonitor.prototype.onFetchComplete = function (response, ajaxData) {
	        if (!ajaxData) {
	            return;
	        }
	        try {
	            ajaxData.responseFinishedTime = DateTimeUtils.Now();
	            ajaxData.CalculateMetrics();
	            if (ajaxData.ajaxTotalDuration < 0) {
	                this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxDur, "Failed to calculate the duration of the fetch call, monitoring data for this fetch call won't be sent.", {
	                    fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(response),
	                    requestSentTime: ajaxData.requestSentTime,
	                    responseFinishedTime: ajaxData.responseFinishedTime
	                });
	            }
	            else {
	                var dependency = {
	                    id: "|" + ajaxData.traceID + "." + ajaxData.spanID,
	                    target: ajaxData.getAbsoluteUrl(),
	                    name: ajaxData.getPathName(),
	                    type: "Fetch",
	                    duration: ajaxData.ajaxTotalDuration,
	                    success: response.status >= 200 && response.status < 400,
	                    responseCode: response.status,
	                    properties: { HttpMethod: ajaxData.method }
	                };
	                // enrich dependency target with correlation context from the server
	                var correlationContext = this.getFetchCorrelationContext(response);
	                if (correlationContext) {
	                    dependency.correlationContext = correlationContext;
	                }
	                if (this._config.enableRequestHeaderTracking) {
	                    if (Object.keys(ajaxData.requestHeaders).length > 0) {
	                        dependency.properties = dependency.properties || {};
	                        dependency.properties.requestHeaders = ajaxData.requestHeaders;
	                    }
	                }
	                if (this._config.enableResponseHeaderTracking) {
	                    var responseHeaderMap_2 = {};
	                    response.headers.forEach(function (value, name) {
	                        responseHeaderMap_2[name] = value;
	                    });
	                    if (Object.keys(responseHeaderMap_2).length > 0) {
	                        dependency.properties = dependency.properties || {};
	                        dependency.properties.responseHeaders = responseHeaderMap_2;
	                    }
	                }
	                this.trackDependencyDataInternal(dependency);
	            }
	        }
	        catch (e) {
	            this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, "Failed to calculate the duration of the fetch call, monitoring data for this fetch call won't be sent.", {
	                fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(response),
	                exception: Util.dump(e)
	            });
	        }
	    };
	    AjaxMonitor.prototype.onFetchFailed = function (input, ajaxData, reason) {
	        if (!ajaxData) {
	            return;
	        }
	        try {
	            ajaxData.responseFinishedTime = DateTimeUtils.Now();
	            ajaxData.CalculateMetrics();
	            if (ajaxData.ajaxTotalDuration < 0) {
	                this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxDur, "Failed to calculate the duration of the failed fetch call, monitoring data for this fetch call won't be sent.", {
	                    fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(input),
	                    requestSentTime: ajaxData.requestSentTime,
	                    responseFinishedTime: ajaxData.responseFinishedTime
	                });
	            }
	            else {
	                var dependency = {
	                    id: "|" + ajaxData.traceID + "." + ajaxData.spanID,
	                    target: ajaxData.getAbsoluteUrl(),
	                    name: ajaxData.getPathName(),
	                    type: "Fetch",
	                    duration: ajaxData.ajaxTotalDuration,
	                    success: false,
	                    responseCode: 0,
	                    properties: { HttpMethod: ajaxData.method }
	                };
	                this.trackDependencyDataInternal(dependency, { error: reason.message });
	            }
	        }
	        catch (e) {
	            this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, "Failed to calculate the duration of the failed fetch call, monitoring data for this fetch call won't be sent.", {
	                fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(input),
	                exception: Util.dump(e)
	            });
	        }
	    };
	    AjaxMonitor.prototype.getFetchCorrelationContext = function (response) {
	        try {
	            var responseHeader = response.headers.get(RequestHeaders.requestContextHeader);
	            return CorrelationIdHelper.getCorrelationContext(responseHeader);
	        }
	        catch (e) {
	            this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, "Failed to get Request-Context correlation header as it may be not included in the response or not accessible.", {
	                fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(response),
	                exception: Util.dump(e)
	            });
	        }
	    };
	    AjaxMonitor.prototype.instrumentXhr = function () {
	        if (this.supportsAjaxMonitoring() && !this.initialized) {
	            this.instrumentOpen();
	            this.instrumentSend();
	            this.instrumentAbort();
	            this.instrumentSetRequestHeader();
	            this.initialized = true;
	        }
	    };
	    AjaxMonitor.getDefaultConfig = function () {
	        var config = {
	            maxAjaxCallsPerView: 500,
	            disableAjaxTracking: false,
	            disableFetchTracking: true,
	            disableCorrelationHeaders: false,
	            distributedTracingMode: DistributedTracingModes.AI,
	            correlationHeaderExcludedDomains: [
	                "*.blob.core.windows.net",
	                "*.blob.core.chinacloudapi.cn",
	                "*.blob.core.cloudapi.de",
	                "*.blob.core.usgovcloudapi.net"
	            ],
	            correlationHeaderDomains: undefined,
	            appId: undefined,
	            enableCorsCorrelation: false,
	            enableRequestHeaderTracking: false,
	            enableResponseHeaderTracking: false
	        };
	        return config;
	    };
	    AjaxMonitor.getEmptyConfig = function () {
	        return {
	            maxAjaxCallsPerView: undefined,
	            disableAjaxTracking: undefined,
	            disableFetchTracking: undefined,
	            disableCorrelationHeaders: undefined,
	            distributedTracingMode: undefined,
	            correlationHeaderExcludedDomains: undefined,
	            appId: undefined,
	            enableCorsCorrelation: undefined,
	            correlationHeaderDomains: undefined,
	            enableRequestHeaderTracking: undefined,
	            enableResponseHeaderTracking: undefined
	        };
	    };
	    AjaxMonitor.prototype.initialize = function (config, core, extensions) {
	        if (!this.initialized && !this._fetchInitialized) {
	            this._core = core;
	            var defaultConfig = AjaxMonitor.getDefaultConfig();
	            this._config = AjaxMonitor.getEmptyConfig();
	            for (var field in defaultConfig) {
	                this._config[field] = ConfigurationManager.getConfig(config, field, AjaxMonitor.identifier, defaultConfig[field]);
	            }
	            this._isUsingAIHeaders = this._config.distributedTracingMode === DistributedTracingModes.AI || this._config.distributedTracingMode === DistributedTracingModes.AI_AND_W3C;
	            this._isUsingW3CHeaders = this._config.distributedTracingMode === DistributedTracingModes.AI_AND_W3C || this._config.distributedTracingMode === DistributedTracingModes.W3C;
	            if (this._config.disableAjaxTracking === false) {
	                this.instrumentXhr();
	            }
	            if (this._config.disableFetchTracking === false) {
	                this.instrumentFetch();
	            }
	            if (extensions.length > 0 && extensions) {
	                var propExt = void 0, extIx = 0;
	                while (!propExt && extIx < extensions.length) {
	                    if (extensions[extIx] && extensions[extIx].identifier === PropertiesPluginIdentifier) {
	                        propExt = extensions[extIx];
	                    }
	                    extIx++;
	                }
	                if (propExt) {
	                    this._context = propExt.context; // we could move IPropertiesPlugin to common as well
	                }
	            }
	        }
	    };
	    AjaxMonitor.identifier = "AjaxDependencyPlugin";
	    return AjaxMonitor;
	}());

	// Copyright (c) Microsoft Corporation. All rights reserved.
	/**
	 * Application Insights API
	 * @class Initialization
	 * @implements {IApplicationInsights}
	 */
	var Initialization = /** @class */ (function () {
	    function Initialization(snippet) {
	        // initialize the queue and config in case they are undefined
	        snippet.queue = snippet.queue || [];
	        snippet.version = snippet.version || 2.0; // Default to new version
	        var config = snippet.config || {};
	        // ensure instrumentationKey is specified
	        if (config && !config.instrumentationKey) {
	            config = snippet;
	            ApplicationInsights.Version = "2.2.2"; // Not currently used anywhere
	        }
	        this.appInsights = new ApplicationInsights();
	        this.properties = new PropertiesPlugin();
	        this.dependencies = new AjaxMonitor();
	        this.core = new AppInsightsCore();
	        this.snippet = snippet;
	        this.config = config;
	        this.getSKUDefaults();
	    }
	    // Analytics Plugin
	    /**
	     * Log a user action or other occurrence.
	     * @param {IEventTelemetry} event
	     * @param {ICustomProperties} [customProperties]
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackEvent = function (event, customProperties) {
	        this.appInsights.trackEvent(event, customProperties);
	    };
	    /**
	     * Logs that a page, or similar container was displayed to the user.
	     * @param {IPageViewTelemetry} pageView
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackPageView = function (pageView) {
	        var inPv = pageView || {};
	        this.appInsights.trackPageView(inPv);
	    };
	    /**
	     * Log a bag of performance information via the customProperties field.
	     * @param {IPageViewPerformanceTelemetry} pageViewPerformance
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackPageViewPerformance = function (pageViewPerformance) {
	        var inPvp = pageViewPerformance || {};
	        this.appInsights.trackPageViewPerformance(inPvp);
	    };
	    /**
	     * Log an exception that you have caught.
	     * @param {IExceptionTelemetry} exception
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackException = function (exception) {
	        if (!exception.exception && exception.error) {
	            exception.exception = exception.error;
	        }
	        this.appInsights.trackException(exception);
	    };
	    /**
	     * Manually send uncaught exception telemetry. This method is automatically triggered
	     * on a window.onerror event.
	     * @param {IAutoExceptionTelemetry} exception
	     * @memberof Initialization
	     */
	    Initialization.prototype._onerror = function (exception) {
	        this.appInsights._onerror(exception);
	    };
	    /**
	     * Log a diagnostic scenario such entering or leaving a function.
	     * @param {ITraceTelemetry} trace
	     * @param {ICustomProperties} [customProperties]
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackTrace = function (trace, customProperties) {
	        this.appInsights.trackTrace(trace, customProperties);
	    };
	    /**
	     * Log a numeric value that is not associated with a specific event. Typically used
	     * to send regular reports of performance indicators.
	     *
	     * To send a single measurement, just use the `name` and `average` fields
	     * of {@link IMetricTelemetry}.
	     *
	     * If you take measurements frequently, you can reduce the telemetry bandwidth by
	     * aggregating multiple measurements and sending the resulting average and modifying
	     * the `sampleCount` field of {@link IMetricTelemetry}.
	     * @param {IMetricTelemetry} metric input object argument. Only `name` and `average` are mandatory.
	     * @param {ICustomProperties} [customProperties]
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackMetric = function (metric, customProperties) {
	        this.appInsights.trackMetric(metric, customProperties);
	    };
	    /**
	     * Starts the timer for tracking a page load time. Use this instead of `trackPageView` if you want to control when the page view timer starts and stops,
	     * but don't want to calculate the duration yourself. This method doesn't send any telemetry. Call `stopTrackPage` to log the end of the page view
	     * and send the event.
	     * @param name A string that idenfities this item, unique within this HTML document. Defaults to the document title.
	     */
	    Initialization.prototype.startTrackPage = function (name) {
	        this.appInsights.startTrackPage(name);
	    };
	    /**
	     * Stops the timer that was started by calling `startTrackPage` and sends the pageview load time telemetry with the specified properties and measurements.
	     * The duration of the page view will be the time between calling `startTrackPage` and `stopTrackPage`.
	     * @param   name  The string you used as the name in startTrackPage. Defaults to the document title.
	     * @param   url   String - a relative or absolute URL that identifies the page or other item. Defaults to the window location.
	     * @param   properties  map[string, string] - additional data used to filter pages and metrics in the portal. Defaults to empty.
	     * @param   measurements    map[string, number] - metrics associated with this page, displayed in Metrics Explorer on the portal. Defaults to empty.
	     */
	    Initialization.prototype.stopTrackPage = function (name, url, customProperties, measurements) {
	        this.appInsights.stopTrackPage(name, url, customProperties, measurements);
	    };
	    Initialization.prototype.startTrackEvent = function (name) {
	        this.appInsights.startTrackEvent(name);
	    };
	    /**
	     * Log an extended event that you started timing with `startTrackEvent`.
	     * @param   name    The string you used to identify this event in `startTrackEvent`.
	     * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
	     * @param   measurements    map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
	     */
	    Initialization.prototype.stopTrackEvent = function (name, properties, measurements) {
	        this.appInsights.stopTrackEvent(name, properties, measurements); // Todo: Fix to pass measurements once type is updated
	    };
	    Initialization.prototype.addTelemetryInitializer = function (telemetryInitializer) {
	        return this.appInsights.addTelemetryInitializer(telemetryInitializer);
	    };
	    // Properties Plugin
	    /**
	     * Set the authenticated user id and the account id. Used for identifying a specific signed-in user. Parameters must not contain whitespace or ,;=|
	     *
	     * The method will only set the `authenicatedUserId` and `accountId` in the curent page view. To set them for the whole sesion, you should set `storeInCookie = true`
	     * @param {string} authenticatedUserId
	     * @param {string} [accountId]
	     * @param {boolean} [storeInCookie=false]
	     * @memberof Initialization
	     */
	    Initialization.prototype.setAuthenticatedUserContext = function (authenticatedUserId, accountId, storeInCookie) {
	        if (storeInCookie === void 0) { storeInCookie = false; }
	        this.properties.context.user.setAuthenticatedUserContext(authenticatedUserId, accountId, storeInCookie);
	    };
	    /**
	     * Clears the authenticated user id and account id. The associated cookie is cleared, if present.
	     * @memberof Initialization
	     */
	    Initialization.prototype.clearAuthenticatedUserContext = function () {
	        this.properties.context.user.clearAuthenticatedUserContext();
	    };
	    // Dependencies Plugin
	    /**
	     * Log a dependency call (e.g. ajax)
	     * @param {IDependencyTelemetry} dependency
	     * @memberof Initialization
	     */
	    Initialization.prototype.trackDependencyData = function (dependency) {
	        this.dependencies.trackDependencyData(dependency);
	    };
	    // Misc
	    /**
	     * Manually trigger an immediate send of all telemetry still in the buffer.
	     * @param {boolean} [async=true]
	     * @memberof Initialization
	     */
	    Initialization.prototype.flush = function (async) {
	        if (async === void 0) { async = true; }
	        this.core.getTransmissionControls().forEach(function (channels) {
	            channels.forEach(function (channel) {
	                channel.flush(async);
	            });
	        });
	    };
	    /**
	     * Manually trigger an immediate send of all telemetry still in the buffer using beacon Sender.
	     * Fall back to xhr sender if beacon is not supported.
	     * @param {boolean} [async=true]
	     * @memberof Initialization
	     */
	    Initialization.prototype.onunloadFlush = function (async) {
	        if (async === void 0) { async = true; }
	        this.core.getTransmissionControls().forEach(function (channels) {
	            channels.forEach(function (channel) {
	                if (channel.onunloadFlush) {
	                    channel.onunloadFlush();
	                }
	                else {
	                    channel.flush(async);
	                }
	            });
	        });
	    };
	    /**
	     * Initialize this instance of ApplicationInsights
	     * @returns {IApplicationInsights}
	     * @memberof Initialization
	     */
	    Initialization.prototype.loadAppInsights = function (legacyMode) {
	        if (legacyMode === void 0) { legacyMode = false; }
	        // dont allow additional channels/other extensions for legacy mode; legacy mode is only to allow users to switch with no code changes!
	        if (legacyMode && this.config.extensions && this.config.extensions.length > 0) {
	            throw new Error("Extensions not allowed in legacy mode");
	        }
	        var extensions = [];
	        var appInsightsChannel = new Sender();
	        extensions.push(appInsightsChannel);
	        extensions.push(this.properties);
	        extensions.push(this.dependencies);
	        extensions.push(this.appInsights);
	        // initialize core
	        this.core.initialize(this.config, extensions);
	        // Empty queue of all api calls logged prior to sdk download
	        this.emptyQueue();
	        this.pollInternalLogs();
	        this.addHousekeepingBeforeUnload(this);
	        this.context = this.properties.context;
	        return this;
	    };
	    /**
	     * Overwrite the lazy loaded fields of global window snippet to contain the
	     * actual initialized API methods
	     * @param {Snippet} snippet
	     * @memberof Initialization
	     */
	    Initialization.prototype.updateSnippetDefinitions = function (snippet) {
	        // apply full appInsights to the global instance
	        // Note: This must be called before loadAppInsights is called
	        for (var field in this) {
	            if (typeof field === 'string') {
	                snippet[field] = this[field];
	            }
	        }
	    };
	    /**
	     * Call any functions that were queued before the main script was loaded
	     * @memberof Initialization
	     */
	    Initialization.prototype.emptyQueue = function () {
	        // call functions that were queued before the main script was loaded
	        try {
	            if (Util.isArray(this.snippet.queue)) {
	                // note: do not check length in the for-loop conditional in case something goes wrong and the stub methods are not overridden.
	                var length = this.snippet.queue.length;
	                for (var i = 0; i < length; i++) {
	                    var call = this.snippet.queue[i];
	                    call();
	                }
	                this.snippet.queue = undefined;
	                delete this.snippet.queue;
	            }
	        }
	        catch (exception) {
	            var properties = {};
	            if (exception && typeof exception.toString === "function") {
	                properties.exception = exception.toString();
	            }
	            // need from core
	            // Microsoft.ApplicationInsights._InternalLogging.throwInternal(
	            //     LoggingSeverity.WARNING,
	            //     _InternalMessageId.FailedToSendQueuedTelemetry,
	            //     "Failed to send queued telemetry",
	            //     properties);
	        }
	    };
	    Initialization.prototype.pollInternalLogs = function () {
	        this.core.pollInternalLogs();
	    };
	    Initialization.prototype.addHousekeepingBeforeUnload = function (appInsightsInstance) {
	        // Add callback to push events when the user navigates away
	        if (!appInsightsInstance.appInsights.config.disableFlushOnBeforeUnload && ('onbeforeunload' in window)) {
	            var performHousekeeping = function () {
	                // Adds the ability to flush all data before the page unloads.
	                // Note: This approach tries to push an async request with all the pending events onbeforeunload.
	                // Firefox does not respect this.Other browsers DO push out the call with < 100% hit rate.
	                // Telemetry here will help us analyze how effective this approach is.
	                // Another approach would be to make this call sync with a acceptable timeout to reduce the
	                // impact on user experience.
	                //appInsightsInstance.context._sender.triggerSend();
	                appInsightsInstance.onunloadFlush(false);
	                // Back up the current session to local storage
	                // This lets us close expired sessions after the cookies themselves expire
	                var ext = appInsightsInstance.appInsights.core['_extensions'][PropertiesPluginIdentifier];
	                if (ext && ext.context && ext.context._sessionManager) {
	                    ext.context._sessionManager.backup();
	                }
	            };
	            if (!Util.addEventHandler('beforeunload', performHousekeeping)) {
	                appInsightsInstance.appInsights.core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedToAddHandlerForOnBeforeUnload, 'Could not add handler for beforeunload');
	            }
	        }
	    };
	    Initialization.prototype.getSKUDefaults = function () {
	        this.config.diagnosticLogInterval =
	            this.config.diagnosticLogInterval && this.config.diagnosticLogInterval > 0 ? this.config.diagnosticLogInterval : 10000;
	    };
	    return Initialization;
	}());

	/**
	 * @private
	 */
	var Insights = /** @class */ (function () {
	    function Insights(options) {
	        this.options = options;
	        if (!this.options.disableTelemetry && env.appInsightsKey) {
	            this.appInsights = new Initialization({
	                config: {
	                    instrumentationKey: env.appInsightsKey,
	                    // Don't globally track exceptions unless we call trackException()
	                    disableExceptionTracking: true,
	                    // Don't track every AJAX call
	                    disableAjaxTracking: true,
	                    // Play nice with other's AI instances by not using cookies
	                    isCookieUseDisabled: true,
	                    // Tighten the batch size window
	                    maxBatchInterval: 5000
	                }
	            });
	            // Load the app insights object.
	            // Add our app version number to all telemetry items.
	            this.appInsights.loadAppInsights();
	            this.appInsights.addTelemetryInitializer(function (item) {
	                // The applicationVersion property is special and defined by the app insights package.
	                item.tags[CtxTagKeys.applicationVersion] = Version.getFullVersion();
	            });
	        }
	    }
	    Insights.prototype.trackEvent = function (event, customProperties) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.trackEvent(event, customProperties);
	        }
	    };
	    Insights.prototype.setAuthenticatedUserContext = function (authenticatedUserId, accountId) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.setAuthenticatedUserContext(authenticatedUserId, accountId);
	        }
	    };
	    Insights.prototype.trackException = function (exception) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.trackException(exception);
	        }
	    };
	    Insights.prototype.flush = function (async) {
	        if (!this.options.disableTelemetry && this.appInsights) {
	            this.appInsights.flush(async);
	        }
	    };
	    return Insights;
	}());

	/**
	 * @private
	 */
	var AzureLogoControl = /** @class */ (function () {
	    function AzureLogoControl() {
	    }
	    AzureLogoControl.prototype.onAdd = function (map) {
	        this.container = document.createElement("div");
	        this.container.className = "azure-map-logo";
	        return this.container;
	    };
	    AzureLogoControl.prototype.onRemove = function () {
	        this.container.remove();
	    };
	    return AzureLogoControl;
	}());

	/**
	 * The options for a CopyrightControl object.
	 */
	var CopyrightControlOptions = /** @class */ (function (_super) {
	    __extends(CopyrightControlOptions, _super);
	    function CopyrightControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The copyright message to display.
	         */
	        _this.copyrightMessage = undefined;
	        /**
	         * If true will show a link to the map feedback page.
	         */
	        _this.showFeedbackLink = true;
	        return _this;
	    }
	    return CopyrightControlOptions;
	}(Options));

	/**
	 * @private
	 */
	var CopyrightControl = /** @class */ (function (_super) {
	    __extends(CopyrightControl, _super);
	    function CopyrightControl(options) {
	        var _this = _super.call(this) || this;
	        _this.options = new CopyrightControlOptions().merge(options);
	        return _this;
	    }
	    CopyrightControl.prototype.onAdd = function (map) {
	        this.container = this.buildContainer(map, exports.ControlStyle.auto);
	        this.container.className = "map-copyright";
	        this.copyrightDiv = this.buildCopyrightDiv();
	        this.container.appendChild(this.copyrightDiv);
	        if (this.options.showFeedbackLink) {
	            this.feedbackLink = this.buildFeedbackLink();
	            this.container.appendChild(this.feedbackLink);
	        }
	        return this.container;
	    };
	    CopyrightControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        delete this.container;
	    };
	    CopyrightControl.prototype.setOptions = function (options) {
	        var newOptions = new CopyrightControlOptions().merge(this.options, options);
	        if (newOptions.copyrightMessage !== this.options.copyrightMessage) {
	            this.copyrightDiv.innerText = newOptions.copyrightMessage;
	        }
	        if (!newOptions.showFeedbackLink && this.feedbackLink) {
	            this.feedbackLink.remove();
	            delete this.feedbackLink;
	        }
	        else if (newOptions.showFeedbackLink && !this.feedbackLink) {
	            this.feedbackLink = this.buildFeedbackLink();
	            this.container.appendChild(this.feedbackLink);
	        }
	        this.options = newOptions;
	    };
	    CopyrightControl.prototype.buildCopyrightDiv = function () {
	        var copyright = document.createElement("div");
	        copyright.innerText = this.options.copyrightMessage || "";
	        return copyright;
	    };
	    CopyrightControl.prototype.buildFeedbackLink = function () {
	        var link = document.createElement("a");
	        link.textContent = "Improve this map";
	        link.href = "https://feedback.azuremaps.com";
	        link.target = "_blank";
	        link.rel = "noopener";
	        return link;
	    };
	    return CopyrightControl;
	}(ControlBase));

	/**
	 * Provides some static methods to translate Mapbox's event based errors to try/catch style.
	 */
	var ErrorHandler = /** @class */ (function () {
	    function ErrorHandler() {
	    }
	    /**
	     * Executes the specified function and throws an error if Mapbox fires an error event.
	     * A call to this should be wrapped in a try/catch.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param func The function to execute.
	     * @internal
	     */
	    ErrorHandler.throwOnError = function (map, func) {
	        // Work directly with the Mapbox map.
	        var mbMap = map instanceof Map$2 ? map._getMap() : map;
	        // Listen for the error event and throw if one is seen.
	        var throwError = function (data) {
	            mbMap.off("error", throwError);
	            throw data.error;
	        };
	        mbMap.on("error", throwError);
	        // Execute the specified function and return the result.
	        // Stop the error listener before returning.
	        var result = func();
	        mbMap.off("error", throwError);
	        return result;
	    };
	    /**
	     * Executes the specified function and and throws an error if Mapbox fires an error event.
	     * The call is wrapped in a try/catch.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param tryFunc The function to try executing.
	     * @param catchFunc The function to execute if an error is fired.
	     * @param finallyFunc An optional function to execute in the finally block.
	     */
	    ErrorHandler.tryCatch = function (map, tryFunc, catchFunc, finallyFunc) {
	        try {
	            return this.throwOnError(map, tryFunc);
	        }
	        catch (error) {
	            return catchFunc(error);
	        }
	        finally {
	            if (typeof finallyFunc === "function") {
	                finallyFunc();
	            }
	        }
	    };
	    /**
	     * Executes the specified function and and throws an error if Mapbox fires an error event.
	     * The call is wrapped in a try/finally.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param tryFunc The function to try executing.
	     * @param finallyFunc An optional function to execute in the finally block.
	     */
	    ErrorHandler.tryFinally = function (map, tryFunc, finallyFunc) {
	        try {
	            return this.throwOnError(map, tryFunc);
	        }
	        finally {
	            finallyFunc();
	        }
	    };
	    return ErrorHandler;
	}());

	/**
	 * @private
	 */
	var NearbyGeographySearchService = /** @class */ (function () {
	    function NearbyGeographySearchService(map) {
	        this.map = map;
	    }
	    NearbyGeographySearchService.prototype.request = function (options) {
	        var domain = this.map.getServiceOptions().domain;
	        var urlOptions = {
	            domain: domain,
	            path: "search/address/reverse/json",
	            queryParams: __assign({ "api-version": "1.0", "language": options.style.language, "limit": 1, "query": normalizeLatitude(options.position[1]) + "," + normalizeLongitude(options.position[0]) }, (options.style.view && { view: options.style.view }))
	        };
	        return new Url(this.map.authentication.signRequest(urlOptions)).get();
	    };
	    return NearbyGeographySearchService;
	}());

	/** A static class that maintains a cache of place labels. */
	var MapLabelCache = /** @class */ (function () {
	    function MapLabelCache() {
	        this._labelCache = {};
	        this._labelIdx = {};
	        this._preloadedCache = new Set();
	    }
	    /**
	     * Adds a label to the cache.
	     * @param label The label to cache.
	     * @param layerInfo The configu info for the label.
	     * @param pos The position of the label.
	     * @param lang The language of the label.
	     */
	    MapLabelCache.prototype.cache = function (name, layerInfo, pos, lang) {
	        var id = name + "_" + pos[0] + "_" + pos[1] + "_" + lang;
	        if (!this._labelIdx[layerInfo.labelType]) {
	            this._labelIdx[layerInfo.labelType] = [];
	            this._labelCache[layerInfo.labelType] = [];
	        }
	        if (this._labelIdx[layerInfo.labelType].indexOf(id) === -1) {
	            // Add label to cache.
	            this._labelCache[layerInfo.labelType].push({
	                name: name,
	                radius: layerInfo.radius,
	                minZoom: layerInfo.minZoom,
	                maxZoom: layerInfo.maxZoom || 24,
	                position: pos
	            });
	            // Add label to index.
	            this._labelIdx[layerInfo.labelType].push(id);
	        }
	    };
	    /**
	     * Calculates the nearest label in the cache.
	     * @param labelType The type/category of the label in which the label is seperated into.
	     * @param pos The position to center the search on.
	     */
	    MapLabelCache.prototype.getNearestLabel = function (labelType, pos, zoom) {
	        var nearest = null;
	        var c = this._labelCache[labelType];
	        if (c) {
	            var minDistance = Infinity;
	            for (var i = 0, len = c.length; i < len; i++) {
	                if (zoom >= c[i].minZoom && zoom <= c[i].maxZoom) {
	                    var d = getDistanceTo(c[i].position, pos);
	                    if (d <= c[i].radius && d <= minDistance) {
	                        minDistance = d;
	                        nearest = c[i];
	                    }
	                }
	            }
	        }
	        return nearest;
	    };
	    /**
	     * This function preloads the cache with major labels for a select few languages
	     * in which these labels are most likely to be used with.
	     * This is to help with identifying these major labels when the user is zoomed in close to the map.
	     * In testing, this has been found to drastically reduce the number of times "unknown" is returned
	     * for locations that border an ocean. Based on Bing Maps usage,
	     * the following languages cover 98% of traffic they recieve.
	     * Limiting the languages to those most likely to be used on the broder with an ocean.
	     * @param lang The language to load into the cache.
	     */
	    MapLabelCache.prototype._preloadCache = function (lang) {
	        // Only load a language once into cache.
	        if (!this._preloadedCache.has(lang)) {
	            // Translations for oceans: https://en.wikipedia.org/wiki/List_of_alternative_names_for_oceans
	            this._preloadedCache.add(lang);
	            var oceanConfig = {
	                source: ["Ocean label", "Ocean name"],
	                labelType: "water",
	                minZoom: 0,
	                radius: 3950000,
	                polygonSources: ["Ocean", "Ocean or sea"]
	            };
	            var shortLang = lang;
	            var index = shortLang.indexOf("-");
	            if (index !== -1) {
	                shortLang = shortLang.substr(0, index);
	            }
	            switch (shortLang) {
	                case "fr":
	                    this.cache("Océan Pacifique", oceanConfig, [-170, 32], lang);
	                    this.cache("Océan Pacifique", oceanConfig, [-138, -27], lang);
	                    this.cache("Océan Atlantique", oceanConfig, [-40, 32], lang);
	                    this.cache("Océan Atlantique", oceanConfig, [-17, -29], lang);
	                    break;
	                case "es":
	                    this.cache("Océan Pacifique", oceanConfig, [-170, 32], lang);
	                    this.cache("Océan Pacifique", oceanConfig, [-138, -27], lang);
	                    this.cache("Océano Atlántico", oceanConfig, [-40, 32], lang);
	                    this.cache("Océano Atlántico", oceanConfig, [-17, -29], lang);
	                    break;
	                case "pt":
	                    this.cache("Oceano Pacífico", oceanConfig, [-170, 32], lang);
	                    this.cache("Oceano Pacífico", oceanConfig, [-138, -27], lang);
	                    this.cache("Oceano Atlântico", oceanConfig, [-40, 32], lang);
	                    this.cache("Oceano Atlântico", oceanConfig, [-17, -29], lang);
	                    break;
	                case "ja":
	                    // Pacific Ocean
	                    this.cache("太平洋", oceanConfig, [-170, 32], lang);
	                    this.cache("太平洋", oceanConfig, [-138, -27], lang);
	                    break;
	                case "en":
	                    this.cache("Pacific Ocean", oceanConfig, [-170, 32], lang);
	                    this.cache("Pacific Ocean", oceanConfig, [-138, -27], lang);
	                    this.cache("Atlantic Ocean", oceanConfig, [-40, 32], lang);
	                    this.cache("Atlantic Ocean", oceanConfig, [-17, -29], lang);
	                    this.cache("Indian Ocean", oceanConfig, [77, -26], lang);
	                    break;
	                default:
	                    break;
	            }
	        }
	    };
	    return MapLabelCache;
	}());

	/**
	 * This class analyizes the current view of a map and provides a description for use by accessibilty tools.
	 * TODO: Use services when in  GeoPol regions. (Kasmir) or when user region sensitive.
	 */
	var MapViewDescriptor = /** @class */ (function () {
	    function MapViewDescriptor(map, descCallback) {
	        var _this = this;
	        // An option specifying if the this logic should fallback to the REST reverse geocoder if unable to generate a description.
	        this._restFallback = true;
	        // Track if disposed.
	        this._disposed = false;
	        // Track when the last description update occurred due to rotation.
	        this._lastHeadingTime = 0;
	        // A queue of the actions that haven't been described yet.
	        this._actionQueue = [];
	        // Number of milliseconds required between move end and the description update.
	        this._camUpdateDelay = 1000;
	        // Number of milliseconds required between heading description updates.
	        this._headUpdateLimit = 1000;
	        // Number of milliseconds to wait before acting on a move event originating from a control element.
	        this._controlEventDelay = 500;
	        // The minium number of pixels the map must move to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._moveThreshold = 25;
	        // The minium number of degrees the map must rotate to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._headingThreshold = 5;
	        // The minium number of degrees the map must pitch to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._pitchThreshold = 5;
	        // The number of pixels to search around the center for a road, or major label.
	        this._roadPixelRadius = 120;
	        // Minum distance a road has to be before it can be displayed. Only used when zoomed in close.
	        this._minRoadDistance = 25;
	        // Minium distance in pixels a second road must be in order to be considered an intersection.
	        this._minIntersectionPixelDistance = 50;
	        // The vector tile source id for Azure Maps.
	        this._baseVectorTileSourceId = "vectorTiles";
	        /*
	         * Show details based on zoom level.
	         *
	         * Country: 1+
	         * Water: 1+
	         * States: 4+
	         * City: 8+
	         * Major POI: 8+  or 12+
	         * Neighborhood: 12+
	         * Poi: 16+
	         * Road: 16+
	         *
	         * The following label types will be cached; Country, State, City, Water, and majorPoi.
	         * The purpose of the cache is to provide a backup if no information is found in the source,
	         * we can do a radial search for appropriate label type.
	         * These often cover large areas and only have a single label.
	         * When zoomed in, no icon is visible, so based on the type of polygon the center intersects with,
	         * we can make an educated guess on what cache to pull a label from.
	         *
	         * Vector Tile source layers: https://developer.tomtom.com/maps-api/maps-api-documentation-vector/tile
	         */
	        // Configuration for label extraction.
	        this._lableConfig = [
	            // Water labels
	            {
	                source: ["Ocean label", "Ocean name"],
	                labelType: "water",
	                minZoom: 0, radius: 3950000,
	                polygonSources: ["Ocean", "Ocean or sea"]
	            },
	            {
	                source: ["Sea label"],
	                labelType: "water",
	                minZoom: 3,
	                radius: 1000000,
	                polygonSources: ["Sea", "Ocean or sea"]
	            },
	            // Country labels
	            {
	                source: ["Country name"],
	                labelType: "country",
	                minZoom: 0,
	                maxZoom: 5,
	                radius: 300000
	            },
	            // State labels
	            {
	                source: ["State name", "State name short"],
	                labelType: "state",
	                minZoom: 4,
	                maxZoom: 7,
	                radius: 300000
	            },
	            // City labels
	            {
	                source: ["Capital city", "Large city"],
	                labelType: "city", minZoom: 8,
	                radius: 40000
	            },
	            {
	                source: ["Medium city"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 30000
	            },
	            {
	                source: ["Small city"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 20000
	            },
	            {
	                source: ["Island label"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 10000
	            },
	            {
	                source: ["Town"],
	                labelType: "city",
	                minZoom: 10,
	                radius: 10000
	            },
	            // Neighbourhood labels
	            {
	                source: ["Village"],
	                labelType: "neighbourhood",
	                minZoom: 12,
	                radius: 6000
	            },
	            // POI labels
	            {
	                source: ["Amusement area label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 2000,
	                polygonSources: ["Amusement park"]
	            },
	            {
	                source: ["Hospital label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Hospital"]
	            },
	            {
	                source: ["Shopping centre label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Shopping"]
	            },
	            {
	                source: ["Stadium label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Stadium"]
	            },
	            {
	                source: ["University/School label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["University"]
	            },
	            {
	                source: ["Zoo label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Zoo"]
	            },
	            // Major Poi labels
	            {
	                source: ["Airport Label", "Airport name", "Airport POI"],
	                labelType: "majorPoi",
	                minZoom: 11,
	                radius: 3000,
	                polygonSources: ["Airport", "Runway"]
	            },
	            {
	                source: ["National park label"],
	                labelType: "majorPoi",
	                minZoom: 7,
	                radius: 15000,
	                polygonSources: ["National or state park", "National park", "Forest"]
	            },
	            {
	                source: ["Reservation label"],
	                labelType: "majorPoi",
	                minZoom: 7,
	                radius: 15000,
	                polygonSources: ["Reservation"]
	            }
	        ];
	        // Name of all polygon layers in which we want to do an intersection test with.
	        this._polygonStyleLayer = ["National or state park", "National park", "Reservation", "Airport",
	            "Runway", "Stadium", "University", "Zoo", "Shopping", "Hospital", "Amusement park", "Ocean", "Sea",
	            "Ocean or sea"];
	        // Name of all label types to cache.
	        this._labelCache = new Set(["city", "state", "country", "water", "majorPoi"]);
	        // Name of all road source layers.
	        this._roadLayers = new Set([
	            "Connecting road",
	            "Connecting road tunnel",
	            "International road",
	            "International road tunnel",
	            "Local road",
	            "Local road tunnel",
	            "Major local road",
	            "Major local road tunnel",
	            "Major road",
	            "Major road tunnel",
	            "Minor local road",
	            "Minor local road tunnel",
	            "Motorway",
	            "Motorway tunnel",
	            "Secondary road",
	            "Secondary road tunnel",
	            "Toll connecting road",
	            "Toll connecting road tunnel",
	            "Toll international road",
	            "Toll international road tunnel",
	            "Toll local road",
	            "Toll local road tunnel",
	            "Toll major local road",
	            "Toll major local road tunnel",
	            "Toll major road",
	            "Toll major road tunnel",
	            "Toll minor local road",
	            "Toll minor local road tunnel",
	            "Toll motorway",
	            "Toll motorway tunnel",
	            "Toll secondary road",
	            "Toll secondary road tunnel"
	        ]);
	        // Flag indicating if detailed descriptions which include zoom, lat/lon information should be returned.
	        this._returnDetailedDescriptions = false;
	        /** Event handler for shortcuts. */
	        this._shortcutListener = function (e) { return __awaiter(_this, void 0, void 0, function () {
	            var cam, styleOps, lang, style, camDesc;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!(e.altKey && e.ctrlKey && e.keyCode === 68)) return [3 /*break*/, 2];
	                        this._returnDetailedDescriptions = !this._returnDetailedDescriptions;
	                        cam = this._map.getCamera();
	                        styleOps = this._map.getStyle();
	                        lang = styleOps.language.toLowerCase();
	                        style = styleOps.style.toLowerCase();
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 1:
	                        camDesc = _a.sent();
	                        this._descCallback(camDesc);
	                        _a.label = 2;
	                    case 2: return [2 /*return*/];
	                }
	            });
	        }); };
	        /** Event handler for when the map is actively rotating and should update the heading description. */
	        this._onRotate = function () {
	            if (!_this._rotateTimeout) {
	                if (Date.now() - _this._lastHeadingTime >= _this._headUpdateLimit) {
	                    // If the min required time has already passed just do the update.
	                    _this._rotateTimeout = setTimeout(_this._updateHeading, CompassControl.RotationDuration + 25);
	                }
	                else {
	                    // If the min required time hasn't passed start a timeout if doesn't already exist.
	                    _this._rotateTimeout = setTimeout(_this._updateHeading, _this._headUpdateLimit - (Date.now() - _this._lastHeadingTime));
	                }
	            }
	        };
	        /** Event handler for when the map is actively moving should wait to update the camera description. */
	        this._onMove = function () {
	            // Clear the timeout for updating the map's camera description.
	            if (_this._moveTimeout) {
	                clearTimeout(_this._moveTimeout);
	                delete _this._moveTimeout;
	            }
	            // Clear the timeout for delaying updates originating from control elements.
	            if (_this._controlTimeout) {
	                clearTimeout(_this._controlTimeout);
	                delete _this._controlTimeout;
	            }
	        };
	        /** Event handler for when the mas has stopped moving and thus a new description is needed. */
	        this._onMoveEnd = function (event) {
	            if (event.fromControl) {
	                // If the move end event originated from a control element delay the response to batch control clicks.
	                _this._controlTimeout = setTimeout(_this._updateCam, _this._controlEventDelay);
	            }
	            else {
	                // Otherwise start processing a new description immediately.
	                _this._updateCam();
	            }
	        };
	        /** Event handler for when the map has changed styles. */
	        this._onStyleData = function () {
	            // Use setTimeout with no delay to allow mapbox time to
	            // update the value of .loaded() before we check it.
	            setTimeout(_this._updateStyle);
	        };
	        /** Called when the map is rotating and needs a new description created */
	        this._updateHeading = function () {
	            // Update the heading description.
	            var cam = _this._map.getCamera();
	            if (!_this._lastHead || _this._checkHeadingThreshold(cam.bearing, _this._lastHead)) {
	                // Update the last heading value and update time.
	                var headDesc = _this._getHeadingDesc(cam);
	                _this._lastHead = cam.bearing;
	                _this._descCallback("<p>Map heading " + headDesc + "</p>");
	                _this._lastHeadingTime = Date.now();
	            }
	            // Reset for the next rotate.
	            delete _this._rotateTimeout;
	        };
	        /** Called when the map has finished changing styles and is ready to create a new description */
	        this._updateStyle = function () { return __awaiter(_this, void 0, void 0, function () {
	            var cam, styleOps, lang, style, camDesc;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        cam = this._map.getCamera();
	                        styleOps = this._map.getStyle();
	                        lang = styleOps.language.toLowerCase();
	                        style = styleOps.style.toLowerCase();
	                        if (!(this._lastLang !== lang)) return [3 /*break*/, 2];
	                        MapViewDescriptor._labelCache._preloadCache(lang);
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 1:
	                        camDesc = _a.sent();
	                        return [3 /*break*/, 4];
	                    case 2:
	                        if (!(this._lastStyle !== style && this._lastStyle === "blank")) return [3 /*break*/, 4];
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 3:
	                        camDesc = _a.sent();
	                        _a.label = 4;
	                    case 4:
	                        // Update the last lang and style values.
	                        this._lastLang = lang;
	                        this._lastStyle = style;
	                        // Send the new description to the map.
	                        if (camDesc) {
	                            this._descCallback(camDesc);
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        }); };
	        /** Called when the map has finished updating and is ready to create a new description */
	        this._updateCam = function (immediate) {
	            if (immediate === void 0) { immediate = false; }
	            var cam = _this._map.getCamera();
	            if (!_this._lastCam || _this._actionQueue.length > 0 || _this._checkThresholds(cam, _this._lastCam)) {
	                var styleOps = _this._map.getStyle();
	                var lang_1 = styleOps.language.toLowerCase();
	                var style_1 = styleOps.style.toLowerCase();
	                // Update the action queue if an action is provided.
	                var action = _this._getActionDesc(cam);
	                if (action) {
	                    _this._actionQueue.push(action);
	                }
	                // Update the last camera value.
	                _this._lastCam = cam;
	                // Make sure no other timeouts are active.
	                if (_this._moveTimeout) {
	                    clearTimeout(_this._moveTimeout);
	                    delete _this._moveTimeout;
	                }
	                // Send the new description to the map.
	                _this._moveTimeout = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
	                    var loc;
	                    return __generator(this, function (_a) {
	                        switch (_a.label) {
	                            case 0:
	                                // Clear the rotate timeout as the move description will cover rotation.
	                                clearTimeout(this._rotateTimeout);
	                                delete this._rotateTimeout;
	                                return [4 /*yield*/, this._getLocDesc(cam, lang_1, style_1)];
	                            case 1:
	                                loc = _a.sent();
	                                // Build the message from the action queue and current loc description.
	                                if (this._actionQueue.length > 0) {
	                                    this._descCallback("<p>Map " + this._actionQueue.join(", then ") + "</p>" + loc);
	                                    this._actionQueue = []; // Reset the queue because all actions have been delivered.
	                                }
	                                else {
	                                    this._descCallback(loc);
	                                }
	                                return [2 /*return*/];
	                        }
	                    });
	                }); }, immediate ? 0 : _this._camUpdateDelay);
	            }
	        };
	        this._map = map;
	        this._descCallback = descCallback;
	        this._reverseSearch = new NearbyGeographySearchService(map);
	        if (!MapViewDescriptor._labelCache) {
	            MapViewDescriptor._labelCache = new MapLabelCache();
	        }
	        this._lastLang = this._map.getStyle().language.toLowerCase();
	        MapViewDescriptor._labelCache._preloadCache(this._lastLang);
	        this._map.events.addOnce("load", function () {
	            if (!_this._disposed) {
	                _this._updateCam(true);
	                // Add event listeners directly to mapbox because we will be using custom event data.
	                // We don't automatically forward all properties of a mapbox event, so the custom data would be lost.
	                _this._map._getMap().on("move", _this._onMove);
	                _this._map._getMap().on("moveend", _this._onMoveEnd);
	                _this._map._getMap().on("styledata", _this._onStyleData);
	                _this._map._getMap().on("rotate", _this._onRotate);
	            }
	        });
	        this._map.getMapContainer().addEventListener("keydown", this._shortcutListener);
	    }
	    /** Disposes the MapViewDescriptor preventing any further updates */
	    MapViewDescriptor.prototype.dispose = function () {
	        this._disposed = true;
	        // Event listeners were added directly to mapbox.
	        // Remove them directly from there too.
	        this._map._getMap().off("move", this._onMove);
	        this._map._getMap().off("moveend", this._onMoveEnd);
	        this._map._getMap().off("styledata", this._onStyleData);
	        this._map._getMap().off("rotate", this._onRotate);
	        this._map.getMapContainer().removeEventListener("keydown", this._shortcutListener);
	    };
	    /** Checks if the camera has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkThresholds = function (newCam, lastCam) {
	        return this._checkZoomThreshold(newCam.zoom, lastCam.zoom) ||
	            this._checkPitchThreshold(newCam.pitch, lastCam.pitch) ||
	            this._checkLocThreshold(newCam.center, lastCam.center) ||
	            this._checkHeadingThreshold(newCam.bearing, lastCam.bearing);
	    };
	    /** Checks if the zoom has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkZoomThreshold = function (newZoom, lastZoom) {
	        return this._round(newZoom) !== this._round(lastZoom);
	    };
	    /** Checks if the pitch has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkPitchThreshold = function (newPitch, lastPitch) {
	        return Math.abs(newPitch - lastPitch) >= this._pitchThreshold;
	    };
	    /** Checks if the location has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkLocThreshold = function (newCenter, lastCenter) {
	        var _a = this._map.positionsToPixels([lastCenter, newCenter]), lastPixel = _a[0], newPixel = _a[1];
	        return Pixel.getDistance(lastPixel, newPixel) >= this._moveThreshold;
	    };
	    /** Checks if the heading has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkHeadingThreshold = function (newHeading, lastHeading) {
	        // Modify the heading values to always be positive.
	        if (newHeading < 0) {
	            newHeading += 360;
	        }
	        if (lastHeading < 0) {
	            lastHeading += 360;
	        }
	        // If the heading diff is greater than 180 it is
	        // less difference in the other direction of rotation.
	        var headDiff = Math.abs(newHeading - lastHeading);
	        if (headDiff > 180) {
	            headDiff = 360 - headDiff;
	        }
	        return headDiff >= this._headingThreshold;
	    };
	    /**
	     * Generates the description for the map view around the center of the map.
	     * @param cam The map camera informaiton.
	     */
	    MapViewDescriptor.prototype._getLocDesc = function (cam, lang, style) {
	        return __awaiter(this, void 0, void 0, function () {
	            var info_1, cPx_1, intersects_1, intersectingPolygon, intersectingType_1, i, cnt, layerInfo, cl_1;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!(style !== "blank")) return [3 /*break*/, 3];
	                        if (!!this._map._getMap().loaded()) return [3 /*break*/, 2];
	                        return [4 /*yield*/, new Promise(function (done) { return _this._map._getMap().once("idle", done); })];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        info_1 = {};
	                        cPx_1 = this._map.positionsToPixels([cam.center])[0];
	                        ErrorHandler.tryCatch(this._map, function () {
	                            intersects_1 = _this._map._getMap().queryRenderedFeatures(cPx_1, {
	                                layers: _this._polygonStyleLayer,
	                                filter: ["==", ["geometry-type"], "Polygon"]
	                            });
	                        }, function () { });
	                        intersectingPolygon = null;
	                        if (intersects_1 && intersects_1.length > 0) {
	                            intersectingPolygon = intersects_1[0];
	                        }
	                        intersectingType_1 = null;
	                        // Loop through each label config and try and retireve details about the map view.
	                        for (i = 0, cnt = this._lableConfig.length; i < cnt; i++) {
	                            layerInfo = this._lableConfig[i];
	                            if (cam.zoom >= layerInfo.minZoom) {
	                                // If the layer info has polygons defined, do an intersection test for matching.
	                                if (layerInfo.polygonSources) {
	                                    // Only if a value of the same type hasn't already been captured and the intersection polygon has the same source, retrieve a label.
	                                    if (intersectingPolygon &&
	                                        layerInfo.polygonSources.indexOf(intersectingPolygon.layer["source-layer"]) !== -1) {
	                                        intersectingType_1 = layerInfo.labelType;
	                                        this._getClosestLabel(layerInfo, cam, lang, info_1, false);
	                                    }
	                                    else {
	                                        // If the polygon doesn't intersect, cache labels.
	                                        this._getClosestLabel(layerInfo, cam, lang, info_1, true);
	                                    }
	                                }
	                                else {
	                                    this._getClosestLabel(layerInfo, cam, lang, info_1, false);
	                                }
	                            }
	                            else {
	                                this._getClosestLabel(layerInfo, cam, lang, info_1, true);
	                            }
	                        }
	                        if (cam.zoom >= 8) {
	                            // When zoomed in get all the roads as possible that roads might be only near edge.
	                            // Need road to determine state info when zoomed in.
	                            this._processRoads(info_1, cam, lang);
	                        }
	                        this._labelCache.forEach(function (label) {
	                            if (!info_1[label]) {
	                                cl_1 = null;
	                                if (label === "water" || label === "majorPoi") {
	                                    // Only check cache for water and majorPoi labels if the map is over top of water or a major Poi.
	                                    if (label === intersectingType_1) {
	                                        cl_1 = MapViewDescriptor._labelCache.getNearestLabel(label, cam.center, cam.zoom);
	                                    }
	                                }
	                                else {
	                                    cl_1 = MapViewDescriptor._labelCache.getNearestLabel(label, cam.center, cam.zoom);
	                                }
	                                if (cl_1) {
	                                    info_1[label] = cl_1.name;
	                                }
	                            }
	                        });
	                        return [2 /*return*/, this._processLocInfo(cam, intersectingType_1, info_1, true, this._restFallback)];
	                    case 3: 
	                    // If the style is blank don't provide a label as that would always require a reverse geocode api call.
	                    return [2 /*return*/, this._processLocInfo(cam, null, null, false, false)];
	                }
	            });
	        });
	    };
	    /**
	     * Generates the description for the map view around the center of the map.
	     * @param cam The map camera informaiton.
	     */
	    MapViewDescriptor.prototype._getHeadingDesc = function (cam) {
	        // Use the heading but shift any negative values.
	        var heading = cam.bearing;
	        if (heading < 0) {
	            heading += 360;
	        }
	        // Snap to the nearest 5 degrees.
	        heading = this._round(heading, this._headingThreshold);
	        // Generate a new description.
	        switch (heading) {
	            case 0:
	            case 360:
	                return "north";
	            case 45:
	                return "north east";
	            case 90:
	                return "east";
	            case 135:
	                return "south east";
	            case 180:
	                return "south";
	            case 225:
	                return "south west";
	            case 270:
	                return "west";
	            case 315:
	                return "north west";
	            default:
	                return heading + " degrees";
	        }
	    };
	    /**
	     * Gets the closest label to the center of the map.
	     * @param layerInfo The label lauyer information.
	     * @param cam The map camera information.
	     * @param info The result information.
	     * @param cacheOnly Specifies if labels should only be cached and not set on the result.
	     */
	    MapViewDescriptor.prototype._getClosestLabel = function (layerInfo, cam, lang, info, cacheOnly) {
	        var radius = layerInfo.radius;
	        // Loop through the label sources.
	        for (var i = 0, len = layerInfo.source.length; i < len; i++) {
	            var params = {
	                sourceLayer: layerInfo.source[i]
	            };
	            var labels = this._map._getMap().querySourceFeatures(this._baseVectorTileSourceId, params);
	            var closest = null;
	            var minDistance = Infinity;
	            var cacheLabels = this._labelCache.has(layerInfo.labelType);
	            if (!cacheOnly || (cacheOnly && cacheLabels)) {
	                for (var j = 0, cnt = labels.length; j < cnt; j++) {
	                    var p = labels[j].geometry.type === "Point" ?
	                        labels[j] :
	                        getClosestPointOnGeometry(cam.center, labels[j].geometry);
	                    if (!cacheOnly) {
	                        // Distance in meters.
	                        var d = labels[j].geometry.type === "Point" ?
	                            getDistanceTo(cam.center, p.geometry.coordinates) :
	                            p.properties.distance;
	                        if (d < minDistance) {
	                            minDistance = d;
	                            closest = labels[j];
	                        }
	                    }
	                    if (cacheLabels) {
	                        MapViewDescriptor._labelCache.cache(labels[j].properties.name, layerInfo, p.geometry.coordinates, lang);
	                    }
	                }
	            }
	            if (!cacheOnly) {
	                var disParam = layerInfo.labelType + "Dis";
	                if (closest && minDistance <= radius &&
	                    (typeof info[disParam] !== "number" || minDistance <= info[disParam])) {
	                    info[layerInfo.labelType] = closest.properties.name;
	                    info[disParam] = minDistance;
	                }
	            }
	        }
	    };
	    /**
	     * Retrieve road information and extracts the closest road (within a threshold), as well as any state/country data that might be on it.
	     * @param info The MapViewInfo object in which the results are added.
	     * @param cam The map camera information.
	     * @param searchArea An optional search area to limit the scope of where roads are extracted from.
	     */
	    MapViewDescriptor.prototype._processRoads = function (info, cam, lang, searchArea) {
	        // Try and get road data. This provides additional country/state info, and also road names.
	        var roads = this._map._getMap().queryRenderedFeatures(searchArea, {
	            filter: ["==", ["geometry-type"], "LineString"]
	        });
	        if (roads) {
	            var closestRoad = void 0;
	            var closestRoad2 = void 0;
	            var cPoint = void 0;
	            var cPoint2 = void 0;
	            // Get the closest road.
	            for (var i = 0, len = roads.length; i < len; i++) {
	                if (this._roadLayers.has(roads[i].layer["source-layer"])) {
	                    if (roads[i].properties.name && roads[i].properties.name !== "") {
	                        var cp = getClosestPointOnGeometry(cam.center, roads[i]);
	                        if (!cPoint || cp.properties.distance < cPoint.properties.distance) {
	                            if (closestRoad && roads[i].properties.name === closestRoad.properties.name) {
	                                cPoint = cp;
	                            }
	                            else if (!closestRoad || roads[i].properties.name !== closestRoad.properties.name) {
	                                cPoint2 = cPoint;
	                                closestRoad2 = closestRoad;
	                                cPoint = cp;
	                                closestRoad = roads[i];
	                            }
	                            else if (!cPoint2 || cp.properties.distance < cPoint2.properties.distance) {
	                                cPoint2 = cp;
	                                closestRoad2 = roads[i];
	                            }
	                        }
	                    }
	                }
	            }
	            if (closestRoad) {
	                // Capture state and country codes from the closest road to ensure we have the most accurate values.
	                if (!info.country) {
	                    info.country = closestRoad.properties.country_code;
	                    info.countryDis = 0;
	                    MapViewDescriptor._labelCache.cache(info.country, {
	                        source: ["Country name"],
	                        labelType: "country",
	                        radius: 5000,
	                        minZoom: 0
	                    }, cPoint.geometry.coordinates, lang);
	                }
	                if (!info.state) {
	                    info.state = closestRoad.properties.country_subdivision;
	                    info.stateDis = 0;
	                    MapViewDescriptor._labelCache.cache(info.state, {
	                        source: ["State name"],
	                        labelType: "state",
	                        radius: 5000,
	                        minZoom: 4
	                    }, cPoint.geometry.coordinates, lang);
	                }
	                // Only capture road name if zoomed in and close enough to the center of the map.
	                if (cam.zoom >= 15) {
	                    var pixels = this._map.positionsToPixels([cam.center, cPoint.geometry.coordinates]);
	                    var pxDis = Pixel.getDistance(pixels[0], pixels[1]);
	                    if (pxDis < this._roadPixelRadius || cPoint.properties.distance < this._minRoadDistance) {
	                        info.road = closestRoad.properties.name;
	                    }
	                    if (closestRoad2) {
	                        var px = this._map.positionsToPixels([cPoint2.geometry.coordinates]);
	                        pxDis = Pixel.getDistance(pixels[0], px[0]);
	                        if (pxDis < this._minIntersectionPixelDistance || cPoint2.properties.distance < this._minRoadDistance) {
	                            info.secondRoad = closestRoad2.properties.name;
	                            info.secondRoadDis = cPoint2.properties.distance;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * Generates a description of the most recent map actions.
	     * @param cam The map camera information.
	     */
	    MapViewDescriptor.prototype._getActionDesc = function (cam) {
	        if (this._lastCam) {
	            // Build and array of actions that have occurred.
	            // Will be flattened into just a string at the end.
	            var actions = [];
	            // Panning/Center
	            if (this._checkLocThreshold(cam.center, this._lastCam.center)) {
	                // Build the panning message is stages.
	                var msg = ["panned"];
	                var heading = Math.round(getHeading(this._lastCam.center, cam.center));
	                // Assign a cardinal direction for the panning.
	                if (heading === 0 || heading === 360) {
	                    msg.push("north");
	                }
	                else if (heading < 90) {
	                    msg.push("north east");
	                }
	                else if (heading === 90) {
	                    msg.push("east");
	                }
	                else if (heading < 180) {
	                    msg.push("south east");
	                }
	                else if (heading === 180) {
	                    msg.push("south");
	                }
	                else if (heading < 270) {
	                    msg.push("south west");
	                }
	                else if (heading === 270) {
	                    msg.push("west");
	                }
	                else if (heading < 360) {
	                    msg.push("north west");
	                }
	                // If the distance is greater than 1000 use KM instead of meters.
	                var distance = getDistanceTo(this._lastCam.center, cam.center, DistanceUnits.meters);
	                msg.push(distance > 1000 ?
	                    _precision(distance / 1000, 2) + " kilometers" :
	                    _precision(distance, 2) + " meters");
	                // Add the complete message to the actions array.
	                actions.push(msg.join(" "));
	            }
	            // Zoom
	            if (this._checkZoomThreshold(cam.zoom, this._lastCam.zoom)) {
	                // Start with zoom and the direction of change.
	                var msg = ["zoomed"];
	                msg.push(this._lastCam.zoom < cam.zoom ? "in" : "out");
	                // Include the number of levels changed if greater than 1.
	                var diff = Math.abs(this._lastCam.zoom - cam.zoom);
	                if (diff >= 1) {
	                    // Round the zoom level difference to the nearest integer.
	                    diff = Math.ceil(diff);
	                    // Add the number of levels difference.
	                    msg.push(diff > 1 ?
	                        diff + " levels" :
	                        diff + " level");
	                }
	                // If the canonical zoom name is different include the new name.
	                if (this._getCanonicalZoom(this._lastCam.zoom) !== this._getCanonicalZoom(cam.zoom)) {
	                    msg.push("to " + this._getCanonicalZoom(cam.zoom) + " level");
	                }
	                // Add the complete message to the actions array.
	                actions.push(msg.join(" "));
	            }
	            // Pitch
	            if (this._checkPitchThreshold(cam.pitch, this._lastCam.pitch)) {
	                // If the pitch has changed enough add the new pitch value to the actions array.
	                var pitch = this._round(cam.pitch, this._pitchThreshold);
	                actions.push("pitched to " + pitch + " degrees");
	            }
	            // Heading
	            if (this._checkHeadingThreshold(this._lastCam.bearing, cam.bearing)) {
	                actions.push("rotated to " + this._getHeadingDesc(cam));
	            }
	            // Return the flattened list of actions as one string.
	            return actions.join(" and ") || null;
	        }
	        return null;
	    };
	    /** Gets the canonical zoom level name, such as world, country, or city level. */
	    MapViewDescriptor.prototype._getCanonicalZoom = function (zoom) {
	        // Determine the canonical name based on the rounded zoom level.
	        zoom = this._round(zoom);
	        // Determine the canonical name.
	        if (zoom < 2) {
	            return "world";
	        }
	        else if (zoom < 5) {
	            return "country";
	        }
	        else if (zoom < 11) {
	            return "state province";
	        }
	        else if (zoom < 15) {
	            return "city";
	        }
	        return "street"; // Zoom 15+ is street level.
	    };
	    /**
	     * Generates a description from extracted location information.
	     * @param cam The map camera information.
	     * @param info The extracted locaiton information.
	     * @returns A string description for the map view.
	     */
	    MapViewDescriptor.prototype._processLocInfo = function (cam, intersectingType, info, location, restFallback) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var html = [];
	            if (location) {
	                /*
	                 * Show details based on zoom level.
	                 *
	                 * Country: 1+
	                 * Water: 1+
	                 * States: 4+
	                 * City: 6+
	                 * Major POI: 8+
	                 * Neighborhood: 12+
	                 * Poi: 14+
	                 * Road: 15+
	                 */
	                var text = [];
	                if (info) {
	                    if (intersectingType) {
	                        if (intersectingType === "water" && info.water) {
	                            text.push(info.water);
	                        }
	                        else if (intersectingType === "majorPoi" && info.majorPoi) {
	                            text.push(info.majorPoi);
	                        }
	                    }
	                    if (text.length === 0) {
	                        if (info.majorPoi && cam.zoom >= 8) {
	                            text.push(info.majorPoi);
	                        }
	                        else {
	                            if (info.poi && cam.zoom >= 14) {
	                                text.push(info.poi);
	                            }
	                            else if (info.road && cam.zoom >= 15) {
	                                if (info.secondRoad) {
	                                    text.push(info.road + " & " + info.secondRoad);
	                                }
	                                else {
	                                    text.push(info.road);
	                                }
	                            }
	                            if (info.neighbourhood && cam.zoom >= 12) {
	                                text.push(info.neighbourhood);
	                            }
	                            if (info.city && cam.zoom >= 6) {
	                                text.push(info.city);
	                            }
	                        }
	                        if (info.state && cam.zoom >= 4) {
	                            text.push(info.state);
	                        }
	                        if (text.length === 0) {
	                            if (info.water) {
	                                text.push(info.water);
	                            }
	                            else if (info.country) {
	                                text.push(info.country);
	                            }
	                        }
	                        else if (text.length === 1 && info.state && cam.zoom >= 4 && info.country) {
	                            text.push(info.country);
	                        }
	                    }
	                }
	                // TODO: need to support localization for these value.
	                if (text.length > 0) {
	                    html.push("<p>Location: ", text.join(", "), "</p>");
	                }
	                else if (restFallback && intersectingType !== "water") {
	                    // No location text found, so fallback onto REST services, but only if map not over water.
	                    _this._reverseGeocodeDescription(cam).then(function (desc) {
	                        resolve(desc);
	                    }, function () {
	                        reject("<p>Location: unknown</p>");
	                    });
	                    return;
	                }
	            }
	            if (_this._returnDetailedDescriptions) {
	                html.push("<p>Zoom: ", _precision(cam.zoom, 2), "</p>");
	                html.push("<p>Latitude: ", _precision(cam.center[1], 5), "</p>");
	                html.push("<p>Longitude: ", _precision(cam.center[0], 5), "</p>");
	            }
	            resolve(html.join(""));
	        });
	    };
	    /**
	     * Uses the reverse geocoding service to determine the description for the center of the map.
	     * @param cam The map camera information.
	     */
	    MapViewDescriptor.prototype._reverseGeocodeDescription = function (cam) {
	        var _this = this;
	        return new Promise(function (resolve) {
	            var style = _this._map.getStyle();
	            _this._reverseSearch.request({
	                position: cam.center,
	                style: style
	            }).then(function (r) {
	                var info = {};
	                if (r && r.addresses && r.addresses.length > 0) {
	                    if (r.addresses[0].address) {
	                        var a = r.addresses[0].address;
	                        if (a.country) {
	                            info.country = a.country;
	                            MapViewDescriptor._labelCache.cache(info.country, {
	                                source: ["Country name"],
	                                labelType: "country",
	                                radius: 5000,
	                                minZoom: 0
	                            }, cam.center, style.language);
	                        }
	                        if (a.countrySubdivision) {
	                            info.state = a.countrySubdivision;
	                            MapViewDescriptor._labelCache.cache(info.state, {
	                                source: ["State name"],
	                                labelType: "state",
	                                radius: 5000,
	                                minZoom: 4
	                            }, cam.center, style.language);
	                        }
	                        if (a.municipality) {
	                            info.city = a.municipality;
	                            MapViewDescriptor._labelCache.cache(info.state, {
	                                source: ["Small city"],
	                                labelType: "city",
	                                radius: 1000,
	                                minZoom: 10
	                            }, cam.center, style.language);
	                        }
	                        if (a.streetNameAndNumber) {
	                            info.road = a.streetNameAndNumber;
	                        }
	                        else if (a.street) {
	                            info.road = a.street;
	                        }
	                    }
	                }
	                _this._processLocInfo(cam, null, info, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            }, function (error) {
	                _this._processLocInfo(cam, null, null, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            }).catch(function (e) {
	                _this._processLocInfo(cam, null, null, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            });
	        });
	    };
	    /** Rounds the input value to the nearest multiple of the specified increment value. */
	    MapViewDescriptor.prototype._round = function (val, increment) {
	        if (increment === void 0) { increment = 1; }
	        return Math.round(val / increment) * increment;
	    };
	    return MapViewDescriptor;
	}());

	/**
	 * @private
	 */
	var AccessibleMapDelegate = /** @class */ (function () {
	    function AccessibleMapDelegate(map) {
	        var _this = this;
	        this.addToMap = function () {
	            _this.createMapKeyBindingInfo();
	            _this.initializeMapLiveStateInfo();
	            _this.initializeMapStyleInfo();
	            _this.map.getMapContainer().setAttribute("role", "application");
	            _this.map.getMapContainer().setAttribute("aria-label", "Map Application");
	            _this.map.getCanvas().setAttribute("aria-label", "Interactive Map");
	            _this.map.getCanvas().setAttribute("aria-describedby", "atlas-map-state atlas-map-shortcuts");
	            _this.map.getCanvas().setAttribute("alt", "Interactive Map");
	        };
	        this.removeFromMap = function () {
	            if (_this.mapViewDesc != null) {
	                _this.mapViewDesc.dispose();
	            }
	            delete _this.mapViewDesc;
	            if (_this.atlasMapKeyBindings != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapKeyBindings);
	            }
	            delete _this.atlasMapKeyBindings;
	            if (_this.atlasMapLiveStateInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapLiveStateInfo);
	            }
	            delete _this.atlasMapLiveStateInfo;
	            if (_this.atlasMapStyleInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapStyleInfo);
	            }
	            delete _this.atlasMapStyleInfo;
	            _this.map.getMapContainer().removeAttribute("role");
	            _this.map.getMapContainer().removeAttribute("aria-label");
	            _this.map.getCanvas().removeAttribute("aria-label");
	            _this.map.getCanvas().removeAttribute("aria-describedby");
	            _this.map.getCanvas().removeAttribute("alt");
	            _this.map.events.remove("styledata", _this.updateMapStyle);
	        };
	        this.createMapKeyBindingInfo = function () {
	            _this.atlasMapKeyBindings = document.createElement("div");
	            _this.atlasMapKeyBindings.setAttribute("tabindex", "-1");
	            _this.atlasMapKeyBindings.setAttribute("aria-label", "Interactive Map Key Bindings");
	            _this.atlasMapKeyBindings.id = "atlas-map-shortcuts";
	            _this.atlasMapKeyBindings.classList.add("hidden-accessible-element");
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapKeyBindings);
	            _this.atlasMapKeyBindings.innerHTML =
	                "<p>Zoom out: hyphen</p>" +
	                    "<p>Zoom in: plus</p>" +
	                    "<p>Pan right 100 pixels: right arrow</p>" +
	                    "<p>Pan left 100 pixels: left arrow</p>" +
	                    "<p>Pan up 100 pixels: up arrow</p>" +
	                    "<p>Pan down 100 pixels: down arrow</p>" +
	                    "<p>Rotate 15 degrees clockwise: shift + right arrow</p>" +
	                    "<p>Rotate 15 degrees counter clockwise: shift + left arrow</p>" +
	                    "<p>Increase pitch 10 degrees: shift + up arrow</p>" +
	                    "<p>Decrease pitch 10 degrees: shift + down arrow</p>" +
	                    "<p>Toggle verbose map state: control + alt + D</p>" +
	                    "<p>Jump focus to the map</p>";
	        };
	        this.initializeMapLiveStateInfo = function () {
	            _this.mapViewDesc = new MapViewDescriptor(_this.map, _this.updateMapState);
	            _this.atlasMapLiveStateInfo = document.createElement("div");
	            _this.atlasMapLiveStateInfo.setAttribute("tabindex", "-1");
	            _this.atlasMapLiveStateInfo.setAttribute("aria-label", "Interactive Map State");
	            _this.atlasMapLiveStateInfo.setAttribute("aria-live", "polite");
	            _this.atlasMapLiveStateInfo.setAttribute("aria-atomic", "true");
	            _this.atlasMapLiveStateInfo.id = "atlas-map-state";
	            _this.atlasMapLiveStateInfo.classList.add("hidden-accessible-element");
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapLiveStateInfo);
	        };
	        this.initializeMapStyleInfo = function () {
	            _this.atlasMapStyleInfo = document.createElement("div");
	            _this.atlasMapStyleInfo.setAttribute("aria-label", "Interactive Map Style");
	            _this.atlasMapStyleInfo.setAttribute("aria-live", "polite");
	            _this.atlasMapStyleInfo.setAttribute("aria-atomic", "true");
	            _this.atlasMapStyleInfo.classList.add("hidden-accessible-element");
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapStyleInfo);
	            _this.updateMapStyle();
	            _this.map.events.add("styledata", _this.updateMapStyle);
	        };
	        this.updateMapStyle = function () {
	            _this.atlasMapStyleInfo.innerHTML = "<p>Style: " + _this.map.getStyle().style + "</p>";
	        };
	        this.updateMapState = function (desc) {
	            _this.atlasMapLiveStateInfo.innerHTML = desc;
	        };
	        this.map = map;
	    }
	    return AccessibleMapDelegate;
	}());

	/**
	 * @private
	 */
	var FlowServiceDelegate = /** @class */ (function () {
	    function FlowServiceDelegate(map) {
	        var _this = this;
	        this.callCounter = 0;
	        this.listenerEnabled = false;
	        this.flowComponent = undefined;
	        this.flowPath = undefined; // Used to prevent loading the same traffic component when changing styles
	        this.addToMap = function () {
	            // Check that the map is ready first.
	            if (!_this.map._isReady()) {
	                throw new Error("Traffic flow could not be added to the map because " +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before enabling traffic flow.");
	            }
	            // Enable the styledata listener.
	            // The flowPath may need to change if the style changes.
	            if (!_this.listenerEnabled) {
	                _this.map.events.add("styledata", _this.addToMap);
	                _this.listenerEnabled = true;
	            }
	            var styleOptions = _this.map.getStyle();
	            var trafficOptions = _this.map.getTraffic();
	            var newPath = _this.map.styles.getFlowPath(styleOptions, trafficOptions);
	            // Check that the path to the traffic flow layer definition is different.
	            // Otherwise, nothing needs to change.
	            if (newPath && _this.flowPath !== newPath) {
	                _this.callCounter++;
	                var currentCall_1 = _this.callCounter;
	                _this.map.styles.getFlowComponent(styleOptions, trafficOptions).then(function (component) {
	                    // If the currentCall doesn't match the callCounter another call to
	                    // addToMap was made after the one that started this promise.
	                    // In that case we only want to let the latest promise add the flow component to the map.
	                    if (_this.callCounter !== currentCall_1) {
	                        return;
	                    }
	                    // If flowComponent is defined then those components need to be removed from the map.
	                    if (_this.flowComponent) {
	                        _this.map.layers.remove(_this.flowComponent.layer);
	                        _this.map.sources.remove(_this.flowComponent.sources);
	                        // Wait until the component has been successfully removed to delete flowComponent.
	                        // This prevents the previous component from getting left on the map.
	                        delete _this.flowComponent;
	                    }
	                    // The traffic flow will be added just on top of the transit layer.
	                    var layers = _this.map.layers.getLayers();
	                    var transitIndex = layers.findIndex(function (layer) { return layer.getId() === "transit"; });
	                    var layerAfterTransit = transitIndex !== -1 ? layers[transitIndex + 1] : undefined;
	                    // Add the new component to the map.
	                    _this.map.sources.add(component.sources);
	                    _this.map.layers.add(component.layer, layerAfterTransit);
	                    // Wait until the component has successfully been added to the map to update flowComponent and flowPath
	                    // This prevents the delegate from trying to remove components that don't actually exist on the map.
	                    _this.flowComponent = component;
	                    _this.flowPath = newPath;
	                });
	            }
	        };
	        this.removeFromMap = function () {
	            // Increment callCounter so any unresolved promises won't
	            // add the flow component to the map once they do resolve.
	            _this.callCounter++;
	            // Disable the styledata listener
	            if (_this.listenerEnabled) {
	                _this.map.events.remove("styledata", _this.addToMap);
	                _this.listenerEnabled = false;
	            }
	            // Reset flowPath
	            if (_this.flowPath) {
	                delete _this.flowPath;
	            }
	            // If flowComponent is defined then it needs to be removed from the map.
	            if (_this.flowComponent) {
	                _this.map.layers.remove(_this.flowComponent.layer);
	                _this.map.sources.remove(_this.flowComponent.sources);
	                // Wait until the component has been successfully removed to delete flowComponent.
	                // This prevents the previous component from getting left on the map.
	                delete _this.flowComponent;
	            }
	        };
	        this.map = map;
	    }
	    return FlowServiceDelegate;
	}());

	/**
	 * @private
	 */
	var IncidentOptions = /** @class */ (function (_super) {
	    __extends(IncidentOptions, _super);
	    function IncidentOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.version = "1.0";
	        _this.bbox = undefined;
	        _this.zoom = undefined;
	        _this.params = {};
	        return _this;
	    }
	    return IncidentOptions;
	}(Options));

	/**
	 * @private
	 */
	var IncidentService = /** @class */ (function () {
	    function IncidentService(map) {
	        this.map = map;
	    }
	    IncidentService.prototype.request = function (options) {
	        var incidentOptions = new IncidentOptions().merge(options);
	        var domain = this.map.getServiceOptions().domain;
	        var trafficModelId = -1;
	        // Limit the lats of the bbox to [-90, 90] and the lngs to [-180, 180]
	        var bboxString;
	        if (BoundingBox.getWest(incidentOptions.bbox) < -180 &&
	            BoundingBox.getEast(incidentOptions.bbox) > 180) {
	            // If both the west and east coordinates are out of the [-180, 180] range just clip them.
	            bboxString = BoundingBox.getSouth(incidentOptions.bbox) + ",-180," +
	                (BoundingBox.getNorth(incidentOptions.bbox) + ",180");
	        }
	        else {
	            // If only one lng is out of range normalize it instead of clipping.
	            bboxString = BoundingBox.getSouth(incidentOptions.bbox) + "," +
	                (normalizeLongitude(BoundingBox.getWest(incidentOptions.bbox)) + ",") +
	                (BoundingBox.getNorth(incidentOptions.bbox) + ",") +
	                ("" + normalizeLongitude(BoundingBox.getEast(incidentOptions.bbox)));
	        }
	        var urlOptions = {
	            domain: domain,
	            path: "traffic/incident/detail/json",
	            queryParams: __assign({ "api-version": incidentOptions.version, "projection": "EPSG4326", style: "s3", boundingbox: bboxString, boundingzoom: incidentOptions.zoom, trafficmodelid: trafficModelId }, incidentOptions.params)
	        };
	        return new Url(this.map.authentication.signRequest(urlOptions)).get();
	    };
	    return IncidentService;
	}());

	/**
	 * @private
	 */
	var Incident = /** @class */ (function (_super) {
	    __extends(Incident, _super);
	    function Incident(data, localizedStrings) {
	        var _this = this;
	        var point = new Point(new Position(data["op"]["x"], data["op"]["y"]));
	        var incidentPinProperties = {
	            icon: Incident.getSeverityColorName(data.ty) + "-" + Incident.getIncidentTypeIconName(data.ic),
	            incidentType: Incident.getIncidentTypeName(data.ic, localizedStrings),
	            description: data.d,
	            length: data.l,
	            delay: data.dl,
	            from: data.f,
	            color: Incident.getSeverityColorHexCode(data.ty),
	            to: data.t,
	            id: data.id
	        };
	        _this = _super.call(this, point, incidentPinProperties) || this;
	        return _this;
	    }
	    Incident.getIncidentTypeName = function (incidentCategory, localizedStrings) {
	        switch (incidentCategory) {
	            case 0:
	                return localizedStrings.Unknown;
	            case 1:
	                return localizedStrings.Accident;
	            case 2:
	                return localizedStrings.Fog;
	            case 3:
	                return localizedStrings.Danger;
	            case 4:
	                return localizedStrings.Rain;
	            case 5:
	                return localizedStrings.Ice;
	            case 6:
	                return localizedStrings.Jam;
	            case 7:
	                return localizedStrings.LaneClosed;
	            case 8:
	                return localizedStrings.RoadClosed;
	            case 9:
	                return localizedStrings.RoadWorks;
	            case 10:
	                return localizedStrings.Wind;
	            case 11:
	                return localizedStrings.Flood;
	            case 12:
	                return localizedStrings.Detour;
	            default:
	                return localizedStrings.Unknown;
	        }
	    };
	    Incident.getIncidentTypeIconName = function (incidentCategory) {
	        switch (incidentCategory) {
	            case 0:
	                return "unknown";
	            case 1:
	                return "accident";
	            case 2:
	                return "fog";
	            case 3:
	                return "danger";
	            case 4:
	                return "rain";
	            case 5:
	                return "ice";
	            case 6:
	                return "jam";
	            case 7:
	                return "lane-closed";
	            case 8:
	                return "road-closed";
	            case 9:
	                return "road-work";
	            case 10:
	                return "wind";
	            case 11:
	                return "flood";
	            case 12:
	                return "detour";
	            default:
	                return "unknown";
	        }
	    };
	    Incident.getSeverityColorName = function (severity) {
	        switch (severity) {
	            case 0:
	                return "grey";
	            case 1:
	                return "yellow";
	            case 2:
	                return "orange";
	            case 3:
	                return "red";
	            case 4:
	                return "grey";
	            default:
	                return "grey";
	        }
	    };
	    Incident.getSeverityColorHexCode = function (severity) {
	        switch (severity) {
	            case 0:
	                return "#B5B6B7";
	            case 1:
	                return "#F4C951";
	            case 2:
	                return "#F4873F";
	            case 3:
	                return "#F04F4E";
	            case 4:
	                return "#B5B6B7";
	            default:
	                return "#B5B6B7";
	        }
	    };
	    return Incident;
	}(Feature));

	/**
	 * @private
	 */
	var IncidentPopupIconName;
	(function (IncidentPopupIconName) {
	    IncidentPopupIconName["DELAY"] = "delay";
	    IncidentPopupIconName["LENGTH"] = "length";
	    IncidentPopupIconName["FROM"] = "from";
	    IncidentPopupIconName["TO"] = "to";
	})(IncidentPopupIconName || (IncidentPopupIconName = {}));
	/**
	 * @private
	 */
	var IncidentPopupFactory = /** @class */ (function () {
	    function IncidentPopupFactory() {
	    }
	    IncidentPopupFactory.build = function (incident, languageCode) {
	        if (languageCode === void 0) { languageCode = "en-US"; }
	        var titleEl = document.createElement("div");
	        titleEl.classList.add("incident-popup-title");
	        titleEl.classList.add("font-segoeui-b");
	        titleEl.setAttribute("tabindex", "0");
	        titleEl.innerText = incident.properties.incidentType;
	        titleEl.setAttribute("aria-label", "Incident Type " + incident.properties.incidentType);
	        var subtitleEl = document.createElement("div");
	        subtitleEl.classList.add("incident-popup-subtitle");
	        subtitleEl.classList.add("font-segoeui-b");
	        subtitleEl.setAttribute("aria-label", "Incident Description " + incident.properties.description);
	        subtitleEl.setAttribute("tabindex", "0");
	        subtitleEl.innerText = incident.properties.description;
	        var headerEl = document.createElement("div");
	        headerEl.classList.add("incident-popup-header");
	        headerEl.style.backgroundColor = incident.properties.color;
	        headerEl.appendChild(titleEl);
	        headerEl.appendChild(subtitleEl);
	        var bodyEl = document.createElement("div");
	        bodyEl.classList.add("incident-popup-body");
	        if (incident.properties.delay) {
	            var delay = Math.floor(incident.properties.delay / 60) + " min";
	            var delayInfoEl = this.createInfoSection(delay, IncidentPopupIconName.DELAY);
	            bodyEl.appendChild(delayInfoEl);
	        }
	        if (incident.properties.length) {
	            var i18nNumberFormat = new Intl.NumberFormat([languageCode, "en-US"], {
	                maximumFractionDigits: 2
	            });
	            // If the language code is "en-US" it will always match this case
	            // because Localizer controls the final language value.
	            var i18nLength = void 0;
	            if (languageCode === "en-US") {
	                var lengthInMiles = convertDistance(incident.properties.length, "meters", "miles");
	                i18nLength = i18nNumberFormat.format(lengthInMiles) + " miles";
	            }
	            else {
	                var lengthInKm = convertDistance(incident.properties.length, "meters", "kilometers");
	                i18nLength = i18nNumberFormat.format(lengthInKm) + " km";
	            }
	            var lengthInfoEl = this.createInfoSection(i18nLength, IncidentPopupIconName.LENGTH);
	            bodyEl.appendChild(lengthInfoEl);
	        }
	        if (incident.properties.from) {
	            var fromInfoEl = this.createInfoSection(incident.properties.from, IncidentPopupIconName.FROM);
	            bodyEl.appendChild(fromInfoEl);
	        }
	        if (incident.properties.to) {
	            var toInfoEl = this.createInfoSection(incident.properties.to, IncidentPopupIconName.TO);
	            bodyEl.appendChild(toInfoEl);
	        }
	        var incidentPopupContentEl = document.createElement("div");
	        incidentPopupContentEl.classList.add("incident-popup-content");
	        incidentPopupContentEl.appendChild(headerEl);
	        incidentPopupContentEl.appendChild(bodyEl);
	        var incidentPopup = new Popup({
	            content: incidentPopupContentEl,
	            position: incident.geometry.coordinates
	        });
	        return incidentPopup;
	    };
	    IncidentPopupFactory.createInfoSection = function (message, iconName) {
	        var infoSectionEl = document.createElement("div");
	        infoSectionEl.classList.add("incident-popup-info");
	        var iconEl = document.createElement("div");
	        iconEl.classList.add("icon");
	        iconEl.classList.add(iconName);
	        var messageEl = document.createElement("span");
	        messageEl.classList.add("message");
	        messageEl.classList.add("font-segoeui");
	        messageEl.setAttribute("aria-label", "Incident " + iconName + " " + message);
	        messageEl.setAttribute("tabindex", "0");
	        messageEl.innerText = message;
	        infoSectionEl.appendChild(iconEl);
	        infoSectionEl.appendChild(messageEl);
	        return infoSectionEl;
	    };
	    return IncidentPopupFactory;
	}());

	/**
	 * @private
	 */
	var IncidentServiceDelegate = /** @class */ (function () {
	    function IncidentServiceDelegate(map) {
	        var _this = this;
	        this.incidentLayerName = "incidents";
	        this.popups = new Dictionary();
	        this.addToMap = function () {
	            _this.map.addPins([], {
	                name: _this.incidentLayerName,
	                cluster: false
	            });
	            _this.map.addEventListener("mouseenter", _this.incidentLayerName, _this.cursorToPointer);
	            _this.map.addEventListener("mouseleave", _this.incidentLayerName, _this.cursorToDefault);
	            _this.map.addEventListener("click", _this.incidentLayerName, _this.openIncidentPopup);
	            _this.map.events.add("moveend", _this.updateIncidents);
	            _this.map.events.add("styledata", _this.updateLanguage);
	            _this.updateIncidents();
	        };
	        this.removeFromMap = function () {
	            _this.map.removeLayers([_this.incidentLayerName]);
	            _this.map.removeEventListener("click", _this.incidentLayerName, _this.openIncidentPopup);
	            _this.map.removeEventListener("mouseenter", _this.incidentLayerName, _this.cursorToPointer);
	            _this.map.removeEventListener("mouseleave", _this.incidentLayerName, _this.cursorToDefault);
	            _this.map.events.remove("moveend", _this.updateIncidents);
	            _this.map.events.remove("styledata", _this.updateLanguage);
	            _this.cleanUpPopups();
	        };
	        this.updateIncidents = function () {
	            var integerZoom = Math.ceil(_this.map.getCamera().zoom);
	            var boundingBox = _this.map.getCamera().bounds;
	            _this.incidentLanguage = _this.map.getStyle().language;
	            var localizedStringsRequest = _this.map._getLocalizedStrings();
	            var incidentRequest = _this.incidentService.request({
	                bbox: boundingBox,
	                zoom: integerZoom,
	                params: {
	                    expandCluster: true,
	                    originalPosition: true,
	                    language: _this.incidentLanguage
	                }
	            });
	            // Concurrently wait for the localized strings and incident response to be available.
	            Promise.all([incidentRequest, localizedStringsRequest]).then(function (_a) {
	                var incidentResponse = _a[0], localizedStrings = _a[1];
	                if (!_this.map.getTraffic().incidents) {
	                    return;
	                }
	                var incidents = [];
	                _this.cleanUpPopups();
	                for (var _i = 0, _b = incidentResponse["tm"]["poi"] || []; _i < _b.length; _i++) {
	                    var poi = _b[_i];
	                    var _loop_1 = function (cpoi) {
	                        // It is possible that the results of the incident request are
	                        // slightly outside of the map's bounding box, so we double check.
	                        if (BoundingBox.containsPosition(boundingBox, [cpoi["op"]["x"], cpoi["op"]["y"]])) {
	                            var incident_1 = new Incident(cpoi, localizedStrings);
	                            incidents.push(incident_1);
	                            var incidentPopup = IncidentPopupFactory.build(incident_1, _this.incidentLanguage);
	                            _this.popups.set(incident_1.properties.id, incidentPopup);
	                            // Track the opened popup and close the others.
	                            _this.map.events.add("open", incidentPopup, function () {
	                                _this.openPopupId = incident_1.properties.id;
	                                _this.popups.forEach(function (popup, id) {
	                                    if (_this.openPopupId !== id) {
	                                        popup.close();
	                                    }
	                                });
	                            });
	                            // If a popup is closed make sure we aren't tracking it as the most recently opened popup.
	                            _this.map.events.add("close", incidentPopup, function () {
	                                if (_this.openPopupId === incident_1.properties.id) {
	                                    delete _this.openPopupId;
	                                }
	                            });
	                            if (_this.openPopupId === incident_1.properties.id) {
	                                _this.popups.get(incident_1.properties.id).open(_this.map);
	                            }
	                            else {
	                                _this.popups.get(incident_1.properties.id).attach(_this.map);
	                            }
	                        }
	                    };
	                    for (var _c = 0, _d = poi.cpoi || [poi]; _c < _d.length; _c++) {
	                        var cpoi = _d[_c];
	                        _loop_1(cpoi);
	                    }
	                }
	                _this.map.addPins(incidents, {
	                    overwrite: true,
	                    name: _this.incidentLayerName
	                });
	            });
	        };
	        this.cursorToPointer = function (data) {
	            _this.map.getCanvas().style.cursor = "pointer";
	        };
	        this.cursorToDefault = function (data) {
	            _this.map.getCanvas().style.cursor = "";
	        };
	        this.openIncidentPopup = function (data) {
	            var incident = data.features[0];
	            var popupId = incident.properties.id;
	            if (_this.popups.has(popupId)) {
	                _this.popups.get(popupId).open(_this.map);
	            }
	        };
	        this.cleanUpPopups = function () {
	            _this.popups.forEach(function (popup) {
	                popup.remove();
	            });
	            _this.popups.clear();
	        };
	        this.updateLanguage = function () {
	            if (_this.map.getStyle().language !== _this.incidentLanguage) {
	                _this.updateIncidents();
	            }
	        };
	        this.map = map;
	        this.incidentService = new IncidentService(this.map);
	    }
	    return IncidentServiceDelegate;
	}());

	/**
	 * The options for enabling/disabling user interaction with the map.
	 */
	var UserInteractionOptions = /** @class */ (function (_super) {
	    __extends(UserInteractionOptions, _super);
	    function UserInteractionOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Whether the map is interactive or static. If false, all user interaction is disabled.  If true, only selected
	         * user interactions will enabled.
	         * default `true`
	         * @default true
	         */
	        _this.interactive = true;
	        /**
	         * Whether the map should zoom on scroll input.
	         * default `true`
	         * @default true
	         */
	        _this.scrollZoomInteraction = true;
	        /**
	         * Whether the Shift + left click and drag will draw a zoom box.
	         * default `true`
	         * @default true
	         */
	        _this.boxZoomInteraction = true;
	        /**
	         * Whether right click and drag will rotate and pitch the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragRotateInteraction = true;
	        /**
	         * Whether left click and drag will pan the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragPanInteraction = true;
	        /**
	         * Whether the keyboard interactions are enabled.
	         * <style> .k-key { border: 1px solid grey; border-radius: 6px; background-color: #ccc; line-height: 14px;
	         * font-size: 14px; padding: 2px; } </style>
	         * <p><span class="k-key">Escape</span>: Jump focus to the map.</p>
	         * <p><span class="k-key">+/=</span>: Increase zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">+/=</span>: Increase the zoom level by 2.</p>
	         * <p><span class="k-key">-</span>: Decrease zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">-</span>: Decrease zoom level by 2.</p>
	         * <p><span class="k-key">⇢</span>: Pan right 100 pixels.</p>
	         * <p><span class="k-key">⇠</span>: Pan left 100 pixels.</p>
	         * <p><span class="k-key">⇡</span>: Pan up 100 pixels.</p>
	         * <p><span class="k-key">⇣</span>: Pan down 100 pixels.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇢</span>: Rotate 15 degrees clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇠</span>: Rotate 15 degrees counter-clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇡</span>: Increase pitch by 10 degrees.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇣</span>: Decrease pitch by 10 degrees.</p>
	         * default `true`
	         * @default true
	         */
	        _this.keyboardInteraction = true;
	        /**
	         * Whether double left click will zoom the map inwards.
	         * default `true`
	         * @default true
	         */
	        _this.dblClickZoomInteraction = true;
	        /**
	         * Whether touch interactions are enabled for touch devices.
	         * default `true`
	         * @default true
	         */
	        _this.touchInteraction = true;
	        /**
	         * Sets the zoom rate of the mouse wheel
	         * default `1/450`
	         * @default 1/450
	         */
	        _this.wheelZoomRate = 1 / 450;
	        return _this;
	    }
	    return UserInteractionOptions;
	}(Options));

	/** A handler that adds a shortcut for jumping focus to the top map div. */
	var FocusShortcutHandler = /** @class */ (function () {
	    function FocusShortcutHandler(map) {
	        var _this = this;
	        /** A listener for the shortcut */
	        this._onKeyDown = function (event) {
	            if (event.keyCode === 27 /* Escape */) {
	                _this.map.getCanvas().focus();
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.enable = function () {
	        this.map.getMapContainer().addEventListener("keydown", this._onKeyDown);
	    };
	    /** Disables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.disable = function () {
	        this.map.getMapContainer().removeEventListener("keydown", this._onKeyDown);
	    };
	    return FocusShortcutHandler;
	}());

	/** A handler that adds support for pitch gestures on mobile devices. */
	var MobilePitchHandler = /** @class */ (function () {
	    function MobilePitchHandler(map) {
	        var _this = this;
	        // Constants for mobile pitch support.
	        this.minDiffX = 70; // min x distance to recognize pitch gesture
	        this.maxDiffY = 100; // max y distance to recognize pitch gesture
	        this.minDiff = 30; // min distance to recognize zoom gesture
	        this.delay = 160; // delay for pitch, in case it's a zoom gesture
	        /** Callback for the touch start event */
	        this._onTouchStart = function (data) {
	            if (data.points.length === 2) {
	                var diffY = data.points[0].y - data.points[1].y;
	                var diffX = data.points[0].x - data.points[1].x;
	                if (Math.abs(diffX) >= _this.minDiffX && Math.abs(diffY) <= _this.maxDiffY) {
	                    data.originalEvent.preventDefault(); // prevent browser refresh on pull down
	                    _this.map._getMap().touchZoomRotate.disable(); // disable native touch controls
	                    _this.map._getMap().dragPan.disable();
	                    _this.dpPoint = data.point;
	                    _this.dpPitch = _this.map._getMap().getPitch();
	                    _this.startTiming = Date.now();
	                    _this.startDistance = Math.hypot(diffX, diffY);
	                    _this.startEventData = data;
	                }
	            }
	        };
	        /** Callback for the touch move event */
	        this._onTouchMove = function (data) {
	            if (_this.dpPoint !== undefined && _this.dpPitch !== undefined) {
	                data.preventDefault();
	                data.originalEvent.preventDefault();
	                var diffY = data.points[0].y - data.points[1].y;
	                var diffX = data.points[0].x - data.points[1].x;
	                var distance = Math.hypot(diffX, diffY);
	                if (Math.abs(distance - _this.startDistance) >= _this.minDiff) {
	                    if (_this.dpPoint) {
	                        _this.map._getMap().touchZoomRotate.enable();
	                        _this.map._getMap().dragPan.enable();
	                        _this.map._getMap().touchZoomRotate.onStart(Date.now() - _this.startTiming >= _this.delay
	                            ? data.originalEvent
	                            : _this.startEventData.originalEvent);
	                    }
	                    _this.dpPoint = undefined;
	                    return;
	                }
	                if (Date.now() - _this.startTiming >= _this.delay) {
	                    var diff = (_this.dpPoint.y - data.point.y) * 0.5;
	                    _this.map._getMap().setPitch(_this.dpPitch + diff);
	                }
	            }
	        };
	        /** Callback for the touch end event */
	        this._onTouchEnd = function () {
	            if (_this.dpPoint) {
	                _this.map._getMap().touchZoomRotate.enable();
	                _this.map._getMap().dragPan.enable();
	            }
	            _this.dpPoint = undefined;
	        };
	        /** Callback for the touch cancel event */
	        this._onTouchCancel = function () {
	            if (_this.dpPoint) {
	                _this.map._getMap().touchZoomRotate.enable();
	                _this.map._getMap().dragPan.enable();
	            }
	            _this.dpPoint = undefined;
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    MobilePitchHandler.prototype.enable = function () {
	        this.map._getMap().on("touchstart", this._onTouchStart);
	        this.map._getMap().on("touchmove", this._onTouchMove);
	        this.map._getMap().on("touchend", this._onTouchEnd);
	        this.map._getMap().on("touchcancel", this._onTouchCancel);
	    };
	    /** Disables the mobile pitch gesture support. */
	    MobilePitchHandler.prototype.disable = function () {
	        this.map._getMap().off("touchstart", this._onTouchStart);
	        this.map._getMap().off("touchmove", this._onTouchMove);
	        this.map._getMap().off("touchend", this._onTouchEnd);
	        this.map._getMap().off("touchcancel", this._onTouchCancel);
	    };
	    return MobilePitchHandler;
	}());

	/** A handler that adds support for pinch and zoom gestures on devices without touch events. */
	var PinchZoomHandler = /** @class */ (function () {
	    function PinchZoomHandler(map) {
	        var _this = this;
	        this._onGestureStart = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.initZoom = _this.map.getCamera().zoom;
	            }
	        };
	        this._onGestureChange = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.map.setCamera({ zoom: _this.initZoom + e.scale - 1 });
	            }
	        };
	        this._onTouchStart = function (e) {
	            _this.hasTouch = true;
	        };
	        this._onTouchEnd = function (e) {
	            if (e.touches.length === 0) {
	                _this.hasTouch = false;
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.enable = function () {
	        this.map.getCanvasContainer().addEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().addEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().addEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().addEventListener("touchend", this._onTouchEnd);
	    };
	    /** Disables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.disable = function () {
	        this.map.getCanvasContainer().removeEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().removeEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().removeEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().removeEventListener("touchend", this._onTouchEnd);
	    };
	    return PinchZoomHandler;
	}());

	/**
	 * @private
	 */
	var UserInteractionDelegate = /** @class */ (function () {
	    function UserInteractionDelegate(map, options) {
	        this.added = false;
	        this.map = map;
	        this.mobilePitch = new MobilePitchHandler(map);
	        this.focusShortcut = new FocusShortcutHandler(map);
	        this.pinchZoom = new PinchZoomHandler(map);
	        this.options = new UserInteractionOptions().merge(options);
	    }
	    UserInteractionDelegate.prototype.addToMap = function () {
	        if (!this.added) {
	            this.added = true;
	            this._setInteractions(this.options);
	        }
	    };
	    UserInteractionDelegate.prototype.removeFromMap = function () {
	        if (this.added) {
	            this.added = false;
	            this._setInteractions({ interactive: false });
	        }
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    UserInteractionDelegate.prototype.setOptions = function (options) {
	        this.options = new UserInteractionOptions().merge(this.options, options);
	        // Only need to actually update things if the delegate has already been added to the map
	        if (this.added) {
	            this._setInteractions(this.options);
	        }
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    UserInteractionDelegate.prototype.getOptions = function () {
	        return Object.assign({}, this.options);
	    };
	    /** Sets the interaction config based on the specified options. */
	    UserInteractionDelegate.prototype._setInteractions = function (options) {
	        if (!options.interactive) {
	            // Disable everything
	            this.map._getMap().boxZoom.disable();
	            this.map._getMap().doubleClickZoom.disable();
	            this.map._getMap().dragPan.disable();
	            this.map._getMap().dragRotate.disable();
	            this.map._getMap().keyboard.disable();
	            this.focusShortcut.disable();
	            this.map._getMap().scrollZoom.disable();
	            this.map._getMap().touchZoomRotate.disable();
	            this.mobilePitch.disable();
	            this.pinchZoom.disable();
	        }
	        else {
	            // Box Zoom
	            if (options.boxZoomInteraction) {
	                this.map._getMap().boxZoom.enable();
	            }
	            else {
	                this.map._getMap().boxZoom.disable();
	            }
	            // Double Click Zoom
	            if (options.dblClickZoomInteraction) {
	                this.map._getMap().doubleClickZoom.enable();
	            }
	            else {
	                this.map._getMap().doubleClickZoom.disable();
	            }
	            // Drag Pan
	            if (options.dragPanInteraction) {
	                this.map._getMap().dragPan.enable();
	            }
	            else {
	                this.map._getMap().dragPan.disable();
	            }
	            // Drag Rotate
	            if (options.dragRotateInteraction) {
	                this.map._getMap().dragRotate.enable();
	            }
	            else {
	                this.map._getMap().dragRotate.disable();
	            }
	            // Keyboard
	            if (options.keyboardInteraction) {
	                this.map._getMap().keyboard.enable();
	                this.focusShortcut.enable();
	            }
	            else {
	                this.map._getMap().keyboard.disable();
	                this.focusShortcut.disable();
	            }
	            // Scroll Zoom
	            if (options.scrollZoomInteraction) {
	                this.map._getMap().scrollZoom.enable();
	                this.map._getMap().scrollZoom.setWheelZoomRate(options.wheelZoomRate);
	            }
	            else {
	                this.map._getMap().scrollZoom.disable();
	            }
	            // Touch
	            if (options.touchInteraction) {
	                this.map._getMap().touchZoomRotate.enable();
	                this.mobilePitch.enable();
	                this.pinchZoom.enable();
	            }
	            else {
	                this.map._getMap().touchZoomRotate.disable();
	                this.mobilePitch.disable();
	                this.pinchZoom.enable();
	            }
	        }
	    };
	    return UserInteractionDelegate;
	}());

	var adal = createCommonjsModule(function (module) {
	//----------------------------------------------------------------------
	// AdalJS v1.0.17
	// @preserve Copyright (c) Microsoft Open Technologies, Inc.
	// All Rights Reserved
	// Apache License 2.0
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//id
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//----------------------------------------------------------------------

	var AuthenticationContext = (function () {

	    /**
	     * Configuration options for Authentication Context.
	     * @class config
	     *  @property {string} tenant - Your target tenant.
	     *  @property {string} clientId - Client ID assigned to your app by Azure Active Directory.
	     *  @property {string} redirectUri - Endpoint at which you expect to receive tokens.Defaults to `window.location.href`.
	     *  @property {string} instance - Azure Active Directory Instance.Defaults to `https://login.microsoftonline.com/`.
	     *  @property {Array} endpoints - Collection of {Endpoint-ResourceId} used for automatically attaching tokens in webApi calls.
	     *  @property {Boolean} popUp - Set this to true to enable login in a popup winodow instead of a full redirect.Defaults to `false`.
	     *  @property {string} localLoginUrl - Set this to redirect the user to a custom login page.
	     *  @property {function} displayCall - User defined function of handling the navigation to Azure AD authorization endpoint in case of login. Defaults to 'null'.
	     *  @property {string} postLogoutRedirectUri - Redirects the user to postLogoutRedirectUri after logout. Defaults is 'redirectUri'.
	     *  @property {string} cacheLocation - Sets browser storage to either 'localStorage' or sessionStorage'. Defaults to 'sessionStorage'.
	     *  @property {Array.<string>} anonymousEndpoints Array of keywords or URI's. Adal will not attach a token to outgoing requests that have these keywords or uri. Defaults to 'null'.
	     *  @property {number} expireOffsetSeconds If the cached token is about to be expired in the expireOffsetSeconds (in seconds), Adal will renew the token instead of using the cached token. Defaults to 300 seconds.
	     *  @property {string} correlationId Unique identifier used to map the request with the response. Defaults to RFC4122 version 4 guid (128 bits).
	     *  @property {number} loadFrameTimeout The number of milliseconds of inactivity before a token renewal response from AAD should be considered timed out.
	     */

	    /**
	     * Creates a new AuthenticationContext object.
	     * @constructor
	     * @param {config}  config               Configuration options for AuthenticationContext
	     */

	    AuthenticationContext = function (config) {
	        /**
	         * Enum for request type
	         * @enum {string}
	         */
	        this.REQUEST_TYPE = {
	            LOGIN: 'LOGIN',
	            RENEW_TOKEN: 'RENEW_TOKEN',
	            UNKNOWN: 'UNKNOWN'
	        };

	        this.RESPONSE_TYPE = {
	            ID_TOKEN_TOKEN: 'id_token token',
	            TOKEN: 'token'
	        };

	        /**
	         * Enum for storage constants
	         * @enum {string}
	         */
	        this.CONSTANTS = {
	            ACCESS_TOKEN: 'access_token',
	            EXPIRES_IN: 'expires_in',
	            ID_TOKEN: 'id_token',
	            ERROR_DESCRIPTION: 'error_description',
	            SESSION_STATE: 'session_state',
	            ERROR: 'error',
	            STORAGE: {
	                TOKEN_KEYS: 'adal.token.keys',
	                ACCESS_TOKEN_KEY: 'adal.access.token.key',
	                EXPIRATION_KEY: 'adal.expiration.key',
	                STATE_LOGIN: 'adal.state.login',
	                STATE_RENEW: 'adal.state.renew',
	                NONCE_IDTOKEN: 'adal.nonce.idtoken',
	                SESSION_STATE: 'adal.session.state',
	                USERNAME: 'adal.username',
	                IDTOKEN: 'adal.idtoken',
	                ERROR: 'adal.error',
	                ERROR_DESCRIPTION: 'adal.error.description',
	                LOGIN_REQUEST: 'adal.login.request',
	                LOGIN_ERROR: 'adal.login.error',
	                RENEW_STATUS: 'adal.token.renew.status',
	                ANGULAR_LOGIN_REQUEST: 'adal.angular.login.request'
	            },
	            RESOURCE_DELIMETER: '|',
	            CACHE_DELIMETER: '||',
	            LOADFRAME_TIMEOUT: 6000,
	            TOKEN_RENEW_STATUS_CANCELED: 'Canceled',
	            TOKEN_RENEW_STATUS_COMPLETED: 'Completed',
	            TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',
	            LOGGING_LEVEL: {
	                ERROR: 0,
	                WARN: 1,
	                INFO: 2,
	                VERBOSE: 3
	            },
	            LEVEL_STRING_MAP: {
	                0: 'ERROR:',
	                1: 'WARNING:',
	                2: 'INFO:',
	                3: 'VERBOSE:'
	            },
	            POPUP_WIDTH: 483,
	            POPUP_HEIGHT: 600
	        };

	        if (AuthenticationContext.prototype._singletonInstance) {
	            return AuthenticationContext.prototype._singletonInstance;
	        }
	        AuthenticationContext.prototype._singletonInstance = this;

	        // public
	        this.instance = 'https://login.microsoftonline.com/';
	        this.config = {};
	        this.callback = null;
	        this.popUp = false;
	        this.isAngular = false;

	        // private
	        this._user = null;
	        this._activeRenewals = {};
	        this._loginInProgress = false;
	        this._acquireTokenInProgress = false;
	        this._renewStates = [];
	        this._callBackMappedToRenewStates = {};
	        this._callBacksMappedToRenewStates = {};
	        this._openedWindows = [];
	        this._requestType = this.REQUEST_TYPE.LOGIN;
	        window._adalInstance = this;

	        // validate before constructor assignments
	        if (config.displayCall && typeof config.displayCall !== 'function') {
	            throw new Error('displayCall is not a function');
	        }

	        if (!config.clientId) {
	            throw new Error('clientId is required');
	        }

	        this.config = this._cloneConfig(config);

	        if (this.config.navigateToLoginRequestUrl === undefined)
	            this.config.navigateToLoginRequestUrl = true;

	        if (this.config.popUp)
	            this.popUp = true;

	        if (this.config.callback && typeof this.config.callback === 'function')
	            this.callback = this.config.callback;

	        if (this.config.instance) {
	            this.instance = this.config.instance;
	        }

	        // App can request idtoken for itself using clientid as resource
	        if (!this.config.loginResource) {
	            this.config.loginResource = this.config.clientId;
	        }

	        // redirect and logout_redirect are set to current location by default
	        if (!this.config.redirectUri) {
	            // strip off query parameters or hashes from the redirect uri as AAD does not allow those.
	            this.config.redirectUri = window.location.href.split("?")[0].split("#")[0];
	        }

	        if (!this.config.postLogoutRedirectUri) {
	            // strip off query parameters or hashes from the post logout redirect uri as AAD does not allow those.
	            this.config.postLogoutRedirectUri = window.location.href.split("?")[0].split("#")[0];
	        }

	        if (!this.config.anonymousEndpoints) {
	            this.config.anonymousEndpoints = [];
	        }

	        if (this.config.isAngular) {
	            this.isAngular = this.config.isAngular;
	        }

	        if (this.config.loadFrameTimeout) {
	            this.CONSTANTS.LOADFRAME_TIMEOUT = this.config.loadFrameTimeout;
	        }
	    };

	    if (typeof window !== 'undefined') {
	        window.Logging = {
	            piiLoggingEnabled: false,
	            level: 0,
	            log: function (message) { }
	        };
	    }

	    /**
	     * Initiates the login process by redirecting the user to Azure AD authorization endpoint.
	     */
	    AuthenticationContext.prototype.login = function () {
	        if (this._loginInProgress) {
	            this.info("Login in progress");
	            return;
	        }

	        this._loginInProgress = true;

	        // Token is not present and user needs to login
	        var expectedState = this._guid();
	        this.config.state = expectedState;
	        this._idTokenNonce = this._guid();
	        var loginStartPage = this._getItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST);

	        if (!loginStartPage || loginStartPage === "") {
	            loginStartPage = window.location.href;
	        }
	        else {
	            this._saveItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST, "");
	        }

	        this.verbose('Expected state: ' + expectedState + ' startPage:' + loginStartPage);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, loginStartPage);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState, true);
	        this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce, true);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');
	        var urlNavigate = this._getNavigateUrl('id_token', null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);

	        if (this.config.displayCall) {
	            // User defined way of handling the navigation
	            this.config.displayCall(urlNavigate);
	        }
	        else if (this.popUp) {
	            this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');// so requestInfo does not match redirect case
	            this._renewStates.push(expectedState);
	            this.registerCallback(expectedState, this.config.clientId, this.callback);
	            this._loginPopup(urlNavigate);
	        }
	        else {
	            this.promptUser(urlNavigate);
	        }
	    };

	    /**
	     * Configures popup window for login.
	     * @ignore
	     */
	    AuthenticationContext.prototype._openPopup = function (urlNavigate, title, popUpWidth, popUpHeight) {
	        try {
	            /**
	            * adding winLeft and winTop to account for dual monitor
	            * using screenLeft and screenTop for IE8 and earlier
	            */
	            var winLeft = window.screenLeft ? window.screenLeft : window.screenX;
	            var winTop = window.screenTop ? window.screenTop : window.screenY;
	            /**
	            * window.innerWidth displays browser window's height and width excluding toolbars
	            * using document.documentElement.clientWidth for IE8 and earlier
	            */
	            var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
	            var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
	            var left = ((width / 2) - (popUpWidth / 2)) + winLeft;
	            var top = ((height / 2) - (popUpHeight / 2)) + winTop;

	            var popupWindow = window.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);

	            if (popupWindow.focus) {
	                popupWindow.focus();
	            }

	            return popupWindow;
	        } catch (e) {
	            this.warn('Error opening popup, ' + e.message);
	            this._loginInProgress = false;
	            this._acquireTokenInProgress = false;
	            return null;
	        }
	    };

	    AuthenticationContext.prototype._handlePopupError = function (loginCallback, resource, error, errorDesc, loginError) {
	        this.warn(errorDesc);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, error);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, errorDesc);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, loginError);

	        if (resource && this._activeRenewals[resource]) {
	            this._activeRenewals[resource] = null;
	        }

	        this._loginInProgress = false;
	        this._acquireTokenInProgress = false;

	        if (loginCallback) {
	            loginCallback(errorDesc, null, error);
	        }
	    };

	    /**
	     * After authorization, the user will be sent to your specified redirect_uri with the user's bearer token
	     * attached to the URI fragment as an id_token field. It closes popup window after redirection.
	     * @ignore
	     */
	    AuthenticationContext.prototype._loginPopup = function (urlNavigate, resource, callback) {
	        var popupWindow = this._openPopup(urlNavigate, "login", this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);
	        var loginCallback = callback || this.callback;

	        if (popupWindow == null) {
	            var error = 'Error opening popup';
	            var errorDesc = 'Popup Window is null. This can happen if you are using IE';
	            this._handlePopupError(loginCallback, resource, error, errorDesc, errorDesc);
	            return;
	        }

	        this._openedWindows.push(popupWindow);

	        if (this.config.redirectUri.indexOf('#') != -1) {
	            var registeredRedirectUri = this.config.redirectUri.split("#")[0];
	        }

	        else {
	            var registeredRedirectUri = this.config.redirectUri;
	        }

	        var that = this;

	        var pollTimer = window.setInterval(function () {
	            if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {
	                var error = 'Popup Window closed';
	                var errorDesc = 'Popup Window closed by UI action/ Popup Window handle destroyed due to cross zone navigation in IE/Edge';

	                if (that.isAngular) {
	                    that._broadcast('adal:popUpClosed', errorDesc + that.CONSTANTS.RESOURCE_DELIMETER + error);
	                }

	                that._handlePopupError(loginCallback, resource, error, errorDesc, errorDesc);
	                window.clearInterval(pollTimer);
	                return;
	            }
	            try {
	                var popUpWindowLocation = popupWindow.location;
	                if (encodeURI(popUpWindowLocation.href).indexOf(encodeURI(registeredRedirectUri)) != -1) {
	                    if (that.isAngular) {
	                        that._broadcast('adal:popUpHashChanged', popUpWindowLocation.hash);
	                    }
	                    else {
	                        that.handleWindowCallback(popUpWindowLocation.hash);
	                    }

	                    window.clearInterval(pollTimer);
	                    that._loginInProgress = false;
	                    that._acquireTokenInProgress = false;
	                    that.info("Closing popup window");
	                    that._openedWindows = [];
	                    popupWindow.close();
	                    return;
	                }
	            } catch (e) {
	            }
	        }, 1);
	    };

	    AuthenticationContext.prototype._broadcast = function (eventName, data) {
	        // Custom Event is not supported in IE, below IIFE will polyfill the CustomEvent() constructor functionality in Internet Explorer 9 and higher
	        (function () {

	            if (typeof window.CustomEvent === "function") {
	                return false;
	            }

	            function CustomEvent(event, params) {
	                params = params || { bubbles: false, cancelable: false, detail: undefined };
	                var evt = document.createEvent('CustomEvent');
	                evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
	                return evt;
	            }

	            CustomEvent.prototype = window.Event.prototype;
	            window.CustomEvent = CustomEvent;
	        })();

	        var evt = new CustomEvent(eventName, { detail: data });
	        window.dispatchEvent(evt);
	    };

	    AuthenticationContext.prototype.loginInProgress = function () {
	        return this._loginInProgress;
	    };

	    /**
	     * Checks for the resource in the cache. By default, cache location is Session Storage
	     * @ignore
	     * @returns {Boolean} 'true' if login is in progress, else returns 'false'.
	     */
	    AuthenticationContext.prototype._hasResource = function (key) {
	        var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);
	        return keys && !this._isEmpty(keys) && (keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1);
	    };

	    /**
	     * Gets token for the specified resource from the cache.
	     * @param {string}   resource A URI that identifies the resource for which the token is requested.
	     * @returns {string} token if if it exists and not expired, otherwise null.
	     */
	    AuthenticationContext.prototype.getCachedToken = function (resource) {
	        if (!this._hasResource(resource)) {
	            return null;
	        }

	        var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);
	        var expiry = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);

	        // If expiration is within offset, it will force renew
	        var offset = this.config.expireOffsetSeconds || 300;

	        if (expiry && (expiry > this._now() + offset)) {
	            return token;
	        } else {
	            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');
	            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);
	            return null;
	        }
	    };

	    /**
	    * User information from idtoken.
	    *  @class User
	    *  @property {string} userName - username assigned from upn or email.
	    *  @property {object} profile - properties parsed from idtoken.
	    */

	    /**
	     * If user object exists, returns it. Else creates a new user object by decoding id_token from the cache.
	     * @returns {User} user object
	     */
	    AuthenticationContext.prototype.getCachedUser = function () {
	        if (this._user) {
	            return this._user;
	        }

	        var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);
	        this._user = this._createUser(idtoken);
	        return this._user;
	    };

	    /**
	     * Adds the passed callback to the array of callbacks for the specified resource and puts the array on the window object. 
	     * @param {string}   resource A URI that identifies the resource for which the token is requested.
	     * @param {string}   expectedState A unique identifier (guid).
	     * @param {tokenCallback} callback - The callback provided by the caller. It will be called with token or error.
	     */
	    AuthenticationContext.prototype.registerCallback = function (expectedState, resource, callback) {
	        this._activeRenewals[resource] = expectedState;

	        if (!this._callBacksMappedToRenewStates[expectedState]) {
	            this._callBacksMappedToRenewStates[expectedState] = [];
	        }

	        var self = this;
	        this._callBacksMappedToRenewStates[expectedState].push(callback);

	        if (!this._callBackMappedToRenewStates[expectedState]) {
	            this._callBackMappedToRenewStates[expectedState] = function (errorDesc, token, error, tokenType) {
	                self._activeRenewals[resource] = null;

	                for (var i = 0; i < self._callBacksMappedToRenewStates[expectedState].length; ++i) {
	                    try {
	                        self._callBacksMappedToRenewStates[expectedState][i](errorDesc, token, error, tokenType);
	                    }
	                    catch (error) {
	                        self.warn(error);
	                    }
	                }

	                self._callBacksMappedToRenewStates[expectedState] = null;
	                self._callBackMappedToRenewStates[expectedState] = null;
	            };
	        }
	    };

	    // var errorResponse = {error:'', error_description:''};
	    // var token = 'string token';
	    // callback(errorResponse, token)
	    // with callback
	    /**
	     * Acquires access token with hidden iframe
	     * @ignore
	     */
	    AuthenticationContext.prototype._renewToken = function (resource, callback, responseType) {
	        // use iframe to try to renew token
	        // use given resource to create new authz url
	        this.info('renewToken is called for resource:' + resource);
	        var frameHandle = this._addAdalFrame('adalRenewFrame' + resource);
	        var expectedState = this._guid() + '|' + resource;
	        this.config.state = expectedState;
	        // renew happens in iframe, so it keeps javascript context
	        this._renewStates.push(expectedState);
	        this.verbose('Renew token Expected state: ' + expectedState);
	        // remove the existing prompt=... query parameter and add prompt=none
	        responseType = responseType || 'token';
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl(responseType, resource), 'prompt');

	        if (responseType === this.RESPONSE_TYPE.ID_TOKEN_TOKEN) {
	            this._idTokenNonce = this._guid();
	            this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce, true);
	            urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);
	        }

	        urlNavigate = urlNavigate + '&prompt=none';
	        urlNavigate = this._addHintParameters(urlNavigate);
	        this.registerCallback(expectedState, resource, callback);
	        this.verbosePii('Navigate to:' + urlNavigate);
	        frameHandle.src = 'about:blank';
	        this._loadFrameTimeout(urlNavigate, 'adalRenewFrame' + resource, resource);

	    };

	    /**
	     * Renews idtoken for app's own backend when resource is clientId and calls the callback with token/error
	     * @ignore
	     */
	    AuthenticationContext.prototype._renewIdToken = function (callback, responseType) {
	        // use iframe to try to renew token
	        this.info('renewIdToken is called');
	        var frameHandle = this._addAdalFrame('adalIdTokenFrame');
	        var expectedState = this._guid() + '|' + this.config.clientId;
	        this._idTokenNonce = this._guid();
	        this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce, true);
	        this.config.state = expectedState;
	        // renew happens in iframe, so it keeps javascript context
	        this._renewStates.push(expectedState);
	        this.verbose('Renew Idtoken Expected state: ' + expectedState);
	        // remove the existing prompt=... query parameter and add prompt=none
	        var resource = responseType === null || typeof (responseType) === "undefined" ? null : this.config.clientId;
	        var responseType = responseType || 'id_token';
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl(responseType, resource), 'prompt');
	        urlNavigate = urlNavigate + '&prompt=none';
	        urlNavigate = this._addHintParameters(urlNavigate);
	        urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);
	        this.registerCallback(expectedState, this.config.clientId, callback);
	        this.verbosePii('Navigate to:' + urlNavigate);
	        frameHandle.src = 'about:blank';
	        this._loadFrameTimeout(urlNavigate, 'adalIdTokenFrame', this.config.clientId);
	    };

	    /**
	     * Checks if the authorization endpoint URL contains query string parameters
	     * @ignore
	     */
	    AuthenticationContext.prototype._urlContainsQueryStringParameter = function (name, url) {
	        // regex to detect pattern of a ? or & followed by the name parameter and an equals character
	        var regex = new RegExp("[\\?&]" + name + "=");
	        return regex.test(url);
	    };

	    /**
	     * Removes the query string parameter from the authorization endpoint URL if it exists
	     * @ignore
	     */
	    AuthenticationContext.prototype._urlRemoveQueryStringParameter = function (url, name) {
	        // we remove &name=value, name=value& and name=value
	        // &name=value
	        var regex = new RegExp('(\\&' + name + '=)[^\&]+');
	        url = url.replace(regex, '');
	        // name=value&
	        regex = new RegExp('(' + name + '=)[^\&]+&');
	        url = url.replace(regex, '');
	        // name=value
	        regex = new RegExp('(' + name + '=)[^\&]+');
	        url = url.replace(regex, '');
	        return url;
	    };

	    // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left
	    // registered when network errors occur and subsequent token requests for same resource are registered to the pending request
	    /**
	     * @ignore
	     */
	    AuthenticationContext.prototype._loadFrameTimeout = function (urlNavigation, frameName, resource) {
	        //set iframe session to pending
	        this.verbose('Set loading state to pending for: ' + resource);
	        this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);
	        this._loadFrame(urlNavigation, frameName);
	        var self = this;

	        setTimeout(function () {
	            if (self._getItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource) === self.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {
	                // fail the iframe session if it's in pending state
	                self.verbose('Loading frame has timed out after: ' + (self.CONSTANTS.LOADFRAME_TIMEOUT / 1000) + ' seconds for resource ' + resource);
	                var expectedState = self._activeRenewals[resource];

	                if (expectedState && self._callBackMappedToRenewStates[expectedState]) {
	                    self._callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null, 'Token Renewal Failed');
	                }

	                self._saveItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource, self.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);
	            }
	        }, self.CONSTANTS.LOADFRAME_TIMEOUT);
	    };

	    /**
	     * Loads iframe with authorization endpoint URL
	     * @ignore
	     */
	    AuthenticationContext.prototype._loadFrame = function (urlNavigate, frameName) {
	        // This trick overcomes iframe navigation in IE
	        // IE does not load the page consistently in iframe
	        var self = this;
	        self.info('LoadFrame: ' + frameName);
	        var frameCheck = frameName;
	        setTimeout(function () {
	            var frameHandle = self._addAdalFrame(frameCheck);

	            if (frameHandle.src === '' || frameHandle.src === 'about:blank') {
	                frameHandle.src = urlNavigate;
	                self._loadFrame(urlNavigate, frameCheck);
	            }

	        }, 500);
	    };

	    /**
	     * @callback tokenCallback
	     * @param {string} error_description error description returned from AAD if token request fails.
	     * @param {string} token token returned from AAD if token request is successful.
	     * @param {string} error error message returned from AAD if token request fails.
	     */

	    /**
	     * Acquires token from the cache if it is not expired. Otherwise sends request to AAD to obtain a new token.
	     * @param {string}   resource  ResourceUri identifying the target resource
	     * @param {tokenCallback} callback -  The callback provided by the caller. It will be called with token or error.
	     */
	    AuthenticationContext.prototype.acquireToken = function (resource, callback) {
	        if (this._isEmpty(resource)) {
	            this.warn('resource is required');
	            callback('resource is required', null, 'resource is required');
	            return;
	        }

	        var token = this.getCachedToken(resource);

	        if (token) {
	            this.info('Token is already in cache for resource:' + resource);
	            callback(null, token, null);
	            return;
	        }

	        if (!this._user && !(this.config.extraQueryParameter && this.config.extraQueryParameter.indexOf('login_hint') !== -1)) {
	            this.warn('User login is required');
	            callback('User login is required', null, 'login required');
	            return;
	        }

	        // renew attempt with iframe
	        // Already renewing for this resource, callback when we get the token.
	        if (this._activeRenewals[resource]) {
	            // Active renewals contains the state for each renewal.
	            this.registerCallback(this._activeRenewals[resource], resource, callback);
	        }
	        else {
	            this._requestType = this.REQUEST_TYPE.RENEW_TOKEN;
	            if (resource === this.config.clientId) {
	                // App uses idtoken to send to api endpoints
	                // Default resource is tracked as clientid to store this token
	                if (this._user) {
	                    this.verbose('renewing idtoken');
	                    this._renewIdToken(callback);
	                }
	                else {
	                    this.verbose('renewing idtoken and access_token');
	                    this._renewIdToken(callback, this.RESPONSE_TYPE.ID_TOKEN_TOKEN);
	                }
	            } else {
	                if (this._user) {
	                    this.verbose('renewing access_token');
	                    this._renewToken(resource, callback);
	                }
	                else {
	                    this.verbose('renewing idtoken and access_token');
	                    this._renewToken(resource, callback, this.RESPONSE_TYPE.ID_TOKEN_TOKEN);
	                }
	            }
	        }
	    };

	    /**
	  * Acquires token (interactive flow using a popUp window) by sending request to AAD to obtain a new token.
	  * @param {string}   resource  ResourceUri identifying the target resource
	  * @param {string}   extraQueryParameters  extraQueryParameters to add to the authentication request
	  * @param {tokenCallback} callback -  The callback provided by the caller. It will be called with token or error.
	  */
	    AuthenticationContext.prototype.acquireTokenPopup = function (resource, extraQueryParameters, claims, callback) {
	        if (this._isEmpty(resource)) {
	            this.warn('resource is required');
	            callback('resource is required', null, 'resource is required');
	            return;
	        }

	        if (!this._user) {
	            this.warn('User login is required');
	            callback('User login is required', null, 'login required');
	            return;
	        }

	        if (this._acquireTokenInProgress) {
	            this.warn("Acquire token interactive is already in progress");
	            callback("Acquire token interactive is already in progress", null, "Acquire token interactive is already in progress");
	            return;
	        }

	        var expectedState = this._guid() + '|' + resource;
	        this.config.state = expectedState;
	        this._renewStates.push(expectedState);
	        this._requestType = this.REQUEST_TYPE.RENEW_TOKEN;
	        this.verbose('Renew token Expected state: ' + expectedState);
	        // remove the existing prompt=... query parameter and add prompt=select_account
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl('token', resource), 'prompt');
	        urlNavigate = urlNavigate + '&prompt=select_account';

	        if (extraQueryParameters) {
	            urlNavigate += extraQueryParameters;
	        }

	        if (claims && (urlNavigate.indexOf("&claims") === -1)) {
	            urlNavigate += '&claims=' + encodeURIComponent(claims);
	        }
	        else if (claims && (urlNavigate.indexOf("&claims") !== -1)) {
	            throw new Error('Claims cannot be passed as an extraQueryParameter');
	        }

	        urlNavigate = this._addHintParameters(urlNavigate);
	        this._acquireTokenInProgress = true;
	        this.info('acquireToken interactive is called for the resource ' + resource);
	        this.registerCallback(expectedState, resource, callback);
	        this._loginPopup(urlNavigate, resource, callback);

	    };

	    /**
	      * Acquires token (interactive flow using a redirect) by sending request to AAD to obtain a new token. In this case the callback passed in the Authentication
	      * request constructor will be called.
	      * @param {string}   resource  ResourceUri identifying the target resource
	      * @param {string}   extraQueryParameters  extraQueryParameters to add to the authentication request
	      */
	    AuthenticationContext.prototype.acquireTokenRedirect = function (resource, extraQueryParameters, claims) {
	        if (this._isEmpty(resource)) {
	            this.warn('resource is required');
	            callback('resource is required', null, 'resource is required');
	            return;
	        }

	        var callback = this.callback;

	        if (!this._user) {
	            this.warn('User login is required');
	            callback('User login is required', null, 'login required');
	            return;
	        }

	        if (this._acquireTokenInProgress) {
	            this.warn("Acquire token interactive is already in progress");
	            callback("Acquire token interactive is already in progress", null, "Acquire token interactive is already in progress");
	            return;
	        }

	        var expectedState = this._guid() + '|' + resource;
	        this.config.state = expectedState;
	        this.verbose('Renew token Expected state: ' + expectedState);

	        // remove the existing prompt=... query parameter and add prompt=select_account
	        var urlNavigate = this._urlRemoveQueryStringParameter(this._getNavigateUrl('token', resource), 'prompt');
	        urlNavigate = urlNavigate + '&prompt=select_account';
	        if (extraQueryParameters) {
	            urlNavigate += extraQueryParameters;
	        }

	        if (claims && (urlNavigate.indexOf("&claims") === -1)) {
	            urlNavigate += '&claims=' + encodeURIComponent(claims);
	        }
	        else if (claims && (urlNavigate.indexOf("&claims") !== -1)) {
	            throw new Error('Claims cannot be passed as an extraQueryParameter');
	        }

	        urlNavigate = this._addHintParameters(urlNavigate);
	        this._acquireTokenInProgress = true;
	        this.info('acquireToken interactive is called for the resource ' + resource);
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, window.location.href);
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, expectedState, true);
	        this.promptUser(urlNavigate);
	    };
	    /**
	     * Redirects the browser to Azure AD authorization endpoint.
	     * @param {string}   urlNavigate  Url of the authorization endpoint.
	     */
	    AuthenticationContext.prototype.promptUser = function (urlNavigate) {
	        if (urlNavigate) {
	            this.infoPii('Navigate to:' + urlNavigate);
	            window.location.replace(urlNavigate);
	        } else {
	            this.info('Navigate url is empty');
	        }
	    };

	    /**
	     * Clears cache items.
	     */
	    AuthenticationContext.prototype.clearCache = function () {
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST, '');
	        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');
	        this._renewStates = [];
	        this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, '');
	        this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');
	        var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);

	        if (!this._isEmpty(keys)) {
	            keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);
	            for (var i = 0; i < keys.length && keys[i] !== ""; i++) {
	                this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');
	                this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);
	            }
	        }

	        this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');
	    };

	    /**
	     * Clears cache items for a given resource.
	     * @param {string}  resource a URI that identifies the resource.
	     */
	    AuthenticationContext.prototype.clearCacheForResource = function (resource) {
	        this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');

	        if (this._hasResource(resource)) {
	            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');
	            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);
	        }
	    };

	    /**
	     * Redirects user to logout endpoint.
	     * After logout, it will redirect to postLogoutRedirectUri if added as a property on the config object.
	     */
	    AuthenticationContext.prototype.logOut = function () {
	        this.clearCache();
	        this._user = null;
	        var urlNavigate;

	        if (this.config.logOutUri) {
	            urlNavigate = this.config.logOutUri;
	        } else {
	            var tenant = 'common';
	            var logout = '';

	            if (this.config.tenant) {
	                tenant = this.config.tenant;
	            }

	            if (this.config.postLogoutRedirectUri) {
	                logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);
	            }

	            urlNavigate = this.instance + tenant + '/oauth2/logout?' + logout;
	        }

	        this.infoPii('Logout navigate to: ' + urlNavigate);
	        this.promptUser(urlNavigate);
	    };

	    AuthenticationContext.prototype._isEmpty = function (str) {
	        return (typeof str === 'undefined' || !str || 0 === str.length);
	    };

	    /**
	     * @callback userCallback
	     * @param {string} error error message if user info is not available.
	     * @param {User} user user object retrieved from the cache.
	     */

	    /**
	     * Calls the passed in callback with the user object or error message related to the user.
	     * @param {userCallback} callback - The callback provided by the caller. It will be called with user or error.
	     */
	    AuthenticationContext.prototype.getUser = function (callback) {
	        // IDToken is first call
	        if (typeof callback !== 'function') {
	            throw new Error('callback is not a function');
	        }

	        // user in memory
	        if (this._user) {
	            callback(null, this._user);
	            return;
	        }

	        // frame is used to get idtoken
	        var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);

	        if (!this._isEmpty(idtoken)) {
	            this.info('User exists in cache: ');
	            this._user = this._createUser(idtoken);
	            callback(null, this._user);
	        } else {
	            this.warn('User information is not available');
	            callback('User information is not available', null);
	        }
	    };

	    /**
	     * Adds login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time.
	     * domain_hint can be one of users/organisations which when added skips the email based discovery process of the user.
	     * @ignore
	     */
	    AuthenticationContext.prototype._addHintParameters = function (urlNavigate) {
	        //If you don�t use prompt=none, then if the session does not exist, there will be a failure.
	        //If sid is sent alongside domain or login hints, there will be a failure since request is ambiguous.
	        //If sid is sent with a prompt value other than none or attempt_none, there will be a failure since the request is ambiguous.

	        if (this._user && this._user.profile) {
	            if (this._user.profile.sid && urlNavigate.indexOf('&prompt=none') !== -1) {
	                // don't add sid twice if user provided it in the extraQueryParameter value
	                if (!this._urlContainsQueryStringParameter("sid", urlNavigate)) {
	                    // add sid
	                    urlNavigate += '&sid=' + encodeURIComponent(this._user.profile.sid);
	                }
	            }
	            else if (this._user.profile.upn) {
	                // don't add login_hint twice if user provided it in the extraQueryParameter value
	                if (!this._urlContainsQueryStringParameter("login_hint", urlNavigate)) {
	                    // add login_hint
	                    urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);
	                }
	                // don't add domain_hint twice if user provided it in the extraQueryParameter value
	                if (!this._urlContainsQueryStringParameter("domain_hint", urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {
	                    var parts = this._user.profile.upn.split('@');
	                    // local part can include @ in quotes. Sending last part handles that.
	                    urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);
	                }
	            }

	        }

	        return urlNavigate;
	    };

	    /**
	     * Creates a user object by decoding the id_token
	     * @ignore
	     */
	    AuthenticationContext.prototype._createUser = function (idToken) {
	        var user = null;
	        var parsedJson = this._extractIdToken(idToken);
	        if (parsedJson && parsedJson.hasOwnProperty('aud')) {
	            if (parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase()) {

	                user = {
	                    userName: '',
	                    profile: parsedJson
	                };

	                if (parsedJson.hasOwnProperty('upn')) {
	                    user.userName = parsedJson.upn;
	                } else if (parsedJson.hasOwnProperty('email')) {
	                    user.userName = parsedJson.email;
	                }
	            } else {
	                this.warn('IdToken has invalid aud field');
	            }

	        }

	        return user;
	    };

	    /**
	     * Returns the anchor part(#) of the URL
	     * @ignore
	     */
	    AuthenticationContext.prototype._getHash = function (hash) {
	        if (hash.indexOf('#/') > -1) {
	            hash = hash.substring(hash.indexOf('#/') + 2);
	        } else if (hash.indexOf('#') > -1) {
	            hash = hash.substring(1);
	        }

	        return hash;
	    };

	    /**
	     * Checks if the URL fragment contains access token, id token or error_description.
	     * @param {string} hash  -  Hash passed from redirect page
	     * @returns {Boolean} true if response contains id_token, access_token or error, false otherwise.
	     */
	    AuthenticationContext.prototype.isCallback = function (hash) {
	        hash = this._getHash(hash);
	        var parameters = this._deserialize(hash);
	        return (
	            parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||
	            parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||
	            parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)
	        );
	    };

	    /**
	     * Gets login error
	     * @returns {string} error message related to login.
	     */
	    AuthenticationContext.prototype.getLoginError = function () {
	        return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);
	    };

	    /**
	     * Request info object created from the response received from AAD.
	     *  @class RequestInfo
	     *  @property {object} parameters - object comprising of fields such as id_token/error, session_state, state, e.t.c.
	     *  @property {REQUEST_TYPE} requestType - either LOGIN, RENEW_TOKEN or UNKNOWN.
	     *  @property {boolean} stateMatch - true if state is valid, false otherwise.
	     *  @property {string} stateResponse - unique guid used to match the response with the request.
	     *  @property {boolean} valid - true if requestType contains id_token, access_token or error, false otherwise.
	     */

	    /**
	     * Creates a requestInfo object from the URL fragment and returns it.
	     * @returns {RequestInfo} an object created from the redirect response from AAD comprising of the keys - parameters, requestType, stateMatch, stateResponse and valid.
	     */
	    AuthenticationContext.prototype.getRequestInfo = function (hash) {
	        hash = this._getHash(hash);
	        var parameters = this._deserialize(hash);
	        var requestInfo = {
	            valid: false,
	            parameters: {},
	            stateMatch: false,
	            stateResponse: '',
	            requestType: this.REQUEST_TYPE.UNKNOWN,
	        };

	        if (parameters) {
	            requestInfo.parameters = parameters;
	            if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||
	                parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||
	                parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {

	                requestInfo.valid = true;

	                // which call
	                var stateResponse = '';
	                if (parameters.hasOwnProperty('state')) {
	                    this.verbose('State: ' + parameters.state);
	                    stateResponse = parameters.state;
	                } else {
	                    this.warn('No state returned');
	                    return requestInfo;
	                }

	                requestInfo.stateResponse = stateResponse;

	                // async calls can fire iframe and login request at the same time if developer does not use the API as expected
	                // incoming callback needs to be looked up to find the request type
	                if (this._matchState(requestInfo)) { // loginRedirect or acquireTokenRedirect
	                    return requestInfo;
	                }

	                // external api requests may have many renewtoken requests for different resource
	                if (!requestInfo.stateMatch && window.parent) {
	                    requestInfo.requestType = this._requestType;
	                    var statesInParentContext = this._renewStates;
	                    for (var i = 0; i < statesInParentContext.length; i++) {
	                        if (statesInParentContext[i] === requestInfo.stateResponse) {
	                            requestInfo.stateMatch = true;
	                            break;
	                        }
	                    }
	                }
	            }
	        }
	        return requestInfo;
	    };

	    /**
	    * Matches nonce from the request with the response.
	    * @ignore
	    */
	    AuthenticationContext.prototype._matchNonce = function (user) {
	        var requestNonce = this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN);

	        if (requestNonce) {
	            requestNonce = requestNonce.split(this.CONSTANTS.CACHE_DELIMETER);
	            for (var i = 0; i < requestNonce.length; i++) {
	                if (requestNonce[i] === user.profile.nonce) {
	                    return true;
	                }
	            }
	        }

	        return false;
	    };

	    /**
	    * Matches state from the request with the response.
	    * @ignore
	    */
	    AuthenticationContext.prototype._matchState = function (requestInfo) {
	        var loginStates = this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN);

	        if (loginStates) {
	            loginStates = loginStates.split(this.CONSTANTS.CACHE_DELIMETER);
	            for (var i = 0; i < loginStates.length; i++) {
	                if (loginStates[i] === requestInfo.stateResponse) {
	                    requestInfo.requestType = this.REQUEST_TYPE.LOGIN;
	                    requestInfo.stateMatch = true;
	                    return true;
	                }
	            }
	        }

	        var acquireTokenStates = this._getItem(this.CONSTANTS.STORAGE.STATE_RENEW);

	        if (acquireTokenStates) {
	            acquireTokenStates = acquireTokenStates.split(this.CONSTANTS.CACHE_DELIMETER);
	            for (var i = 0; i < acquireTokenStates.length; i++) {
	                if (acquireTokenStates[i] === requestInfo.stateResponse) {
	                    requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;
	                    requestInfo.stateMatch = true;
	                    return true;
	                }
	            }
	        }

	        return false;

	    };

	    /**
	     * Extracts resource value from state.
	     * @ignore
	     */
	    AuthenticationContext.prototype._getResourceFromState = function (state) {
	        if (state) {
	            var splitIndex = state.indexOf('|');

	            if (splitIndex > -1 && splitIndex + 1 < state.length) {
	                return state.substring(splitIndex + 1);
	            }
	        }

	        return '';
	    };

	    /**
	     * Saves token or error received in the response from AAD in the cache. In case of id_token, it also creates the user object.
	     */
	    AuthenticationContext.prototype.saveTokenFromHash = function (requestInfo) {
	        this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');
	        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');

	        var resource = this._getResourceFromState(requestInfo.stateResponse);

	        // Record error
	        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {
	            this.infoPii('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);
	            this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);
	            this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);

	            if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {
	                this._loginInProgress = false;
	                this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);
	            }
	        } else {
	            // It must verify the state from redirect
	            if (requestInfo.stateMatch) {
	                // record tokens to storage if exists
	                this.info('State is right');
	                if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {
	                    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);
	                }

	                var keys;

	                if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {
	                    this.info('Fragment has access token');

	                    if (!this._hasResource(resource)) {
	                        keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';
	                        this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);
	                    }

	                    // save token with related resource
	                    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);
	                    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));
	                }

	                if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {
	                    this.info('Fragment has id token');
	                    this._loginInProgress = false;
	                    this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
	                    if (this._user && this._user.profile) {
	                        if (!this._matchNonce(this._user)) {
	                            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce received: ' + this._user.profile.nonce + ' is not same as requested: ' +
	                                this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN));
	                            this._user = null;
	                        } else {
	                            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);

	                            // Save idtoken as access token for app itself
	                            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;

	                            if (!this._hasResource(resource)) {
	                                keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';
	                                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);
	                            }

	                            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
	                            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);
	                        }
	                    }
	                    else {
	                        requestInfo.parameters['error'] = 'invalid id_token';
	                        requestInfo.parameters['error_description'] = 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN];
	                        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');
	                        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
	                    }
	                }
	            } else {
	                requestInfo.parameters['error'] = 'Invalid_state';
	                requestInfo.parameters['error_description'] = 'Invalid_state. state: ' + requestInfo.stateResponse;
	                this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');
	                this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);
	            }
	        }

	        this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);
	    };

	    /**
	     * Gets resource for given endpoint if mapping is provided with config.
	     * @param {string} endpoint  -  The URI for which the resource Id is requested.
	     * @returns {string} resource for this API endpoint.
	     */
	    AuthenticationContext.prototype.getResourceForEndpoint = function (endpoint) {

	        // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.
	        if (this.config && this.config.anonymousEndpoints) {
	            for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {
	                if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {
	                    return null;
	                }
	            }
	        }

	        if (this.config && this.config.endpoints) {
	            for (var configEndpoint in this.config.endpoints) {
	                // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1
	                if (endpoint.indexOf(configEndpoint) > -1) {
	                    return this.config.endpoints[configEndpoint];
	                }
	            }
	        }

	        // default resource will be clientid if nothing specified
	        // App will use idtoken for calls to itself
	        // check if it's staring from http or https, needs to match with app host
	        if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {
	            if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {
	                return this.config.loginResource;
	            }
	        }
	        else {
	            // in angular level, the url for $http interceptor call could be relative url,
	            // if it's relative call, we'll treat it as app backend call.            
	            return this.config.loginResource;
	        }

	        // if not the app's own backend or not a domain listed in the endpoints structure
	        return null;
	    };

	    /**
	     * Strips the protocol part of the URL and returns it.
	     * @ignore
	     */
	    AuthenticationContext.prototype._getHostFromUri = function (uri) {
	        // remove http:// or https:// from uri
	        var extractedUri = String(uri).replace(/^(https?:)\/\//, '');
	        extractedUri = extractedUri.split('/')[0];
	        return extractedUri;
	    };

	    /**
	     * This method must be called for processing the response received from AAD. It extracts the hash, processes the token or error, saves it in the cache and calls the registered callbacks with the result.
	     * @param {string} [hash=window.location.hash] - Hash fragment of Url.
	     */
	    AuthenticationContext.prototype.handleWindowCallback = function (hash) {
	        // This is for regular javascript usage for redirect handling
	        // need to make sure this is for callback
	        if (hash == null) {
	            hash = window.location.hash;
	        }

	        if (this.isCallback(hash)) {
	            var self = null;
	            var isPopup = false;

	            if (this._openedWindows.length > 0 && this._openedWindows[this._openedWindows.length - 1].opener
	                && this._openedWindows[this._openedWindows.length - 1].opener._adalInstance) {
	                self = this._openedWindows[this._openedWindows.length - 1].opener._adalInstance;
	                isPopup = true;
	            }
	            else if (window.parent && window.parent._adalInstance) {
	                self = window.parent._adalInstance;
	            }

	            var requestInfo = self.getRequestInfo(hash);
	            var token, tokenReceivedCallback, tokenType = null;

	            if (isPopup || window.parent !== window) {
	                tokenReceivedCallback = self._callBackMappedToRenewStates[requestInfo.stateResponse];
	            }
	            else {
	                tokenReceivedCallback = self.callback;
	            }

	            self.info("Returned from redirect url");
	            self.saveTokenFromHash(requestInfo);

	            if ((requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN) && window.parent) {
	                if (window.parent !== window) {
	                    self.verbose("Window is in iframe, acquiring token silently");
	                } else {
	                    self.verbose("acquiring token interactive in progress");
	                }

	                token = requestInfo.parameters[self.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[self.CONSTANTS.ID_TOKEN];
	                tokenType = self.CONSTANTS.ACCESS_TOKEN;
	            } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {
	                token = requestInfo.parameters[self.CONSTANTS.ID_TOKEN];
	                tokenType = self.CONSTANTS.ID_TOKEN;
	            }

	            var errorDesc = requestInfo.parameters[self.CONSTANTS.ERROR_DESCRIPTION];
	            var error = requestInfo.parameters[self.CONSTANTS.ERROR];
	            try {
	                if (tokenReceivedCallback) {
	                    tokenReceivedCallback(errorDesc, token, error, tokenType);
	                }

	            } catch (err) {
	                self.error("Error occurred in user defined callback function: " + err);
	            }

	            if (window.parent === window && !isPopup) {
	                if (self.config.navigateToLoginRequestUrl) {
	                    window.location.href = self._getItem(self.CONSTANTS.STORAGE.LOGIN_REQUEST);
	                } else window.location.hash = '';
	            }
	        }
	    };

	    /**
	     * Constructs the authorization endpoint URL and returns it.
	     * @ignore
	     */
	    AuthenticationContext.prototype._getNavigateUrl = function (responseType, resource) {
	        var tenant = 'common';
	        if (this.config.tenant) {
	            tenant = this.config.tenant;
	        }

	        var urlNavigate = this.instance + tenant + '/oauth2/authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();
	        this.info('Navigate url:' + urlNavigate);
	        return urlNavigate;
	    };

	    /**
	     * Returns the decoded id_token.
	     * @ignore
	     */
	    AuthenticationContext.prototype._extractIdToken = function (encodedIdToken) {
	        // id token will be decoded to get the username
	        var decodedToken = this._decodeJwt(encodedIdToken);

	        if (!decodedToken) {
	            return null;
	        }

	        try {
	            var base64IdToken = decodedToken.JWSPayload;
	            var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);

	            if (!base64Decoded) {
	                this.info('The returned id_token could not be base64 url safe decoded.');
	                return null;
	            }

	            // ECMA script has JSON built-in support
	            return JSON.parse(base64Decoded);
	        } catch (err) {
	            this.error('The returned id_token could not be decoded', err);
	        }

	        return null;
	    };

	    /**
	     * Decodes a string of data which has been encoded using base-64 encoding.
	     * @ignore
	     */
	    AuthenticationContext.prototype._base64DecodeStringUrlSafe = function (base64IdToken) {
	        // html5 should support atob function for decoding
	        base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');

	        if (window.atob) {
	            return decodeURIComponent(escape(window.atob(base64IdToken))); // jshint ignore:line
	        }
	        else {
	            return decodeURIComponent(escape(this._decode(base64IdToken)));
	        }
	    };

	    //Take https://cdnjs.cloudflare.com/ajax/libs/Base64/0.3.0/base64.js and https://en.wikipedia.org/wiki/Base64 as reference. 
	    AuthenticationContext.prototype._decode = function (base64IdToken) {
	        var codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	        base64IdToken = String(base64IdToken).replace(/=+$/, '');

	        var length = base64IdToken.length;

	        if (length % 4 === 1) {
	            throw new Error('The token to be decoded is not correctly encoded.');
	        }

	        var h1, h2, h3, h4, bits, c1, c2, c3, decoded = '';

	        for (var i = 0; i < length; i += 4) {
	            //Every 4 base64 encoded character will be converted to 3 byte string, which is 24 bits
	            // then 6 bits per base64 encoded character
	            h1 = codes.indexOf(base64IdToken.charAt(i));
	            h2 = codes.indexOf(base64IdToken.charAt(i + 1));
	            h3 = codes.indexOf(base64IdToken.charAt(i + 2));
	            h4 = codes.indexOf(base64IdToken.charAt(i + 3));

	            // For padding, if last two are '='
	            if (i + 2 === length - 1) {
	                bits = h1 << 18 | h2 << 12 | h3 << 6;
	                c1 = bits >> 16 & 255;
	                c2 = bits >> 8 & 255;
	                decoded += String.fromCharCode(c1, c2);
	                break;
	            }
	            // if last one is '='
	            else if (i + 1 === length - 1) {
	                bits = h1 << 18 | h2 << 12;
	                c1 = bits >> 16 & 255;
	                decoded += String.fromCharCode(c1);
	                break;
	            }

	            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

	            // then convert to 3 byte chars
	            c1 = bits >> 16 & 255;
	            c2 = bits >> 8 & 255;
	            c3 = bits & 255;

	            decoded += String.fromCharCode(c1, c2, c3);
	        }

	        return decoded;
	    };

	    /**
	     * Decodes an id token into an object with header, payload and signature fields.
	     * @ignore
	     */
	    // Adal.node js crack function
	    AuthenticationContext.prototype._decodeJwt = function (jwtToken) {
	        if (this._isEmpty(jwtToken)) {
	            return null;
	        }
	        var idTokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;

	        var matches = idTokenPartsRegex.exec(jwtToken);

	        if (!matches || matches.length < 4) {
	            this.warn('The returned id_token is not parseable.');
	            return null;
	        }

	        var crackedToken = {
	            header: matches[1],
	            JWSPayload: matches[2],
	            JWSSig: matches[3]
	        };

	        return crackedToken;
	    };

	    /**
	     * Converts string to represent binary data in ASCII string format by translating it into a radix-64 representation and returns it
	     * @ignore
	     */
	    AuthenticationContext.prototype._convertUrlSafeToRegularBase64EncodedString = function (str) {
	        return str.replace('-', '+').replace('_', '/');
	    };

	    /**
	     * Serializes the parameters for the authorization endpoint URL and returns the serialized uri string.
	     * @ignore
	     */
	    AuthenticationContext.prototype._serialize = function (responseType, obj, resource) {
	        var str = [];

	        if (obj !== null) {
	            str.push('?response_type=' + responseType);
	            str.push('client_id=' + encodeURIComponent(obj.clientId));
	            if (resource) {
	                str.push('resource=' + encodeURIComponent(resource));
	            }

	            str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));
	            str.push('state=' + encodeURIComponent(obj.state));

	            if (obj.hasOwnProperty('slice')) {
	                str.push('slice=' + encodeURIComponent(obj.slice));
	            }

	            if (obj.hasOwnProperty('extraQueryParameter')) {
	                str.push(obj.extraQueryParameter);
	            }

	            var correlationId = obj.correlationId ? obj.correlationId : this._guid();
	            str.push('client-request-id=' + encodeURIComponent(correlationId));
	        }

	        return str.join('&');
	    };

	    /**
	     * Parses the query string parameters into a key-value pair object.
	     * @ignore
	     */
	    AuthenticationContext.prototype._deserialize = function (query) {
	        var match,
	            pl = /\+/g,  // Regex for replacing addition symbol with a space
	            search = /([^&=]+)=([^&]*)/g,
	            decode = function (s) {
	                return decodeURIComponent(s.replace(pl, ' '));
	            },
	            obj = {};
	        match = search.exec(query);

	        while (match) {
	            obj[decode(match[1])] = decode(match[2]);
	            match = search.exec(query);
	        }

	        return obj;
	    };

	    /**
	     * Converts decimal value to hex equivalent
	     * @ignore
	     */
	    AuthenticationContext.prototype._decimalToHex = function (number) {
	        var hex = number.toString(16);

	        while (hex.length < 2) {
	            hex = '0' + hex;
	        }
	        return hex;
	    };

	    /**
	     * Generates RFC4122 version 4 guid (128 bits)
	     * @ignore
	     */
	    /* jshint ignore:start */
	    AuthenticationContext.prototype._guid = function () {
	        // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or
	        // pseudo-random numbers.
	        // The algorithm is as follows:
	        //     Set the two most significant bits (bits 6 and 7) of the
	        //        clock_seq_hi_and_reserved to zero and one, respectively.
	        //     Set the four most significant bits (bits 12 through 15) of the
	        //        time_hi_and_version field to the 4-bit version number from
	        //        Section 4.1.3. Version4
	        //     Set all the other bits to randomly (or pseudo-randomly) chosen
	        //     values.
	        // UUID                   = time-low "-" time-mid "-"time-high-and-version "-"clock-seq-reserved and low(2hexOctet)"-" node
	        // time-low               = 4hexOctet
	        // time-mid               = 2hexOctet
	        // time-high-and-version  = 2hexOctet
	        // clock-seq-and-reserved = hexOctet:
	        // clock-seq-low          = hexOctet
	        // node                   = 6hexOctet
	        // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
	        // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10
	        // y values are 8, 9, A, B
	        var cryptoObj = window.crypto || window.msCrypto; // for IE 11
	        if (cryptoObj && cryptoObj.getRandomValues) {
	            var buffer = new Uint8Array(16);
	            cryptoObj.getRandomValues(buffer);
	            //buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).
	            buffer[6] |= 0x40; //buffer[6] | 01000000 will set the 6 bit to 1.
	            buffer[6] &= 0x4f; //buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = "4".
	            //buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.
	            buffer[8] |= 0x80; //buffer[8] | 10000000 will set the 7 bit to 1.
	            buffer[8] &= 0xbf; //buffer[8] & 10111111 will set the 6 bit to 0.
	            return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' +
	                this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);
	        }
	        else {
	            var guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
	            var hex = '0123456789abcdef';
	            var r = 0;
	            var guidResponse = "";
	            for (var i = 0; i < 36; i++) {
	                if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {
	                    // each x and y needs to be random
	                    r = Math.random() * 16 | 0;
	                }
	                if (guidHolder[i] === 'x') {
	                    guidResponse += hex[r];
	                } else if (guidHolder[i] === 'y') {
	                    // clock-seq-and-reserved first hex is filtered and remaining hex values are random
	                    r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??
	                    r |= 0x8; // set pos 3 to 1 as 1???
	                    guidResponse += hex[r];
	                } else {
	                    guidResponse += guidHolder[i];
	                }
	            }
	            return guidResponse;
	        }
	    };
	    /* jshint ignore:end */

	    /**
	     * Calculates the expires in value in milliseconds for the acquired token
	     * @ignore
	     */
	    AuthenticationContext.prototype._expiresIn = function (expires) {
	        // if AAD did not send "expires_in" property, use default expiration of 3599 seconds, for some reason AAD sends 3599 as "expires_in" value instead of 3600
	        if (!expires) expires = 3599;
	        return this._now() + parseInt(expires, 10);
	    };

	    /**
	     * Return the number of milliseconds since 1970/01/01
	     * @ignore
	     */
	    AuthenticationContext.prototype._now = function () {
	        return Math.round(new Date().getTime() / 1000.0);
	    };

	    /**
	     * Adds the hidden iframe for silent token renewal
	     * @ignore
	     */
	    AuthenticationContext.prototype._addAdalFrame = function (iframeId) {
	        if (typeof iframeId === 'undefined') {
	            return;
	        }

	        this.info('Add adal frame to document:' + iframeId);
	        var adalFrame = document.getElementById(iframeId);

	        if (!adalFrame) {
	            if (document.createElement && document.documentElement &&
	                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {
	                var ifr = document.createElement('iframe');
	                ifr.setAttribute('id', iframeId);
	                ifr.setAttribute('aria-hidden', 'true');
	                ifr.style.visibility = 'hidden';
	                ifr.style.position = 'absolute';
	                ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';

	                adalFrame = document.getElementsByTagName('body')[0].appendChild(ifr);
	            }
	            else if (document.body && document.body.insertAdjacentHTML) {
	                document.body.insertAdjacentHTML('beforeEnd', '<iframe name="' + iframeId + '" id="' + iframeId + '" style="display:none"></iframe>');
	            }
	            if (window.frames && window.frames[iframeId]) {
	                adalFrame = window.frames[iframeId];
	            }
	        }

	        return adalFrame;
	    };

	    /**
	     * Saves the key-value pair in the cache
	     * @ignore
	     */
	    AuthenticationContext.prototype._saveItem = function (key, obj, preserve) {

	        if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {

	            if (!this._supportsLocalStorage()) {
	                this.info('Local storage is not supported');
	                return false;
	            }

	            if (preserve) {
	                var value = this._getItem(key) || '';
	                localStorage.setItem(key, value + obj + this.CONSTANTS.CACHE_DELIMETER);
	            }
	            else {
	                localStorage.setItem(key, obj);
	            }

	            return true;
	        }

	        // Default as session storage
	        if (!this._supportsSessionStorage()) {
	            this.info('Session storage is not supported');
	            return false;
	        }

	        sessionStorage.setItem(key, obj);
	        return true;
	    };

	    /**
	     * Searches the value for the given key in the cache
	     * @ignore
	     */
	    AuthenticationContext.prototype._getItem = function (key) {

	        if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {

	            if (!this._supportsLocalStorage()) {
	                this.info('Local storage is not supported');
	                return null;
	            }

	            return localStorage.getItem(key);
	        }

	        // Default as session storage
	        if (!this._supportsSessionStorage()) {
	            this.info('Session storage is not supported');
	            return null;
	        }

	        return sessionStorage.getItem(key);
	    };

	    /**
	     * Returns true if browser supports localStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationContext.prototype._supportsLocalStorage = function () {
	        try {
	            if (!window.localStorage) return false; // Test availability
	            window.localStorage.setItem('storageTest', 'A'); // Try write
	            if (window.localStorage.getItem('storageTest') != 'A') return false; // Test read/write
	            window.localStorage.removeItem('storageTest'); // Try delete
	            if (window.localStorage.getItem('storageTest')) return false; // Test delete
	            return true; // Success
	        } catch (e) {
	            return false;
	        }
	    };

	    /**
	     * Returns true if browser supports sessionStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationContext.prototype._supportsSessionStorage = function () {
	        try {
	            if (!window.sessionStorage) return false; // Test availability
	            window.sessionStorage.setItem('storageTest', 'A'); // Try write
	            if (window.sessionStorage.getItem('storageTest') != 'A') return false; // Test read/write
	            window.sessionStorage.removeItem('storageTest'); // Try delete
	            if (window.sessionStorage.getItem('storageTest')) return false; // Test delete
	            return true; // Success
	        } catch (e) {
	            return false;
	        }
	    };

	    /**
	     * Returns a cloned copy of the passed object.
	     * @ignore
	     */
	    AuthenticationContext.prototype._cloneConfig = function (obj) {
	        if (null === obj || 'object' !== typeof obj) {
	            return obj;
	        }

	        var copy = {};
	        for (var attr in obj) {
	            if (obj.hasOwnProperty(attr)) {
	                copy[attr] = obj[attr];
	            }
	        }
	        return copy;
	    };

	    /**
	     * Adds the library version and returns it.
	     * @ignore
	     */
	    AuthenticationContext.prototype._addLibMetadata = function () {
	        // x-client-SKU
	        // x-client-Ver
	        return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();
	    };

	    /**
	     * Checks the Logging Level, constructs the Log message and logs it. Users need to implement/override this method to turn on Logging. 
	     * @param {number} level  -  Level can be set 0,1,2 and 3 which turns on 'error', 'warning', 'info' or 'verbose' level logging respectively.
	     * @param {string} message  -  Message to log.
	     * @param {string} error  -  Error to log.
	     */
	    AuthenticationContext.prototype.log = function (level, message, error, containsPii) {

	        if (level <= Logging.level) {

	            if (!Logging.piiLoggingEnabled && containsPii)
	                return;

	            var timestamp = new Date().toUTCString();
	            var formattedMessage = '';

	            if (this.config.correlationId)
	                formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;
	            else
	                formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;

	            if (error) {
	                formattedMessage += '\nstack:\n' + error.stack;
	            }

	            Logging.log(formattedMessage);
	        }
	    };

	    /**
	     * Logs messages when Logging Level is set to 0.
	     * @param {string} message  -  Message to log.
	     * @param {string} error  -  Error to log.
	     */
	    AuthenticationContext.prototype.error = function (message, error) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);
	    };

	    /**
	     * Logs messages when Logging Level is set to 1.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.warn = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);
	    };

	    /**
	     * Logs messages when Logging Level is set to 2.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.info = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);
	    };

	    /**
	     * Logs messages when Logging Level is set to 3.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.verbose = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);
	    };

	    /**
	    * Logs Pii messages when Logging Level is set to 0 and window.piiLoggingEnabled is set to true.
	    * @param {string} message  -  Message to log.
	    * @param {string} error  -  Error to log.
	    */
	    AuthenticationContext.prototype.errorPii = function (message, error) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error, true);
	    };

	    /**
	     * Logs  Pii messages when Logging Level is set to 1 and window.piiLoggingEnabled is set to true.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.warnPii = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null, true);
	    };

	    /**
	     * Logs messages when Logging Level is set to 2 and window.piiLoggingEnabled is set to true.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.infoPii = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null, true);
	    };

	    /**
	     * Logs messages when Logging Level is set to 3 and window.piiLoggingEnabled is set to true.
	     * @param {string} message  -  Message to log.
	     */
	    AuthenticationContext.prototype.verbosePii = function (message) {
	        this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null, true);
	    };
	    /**
	     * Returns the library version.
	     * @ignore
	     */
	    AuthenticationContext.prototype._libVersion = function () {
	        return '1.0.17';
	    };

	    /**
	     * Returns a reference of Authentication Context as a result of a require call.
	     * @ignore
	     */
	    if ( module.exports) {
	        module.exports = AuthenticationContext;
	        module.exports.inject = function (conf) {
	            return new AuthenticationContext(conf);
	        };
	    }

	    return AuthenticationContext;

	}());
	});
	var adal_1 = adal.inject;

	/**
	 * The code was extracted from:
	 * https://github.com/davidchambers/Base64.js
	 */

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function InvalidCharacterError(message) {
	  this.message = message;
	}

	InvalidCharacterError.prototype = new Error();
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	function polyfill (input) {
	  var str = String(input).replace(/=+$/, '');
	  if (str.length % 4 == 1) {
	    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	  }
	  for (
	    // initialize result and counters
	    var bc = 0, bs, buffer, idx = 0, output = '';
	    // get next character
	    buffer = str.charAt(idx++);
	    // character found in table? initialize bit storage and add its ascii value;
	    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	      // and if not first of each 4 characters,
	      // convert the first 8 bits to one ascii character
	      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	  ) {
	    // try to find character in table (0-63, not found => -1)
	    buffer = chars.indexOf(buffer);
	  }
	  return output;
	}


	var atob = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;

	function b64DecodeUnicode(str) {
	  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {
	    var code = p.charCodeAt(0).toString(16).toUpperCase();
	    if (code.length < 2) {
	      code = '0' + code;
	    }
	    return '%' + code;
	  }));
	}

	var base64_url_decode = function(str) {
	  var output = str.replace(/-/g, "+").replace(/_/g, "/");
	  switch (output.length % 4) {
	    case 0:
	      break;
	    case 2:
	      output += "==";
	      break;
	    case 3:
	      output += "=";
	      break;
	    default:
	      throw "Illegal base64url string!";
	  }

	  try{
	    return b64DecodeUnicode(output);
	  } catch (err) {
	    return atob(output);
	  }
	};

	function InvalidTokenError(message) {
	  this.message = message;
	}

	InvalidTokenError.prototype = new Error();
	InvalidTokenError.prototype.name = 'InvalidTokenError';

	var lib = function (token,options) {
	  if (typeof token !== 'string') {
	    throw new InvalidTokenError('Invalid token specified');
	  }

	  options = options || {};
	  var pos = options.header === true ? 0 : 1;
	  try {
	    return JSON.parse(base64_url_decode(token.split('.')[pos]));
	  } catch (e) {
	    throw new InvalidTokenError('Invalid token specified: ' + e.message);
	  }
	};

	var InvalidTokenError_1 = InvalidTokenError;
	lib.InvalidTokenError = InvalidTokenError_1;

	/**
	 * A manager for the map control's authentication.
	 * Exposed through the authentication property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var AuthenticationManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function AuthenticationManager(map) {
	        var _this = this;
	        /**
	         * Triggers the user provided function to fetch the token and stores it.
	         * @internal
	         */
	        this._triggerTokenFetch = function () {
	            return new Promise(function (resolve, reject) {
	                _this.options.getToken(function (token) {
	                    try {
	                        // Try to get the timeout first as this will guarantee the token is correctly formatted.
	                        var timeout = _this._getTokenExpiry(token) - AuthenticationManager.constants.tokenRefreshClockSkew;
	                        _this._storeAccessToken(token);
	                        clearTimeout(_this.tokenTimeOutHandle); // Clear the previous refresh timeout in case it hadn't triggered yet.
	                        _this.tokenTimeOutHandle = setTimeout(_this._triggerTokenFetch, timeout * 1000);
	                        resolve();
	                    }
	                    catch (_a) {
	                        reject(new Error("Invalid token returned by getToken function"));
	                    }
	                }, function (error) {
	                    reject(error);
	                }, _this.map);
	            });
	        };
	        var serviceOptions = map.getServiceOptions();
	        this.options = serviceOptions.authOptions;
	        this.sessionId = serviceOptions.sessionId;
	        this.map = map;
	    }
	    /**
	     * Initializes the authentication mechanism specified in AuthenticationOptions.
	     * If this method has been called before the original initialize promise is returned.
	     */
	    AuthenticationManager.prototype.initialize = function () {
	        var _this = this;
	        if (!this.initPromise) {
	            // If an init promise hasn't been created this is the first initialize call.
	            this.initPromise = new Promise(function (resolve, reject) {
	                if (_this.options.authType === exports.AuthenticationType.subscriptionKey) {
	                    resolve();
	                }
	                else if (_this.options.authType === exports.AuthenticationType.aad) {
	                    // If a specific auth context was provided to the map use that.
	                    // If not use/create a default auth context shared between maps.
	                    _this.options.authContext = _this.options.authContext ||
	                        AuthenticationManager.getDefaultAuthContext(_this.options);
	                    // If this window is a callback then it is the hidden iframe created by ADAL.
	                    // The map doesn't need to finish constructing, so we can dispose it.
	                    _this.options.authContext.handleWindowCallback();
	                    if (_this.options.authContext.getLoginError()) {
	                        reject(new Error("Error logging in the AAD users: " +
	                            _this.options.authContext.getLoginError()));
	                        return;
	                    }
	                    if (_this.options.authContext.isCallback(window.location.hash)) {
	                        _this.map.dispose();
	                        return;
	                    }
	                    // Login and acquire a token.
	                    // Fire it async so that users can add any listeners for token acquire events first.
	                    setTimeout(function () { return _this._loginAndAcquire(resolve, reject); });
	                }
	                else if (_this.options.authType === exports.AuthenticationType.anonymous) {
	                    // Anonymous authentication, just call the users provided callback.
	                    resolve(_this._triggerTokenFetch());
	                }
	                else {
	                    reject(new Error("An invalid authentication type was specified."));
	                }
	            });
	        }
	        return this.initPromise;
	    };
	    /**
	     * Gets the default auth context to be shared between maps without one specified to them.
	     */
	    AuthenticationManager.getDefaultAuthContext = function (options) {
	        if (!options.aadAppId) {
	            throw new Error("No AAD app ID was specified.");
	        }
	        if (!options.aadTenant) {
	            throw new Error("No AAD tenant was specified.");
	        }
	        // Create a new auth context if one doesn't already exist.
	        if (!this.defaultAuthContext) {
	            this.defaultAuthContext = new adal({
	                instance: options.aadInstance || env.aadInstance,
	                tenant: options.aadTenant,
	                clientId: options.aadAppId,
	                cacheLocation: this.constants.preferredCacheLocation
	            });
	        }
	        // Return either a reused auth context or the one created just above.
	        return this.defaultAuthContext;
	    };
	    /**
	     * The login callback function, called after user interactive login session is completed
	     * @param resolve the resolve callback for the promise created from the initialize call
	     */
	    AuthenticationManager.prototype._loginAndAcquire = function (resolve, reject) {
	        var _this = this;
	        var acquireAndResolve = function () {
	            // Check that we can acquire a token and then resolve the promise.
	            // Reject if an error occurs when acquiring the token.
	            _this.options.authContext.acquireToken(constants.resourceId, function (error) {
	                if (error) {
	                    reject(new Error(error));
	                }
	                else {
	                    var tokenEvent = {
	                        map: _this.map,
	                        type: AuthenticationManager.constants.events.tokenAcquired
	                    };
	                    _this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	                    resolve();
	                }
	            });
	        };
	        var cachedToken = this.options.authContext.getCachedToken(this.options.aadAppId);
	        var cachedUser = this.options.authContext.getCachedUser();
	        if (cachedToken && cachedUser) {
	            // If a cached token and user are available we should be able to
	            // acquire the access token and then resolve the promise.
	            acquireAndResolve();
	        }
	        else {
	            // If a login isn't already in progress start a new one.
	            if (!this.options.authContext.loginInProgress()) {
	                this.options.authContext.login();
	            }
	            // Poll for when the login done and then use the cached token.
	            var loginPoll_1 = setInterval(function () {
	                if (!_this.options.authContext.loginInProgress()) {
	                    // Stop polling for login done.
	                    clearInterval(loginPoll_1);
	                    if (_this.options.authContext.getCachedToken(_this.options.aadAppId)) {
	                        // If a token for the specified AAD app id is available we are ready
	                        // to acquire the access token and resolve the init promise.
	                        acquireAndResolve();
	                    }
	                    else {
	                        // If done logging in but no token for the specified AAD app ID is cached
	                        // then there is a mistake in the auth context config.
	                        reject(new Error(_this.options.authContext.getLoginError() ||
	                            "The AAD authentication context is not logged-in for the specified app ID: " +
	                                _this.options.aadAppId));
	                    }
	                }
	            }, 25);
	        }
	    };
	    /**
	     * Returns the current authentication type in use.
	     */
	    AuthenticationManager.prototype.getAuthType = function () {
	        return this.options.authType;
	    };
	    /**
	     * Returns the current client ID in use.
	     */
	    AuthenticationManager.prototype.getClientId = function () {
	        return this.options.clientId;
	    };
	    /**
	     * Returns the access token with an audience URI of https://atlas.microsoft.com.
	     */
	    AuthenticationManager.prototype.getToken = function () {
	        var _this = this;
	        if (this.options.authType === exports.AuthenticationType.aad) {
	            var token_1 = this.options.authContext.getCachedToken(constants.resourceId);
	            if (!token_1) {
	                if (!this.options.authContext.getCachedUser()) {
	                    // Login if a user isn't cached. This shouldn't typically happen.
	                    this.options.authContext.login();
	                }
	                this.options.authContext.acquireToken(constants.resourceId, function (error, renewedToken) {
	                    if (!error) {
	                        token_1 = renewedToken;
	                        var tokenEvent = {
	                            map: _this.map,
	                            type: AuthenticationManager.constants.events.tokenAcquired
	                        };
	                        _this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	                    }
	                });
	            }
	            return token_1;
	        }
	        else if (this.options.authType === exports.AuthenticationType.anonymous) {
	            var token = this._getItem(AuthenticationManager.constants.storage.accessTokenKey);
	            if (!token) {
	                // Cached Token not present, invoke the user provided callback function to fetch function
	                this._triggerTokenFetch();
	            }
	            else {
	                // check for cached token validity
	                var expiresIn = this._getTokenExpiry(token);
	                if (expiresIn < 300 && expiresIn > 0) {
	                    // We are within a window for the token expiry,
	                    // trigger a new token fetch, but still return the current token
	                    this._triggerTokenFetch();
	                }
	                else if (expiresIn <= 0) {
	                    // token renew failed and dont have a token.
	                    this._saveItem(AuthenticationManager.constants.storage.accessTokenKey, "");
	                    throw new Error(AuthenticationManager.constants.errors.tokenExpired);
	                }
	            }
	            return token;
	        }
	        else if (this.options.authType === exports.AuthenticationType.subscriptionKey) {
	            return this.options.subscriptionKey;
	        }
	    };
	    /**
	     * Given a token, calculate the time left for token expiry
	     * @param token
	     * @internal
	     */
	    AuthenticationManager.prototype._getTokenExpiry = function (token) {
	        var decodedToken = lib(token);
	        var expiresIn = decodedToken.exp;
	        var now = this._getCurrentTime();
	        return expiresIn - now > 0 ? expiresIn - now : -1;
	    };
	    /**
	     * stores the token
	     * @param token token fetched from the user's server endpoint
	     * @internal
	     */
	    AuthenticationManager.prototype._storeAccessToken = function (token) {
	        // Store the value
	        this._saveItem(AuthenticationManager.constants.storage.accessTokenKey, token);
	        var tokenEvent = {
	            map: this.map,
	            type: AuthenticationManager.constants.events.tokenAcquired
	        };
	        this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	    };
	    /**
	     * Saves the item to storage
	     * @param key key/identifier
	     * @param value value to be stored
	     */
	    AuthenticationManager.prototype._saveItem = function (key, value) {
	        if (this._supportsLocalStorage()) {
	            localStorage.setItem(key, value);
	            return true;
	        }
	        else if (this._supportsSessionStorage()) {
	            sessionStorage.setItem(key, value);
	            return true;
	        }
	        return false;
	    };
	    /**
	     * Gets an item saved in storage
	     * @param key Key/Identifier to be used for lookup
	     */
	    AuthenticationManager.prototype._getItem = function (key) {
	        if (this._supportsLocalStorage()) {
	            return localStorage.getItem(key);
	        }
	        else if (this._supportsSessionStorage()) {
	            return sessionStorage.getItem(key);
	        }
	        return null;
	    };
	    /**
	     * Returns true if browser supports localStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationManager.prototype._supportsLocalStorage = function () {
	        try {
	            if (!window.localStorage) {
	                return false;
	            } // Test availability
	            window.localStorage.setItem(AuthenticationManager.constants.storage.testStorageKey, "A"); // Try write
	            if (window.localStorage.getItem(AuthenticationManager.constants.storage.testStorageKey) !== "A") {
	                return false;
	            } // Test read/write
	            window.localStorage.removeItem(AuthenticationManager.constants.storage.testStorageKey); // Try delete
	            if (window.localStorage.getItem(AuthenticationManager.constants.storage.testStorageKey)) {
	                return false;
	            } // Test delete
	            return true; // Success
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * Returns true if browser supports sessionStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationManager.prototype._supportsSessionStorage = function () {
	        try {
	            if (!window.sessionStorage) {
	                return false;
	            } // Test availability
	            window.sessionStorage.setItem(AuthenticationManager.constants.storage.testStorageKey, "A"); // Try write
	            if (window.sessionStorage.getItem(AuthenticationManager.constants.storage.testStorageKey) !== "A") {
	                return false;
	            } // Test read/write
	            window.sessionStorage.removeItem(AuthenticationManager.constants.storage.testStorageKey); // Try delete
	            if (window.sessionStorage.getItem(AuthenticationManager.constants.storage.testStorageKey)) {
	                return false;
	            } // Test delete
	            return true; // Success
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * Return the number of milliseconds since 1970/01/01
	     * @ignore
	     */
	    AuthenticationManager.prototype._getCurrentTime = function () {
	        return Math.round(new Date().getTime() / 1000.0);
	    };
	    AuthenticationManager.prototype.signRequest = function (request) {
	        // Add the headers used for identifying a request is from the map control.
	        request.headers = request.headers || {};
	        request.headers[constants.sessionIdHeaderName] = this.sessionId;
	        request.headers[constants.msOriginHeaderName] = constants.msOriginHeaderValue;
	        request.headers[constants.mapAgentHeaderName] = "MapControl/" + version + " (Web)";
	        var token = this.getToken();
	        switch (this.options.authType) {
	            case exports.AuthenticationType.aad:
	            case exports.AuthenticationType.anonymous:
	                request.headers[constants.msClientIdHeaderName] = this.options.clientId;
	                request.headers[constants.authorizationHeaderName] = constants.authorizationTokenPrefix + token;
	                break;
	            case exports.AuthenticationType.subscriptionKey:
	                if ("url" in request) {
	                    if (request.url.indexOf("?") !== -1) {
	                        request.url += "&subscription-key=" + token;
	                    }
	                    else {
	                        request.url += "?&subscription-key=" + token;
	                    }
	                }
	                else if ("domain" in request) {
	                    request.queryParams = request.queryParams || {};
	                    request.queryParams["subscription-key"] = token;
	                }
	                else {
	                    throw new Error("Could not determine if the provided object was UrlOptions or RequestParameters");
	                }
	                break;
	            default:
	                throw new Error("An invalid authentication type was specified");
	        }
	        return request;
	    };
	    /**
	     * Constants for internal use
	     */
	    AuthenticationManager.constants = {
	        // Enable localStorage for IE, as sessionStorage does not work for localhost.
	        preferredCacheLocation: "localStorage",
	        storage: {
	            accessTokenKey: "access.token.key",
	            testStorageKey: "testStorage"
	        },
	        events: {
	            tokenAcquired: "tokenacquired"
	        },
	        tokenExpiresIn: 3599,
	        tokenRefreshClockSkew: 300,
	        errors: {
	            tokenExpired: "Token Expired, Try again"
	        }
	    };
	    return AuthenticationManager;
	}());

	/**
	 * A manager for the map control's controls.
	 * Exposed through the controls property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ControlManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function ControlManager(map) {
	        this.map = map;
	        // Add containers for map controls
	        this.controlContainer = document.createElement("div");
	        this.controlContainer.classList.add("atlas-control-container");
	        for (var controlPosition in exports.ControlPosition) {
	            if (exports.ControlPosition.hasOwnProperty(controlPosition)) {
	                var subcontrolContainer = document.createElement("div");
	                subcontrolContainer.classList.add(exports.ControlPosition[controlPosition]);
	                subcontrolContainer.classList.add("subcontrol-container");
	                this.controlContainer.appendChild(subcontrolContainer);
	            }
	        }
	        this.map.getMapContainer().appendChild(this.controlContainer);
	        this.controls = new Set();
	    }
	    /**
	     * Add a control(s) to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     */
	    ControlManager.prototype.add = function (control, options) {
	        if (Array.isArray(control)) {
	            for (var _i = 0, control_1 = control; _i < control_1.length; _i++) {
	                var c = control_1[_i];
	                this._add(c, options);
	            }
	        }
	        else {
	            this._add(control, options);
	        }
	    };
	    /**
	     * Gets an array of all controls on the map
	     */
	    ControlManager.prototype.getControls = function () {
	        return Array.from(this.controls);
	    };
	    /**
	     * Remove a control(s) from the map.
	     * @param control The control to remove.
	     */
	    ControlManager.prototype.remove = function (control) {
	        if (Array.isArray(control)) {
	            for (var _i = 0, control_2 = control; _i < control_2.length; _i++) {
	                var c = control_2[_i];
	                this._remove(c);
	            }
	        }
	        else {
	            this._remove(control);
	        }
	    };
	    /**
	     * Add a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._add = function (control, options) {
	        this.controls.add(control);
	        var controlOptions = new ControlOptions().merge(options);
	        var controlHtml = control.onAdd(this.map, options);
	        var subcontrolContainers = this.controlContainer.getElementsByClassName(controlOptions.position);
	        if (subcontrolContainers.length > 0) {
	            subcontrolContainers.item(0).appendChild(controlHtml);
	        }
	        else {
	            throw new Error("Control position " + controlOptions.position + " does not exist.");
	        }
	    };
	    /**
	     * Remove a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._remove = function (control) {
	        control.onRemove();
	        this.controls.delete(control);
	    };
	    return ControlManager;
	}());

	/**
	 * @private
	 */
	var MapCallbackHandler = /** @class */ (function () {
	    function MapCallbackHandler(map) {
	        // Dictionary keys represent the following: layer name -> event type -> user callback => [modified callback, once].
	        this.callbacks = new Dictionary();
	        this.map = map;
	    }
	    MapCallbackHandler.prototype.addCallback = function (eventType, layer, callback, legacy, once) {
	        var _this = this;
	        var modifiedCallback;
	        // If using legacy callbacks provide a MapEventData object to the user's callback
	        // Legacy callbacks cannot be added as once handles, so we don't need any logic for the once case.
	        if (legacy) {
	            modifiedCallback = function (data) {
	                var position = (data.lngLat) ?
	                    new Position(data.lngLat.lng, data.lngLat.lat) :
	                    undefined;
	                var coordinate = (data.point) ?
	                    [data.point.x, data.point.y] :
	                    undefined;
	                var features = (data.features) ?
	                    data.features.map(function (f) { return new Feature(f.geometry, f.properties, f.id); }) :
	                    [];
	                var mapEventData = {
	                    type: data.type,
	                    originalEvent: data.originalEvent,
	                    position: position,
	                    coordinate: coordinate,
	                    features: features
	                };
	                callback(mapEventData);
	            };
	        }
	        else {
	            var lastOriginalEvent_1;
	            switch (eventType) {
	                case "data":
	                case "sourcedata":
	                case "styledata":
	                    modifiedCallback = function (data) {
	                        var mapEventData = __assign(__assign({ dataType: data.dataType }, (data.dataType === "source" && __assign(__assign(__assign({ isSourceLoaded: data.isSourceLoaded }, (data.sourceDataType && { sourceDataType: data.sourceDataType })), { source: _this.map.sources.getById(data.sourceId) }), (data.tile && {
	                            tile: {
	                                id: {
	                                    x: data.tile.tileID.canonical.x,
	                                    y: data.tile.tileID.canonical.y,
	                                    z: data.tile.tileID.canonical.z
	                                },
	                                size: data.tile.tileSize,
	                                state: data.tile.state
	                            }
	                        })))), { map: _this.map, type: data.type });
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "error":
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            error: data.error,
	                            map: _this.map,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "touchstart":
	                case "touchend":
	                case "touchmove":
	                case "touchcancel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var pixels = (data.points) ?
	                            data.points.map(function (p) { return new Pixel(p.x, p.y); }) :
	                            [];
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var positions = (data.lngLats) ?
	                            data.lngLats.map(function (l) { return new Position(l.lng, l.lat); }) :
	                            [];
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            pixel: pixel,
	                            pixels: pixels,
	                            position: position,
	                            positions: positions,
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            preventDefault: data.preventDefault,
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "mousedown":
	                case "mouseup":
	                case "mouseover":
	                case "mousemove":
	                case "click":
	                case "dblclick":
	                case "mouseout":
	                case "mouseenter":
	                case "mouseleave":
	                case "contextmenu":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            position: position,
	                            pixel: pixel,
	                            preventDefault: data.preventDefault,
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "styleimagemissing":
	                    modifiedCallback = function (data) {
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(data.id);
	                    };
	                    break;
	                case "wheel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            preventDefault: data.preventDefault,
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "resize":
	                    // The resize event is technically one of the default callback types.
	                    // However, since users can specify custom eventData to add to the resize event
	                    // we need to make sure to include that in our modified callback.
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Add any extra properties to the modified callback data.
	                        // Skip the "type" and "target" properties as these are
	                        // replaced by the "type" and "map" properties above.
	                        for (var prop in data) {
	                            if (prop !== "type" && prop !== "target") {
	                                mapEventData[prop] = data[prop];
	                            }
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                default:
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Not every event will have an originalEvent property.
	                        // Only add this properties to our modified callback's data if it will be defined.
	                        if (data.originalEvent) {
	                            mapEventData.originalEvent = data.originalEvent;
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	            }
	        }
	        // Add an empty dictionary for the specified layer if one doesn't already exist.
	        if (!this.callbacks.has(layer)) {
	            this.callbacks.set(layer, new Dictionary());
	        }
	        // Add an empty dictionary for the specified event type if one doesn't already exist.
	        if (!this.callbacks.get(layer).has(eventType)) {
	            this.callbacks.get(layer).set(eventType, new Dictionary());
	        }
	        this.callbacks.get(layer).get(eventType).set(callback, [modifiedCallback, once]);
	    };
	    MapCallbackHandler.prototype.removeCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            this.callbacks.get(layer).get(eventType).delete(callback);
	        }
	    };
	    MapCallbackHandler.prototype.getModifiedCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            return this.callbacks.get(layer).get(eventType).get(callback)[0];
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getLayerCallbacks = function (layer) {
	        if (this.callbacks.has(layer)) {
	            return this.callbacks.get(layer);
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getEventCallbacks = function (eventType, layer) {
	        if (this.callbacks.has(layer)) {
	            var layerCallbacks = this.callbacks.get(layer);
	            if (layerCallbacks.has(eventType)) {
	                return layerCallbacks.get(eventType);
	            }
	        }
	        return undefined;
	    };
	    return MapCallbackHandler;
	}());

	// Disable unified signatures linter rule so we can generate separate docs for function overloads.
	// tslint:disable:unified-signatures
	/**
	 * A manager for the map control's events.
	 * Exposed through the events property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var EventManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function EventManager(map) {
	        this.map = map;
	        this.mapCallbackHandler = new MapCallbackHandler(this.map);
	    }
	    EventManager.prototype.add = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, false);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            for (var _i = 0, targetOrCallback_1 = targetOrCallback; _i < targetOrCallback_1.length; _i++) {
	                var target = targetOrCallback_1[_i];
	                if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                    this._addLayerListener(eventType, target, callback, false, false);
	                }
	                else {
	                    target._addEventListener(eventType, callback, false);
	                }
	            }
	        }
	    };
	    EventManager.prototype.addOnce = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, true);
	        }
	        else if (targetOrCallback instanceof Layer && Layer._isMBoxEvent(eventType)) {
	            this._addLayerListener(eventType, targetOrCallback, callback, false, true);
	        }
	        else {
	            targetOrCallback._addEventListener(eventType, callback, true);
	        }
	    };
	    EventManager.prototype._addLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, true, false);
	        }
	        else {
	            this._addLayerListener(eventType, targetOrCallback, callback, true, false);
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addLayerListener = function (eventType, target, callback, legacy, once) {
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var layer = this.map.layers.getLayerById(layerId);
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        // Must disable it on every Mapbox layer our layer builds.
	        if (modifiedCallback && layer) {
	            for (var _i = 0, _a = layer._getLayerIds(); _i < _a.length; _i++) {
	                var id = _a[_i];
	                this.map._getMap().off(eventType, id, modifiedCallback);
	            }
	        }
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, layerId, callback, legacy, once);
	        // If the layer already exists on the map immediately add the callbacks.
	        // Otherwise the callbacks will be added once the layer is added to the map.
	        if (layer) {
	            modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	            for (var _b = 0, _c = layer._getLayerIds(); _b < _c.length; _b++) {
	                var id = _c[_b];
	                this.map._getMap().on(eventType, id, modifiedCallback);
	            }
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addGlobalListener = function (eventType, callback, legacy, once) {
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // If a callback already exists disable it so the new one can replace it.
	        if (modifiedCallback) {
	            this.map._getMap().off(eventType, modifiedCallback);
	        }
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, "", callback, legacy, once);
	        modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // Enable the new modified callback on the Mapbox map.
	        if (eventType === "load" && this.map._isLoaded()) {
	            // Manually execute the callback if the load event has already fired.
	            // Use setTimeout to execute the callback async.
	            // This is for consistency with the case where the load event hasn't already fired.
	            // If the load event hasn't already fired the callback will also be executed async once it does fire.
	            var loadData_1 = { type: "load", map: this.map };
	            setTimeout(function () { return modifiedCallback(loadData_1); });
	        }
	        else if (eventType === "ready") {
	            // The ready event doesn't exist on the Mapbox map.
	            // Don't enable the callback for the Mapbox map.
	            if (this.map._isReady()) {
	                // Manually execute the callback if the ready event has already fired.
	                var readyData_1 = { type: "ready", map: this.map };
	                setTimeout(function () { return modifiedCallback(readyData_1); });
	            }
	        }
	        else {
	            this.map._getMap().on(eventType, modifiedCallback);
	        }
	    };
	    EventManager.prototype.invoke = function (eventType, targetOrArgs, args) {
	        // If args is undefined assume there is not target for the event.
	        if (typeof args === "undefined") {
	            // Empty string indicates the map global level.
	            this._invokeListeners(eventType, "", targetOrArgs);
	        }
	        else {
	            if (targetOrArgs instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                this._invokeListeners(eventType, targetOrArgs.getId(), args);
	            }
	            else if (targetOrArgs instanceof EventEmitter) {
	                targetOrArgs._invokeEvent(eventType, args);
	            }
	            else {
	                throw new Error("The invoke target is invalid.");
	            }
	        }
	    };
	    /**
	     * Invokes all listeners for the given event and layer.
	     * @param eventType The event type to invoke.
	     * @param layer The layer to invoke the event for. Use an empty string for map global events.
	     * @param args The data to pass to the listener callbacks.
	     * @private
	     */
	    EventManager.prototype._invokeListeners = function (eventType, layer, args) {
	        var _this = this;
	        var callbacks = this.mapCallbackHandler.getEventCallbacks(eventType, layer);
	        if (callbacks) {
	            callbacks.forEach(function (_a, callback) {
	                var _ = _a[0], once = _a[1];
	                // Invoking a listener this way circumvents the fire once logic in the modified callback.
	                // So we check if the callback was added as a fire once and if so remove it here.
	                if (once) {
	                    _this._removeListener(eventType, layer, callback);
	                }
	                callback(args);
	            });
	        }
	        else if (eventType === "error") {
	            // If there are no user specified callback for the error event print to console.
	            // tslint:disable-next-line:no-console
	            console.error("error" in args ? args.error : args);
	        }
	    };
	    EventManager.prototype.remove = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            for (var _i = 0, targetOrCallback_2 = targetOrCallback; _i < targetOrCallback_2.length; _i++) {
	                var target = targetOrCallback_2[_i];
	                if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                    this._removeListener(eventType, target, callback);
	                }
	                else {
	                    target._removeEventListener(eventType, callback);
	                }
	            }
	        }
	    };
	    EventManager.prototype._removeLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            this._removeListener(eventType, targetOrCallback, callback);
	        }
	    };
	    /**
	     * Removes a listener from the map or a single layer.
	     * Will remove the event listeners from the layer's underlying Mapbox layers too.
	     * @internal
	     */
	    EventManager.prototype._removeListener = function (eventType, target, callback) {
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        if (modifiedCallback) {
	            // An empty layerId indicates the listener is being removed from the global map.
	            if (layerId) {
	                // If a callback already exists disable it so the new one can replace it.
	                // Must disable it on every Mapbox layer our layer builds.
	                var layer = this.map.layers.getLayerById(layerId);
	                if (layer) {
	                    for (var _i = 0, _a = layer._getLayerIds(); _i < _a.length; _i++) {
	                        var id = _a[_i];
	                        this.map._getMap().off(eventType, id, modifiedCallback);
	                    }
	                }
	            }
	            else {
	                this.map._getMap().off(eventType, modifiedCallback);
	            }
	        }
	        this.mapCallbackHandler.removeCallback(eventType, layerId, callback);
	    };
	    /**
	     * Enables all the events associated with the specified layers.
	     * Enables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._enableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var modifiedCallback = _a[0];
	                    for (var _i = 0, _b = layer._getLayerIds(); _i < _b.length; _i++) {
	                        var mbLayerId = _b[_i];
	                        _this.map._getMap().on(eventType, mbLayerId, modifiedCallback);
	                    }
	                });
	            });
	        }
	    };
	    /**
	     * Disables all the events associated with the specified layers.
	     * Disables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._disableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var modifiedCallback = _a[0];
	                    for (var _i = 0, _b = layer._getLayerIds(); _i < _b.length; _i++) {
	                        var mbLayerId = _b[_i];
	                        _this.map._getMap().off(eventType, mbLayerId, modifiedCallback);
	                    }
	                });
	            });
	        }
	    };
	    return EventManager;
	}());

	/**
	 * A manager for the map control's HTML markers.
	 * Exposed through the markers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var HtmlMarkerManager = /** @class */ (function () {
	    /**
	     * Constructs the marker manager to be exposed only through the markers property of the Map class.
	     * @param map The map whose markers are being managed by this.
	     * @internal
	     */
	    function HtmlMarkerManager(map) {
	        this.markers = new Set();
	        this.map = map;
	    }
	    HtmlMarkerManager.prototype.add = function (element, position) {
	        if (Array.isArray(element)) {
	            for (var _i = 0, element_1 = element; _i < element_1.length; _i++) {
	                var marker = element_1[_i];
	                this._addMarker(marker, position);
	            }
	        }
	        else {
	            this._addMarker(element, position);
	        }
	    };
	    /**
	     * Adds a single marker.
	     */
	    HtmlMarkerManager.prototype._addMarker = function (marker, position) {
	        marker._addToMap(this.map, position);
	        this.markers.add(marker);
	    };
	    /**
	     * Gets an array of all the markers on the map.
	     */
	    HtmlMarkerManager.prototype.getMarkers = function () {
	        return Array.from(this.markers);
	    };
	    /**
	     * Removes one or more HTML markers from the map.
	     * @param marker A HtmlMarker instance, a string id of a marker's htmlContent, or an array of these.
	     */
	    HtmlMarkerManager.prototype.remove = function (marker) {
	        if (Array.isArray(marker)) {
	            for (var _i = 0, marker_1 = marker; _i < marker_1.length; _i++) {
	                var singleMarker = marker_1[_i];
	                this._removeMarker(singleMarker);
	            }
	        }
	        else {
	            this._removeMarker(marker);
	        }
	    };
	    /**
	     * Removes a single marker.
	     */
	    HtmlMarkerManager.prototype._removeMarker = function (marker) {
	        var _this = this;
	        if (marker instanceof HtmlMarker) {
	            marker._removeFromMap();
	            this.markers.delete(marker);
	        }
	        else {
	            this.markers.forEach(function (singleMarker) {
	                if (singleMarker._getId() === marker) {
	                    singleMarker._removeFromMap();
	                    _this.markers.delete(singleMarker);
	                }
	            });
	        }
	    };
	    /**
	     * Clears all markers.
	     */
	    HtmlMarkerManager.prototype.clear = function () {
	        var _this = this;
	        this.markers.forEach(function (singleMarker) {
	            singleMarker._removeFromMap();
	            _this.markers.delete(singleMarker);
	        });
	    };
	    return HtmlMarkerManager;
	}());

	/**
	 * A manager for the map control's image sprite.
	 * Exposed through the imageSprite property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ImageSpriteManager = /** @class */ (function () {
	    /**
	     * Constructs the image sprite manager to be exposed only through the imageSprite property of the Map class.
	     * @param map The Map object this will manage the image sprite for.
	     * @internal
	     */
	    function ImageSpriteManager(map) {
	        this.userImages = new Dictionary();
	        this.imageLoadTimeout = 5000;
	        this.map = map;
	    }
	    /**
	     * Add an icon image to the map's image sprite for use with symbols and patterns.
	     * @param id The image's id.
	     * If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param icon The image to add to the map's sprite. Can be a data URI, inline SVG, or image URL.
	     */
	    ImageSpriteManager.prototype.add = function (id, icon) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            // Take no action if the new image uses the id of a previously added image.
	            if (_this.userImages.has(id)) {
	                resolve();
	                return;
	            }
	            if (icon instanceof HTMLImageElement || icon instanceof ImageData) {
	                _this.map._getMap().addImage(id, icon);
	                _this.userImages.set(id, icon);
	                resolve();
	            }
	            else if (typeof icon === "string") {
	                var imageSrc = void 0;
	                // Assume an inline svg image string if icon doesn't start with "data:", but does include "<svg"
	                if (/<svg/i.test(icon) && !(/^data:/i.test(icon))) {
	                    imageSrc = "data:image/svg+xml;base64," + window.btoa(icon);
	                }
	                else {
	                    imageSrc = icon;
	                }
	                // Use a timer to prevent the request from waiting forever.
	                var timeoutId_1;
	                var timedOut_1 = false;
	                // Use the map to send the request so transformRequest is used.
	                _this.map._sendRequest(imageSrc, "Image").then(function (response) {
	                    if (!timedOut_1) {
	                        return response.blob();
	                    }
	                }).then(function (blob) {
	                    if (!timedOut_1) {
	                        clearTimeout(timeoutId_1);
	                        var imageEle_1 = new Image();
	                        // Wait for the blob to load into the element.
	                        imageEle_1.onload = function () {
	                            _this.map._getMap().addImage(id, imageEle_1);
	                            _this.userImages.set(id, imageEle_1);
	                            resolve();
	                        };
	                        // Reject if the blob failed to load in the element.
	                        imageEle_1.onerror = imageEle_1.onabort = function () {
	                            reject("Failed to load image into HTML element.");
	                        };
	                        // Convert the blob to a data url then load it into an Image element.
	                        imageEle_1.src = URL.createObjectURL(blob);
	                    }
	                }).catch(function () {
	                    if (!timedOut_1) {
	                        clearTimeout(timeoutId_1);
	                        reject("Failed to load image into HTML element.");
	                    }
	                });
	                // Allow the image a fixed amount of time to load the image before aborting.
	                timeoutId_1 = setTimeout(function () {
	                    timedOut_1 = true;
	                    reject("Failed to load image within specified timeout: " + _this.imageLoadTimeout + " ms.");
	                }, _this.imageLoadTimeout);
	            }
	        });
	    };
	    /**
	     * Removes all images added by the user.
	     */
	    ImageSpriteManager.prototype.clear = function () {
	        var _this = this;
	        this.userImages.forEach(function (image, id) {
	            _this.map._getMap().removeImage(id);
	        });
	        // Clear the list of user added image ids.
	        this.userImages.clear();
	    };
	    /**
	     * Gets a list of all the image ids that have been added to the maps image sprite.
	     */
	    ImageSpriteManager.prototype.getImageIds = function () {
	        var ids = [];
	        this.userImages.forEach(function (image, id) {
	            ids.push(id);
	        });
	        return ids;
	    };
	    /**
	     * Creates and adds an image to the maps image sprite. Provide the name of the built-in template to use, and a color to apply.
	     * Optionally, specifiy a secondary color if the template supports one. A scale can also be specified.
	     * This will allow the SVG to be scaled before it is converted into an image and thus look much better when scaled up.
	     * Returns a promise.
	     * Reference this in the Polygon or Symbol layer.
	     * @param id  The image's id. If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param templateName The name of the template to use.
	     * @param color The primary color value. Default: #1A73AA
	     * @param secondaryColor A secondary color value. Default: white
	     * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	     */
	    ImageSpriteManager.prototype.createFromTemplate = function (id, templateName, color, secondaryColor, scale) {
	        color = color || "#1A73AA";
	        secondaryColor = secondaryColor || "#fff";
	        var t = getImageTemplate(templateName, scale);
	        t = t.replace(/{color}/g, color).replace(/{secondaryColor}/g, secondaryColor).replace(/{text}/g, "");
	        return this.add(id, t);
	    };
	    /**
	     * Checks to see if an image is already loaded into the maps image sprite.
	     * @param id The id to check the map's image sprite for.
	     */
	    ImageSpriteManager.prototype.hasImage = function (id) {
	        return this.userImages.has(id);
	    };
	    /**
	     * Removes an image from the map's image sprite.
	     * @param id The id of the image to remove.
	     */
	    ImageSpriteManager.prototype.remove = function (id) {
	        this.map._getMap().removeImage(id);
	        this.userImages.delete(id);
	    };
	    /**
	     * Restores the images the user has added to the Mapbox image sprite.
	     * @internal
	     */
	    ImageSpriteManager.prototype._restoreImages = function () {
	        var _this = this;
	        // Check that all user added images still exist in the sprite after changing styles.
	        // Currently Mapbox doesn't support diff operations for sprites.
	        // Therefore changing a sprite will cause a full style rebuild.
	        this.userImages.forEach(function (image, id) {
	            if (!_this.map._getMap().hasImage(id)) {
	                _this.map._getMap().addImage(id, image);
	            }
	        });
	    };
	    return ImageSpriteManager;
	}());

	/**
	 * A manager for the map control's layers.
	 * Exposed through the layers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var LayerManager = /** @class */ (function () {
	    /**
	     * Constructs the layer manager to be exposed only through the layers property of the Map class.
	     * @param map The map whose layers are being managed by this.
	     * @internal
	     */
	    function LayerManager(map) {
	        this.layersById = new Dictionary();
	        this.layers = [];
	        this.map = map;
	    }
	    LayerManager.prototype.add = function (layer, before, update) {
	        if (update === void 0) { update = true; }
	        var beforeId = before instanceof Layer ?
	            before.getId() :
	            before;
	        if (Array.isArray(layer)) {
	            for (var _i = 0, layer_1 = layer; _i < layer_1.length; _i++) {
	                var singleLayer = layer_1[_i];
	                this._addLayer(singleLayer, beforeId, update);
	            }
	        }
	        else {
	            this._addLayer(layer, beforeId, update);
	        }
	    };
	    /**
	     * Adds a single layer to the map.
	     * Update should only be false if a call to setStyle will immediately follow.
	     * @private
	     */
	    LayerManager.prototype._addLayer = function (layer, before, update) {
	        if (before !== layer.getId() && this.layersById.has(before)) {
	            if (this.layersById.has(layer.getId())) {
	                // Replace the existing layer with the new one.
	                // Place the new layer behind the specified before layer.
	                var layerIndex = this.layers.findIndex(function (l) { return l.getId() === layer.getId(); });
	                if (update) {
	                    this._removeMapboxLayers(this.layers[layerIndex]);
	                    this._addMapboxLayers(layer, before);
	                }
	                this.layers[layerIndex].onRemove();
	                layer.onAdd(this.map);
	                // Update any events associated with these layers
	                this.map.events._disableLayerEvents(this.layers[layerIndex]);
	                this.map.events._enableLayerEvents(layer);
	                this.layersById.set(layer.getId(), layer);
	                this.layers.splice(layerIndex, 1);
	                var beforeIndex = this.layers.findIndex(function (l) { return l.getId() === before; });
	                this.layers.splice(beforeIndex, 0, layer);
	            }
	            else {
	                // Add the new layer behind the specified before layer.
	                if (update) {
	                    this._addMapboxLayers(layer, before);
	                }
	                var beforeIndex = this.layers.findIndex(function (l) { return l.getId() === before; });
	                this.layers.splice(beforeIndex, 0, layer);
	                this.layersById.set(layer.getId(), layer);
	                // Update the layer's map reference and any events associated with this layer.
	                layer.onAdd(this.map);
	                this.map.events._enableLayerEvents(layer);
	            }
	        }
	        else {
	            if (this.layersById.has(layer.getId())) {
	                // Replace the existing layer with the new one.
	                var layerIndex = this.layers.findIndex(function (l) { return l.getId() === layer.getId(); });
	                if (update) {
	                    this._removeMapboxLayers(this.layers[layerIndex]);
	                    this._addMapboxLayers(layer, layerIndex + 1);
	                }
	                this.layers[layerIndex].onRemove();
	                layer.onAdd(this.map);
	                // Update any events associated with these layers
	                this.map.events._disableLayerEvents(this.layers[layerIndex]);
	                this.map.events._enableLayerEvents(layer);
	                this.layersById.set(layer.getId(), layer);
	                this.layers[layerIndex] = layer;
	            }
	            else {
	                // Add the layer to the top of the z-order.
	                if (update) {
	                    this._addMapboxLayers(layer);
	                }
	                this.layersById.set(layer.getId(), layer);
	                this.layers.push(layer);
	                // Update the layer's map reference and any events associated with this layer.
	                layer.onAdd(this.map);
	                this.map.events._enableLayerEvents(layer);
	            }
	        }
	    };
	    /**
	     * Adds all the Mapbox layers built by an atlas layer to the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._addMapboxLayers = function (layer, before) {
	        // Check if the map ready before adding any layers.
	        if (!this.map._isReady()) {
	            throw new Error("The layer '" + layer.getId() + "' could not be added to the map because " +
	                "the map is not ready. Please use a ready event listener to guarantee " +
	                "the map is ready before adding a layer to it.");
	        }
	        // if the TileLayer's tile URL isn't defined yet, don't add the source and layer.
	        if (layer instanceof TileLayer && !layer.getOptions().tileUrl) {
	            return;
	        }
	        // SourceBuildingLayers are a special case because they create their own source and manage it internally.
	        // If adding a SourceBuildingLayer the source associated must also be added.
	        if (layer instanceof SourceBuildingLayer) {
	            this.map._getMap().addSource(layer._getSourceId(), layer._buildSource());
	        }
	        var mbBefore = this._getMapboxBefore(before);
	        for (var _i = 0, _a = layer._buildLayers(); _i < _a.length; _i++) {
	            var mbLayer = _a[_i];
	            this.map._getMap().addLayer(mbLayer, mbBefore);
	        }
	    };
	    /**
	     * Removes all the Mapbox layers built by an atlas layer from the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._removeMapboxLayers = function (layer) {
	        for (var _i = 0, _a = layer._getLayerIds(); _i < _a.length; _i++) {
	            var mbLayerId = _a[_i];
	            // Check if the layer does exist just in case a call to _addNoUpdate(...) occurred.
	            if (this.map._getMap().getLayer(mbLayerId)) {
	                this.map._getMap().removeLayer(mbLayerId);
	            }
	        }
	        // SourceBuildingLayer are a special case because they create their own source and manage it internally.
	        // If removing a SourceBuildingLayer the source associated must also be removed.
	        if (layer instanceof SourceBuildingLayer &&
	            this.map._getMap().getSource(layer._getSourceId())) {
	            this.map._getMap().removeSource(layer._getSourceId());
	        }
	    };
	    /**
	     * Gets the ID of the Mapbox layer to add before given the id of the atlas before layer.
	     * @private
	     */
	    LayerManager.prototype._getMapboxBefore = function (before) {
	        // If passed a string use it as the name of an atlas layer.
	        if (typeof before === "string") {
	            var beforeLayer = this.layersById.get(before);
	            // If the before layer exists iterate over the mapbox layers
	            // it would build until a layer exists on the mapbox map.
	            if (beforeLayer) {
	                for (var _i = 0, _a = beforeLayer._getLayerIds(); _i < _a.length; _i++) {
	                    var layerId = _a[_i];
	                    if (this.map._getMap().getLayer(layerId)) {
	                        return layerId;
	                    }
	                }
	                // If none of the layers built by the specified before layer
	                // actually exists on the map start checking the next layers.
	                before = this.layers.findIndex(function (l) { return l.getId() === before; }) + 1;
	            }
	            else {
	                // If the before layer hasn't been added just return undefined.
	                return undefined;
	            }
	        }
	        // If passed a number assume it is the index of the before layer.
	        // Or the string passed didn't lead to finding any existing mapbox layers.
	        //
	        // Iterate over all layers at or after the before index until one of
	        // the mapbox layers built by an atlas layer exists in the mapbox map.
	        for (var i = before; i < this.layers.length; i++) {
	            for (var _b = 0, _c = this.layers[i]._getLayerIds(); _b < _c.length; _b++) {
	                var layerId = _c[_b];
	                if (this.map._getMap().getLayer(layerId)) {
	                    return layerId;
	                }
	            }
	        }
	        // If nothing was found just return undefined.
	        return undefined;
	    };
	    /**
	     * Removes all user added layers from the map.
	     */
	    LayerManager.prototype.clear = function () {
	        for (var layerIndex = this.layers.length - 1; layerIndex >= 0; layerIndex--) {
	            this._removeMapboxLayers(this.layers[layerIndex]);
	            this.layers[layerIndex].onRemove();
	            this.map.events._disableLayerEvents(this.layers[layerIndex]);
	            this.layersById.delete(this.layers[layerIndex].getId());
	            this.layers.splice(layerIndex, 1);
	        }
	    };
	    /**
	     * Retrieves a layer with the specified id.
	     * @param id The id of the layer to retrieve.
	     */
	    LayerManager.prototype.getLayerById = function (id) {
	        return this.layersById.get(id);
	    };
	    /**
	     * Retrieves all layers that have been added to the map.
	     */
	    LayerManager.prototype.getLayers = function () {
	        return this.layers.slice(0);
	    };
	    /**
	     * Returns a set of all the source IDs that any layers depend on.
	     * @internal
	     */
	    LayerManager.prototype._getSourceIds = function () {
	        var ids = new Set();
	        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
	            var layer = _a[_i];
	            layer._getSourceIds().forEach(function (id) { return ids.add(id); });
	        }
	        return ids;
	    };
	    /**
	     * Moves a layer to a different z-position.
	     * @param layer The layer or id of the layer to move.
	     * @param before Optionally specify to move the layer before this.
	     */
	    LayerManager.prototype.move = function (layer, before) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        var beforeId = before instanceof Layer ? before.getId() : before;
	        if (!this.layersById.has(layerId)) {
	            throw new Error("The layer '" + layerId + "' has not been added to the map and cannot be moved.");
	        }
	        var layerIndex = this.layers.findIndex(function (l) { return l.getId() === layerId; });
	        this._moveMapboxLayers(this.layers[layerIndex], beforeId);
	        layer = this.layers[layerIndex];
	        this.layers.splice(layerIndex, 1);
	        if (this.layersById.has(beforeId)) {
	            var beforeIndex = this.layers.findIndex(function (l) { return l.getId() === beforeId; });
	            this.layers.splice(beforeIndex, 0, layer);
	        }
	        else {
	            this.layers.push(layer);
	        }
	    };
	    LayerManager.prototype._moveMapboxLayers = function (layer, before) {
	        var mbBefore = this._getMapboxBefore(before);
	        for (var _i = 0, _a = layer._getLayerIds(); _i < _a.length; _i++) {
	            var mbLayerId = _a[_i];
	            this.map._getMap().moveLayer(mbLayerId, mbBefore);
	        }
	    };
	    /**
	     * Retrieve all Shapes and GeoJSON features that are visible on the map that are in a DataSource or VectorTileSource.
	     * Shape objects are editable, while Feature objects are not editable and either reside in a VectorTileSource or represent a cluster point.
	     * Clusters have the following properties:
	     * <p>cluster: `boolean` - Indicates that the point is a cluster.
	     * This will be set to true if Point object represents a cluster.
	     * All other point objects are unlikely to have this value unless
	     * a property with this same name was added to the Point property data from your app.</p>
	     * <p>cluster_id: `string` - A unique id for the cluster.</p>
	     * <p>point_count: `number` - The number of points inside the cluster.</p>
	     * <p>point_count_abbreviated: `string` - An abbreviated string version of the point count. i.e. `"10K"`</p>
	     * Features/Shapes that are not visible or who's layer zoom range does not include the current zoom level will not be returned.
	     * Symbol features/Shapes that have been hidden due to text or icon collisions are not included.
	     * Features/Shapes from all other layers are included even if they have no contribution to the map rendering, e.g. alpha set to zero.
	     * The topmost rendered features/shapes appears first in the returned array and subsequent features are sorted in descending z-order.
	     * @param geometry A Position, Point, or BoundingBox that returned features must intersect. If not specified the whole visible world is used.
	     * @param layers An array of layers or their ids to limit the query to.
	     * @param filter A expression to filter the returned features by.
	     */
	    LayerManager.prototype.getRenderedShapes = function (geometry, layers, filter) {
	        var _this = this;
	        // If no geometry was provided use a bounding box covering the whole world.
	        if (!geometry) {
	            geometry = [-180, -85.0511, 180, 85.0511];
	        }
	        // Mapbox's queryRenderedFeatures uses screen coordinates not GeoJSON positions.
	        // Here we convert the input bounding box or point into screen coordinates.
	        var scope;
	        if (Array.isArray(geometry)) {
	            if (geometry.length === 4 || geometry.length === 6) {
	                // BoundingBox has length of 4 or 6: [west, south, east, north] or [west, south, elevation1, east, north, elevation2]
	                scope = this.map.positionsToPixels([
	                    BoundingBox.getSouthWest(geometry),
	                    BoundingBox.getNorthEast(geometry)
	                ]);
	            }
	            else if (geometry.length === 2 || geometry.length === 3) {
	                // Position has length of 2, or 3: [lon, lat] or [lon, lat, elv]
	                scope = this.map.positionsToPixels([geometry])[0];
	            }
	        }
	        else {
	            scope = this.map.positionsToPixels([geometry.coordinates])[0];
	        }
	        // Create an array of all the mapbox layer ids that make up the layers specified by the user.
	        // Skip any mapbox layer ids that don't currently exist in the mapbox style.
	        var layerIds;
	        if (layers) {
	            layers = Array.isArray(layers) ? layers : [layers];
	            layerIds = [];
	            for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
	                var layer = layers_1[_i];
	                var layerId = layer instanceof Layer ? layer.getId() : layer;
	                // If a specified layer hasn't been added to the map throw an error.
	                if (this.layersById.has(layerId)) {
	                    layerIds.push.apply(layerIds, this.layersById.get(layerId)._getLayerIds()
	                        .filter(function (id) { return !!_this.map._getMap().getLayer(id); }));
	                }
	                else {
	                    throw new Error("The layer '" + layerId + "' has not been added to the map " +
	                        "and its rendered features cannot be retrieved.");
	                }
	            }
	        }
	        // Use queryRenderedFeatures to get a basic list of the features
	        // within the scope and belonging to the specified layers.
	        var features = this.map._getMap().queryRenderedFeatures(scope, {
	            layers: layerIds,
	            filter: filter
	        });
	        // Any features belonging to a DataSource will be mapped to the Shapes that wrap them.
	        return this.map.sources._mapFeaturesToShapes(features);
	    };
	    LayerManager.prototype.remove = function (layer, update) {
	        if (update === void 0) { update = true; }
	        if (Array.isArray(layer)) {
	            for (var _i = 0, layer_2 = layer; _i < layer_2.length; _i++) {
	                var singleLayer = layer_2[_i];
	                this._removeLayer(singleLayer, update);
	            }
	        }
	        else {
	            this._removeLayer(layer, update);
	        }
	    };
	    /**
	     * Removes a single layer from the map.
	     * @private
	     */
	    LayerManager.prototype._removeLayer = function (layer, update) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        if (!this.layersById.has(layerId)) {
	            throw new Error("The layer '" + layerId + "' has not been added to the map and cannot be removed.");
	        }
	        var layerIndex = this.layers.findIndex(function (l) { return l.getId() === layerId; });
	        if (update) {
	            this._removeMapboxLayers(this.layers[layerIndex]);
	        }
	        this.layers[layerIndex].onRemove();
	        this.map.events._disableLayerEvents(this.layers[layerIndex]);
	        this.layersById.delete(layerId);
	        this.layers.splice(layerIndex, 1);
	    };
	    return LayerManager;
	}());

	/**
	 * A manager for the map control's popups.
	 * Exposed through the `popups` property of the `atlas.Map` class.
	 * Cannot be instantiated by the user.
	 */
	var PopupManager = /** @class */ (function () {
	    /**
	     * Constructs the popup manager to be exposed only through the `popups` property of the `Map` class.
	     * @param map The map whose popups are being managed by this.
	     * @internal
	     */
	    function PopupManager(map) {
	        var _this = this;
	        /**
	         * Listens for mouse or touch movement when dragging popups.
	         */
	        this._onDrag = function (event) {
	            // Determine the new x and y from the event data.
	            var x;
	            var y;
	            if (event.type === "mousemove") {
	                event = event;
	                x = event.clientX;
	                y = event.clientY;
	            }
	            else if (event.type === "touchmove") {
	                event = event;
	                x = event.touches[0].clientX;
	                y = event.touches[0].clientY;
	            }
	            _this.draggedPopups.forEach(function (popup) {
	                popup._dragToPixel([x, y]);
	            });
	        };
	        /**
	         * Listens for mouse up or touch end to indicate popups aren't being dragged anymore.
	         */
	        this._onUp = function () {
	            // Remove the listeners since no popups are being dragged anymore.
	            _this.map.getMapContainer().removeEventListener("mousemove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("touchmove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("mouseup", _this._onUp);
	            _this.map.getMapContainer().removeEventListener("touchend", _this._onUp);
	            _this.draggedPopups.forEach(function (popup) {
	                _this.draggedPopups.delete(popup);
	                popup._onUp();
	            });
	        };
	        this.map = map;
	        this.popups = new Set();
	        this.draggedPopups = new Set();
	    }
	    /**
	     * Adds a popup to the map
	     * @param popup The popup(s) to add.
	     */
	    PopupManager.prototype.add = function (popup) {
	        popup = Array.isArray(popup) ? popup : [popup];
	        for (var _i = 0, popup_1 = popup; _i < popup_1.length; _i++) {
	            var p = popup_1[_i];
	            if (!this.popups.has(p)) {
	                this.popups.add(p);
	                p.attach(this.map);
	            }
	        }
	    };
	    /**
	     * Removes all popups from the map.
	     */
	    PopupManager.prototype.clear = function () {
	        var _this = this;
	        this.popups.forEach(function (popup) {
	            _this.popups.delete(popup);
	            popup.remove();
	        });
	    };
	    /**
	     * Removes a popup from the map
	     * @param popup The popup(s) to remove.
	     */
	    PopupManager.prototype.remove = function (popup) {
	        popup = Array.isArray(popup) ? popup : [popup];
	        for (var _i = 0, popup_2 = popup; _i < popup_2.length; _i++) {
	            var p = popup_2[_i];
	            if (this.popups.has(p)) {
	                this.popups.delete(p);
	                p.remove();
	            }
	        }
	    };
	    /**
	     * Returns the popups currently attached to the map.
	     */
	    PopupManager.prototype.getPopups = function () {
	        return Array.from(this.popups);
	    };
	    /**
	     * Returns the div element that should contain all the popup containers.
	     * Creates it if it doesn't already exist.
	     * @internal
	     */
	    PopupManager.prototype._getCollectionDiv = function () {
	        var collection = this.map.getMapContainer()
	            .querySelector("." + PopupManager.Css.collection);
	        if (!collection) {
	            // If the collection div doesn't exist create it.
	            collection = document.createElement("div");
	            collection.classList.add(PopupManager.Css.collection);
	            collection.setAttribute("role", "region");
	            collection.setAttribute("aria-label", "Map Information");
	            this.map.getMapContainer().appendChild(collection);
	        }
	        return collection;
	    };
	    /**
	     * Adds a popup to the set of popups actively being dragged.
	     * @internal
	     */
	    PopupManager.prototype._addDraggedPopup = function (popup) {
	        // If no popups are being dragged yet add the listeners.
	        if (this.draggedPopups.size === 0) {
	            this.map.getMapContainer().addEventListener("mousemove", this._onDrag);
	            this.map.getMapContainer().addEventListener("touchmove", this._onDrag);
	            this.map.getMapContainer().addEventListener("mouseup", this._onUp);
	            this.map.getMapContainer().addEventListener("touchend", this._onUp);
	        }
	        // Track the popups being dragged for the mousemove events.
	        this.draggedPopups.add(popup);
	    };
	    PopupManager.Css = {
	        collection: "popup-collection-container"
	    };
	    return PopupManager;
	}());

	/**
	 * A manager for the map control's sources.
	 * Exposed through the sources property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var SourceManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function SourceManager(map) {
	        this.map = map;
	        this.sources = new Dictionary();
	    }
	    SourceManager.prototype.add = function (source, update) {
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
	                var singleSource = source_1[_i];
	                this._addSource(singleSource, update);
	            }
	        }
	        else {
	            this._addSource(source, update);
	        }
	    };
	    /**
	     * Returns all rendered shape features in a source that match a specified filter. If the source is a vector tile source, a source layer name needs to be specified.
	     * @param source source to be queried
	     * @param filter a filter to limit the query
	     * @param sourceLayer the layer where shapes and features are matched
	     */
	    SourceManager.prototype.getRenderedShapes = function (source, filter, sourceLayer) {
	        var sourceID = typeof source === "string" ? source : source.getId();
	        var features = this.map._getMap().querySourceFeatures(sourceID, { sourceLayer: sourceLayer, filter: filter });
	        return this.map.sources._mapFeaturesToShapes(features, true, this.sources.get(sourceID));
	    };
	    // TODO: wait till the mapbox's bug is fixed
	    // /**
	    //  * Gets the state of a feature
	    //  * @param shape the ID of the shape
	    //  * @param source the ID of the source
	    //  * @param sourceLayer the ID of the layer
	    //  */
	    // public getFeatureState(shape: string | Shape | Feature<Geometry, any>, source: string | Source, sourceLayer?: string): object {
	    //     let featureID;
	    //     if (typeof shape === "string") {
	    //         featureID = shape;
	    //     } else {
	    //         featureID = shape instanceof Shape ? shape.getId() : shape.id;
	    //     }
	    //     const featureSource = typeof source === "string" ? source : source.getId();
	    //     return this.map._getMap().getFeatureState({ id: featureID, source: featureSource, sourceLayer: sourceLayer });
	    // }
	    // /**
	    //  * Removes the state or a single key value of the state of a feature.
	    //  * @param shape the ID of the shape
	    //  * @param source the ID of the source
	    //  * @param sourceLayer the ID of the layer
	    //  * @param key the key in the feature state to update
	    //  */
	    // public removeFeatureState(shape: string | Shape | Feature<Geometry, any>, source: string | Source, sourceLayer?: string, key?: string) {
	    //     let featureID;
	    //     if (typeof shape === "string") {
	    //         featureID = shape;
	    //     } else {
	    //         featureID = shape instanceof Shape ? shape.getId() : shape.id;
	    //     }
	    //     const featureSource = typeof source === "string" ? source : source.getId();
	    //     // TODO: update the method when the mapbox typing file is updated
	    //     (this.map._getMap() as any).removeFeatureState({ id: featureID, source: featureSource, sourceLayer: sourceLayer }, key);
	    // }
	    // /**
	    //  * Sets the state of the feature by passing in a key value pair object.
	    //  * @param shape the ID of the shape
	    //  * @param source the ID of the source
	    //  * @param sourceLayer the ID of the layer
	    //  * @param key the key in the feature state to update
	    //  */
	    // public setFeatureState(shape: string | Shape | Feature<Geometry, any>, source: string | Source, state: object, sourceLayer?: string) {
	    //     let featureID;
	    //     if (typeof shape === "string") {
	    //         featureID = shape;
	    //     } else {
	    //         featureID = shape instanceof Shape ? shape.getId() : shape.id;
	    //     }
	    //     const featureSource = typeof source === "string" ? source : source.getId();
	    //     // TODO: update the method when the mapbox typing file is updated
	    //     this.map._getMap().setFeatureState({ id: featureID, source: featureSource, sourceLayer: sourceLayer }, state);
	    // }
	    /**
	     * @internal
	     */
	    SourceManager.prototype._buildSources = function () {
	        var ret = {};
	        this.sources.forEach(function (source) {
	            ret[source.getId()] = source._buildSource();
	        });
	        return ret;
	    };
	    /**
	     * Removes all sources from the map.
	     */
	    SourceManager.prototype.clear = function () {
	        var _this = this;
	        this.sources.forEach(function (source) {
	            _this.remove(source);
	        });
	    };
	    /**
	     * Retrieves a source with the specified id.
	     * @param id
	     */
	    SourceManager.prototype.getById = function (id) {
	        return this.sources.get(id);
	    };
	    /**
	     * Retrieves all sources that have been added to the map.
	     */
	    SourceManager.prototype.getSources = function () {
	        return Array.from(this.sources.values());
	    };
	    /**
	     * Returns a boolean indicating if the source is loaded or not.
	     * @param source The id of a source or a Source object.
	     */
	    SourceManager.prototype.isSourceLoaded = function (source) {
	        var id = source instanceof Source ? source.getId() : source;
	        return this.map._getMap().isSourceLoaded(id);
	    };
	    SourceManager.prototype.remove = function (source, update) {
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            for (var _i = 0, source_2 = source; _i < source_2.length; _i++) {
	                var singleSource = source_2[_i];
	                this._removeSource(singleSource, update);
	            }
	        }
	        else {
	            this._removeSource(source, update);
	        }
	    };
	    SourceManager.prototype._removeSource = function (source, update) {
	        var id = source instanceof Source ? source.getId() : source;
	        if (this.sources.has(id)) {
	            if (this.map._getMap().getSource(id) && update) {
	                this.map._getMap().removeSource(id);
	            }
	            if (!this.map._getMap().getSource(id) || !update) {
	                this.sources.get(id)._setMap(null);
	                this.sources.delete(id);
	            }
	            else {
	                throw new Error("One or more layers have a dependency on the source '" + id + "'");
	            }
	            return;
	        }
	        throw new Error("'" + id + "' is not added to the map");
	    };
	    SourceManager.prototype._addSource = function (source, update) {
	        // If adding a source that shares an id with an existing source throw an error unless update is false.
	        // Update being false assumes that a call to map.setStyle(...) will occurs soon.
	        if (this.sources.has(source.getId())) {
	            if (update) {
	                throw new Error("'" + source.getId() + "' is already added to the map");
	            }
	            else {
	                this.sources.get(source.getId())._setMap(null);
	                this.sources.delete(source.getId());
	            }
	        }
	        if (update) {
	            // Check if the map is ready before adding any sources.
	            if (!this.map._isReady()) {
	                throw new Error("The source '" + source.getId() + "' could not be added to the map because " +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before adding a source to it.");
	            }
	            this.map._getMap().addSource(source.getId(), source._buildSource());
	        }
	        this.sources.set(source.getId(), source);
	        source._setMap(this.map);
	    };
	    /**
	     * Converts an array of features as returned by one of Mapbox's query*Features(...) function
	     * to an array of our features or shapes if one is currently wrapping the feature.
	     * @internal
	     */
	    SourceManager.prototype._mapFeaturesToShapes = function (features, shapesOnly, dataSource) {
	        var shapesOrFeatures = [];
	        for (var _i = 0, features_1 = features; _i < features_1.length; _i++) {
	            var feature = features_1[_i];
	            if ((dataSource || typeof feature["source"] === "string") &&
	                typeof feature.properties[Shape._shapeIdPropName] === "string") {
	                var source = dataSource || this.sources.get(feature["source"]);
	                if (source instanceof DataSource) {
	                    var shape = source.getShapeById(feature.properties[Shape._shapeIdPropName]);
	                    if (shape instanceof Shape) {
	                        shapesOrFeatures.push(shape);
	                        continue;
	                    }
	                }
	            }
	            if (!shapesOnly) {
	                // If the feature couldn't be matched to a shape in a DataSource
	                // just return the feature data as provided by mapbox.
	                shapesOrFeatures.push(feature);
	            }
	        }
	        return shapesOrFeatures;
	    };
	    return SourceManager;
	}());

	/**
	 * The options for animating changes to the map control's camera.
	 */
	var AnimationOptions = /** @class */ (function (_super) {
	    __extends(AnimationOptions, _super);
	    function AnimationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The duration of the animation in milliseconds.
	         * Default `1000`.
	         * @default 1000
	         */
	        _this.duration = 1000;
	        /**
	         * The type of animation.
	         * <p>"jump" is an immediate change.</p>
	         * <p>"ease" is a gradual change of the camera's settings.</p>
	         * <p>"fly" is a gradual change of the camera's settings following an arc resembling flight.</p>
	         * Default `"jump"`.
	         * @default "jump"
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        _this.type = "jump";
	        return _this;
	    }
	    return AnimationOptions;
	}(Options));

	/**
	 * Represent the amount of padding in pixels to add to the side of a BoundingBox when setting the camera of a map.
	 */
	var Padding = /** @class */ (function (_super) {
	    __extends(Padding, _super);
	    function Padding() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Amount of padding in pixels to add to the bottom.
	         * default `0`
	         * @default 0
	         */
	        _this.bottom = 0;
	        /**
	         * Amount of padding in pixels to add to the left.
	         * default `0`
	         * @default 0
	         */
	        _this.left = 0;
	        /**
	         * Amount of padding in pixels to add to the right.
	         * default `0`
	         * @default 0
	         */
	        _this.right = 0;
	        /**
	         * Amount of padding in pixels to add to the top.
	         * default `0`
	         * @default 0
	         */
	        _this.top = 0;
	        return _this;
	    }
	    return Padding;
	}(Options));

	/**
	 * The options for setting the bounds of the map control's camera.
	 */
	var CameraBoundsOptions = /** @class */ (function (_super) {
	    __extends(CameraBoundsOptions, _super);
	    function CameraBoundsOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The bounds of the map control's camera.
	         * Default `[-180, -89, 180, 90]`.
	         * @default [-180, -89, 180, 90]
	         */
	        _this.bounds = [-180, -89, 180, 90];
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        /**
	         * The maximum zoom level to allow when the map view transitions to the specified bounds.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * An offset of the center of the given bounds relative to the map's center, measured in pixels.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * The amount of padding in pixels to add to the given bounds.
	         * Default `{top: 0, bottom: 0, left: 0, right: 0}`.
	         * @default {top: 0, bottom: 0, left: 0, right: 0}
	         */
	        _this.padding = new Padding();
	        return _this;
	    }
	    /**
	     * overwriting merge to accept one value for padding
	     */
	    CameraBoundsOptions.prototype.merge = function () {
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        for (var _a = 0, valuesList_1 = valuesList; _a < valuesList_1.length; _a++) {
	            var value = valuesList_1[_a];
	            if (value && typeof value.padding === "number") {
	                value.padding = {
	                    top: value.padding,
	                    bottom: value.padding,
	                    left: value.padding,
	                    right: value.padding
	                };
	            }
	        }
	        return _super.prototype.merge.apply(this, valuesList);
	    };
	    return CameraBoundsOptions;
	}(Options));

	/**
	 * The options for setting the map control's camera.
	 */
	var CameraOptions = /** @class */ (function (_super) {
	    __extends(CameraOptions, _super);
	    function CameraOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The zoom level of the map view.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoom = 1;
	        /**
	         * The position to align the center of the map view with.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.center = new Position(0, 0);
	        /**
	         * A pixel offset to apply to the center of the map.
	         * This is useful if you want to programmatically pan the map to another location or if you want to center the map over a shape, then offset the maps view to make room for a popup.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.centerOffset = new Pixel(0, 0);
	        /**
	         * The bearing of the map (rotation) in degrees. When the bearing is 0, 90, 180, or 270 the top of the map container will be north, east, south or west respectively.
	         * Default `0`.
	         * @default 0
	         */
	        _this.bearing = 0;
	        /**
	         * The pitch (tilt) of the map in degrees between 0 and 60, where 0 is looking straight down on the map.
	         * Default `0`.
	         * @default 0
	         */
	        _this.pitch = 0;
	        /**
	         * The minimum zoom level that the map can be zoomed out to during the animation. Must be between 0 and 24, and less than or equal to `maxZoom`.
	         * Default `1`.
	         * @default 1
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom level that the map can be zoomed into during the animation. Must be between 0 and 24, and greater than or equal to `minZoom`.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        return _this;
	    }
	    return CameraOptions;
	}(Options));

	/**
	 * The options for a layer of the map.
	 */
	var LayerOptions$1 = /** @class */ (function (_super) {
	    __extends(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = undefined;
	        /**
	         * The name of the layer to place this layer before.  If not specified, the layer will be placed at the top of the
	         * layer list.
	         */
	        _this.before = undefined;
	        /**
	         * The minimum zoom at which the layer will display inclusive.
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom at which the layer will display inclusive.
	         */
	        _this.maxZoom = 20;
	        /**
	         * Whether to overwrite previous data for the layer.
	         */
	        _this.overwrite = false;
	        /**
	         * Whether to defer the layer's updates to the map until a subsequent layer's update or an update to the map's
	         * style options.
	         */
	        _this.defer = false;
	        /**
	         * The opacity of the layer.
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return LayerOptions;
	}(Options));

	/**
	 * The options for a circle layer.
	 * @deprecated Use BubbleLayerOptions with atlas.layer.BubbleLayer instead.
	 */
	var CircleLayerOptions = /** @class */ (function (_super) {
	    __extends(CircleLayerOptions, _super);
	    function CircleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the circles for the layer. Is used as the default if a fill color is not specified for a
	         * circle.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the circles for the layer. Is used as the default if an outline color is not specified for
	         * a circle.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The radius in pixels of the circles for the layer. Is used as the default if a radius is not specified for a
	         * circle.
	         */
	        _this.radius = 1;
	        /**
	         * The outline stroke width of the circles for the layer. Is used as the default if outline width is not specified
	         * for a circle.
	         */
	        _this.outlineWidth = 5;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-circles";
	        return _this;
	    }
	    return CircleLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a linestring layer.
	 * @deprecated Use LineLayerOptions with atlas.layer.LineLayer instead.
	 */
	var LinestringLayerOptions = /** @class */ (function (_super) {
	    __extends(LinestringLayerOptions, _super);
	    function LinestringLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of cap to use for the ends of the linestrings:
	         * <p>"butt" is a squared ending that is drawn to the exact endpoint of the line.</p>
	         * <p>"round" is a circular ending that is drawn past the exact endpoint with a radius of half the linestring's
	         * width.</p>
	         * <p>"square" is a squared ending that is drawn past the exact endpoint by half the linestring's width.
	         */
	        _this.cap = "butt";
	        /**
	         * The type of join to use for the linestrings:
	         * <p>"bevel" is a squared join that cuts a corner flat at half the linestring's width from the vertex.</p>
	         * <p>"round" is a circular join that rounds a corner with a radius of half the linestring's width from the
	         * vertex.</p>
	         * <p>"miter" is a sharp join that extends the segments of the linestring past the vertex until they intersect.</p>
	         */
	        _this.join = "miter";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-linestrings";
	        /**
	         * The color of the lines for the layer. Is used as the default if a specific color is not specified for a line.
	         */
	        _this.color = "#000";
	        /**
	         * The width of the lines for the layer. Is used as the default if a specific width is not specified for a line.
	         */
	        _this.width = 1;
	        return _this;
	    }
	    return LinestringLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a pin layer.
	 * @deprecated Use SymbolLayerOptions with atlas.layer.SymbolLayer instead.
	 */
	var PinLayerOptions = /** @class */ (function (_super) {
	    __extends(PinLayerOptions, _super);
	    function PinLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The factor by which the icon should be scaled. A value of 1 is the original size; a value of 2 will double the
	         * size of the icon.
	         */
	        _this.iconSize = 1;
	        /**
	         * The size of the title text.
	         */
	        _this.fontSize = 14;
	        /**
	         * The color of the title text.
	         */
	        _this.fontColor = "#000";
	        /**
	         * The font for the title of the pin.
	         */
	        _this.textFont = "SegoeUi-Regular";
	        /**
	         * Whether the icons should cluster when they collide on the map, or stay separate.
	         */
	        _this.cluster = true;
	        /**
	         * The icon to use to represent a cluster.
	         */
	        _this.clusterIcon = undefined;
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the title text should be
	         * offset. Negative numbers can be used to offset the title left and up.
	         */
	        _this.textOffset = [0, 0];
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-pins";
	        /**
	         * The icon of the pins for the layer. Is used as the default if an icon is not specified for a pin.
	         */
	        _this.icon = "pin-darkblue";
	        /**
	         * The title of the pins for the layer. Is used as the default if a title is not specified for a pin.
	         */
	        _this.title = "";
	        return _this;
	    }
	    return PinLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a polygon layer.
	 * @deprecated Use new PolygonLayerOptions with atlas.layer.PolygonLayer instead.
	 */
	var PolygonLayerOptions$1 = /** @class */ (function (_super) {
	    __extends(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the polygons for the layer. Is used as the default if a fill color is not specified for a
	         * polygon.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the polygons for the layer. Is used as the default if an outline color is not specified for
	         * a polygon.
	         * @deprecated Use `atlas.layer.LineLayer` to provide an outline for a polygon.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-polygons";
	        return _this;
	    }
	    return PolygonLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for a raster layer.
	 * @deprecated Use TileLayerOptions with atlas.layer.TileLayer instead.
	 */
	var RasterLayerOptions = /** @class */ (function (_super) {
	    __extends(RasterLayerOptions, _super);
	    function RasterLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-raster";
	        return _this;
	    }
	    return RasterLayerOptions;
	}(LayerOptions$1));

	/**
	 * The options for the map's lighting.
	 */
	var LightOptions = /** @class */ (function (_super) {
	    __extends(LightOptions, _super);
	    function LightOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies wether extruded geometries are lit relative to the map or viewport.
	         * Supported values:
	         * <p>`"map"`: The position of the light source is aligned to the rotation of the map.</p>
	         * <p>`"viewport"`: The position fo the light source is aligned to the rotation of the viewport.</p>
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.anchor = "map";
	        /**
	         * Color tint for lighting extruded geometries
	         * Default: `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.color = "#FFFFFF";
	        /**
	         * Intensity of lighting (on a scale from 0 to 1).
	         * Higher numbers will present as more extreme contrast.
	         * Default `0.5`
	         * @default 0.5
	         */
	        _this.intensity = 0.5;
	        /**
	         * Position of the light source relative to lit (extruded) geometries,
	         * in [r radial coordinate, a azimuthal angle, p polar angle]
	         * where r indicates the distance from the center of the base of an object to its light,
	         * a indicates the position of the light relative to 0°
	         * (0° when `anchor` is set to viewport corresponds to the top of the viewport,
	         * or 0° when `anchor` is set to map corresponds to due north, and degrees proceed clockwise),
	         * and p indicates the height of the light (from 0°, directly above, to 180°, directly below).
	         */
	        _this.position = [1.15, 210, 30];
	        return _this;
	    }
	    return LightOptions;
	}(Options));

	/**
	 * The options for the map's style.
	 */
	var StyleOptions = /** @class */ (function (_super) {
	    __extends(StyleOptions, _super);
	    function StyleOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * If true the map will automatically resize whenever the window's size changes.
	         * Otherwise map.resize() must be called.
	         * Default `true`.
	         * @default true
	         */
	        _this.autoResize = true;
	        /**
	         * The language of the map labels.
	         * [Supported language]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages}.
	         * Default `atlas.getLanguage()`.
	         * @default atlas.getLanguage()
	         */
	        _this.language = getLanguage();
	        /**
	         * Sets the lighting options of the map.
	         */
	        _this.light = new LightOptions();
	        /**
	         * If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL().
	         * This option may only be set when initializing the map.
	         * Default `false`
	         * @default false
	         */
	        _this.preserveDrawingBuffer = false;
	        /**
	         * Specifies if multiple copies of the world should be rendered when zoomed out.
	         * Default `true`
	         * @default true
	         */
	        _this.renderWorldCopies = true;
	        /**
	         * Specifies if buildings will be rendered with their models.
	         * If false all buildings will be rendered as just their footprints.
	         * Default `false`
	         * @default false
	         */
	        _this.showBuildingModels = false;
	        /**
	         * Specifies if the feedback link should be displayed on the map or not.
	         * Default `true`
	         * @default true
	         */
	        _this.showFeedbackLink = true;
	        /**
	         * Specifies if the Microsoft logo should be hidden or not.
	         * If set to true a Microsoft copyright string will be added to the map.
	         * Default `true`
	         * @default true
	         */
	        _this.showLogo = true;
	        /**
	         * Specifies if the map should render an outline around each tile and the tile ID.
	         * These tile boundaries are useful for debugging.
	         * The uncompressed file size of the first vector source is drawn in the top left corner of each tile,
	         * next to the tile ID.
	         * Default `false`
	         * @default false
	         */
	        _this.showTileBoundaries = false;
	        /**
	         * The name of the style to use when rendering the map. Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article. The
	         * default style is "road".
	         */
	        _this.style = "road";
	        /**
	         * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	         * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews}
	         * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	         * default: `undefined`
	         * @default undefined
	         */
	        _this.view = getView();
	        /**
	         * @deprecated use `view` instead.
	         */
	        _this.userRegion = _this.view;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the view property names to the new view one.
	     * Also converts the specified language to a best fit supported one.
	     * @internal
	     */
	    StyleOptions.prototype.merge = function () {
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        for (var _a = 0, valueList_1 = valueList; _a < valueList_1.length; _a++) {
	            var value = valueList_1[_a];
	            if (value) {
	                // Make sure both view and userRegion properties exist. Prefer view's value.
	                if (value.hasOwnProperty("view")) {
	                    value.userRegion = value.view;
	                }
	                else if (value.hasOwnProperty("userRegion")) {
	                    value.view = value.userRegion;
	                }
	                // Make sure the language is converted to the best fit supported one.
	                if (typeof value.language === "string") {
	                    value.language = Localizer.getCode(value.language);
	                }
	            }
	        }
	        // Then execute the standard merge behavior.
	        return _super.prototype.merge.apply(this, valueList);
	    };
	    return StyleOptions;
	}(Options));

	/**
	 * The options for setting traffic on the map.
	 */
	var TrafficOptions = /** @class */ (function (_super) {
	    __extends(TrafficOptions, _super);
	    function TrafficOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of traffic flow to display:
	         * <p>"none" is to display no traffic flow data</p>
	         * <p>"relative" is the speed of the road relative to free-flow</p>
	         * <p>"absolute" is the absolute speed of the road</p>
	         * <p>"relative-delay" displays relative speed only where they differ from free-flow;
	         * false to stop displaying the traffic flow.</p>
	         * default `"none"``
	         * @default "none"
	         */
	        _this.flow = "none";
	        /**
	         * Whether to display incidents on the map.
	         * default `false`
	         * @default false
	         */
	        _this.incidents = false;
	        return _this;
	    }
	    return TrafficOptions;
	}(Options));

	/**
	 * Global properties used in all atlas service requests.
	 */
	var ServiceOptions = /** @class */ (function (_super) {
	    __extends(ServiceOptions, _super);
	    function ServiceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication options used to customize how the map control authenticates with Azure Maps services.
	         * If these authentication options are specified then ServiceOptions.subscriptionKey should not be.
	         * Recommend using the atlas.setAuthenticationOptions function instead.
	         */
	        _this.authOptions = getAuthenticationOptions();
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * default: false
	         * @default false
	         */
	        _this.disableTelemetry = false;
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using disableTelemetry instead.
	         */
	        _this["disable-telemetry"] = _this.disableTelemetry;
	        /**
	         * The domain to use when requesting map tiles and other Azure Maps services.
	         * If the protocol is not specified `https` is assumed.
	         * Recommend using atlas.setDomain function instead.
	         * @default "atlas.microsoft.com"
	         */
	        _this.domain = getDomain();
	        /**
	         * Enable accessibility
	         * default: true
	         * @default true
	         */
	        _this.enableAccessibility = true;
	        /**
	         * Enable accessibility
	         * @deprecated Recommend using enableAccessibility instead.
	         */
	        _this["enable-accessibility"] = _this.enableAccessibility;
	        /**
	         * A boolean that specifies if vector and raster tiles should be reloaded when they expire (based on expires header).
	         * This is useful for data sets that update frequently. When set to false, each tile will be loaded once, when needed, and not reloaded when they expire.
	         * default: true
	         * @default true
	         */
	        _this.refreshExpiredTiles = true;
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this.subscriptionKey = getSubscriptionKey();
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this["subscription-key"] = _this.subscriptionKey;
	        /**
	         * The session id to pass with requests.
	         * Recommend using atlas.setSessionId instead.
	         * @default Random UUID generated at runtime
	         */
	        _this.sessionId = getSessionId();
	        /**
	         * The session id to pass with requests.
	         * @deprecated Recommend using atlas.setSessionId instead.
	         */
	        _this["session-id"] = _this.sessionId;
	        /**
	         * If defined transformRequest will be called to provide custom request parameters for loading a tile.
	         */
	        _this.transformRequest = undefined;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the old dash property names to the new camelCase ones.
	     * @internal
	     */
	    ServiceOptions.prototype.merge = function () {
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        // Make sure both camel and dash case properties exist. Prefer the camel case ones.
	        for (var _a = 0, valueList_1 = valueList; _a < valueList_1.length; _a++) {
	            var value = valueList_1[_a];
	            if (value) {
	                // authOptions can also have a subscription key so check for that first.
	                // If authOptions are specified then they should be preferred over the previous ServiceOptions.subscriptionKey.
	                if (value.authOptions) {
	                    if (typeof value.authOptions.subscriptionKey === "string") {
	                        value.subscriptionKey = value["subscription-key"] = value.authOptions.subscriptionKey;
	                    }
	                }
	                else {
	                    if (typeof value.subscriptionKey === "string") {
	                        value["subscription-key"] = value.subscriptionKey;
	                        value.authOptions = {
	                            authType: exports.AuthenticationType.subscriptionKey,
	                            subscriptionKey: value.subscriptionKey
	                        };
	                    }
	                    else if (typeof value["subscription-key"] === "string") {
	                        value.subscriptionKey = value["subscription-key"];
	                        value.authOptions = {
	                            authType: exports.AuthenticationType.subscriptionKey,
	                            subscriptionKey: value["subscription-key"]
	                        };
	                    }
	                }
	                if (typeof value.sessionId === "string") {
	                    value["session-id"] = value.sessionId;
	                }
	                else if (typeof value["session-id"] === "string") {
	                    value.sessionId = value["session-id"];
	                }
	                if (typeof value.disableTelemetry === "boolean") {
	                    value["disable-telemetry"] = value.disableTelemetry;
	                }
	                else if (typeof value["disable-telemetry"] === "boolean") {
	                    value.disableTelemetry = value["disable-telemetry"];
	                }
	                if (typeof value.enableAccessibility === "boolean") {
	                    value["enable-accessibility"] = value.enableAccessibility;
	                }
	                else if (typeof value["enable-accessibility"] === "boolean") {
	                    value.enableAccessibility = value["enable-accessibility"];
	                }
	            }
	        }
	        // Then execute the standard merge behavior.
	        // If subscription key auth method isn't being used then the subscription key property should be undefined.
	        var merged = _super.prototype.merge.apply(this, valueList);
	        if (merged.authOptions.authType !== exports.AuthenticationType.subscriptionKey) {
	            merged["subscription-key"] = merged.subscriptionKey = undefined;
	        }
	        return merged;
	    };
	    /**
	     * Customizer for _.cloneDeep calls, allows objects to pass through with only a shallow cloning.
	     * Currently the only objects being cloned should be the `AuthenticationOptions`.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ServiceOptions._cloneCustomizer = function (value) {
	        if (typeof value === "object") {
	            return Object.assign({}, value);
	        }
	    };
	    return ServiceOptions;
	}(Options));

	/**
	 * @private
	 */
	var Style = /** @class */ (function () {
	    function Style() {
	        this.version = 8;
	        this.sprite = "";
	        this.glyphs = "";
	        this.light = {};
	        this.sources = {};
	        this.layers = [];
	    }
	    return Style;
	}());

	/**
	 * @private
	 */
	var StyleBuilder = /** @class */ (function () {
	    function StyleBuilder(map) {
	        this.sprite = "";
	        this.glyphs = "{fontstack}/{range}";
	        this.map = map;
	    }
	    StyleBuilder.prototype.build = function (styleOptions) {
	        // initialize mapbox style
	        var style = new Style();
	        // set glyphs and sprite on mapbox style
	        if (this.glyphs != null) {
	            style.glyphs = this.glyphs;
	        }
	        if (this.sprite != null) {
	            style.sprite = this.sprite;
	        }
	        // set the light on mapbox style
	        if (styleOptions.light != null) {
	            Object.assign(style.light, styleOptions.light);
	        }
	        // set sources and layers on mapbox style
	        if (this.map.sources != null) {
	            style.sources = this.map.sources._buildSources();
	        }
	        if (this.map.layers != null) {
	            var layers = this.map.layers.getLayers();
	            for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
	                var layer = layers_1[_i];
	                style.layers = style.layers.concat(layer._buildLayers());
	                // SourceBuildingLayer are a special case because they create their own source and manage it internally.
	                // If building a SourceBuildingLayer the source associated must also be built.
	                if (layer instanceof SourceBuildingLayer) {
	                    style.sources[layer._getSourceId()] = layer._buildSource();
	                }
	            }
	        }
	        return style;
	    };
	    StyleBuilder.prototype.setGlyphs = function (glyphs) {
	        this.glyphs = glyphs;
	    };
	    StyleBuilder.prototype.setSprite = function (sprite) {
	        this.sprite = sprite;
	    };
	    return StyleBuilder;
	}());

	/**
	 * Used to represent the layer described by a resource files.
	 * Serves primarily as a wrapper for multiple Mapbox layers in LayerManger.
	 * @private
	 */
	var FundamentalMapLayer = /** @class */ (function (_super) {
	    __extends(FundamentalMapLayer, _super);
	    /**
	     * Constructs a base layer used to represent the base, transit, and labels layers.
	     * @param options Options to be used in constructing the layer.
	     * @param mbLayers The stylesheet used to define the style sources and style layers.
	     * @param id The layer's id.
	     */
	    function FundamentalMapLayer(mbLayers, id) {
	        var _this = _super.call(this, id) || this;
	        _this.layers = mbLayers;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._buildLayers = function () {
	        return this.layers;
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getLayerIds = function () {
	        return this.layers.map(function (l) { return l.id; });
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
	            var layer = _a[_i];
	            if (typeof layer.source === "string") {
	                // If the layer's source is just a string id use that.
	                ids.add(layer.source);
	            }
	            else if (layer.source) {
	                // If the layer has an inline source definition the id will match the layer's.
	                ids.add(layer.id);
	            }
	        }
	        return ids;
	    };
	    return FundamentalMapLayer;
	}(Layer));

	/**
	 * Used to represent the fundamental map source.
	 * @private
	 */
	var FundamentalMapSource = /** @class */ (function (_super) {
	    __extends(FundamentalMapSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef The sources entry of the resource file.
	     * @param options The query parameters to add to the urls listed in the resource file.
	     */
	    function FundamentalMapSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = _this._modifySource(sourceDef, options);
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    FundamentalMapSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    /**
	     * Updates the source info to convert the tiles to url strings.
	     * @param sourceDef The original source info.
	     * @param options The query parameters to add to the tile urls.
	     */
	    FundamentalMapSource.prototype._modifySource = function (sourceDef, options) {
	        var tileStrings = sourceDef.tiles.map(function (tile) {
	            if (typeof tile === "string") {
	                return tile;
	            }
	            var tileUrl = new Url({
	                domain: constants.domainPlaceHolder,
	                path: tile.path,
	                queryParams: __assign(__assign({}, options), tile.queryParams)
	            });
	            return tileUrl.toString();
	        });
	        sourceDef.tiles = tileStrings;
	        return sourceDef;
	    };
	    return FundamentalMapSource;
	}(Source));

	/**
	 * @private
	 */
	var StyleManager = /** @class */ (function () {
	    function StyleManager() {
	    }
	    /**
	     * If this method has been called before the original initialize promise is returned.
	     */
	    StyleManager.prototype.initialize = function () {
	        var _this = this;
	        if (!this.initPromise) {
	            this.initPromise = this.request(env.staticAssetsDomain, env.styleDefinitionsPath).then(function (response) {
	                _this.definitions = response;
	            }).catch(function (reason) {
	                throw new Error("Failed to retrieve the style definitions: " + reason);
	            });
	        }
	        return this.initPromise;
	    };
	    /**
	     * Builds an array of the map components that represent the style type specified in the style options.
	     */
	    StyleManager.prototype.getStyleComponents = function (styleOptions) {
	        return __awaiter(this, void 0, void 0, function () {
	            var knownSources, style, promises;
	            var _this = this;
	            return __generator(this, function (_a) {
	                knownSources = new Set();
	                style = this.lookUp(styleOptions);
	                promises = style.layerGroups.map(function (layerGroup) { return __awaiter(_this, void 0, void 0, function () {
	                    var path, layerName, queryParams, component, _i, _a, layer, paint;
	                    return __generator(this, function (_b) {
	                        switch (_b.label) {
	                            case 0:
	                                path = layerGroup.layerPath;
	                                layerName = layerGroup.name;
	                                queryParams = {
	                                    language: styleOptions.language
	                                };
	                                // Specify view if one has been set.
	                                if (styleOptions.view) {
	                                    queryParams.view = styleOptions.view;
	                                }
	                                return [4 /*yield*/, this.buildComponent(layerName, path, queryParams, knownSources)];
	                            case 1:
	                                component = _b.sent();
	                                if (!styleOptions.showBuildingModels) {
	                                    for (_i = 0, _a = component.layer.layers; _i < _a.length; _i++) {
	                                        layer = _a[_i];
	                                        if (layer.type === "fill-extrusion") {
	                                            paint = layer.paint;
	                                            paint["fill-extrusion-base"] = 0;
	                                            paint["fill-extrusion-height"] = 0;
	                                        }
	                                    }
	                                }
	                                return [2 /*return*/, component];
	                        }
	                    });
	                }); });
	                return [2 /*return*/, Promise.all(promises)];
	            });
	        });
	    };
	    /**
	     * Builds the map component that represents the traffic flow type specified by the style and traffic options.
	     */
	    StyleManager.prototype.getFlowComponent = function (styleOptions, trafficOptions) {
	        return __awaiter(this, void 0, void 0, function () {
	            var path;
	            return __generator(this, function (_a) {
	                path = this.getFlowPath(styleOptions, trafficOptions);
	                return [2 /*return*/, this.buildComponent("flow", path)];
	            });
	        });
	    };
	    /**
	     * Gets the copyright caption for the style type specified by the style options.
	     */
	    StyleManager.prototype.getCopyrightCaption = function (options) {
	        var style = this.lookUp(options);
	        var copyright = style.copyright.join(" ");
	        if (!options.showLogo) {
	            copyright += " ©2019 Microsoft";
	        }
	        return copyright;
	    };
	    /**
	     * Gets the sprite path for the style type specified by the style options.
	     */
	    StyleManager.prototype.getSprite = function (options) {
	        var style = this.lookUp(options);
	        var spriteUrl = new Url({
	            domain: this.definitions.domain,
	            path: style.spritePath
	        });
	        return spriteUrl.toString();
	    };
	    /**
	     * Gets the glyph path for the style type specified by the style options.
	     */
	    StyleManager.prototype.getGlyphs = function (options) {
	        var style = this.lookUp(options);
	        var glyphsUrl = new Url({
	            domain: this.definitions.domain,
	            path: style.glyphsPath
	        });
	        return glyphsUrl.toString();
	    };
	    /**
	     * Gets the path to the traffic flow layer definition specified by the style and traffic options.
	     */
	    StyleManager.prototype.getFlowPath = function (styleOptions, trafficOptions) {
	        var style = this.lookUp(styleOptions);
	        return style.flowPaths[trafficOptions.flow];
	    };
	    /**
	     * Gets the color theme (light/dark) for the style type specified by the style options.
	     */
	    StyleManager.prototype.getTheme = function (styleOptions) {
	        var style = this.lookUp(styleOptions);
	        return style.theme.toLowerCase() || "light";
	    };
	    /**
	     * Gets the full style definition object.
	     */
	    StyleManager.prototype.getDef = function () {
	        return this.definitions;
	    };
	    /**
	     * Looks up the style type info from the style definition
	     */
	    StyleManager.prototype.lookUp = function (options) {
	        var styleName = options.style || this.definitions.defaultStyle;
	        var fallbackStyle;
	        for (var _i = 0, _a = this.definitions.styles; _i < _a.length; _i++) {
	            var style = _a[_i];
	            if (style.name === styleName) {
	                return style;
	            }
	            else if (style.name === this.definitions.defaultStyle) {
	                fallbackStyle = style;
	            }
	        }
	        return fallbackStyle;
	    };
	    /**
	     * Fetches a json resource at the specified domain and path.
	     */
	    StyleManager.prototype.request = function (domain, path) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, new Url({
	                        domain: domain,
	                        path: path
	                    }).get()];
	            });
	        });
	    };
	    /**
	     * Builds a map components with the given layer name from the resource found at the specified path.
	     * @param layerName The name of the layer that will be created.
	     * @param path The path to the resource with the layer and source info.
	     * @param queryParams The query parameters to use for the tile urls of the source.
	     * @param knownSources A optional set of any sources already built.
	     * The the source has already been built it won't be rebuilt.
	     */
	    StyleManager.prototype.buildComponent = function (layerName, path, queryParams, knownSources) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.request(this.definitions.domain, path).then(function (response) {
	                        var layer = new FundamentalMapLayer(response.layers, layerName);
	                        var sources = [];
	                        for (var _i = 0, _a = response.sources; _i < _a.length; _i++) {
	                            var sourceDef = _a[_i];
	                            var sourceName = sourceDef.name;
	                            if (knownSources) {
	                                if (knownSources.has(sourceName)) {
	                                    continue;
	                                }
	                                else {
	                                    knownSources.add(sourceName);
	                                }
	                            }
	                            sources.push(new FundamentalMapSource(sourceName, sourceDef, queryParams));
	                        }
	                        return {
	                            layer: layer,
	                            sources: sources
	                        };
	                    })];
	            });
	        });
	    };
	    return StyleManager;
	}());

	/**
	 * The control for a visual and interactive web map.
	 */
	var Map$2 = /** @class */ (function () {
	    /**
	     * Displays a map in the specified container.
	     * @param container The id of the element where the map should be displayed.
	     * @param options Options for the initial display and interactability with the map.
	     */
	    function Map(container, options) {
	        var _this = this;
	        this.styleLayerIds = new Set();
	        this.styleSourceIds = new Set();
	        // Map state trackers
	        this.removed = false;
	        this.loaded = false;
	        this.ready = false;
	        /**
	         * The callback used when styleOptions.autoResize is true.
	         */
	        this._windowResizeCallback = function () { return _this.resize(); };
	        var successfulLoad = true;
	        // Update global defaults based on which options were specified to this constructor.
	        this._updateGlobalDefaults(options);
	        this.serviceOptions = new ServiceOptions().merge(options);
	        this.styleOptions = new StyleOptions().merge(options);
	        this.trafficOptions = new TrafficOptions();
	        this.styles = new StyleManager();
	        this.insights = new Insights(this.serviceOptions);
	        var mapboxMapOptions = {
	            attributionControl: false,
	            container: container,
	            preserveDrawingBuffer: this.styleOptions.preserveDrawingBuffer,
	            refreshExpiredTiles: this.serviceOptions.refreshExpiredTiles,
	            renderWorldCopies: this.styleOptions.renderWorldCopies,
	            trackResize: false,
	            transformRequest: function (url, resourceType) {
	                var requestParams = {
	                    url: url
	                };
	                if (resourceType === "Tile" && url.includes(constants.domainPlaceHolder)) {
	                    _this.insights.trackEvent({ name: "TileLoad" });
	                    if (Url.protoRegEx.test(_this.serviceOptions.domain)) {
	                        // If the user specified domain includes a protocol replace that in the url too.
	                        var idx = url.indexOf(constants.domainPlaceHolder);
	                        requestParams.url = _this.serviceOptions.domain +
	                            url.substring(idx + constants.domainPlaceHolder.length);
	                    }
	                    else {
	                        // If the user specified domain doesn't include a protocol keep the original.
	                        requestParams.url = url.replace(constants.domainPlaceHolder, _this.serviceOptions.domain);
	                    }
	                    _this.authentication.signRequest(requestParams);
	                }
	                // Apply the users specified transform after ours
	                if (_this.serviceOptions.transformRequest) {
	                    merge_1(requestParams, _this.serviceOptions.transformRequest(requestParams.url, resourceType));
	                }
	                return requestParams;
	            }
	        };
	        // If a client id is available use that for telemetry, fallback to subscription key if necessary.
	        // Only keep the last 3 characters of the subscription key.
	        var accountId;
	        if (this.serviceOptions.authOptions.clientId) {
	            accountId = this.serviceOptions.authOptions.clientId;
	        }
	        else if (this.serviceOptions.authOptions.subscriptionKey) {
	            accountId = this.serviceOptions.authOptions.subscriptionKey.replace(/.(?=.{3,}$)/g, "*");
	        }
	        else {
	            accountId = "invalid-setting";
	        }
	        this.insights.setAuthenticatedUserContext(this.serviceOptions.sessionId, accountId);
	        try {
	            var mapboxMap = new mapboxGl.Map(mapboxMapOptions);
	            this.map = mapboxMap;
	            // Initialize managers
	            this.authentication = new AuthenticationManager(this);
	            this.controls = new ControlManager(this);
	            this.events = new EventManager(this);
	            this.imageSprite = new ImageSpriteManager(this);
	            this.layers = new LayerManager(this);
	            this.markers = new HtmlMarkerManager(this);
	            this.sources = new SourceManager(this);
	            this.popups = new PopupManager(this);
	            this.styleBuilder = new StyleBuilder(this);
	            // Add CSS classes and set attributes for DOM elements.
	            this.map.getContainer().classList.add("atlas-map");
	            this.map.getCanvasContainer().classList.add("atlas-map-canvas-container");
	            this.map.getCanvasContainer().id = "atlas-map_" + uuidRandom();
	            this.map.getCanvas().classList.add("atlas-map-canvas");
	            // Always add the copyright label.
	            this.copyrightControl = new CopyrightControl({ showFeedbackLink: this.styleOptions.showFeedbackLink });
	            this.controls.add(this.copyrightControl, {
	                position: exports.ControlPosition.NonFixed
	            });
	            // Add Azure logo if required
	            if (this.styleOptions.showLogo) {
	                this.logoControl = new AzureLogoControl();
	                this.controls.add(this.logoControl, {
	                    position: exports.ControlPosition.NonFixed
	                });
	            }
	            // Initialize state of map
	            // --> Initialize the authentication manager
	            var authManInit = this.authentication.initialize();
	            if (this.removed) {
	                // If the map is remove it must be because we are in an ADAL iframe.
	                // The auth manager handles the dispose call, but we should stop the constructor here too.
	                return;
	            }
	            // --> Track if the map has completed its first load
	            var setLoaded_1 = function () {
	                _this.loaded = true;
	                _this.map.off("load", setLoaded_1);
	            };
	            this.map.on("load", setLoaded_1);
	            // --> Track if the map has set its initial style
	            var setReady_1 = function () {
	                _this.ready = true;
	                _this.map.off("styledata", setReady_1);
	                // Manually invoke the ready event the first time styledata fires.
	                var readyData = { map: _this, type: "ready" };
	                _this.events.invoke("ready", readyData);
	            };
	            this.map.on("styledata", setReady_1);
	            // --> Set initial style including downloading style definitions and restyle map
	            this._setAutoResize(this.styleOptions.autoResize);
	            this.map.showTileBoundaries = this.styleOptions.showTileBoundaries;
	            this.localizedStringsPromise = Localizer.getStrings(this.styleOptions.language);
	            var stylesInit = this.styles.initialize();
	            Promise.all([authManInit, stylesInit]).then(function () {
	                // Check that the map hasn't been removed for any reason.
	                // If so no need to finish styling the map.
	                if (_this.removed) {
	                    return;
	                }
	                if (!_this.authentication.getToken()) {
	                    throw new Error("AuthenticationManager finished initializing, but no token is available");
	                }
	                // Add the accessibility delegate to the map here
	                // so that the auth mechanism is setup before any calls are made.
	                if (_this.serviceOptions["enable-accessibility"]) {
	                    _this.accessibleMapDelegate.addToMap();
	                }
	                _this._setStyleComponents(_this.styleOptions);
	            }).catch(function (reason) {
	                var error = reason instanceof Error ? reason : new Error(reason);
	                _this.insights.trackException({ error: error });
	                // Invoke the error event to report any errors initializing the styles or auth.
	                var errorData = {
	                    map: _this,
	                    type: "error",
	                    error: error
	                };
	                _this.events.invoke("error", errorData);
	            });
	            // --> Set initial camera state of map
	            this.setCamera(__assign(__assign({}, options), { type: "jump", duration: 0 }));
	            // Add delegates to map
	            this.incidentDelegate = new IncidentServiceDelegate(this);
	            this.flowDelegate = new FlowServiceDelegate(this);
	            this.accessibleMapDelegate = new AccessibleMapDelegate(this);
	            this.userInteractionDelegate = new UserInteractionDelegate(this, options);
	            this.userInteractionDelegate.addToMap();
	        }
	        catch (err) {
	            successfulLoad = false;
	            this.insights.trackException({ error: err instanceof Error ? err : new Error(err) });
	            throw err;
	        }
	        finally {
	            // Track the successful session load
	            this.insights.trackEvent({ name: "MapLoad" }, {
	                success: successfulLoad,
	                supported: isSupported(false),
	                supportedWithPerformance: isSupported(true)
	            });
	            this.insights.flush();
	        }
	    }
	    /**
	     * Returns the HTMLCanvasElement that the map is drawn to.
	     */
	    Map.prototype.getCanvas = function () {
	        return this.map.getCanvas();
	    };
	    /**
	     * Returns the HTMLElement that contains the map's HTMLCanvasElement. The map's events (e.g. panning and zooming)
	     * are attached to this element.
	     */
	    Map.prototype.getCanvasContainer = function () {
	        return this.map.getCanvasContainer();
	    };
	    /**
	     * Returns the HTMLElement that contains the map.
	     */
	    Map.prototype.getMapContainer = function () {
	        return this.map.getContainer();
	    };
	    /**
	     * Returns the service options with which the map control was initialized.
	     */
	    Map.prototype.getServiceOptions = function () {
	        return cloneDeepWith_1(this.serviceOptions, ServiceOptions._cloneCustomizer);
	    };
	    /**
	     * Set the service options.
	     */
	    Map.prototype.setServiceOptions = function (options) {
	        this.serviceOptions = new ServiceOptions().merge(this.serviceOptions, options);
	        if (this.serviceOptions["enable-accessibility"]) {
	            this.accessibleMapDelegate.addToMap();
	        }
	        else {
	            this.accessibleMapDelegate.removeFromMap();
	        }
	    };
	    Map.prototype.setCamera = function (options, fromControl) {
	        if (fromControl === void 0) { fromControl = false; }
	        var mapboxCameraOptions;
	        var maxBounds;
	        // Test between CameraOptions and CameraBoundsOptions
	        if ("padding" in options || "offset" in options || "bounds" in options) {
	            var cameraBoundsOptions = new CameraBoundsOptions()
	                .merge({ maxZoom: this.getCamera().maxZoom }, options);
	            var bounds = this._generateSafeBounds(cameraBoundsOptions.bounds);
	            mapboxCameraOptions = this.map.cameraForBounds(bounds, {
	                padding: cameraBoundsOptions.padding,
	                offset: cameraBoundsOptions.offset,
	                maxZoom: cameraBoundsOptions.maxZoom
	            });
	            if (!mapboxCameraOptions) {
	                throw new Error("The map cannot be fit to the current canvas with the given CameraBoundsOptions.");
	            }
	            this.map.setMaxZoom(cameraBoundsOptions.maxZoom);
	            maxBounds = this._generateSafeBounds(cameraBoundsOptions.maxBounds);
	        }
	        else {
	            var cameraOptions = new CameraOptions().merge(this.getCamera(), options);
	            // adjust for center offset
	            if (cameraOptions.centerOffset && cameraOptions.centerOffset.length >= 2) {
	                var centerOffset = cameraOptions.centerOffset;
	                // Calculate a new center which accounts for the offset at the specified zoom level.
	                var p = mercatorPositionsToPixels([cameraOptions.center], cameraOptions.zoom);
	                p[0][0] += centerOffset[0];
	                p[0][1] += centerOffset[1];
	                cameraOptions.center = mercatorPixelsToPositions(p, cameraOptions.zoom)[0];
	            }
	            mapboxCameraOptions = {
	                center: cameraOptions.center,
	                zoom: cameraOptions.zoom,
	                bearing: cameraOptions.bearing,
	                pitch: cameraOptions.pitch,
	                around: undefined
	            };
	            this.map.setMinZoom(cameraOptions.minZoom);
	            this.map.setMaxZoom(cameraOptions.maxZoom);
	            maxBounds = this._generateSafeBounds(cameraOptions.maxBounds);
	        }
	        // set maxBounds. maxBounds will be removed if null or undefined is provided.
	        if (maxBounds) {
	            this.map.setMaxBounds(maxBounds);
	        }
	        else {
	            this.map.setMaxBounds(null);
	        }
	        var animOptions = new AnimationOptions().merge(options);
	        var mapboxAnimationOptions = {
	            duration: animOptions.duration,
	            easing: function (t) { return t; },
	            offset: [0, 0],
	            animate: true
	        };
	        // Supply event data regarding if a control caused this camera change.
	        var eventData = { fromControl: fromControl };
	        if (animOptions.type === "jump") {
	            this.map.jumpTo(mapboxCameraOptions, eventData);
	        }
	        else if (animOptions.type === "ease") {
	            this.map.easeTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	        else if (animOptions.type === "fly") {
	            this.map.flyTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	    };
	    /**
	     * Set the camera bounds of the map control.
	     * @param options The options for setting the map's camera bounds.
	     * @deprecated recommend setCamera.
	     */
	    Map.prototype.setCameraBounds = function (options) {
	        this.setCamera(options);
	    };
	    /**
	     * Returns the camera's current properties.
	     */
	    Map.prototype.getCamera = function () {
	        var southWest = this.map.getBounds().getSouthWest().toArray();
	        var northEast = this.map.getBounds().getNorthEast().toArray();
	        var cameraOptions = {
	            zoom: this.map.getZoom(),
	            center: this.map.getCenter().toArray(),
	            bearing: this.map.getBearing(),
	            pitch: this.map.getPitch(),
	            bounds: new BoundingBox(southWest, northEast),
	            minZoom: this.map.getMinZoom(),
	            maxZoom: this.map.getMaxZoom()
	        };
	        return cameraOptions;
	    };
	    /**
	     * Set the map control's style options. Any options not specified will default to their current values.
	     * @param options The options for setting the style of the map control.
	     */
	    Map.prototype.setStyle = function (options) {
	        // This option may only be set when initializing the map.
	        // The delete operation will handle non-exist property.
	        delete options.preserveDrawingBuffer;
	        var newOptions = new StyleOptions().merge(this.styleOptions, options);
	        // Add or remove the autoResize listener if needed.
	        if (newOptions.autoResize !== this.styleOptions.autoResize) {
	            this._setAutoResize(newOptions.autoResize);
	        }
	        // Update the localized strings promise if needed.
	        if (newOptions.language !== this.styleOptions.language) {
	            this.localizedStringsPromise = Localizer.getStrings(newOptions.language);
	        }
	        // Update rendering of world copies if needed.
	        if (newOptions.renderWorldCopies !== this.styleOptions.renderWorldCopies) {
	            this.map.setRenderWorldCopies(newOptions.renderWorldCopies);
	        }
	        // Add or remove the feedback link if needed.
	        if (newOptions.showFeedbackLink !== this.styleOptions.showFeedbackLink) {
	            this.copyrightControl.setOptions({ showFeedbackLink: newOptions.showFeedbackLink });
	        }
	        // Add or remove the logo if needed.
	        if (newOptions.showLogo && !this.logoControl) {
	            this.logoControl = new AzureLogoControl();
	            this.controls.add(this.logoControl, {
	                position: exports.ControlPosition.NonFixed
	            });
	        }
	        else if (!newOptions.showLogo && this.logoControl) {
	            this.controls.remove(this.logoControl);
	            delete this.logoControl;
	        }
	        // Update showing tile boundaries if needed.
	        if (newOptions.showTileBoundaries !== this.styleOptions.showTileBoundaries) {
	            this.map.showTileBoundaries = newOptions.showTileBoundaries;
	        }
	        // Some delegates may rely on a styledata event to know when to check if the language changes.
	        // If this function is restructured such that a styledata event won't always trigger
	        // if the language is changed, then either those delegates need changed
	        // or the styledata event manually invoked.
	        this._setStyleComponents(newOptions);
	        this.styleOptions = newOptions;
	    };
	    /**
	     * Returns the map control's current style settings.
	     */
	    Map.prototype.getStyle = function () {
	        return cloneDeep_1(this.styleOptions);
	    };
	    /**
	     * Add an icon to the map to use for pins.
	     * Map must be ready and the image must be fully loaded before the icon can be added.
	     * Use the events.add method with event type 'ready'.
	     * @param id The identifier of the icon.
	     * @param icon The icon image.
	     * @deprecated Use map.imageSprite.add instead.
	     */
	    Map.prototype.addIcon = function (id, icon) {
	        this.imageSprite.add(id, icon);
	    };
	    /**
	     * Add a collection of points to a layer of the map as pins. The layer and its options can be specified through a
	     * PinLayerOptions object. Options for the layer can
	     * only be specified upon the layer's initial creation. Map must be ready before the pins can be added. Use
	     * the events.add method with event type 'ready'.
	     * @param pins The points to add.
	     * @param options The layer options for the pins.
	     * @deprecated Use atlas.layer.SymbolLayer instead.
	     */
	    Map.prototype.addPins = function (pins, options) {
	        var layerOptions = new PinLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new SymbolLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                iconOptions: {
	                    anchor: "center",
	                    size: layerOptions.iconSize,
	                    image: ["case",
	                        ["has", "icon"], ["get", "icon"],
	                        layerOptions.icon
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity
	                },
	                textOptions: {
	                    anchor: "center",
	                    textField: ["case",
	                        ["has", "point_count"], ["to-string", ["get", "point_count"]],
	                        ["has", "title"], ["to-string", ["get", "title"]],
	                        layerOptions.title
	                    ],
	                    font: ["case",
	                        ["has", "point_count"], ["literal", ["StandardFontCondensed-Bold"]],
	                        ["literal", [layerOptions.textFont]]
	                    ],
	                    size: ["case",
	                        ["has", "point_count"], 20,
	                        layerOptions.fontSize
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity,
	                    offset: ["case",
	                        ["has", "point_count"], ["literal", [0.50, -0.45]],
	                        ["literal", [layerOptions.textOffset[0] / 16, layerOptions.textOffset[1] / 16]]
	                    ],
	                    color: layerOptions.fontColor
	                }
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof SymbolLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a SymbolLayer." +
	                "A SymbolLayer should be used for rendering pins.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId, {
	                cluster: layerOptions.cluster
	            });
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it in case defer is specified.
	        // If defer is specified data will be added to the source but the map won't be updated.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        // If defer was chosen do not update the map.
	        var pinCollection = new FeatureCollection(pins);
	        if (layerOptions.defer) {
	            if (layerOptions.overwrite) {
	                source._clearNoUpdate();
	            }
	            source._addNoUpdate(pinCollection);
	        }
	        else {
	            if (layerOptions.overwrite) {
	                source.setShapes(pinCollection);
	            }
	            else {
	                source.add(pinCollection);
	            }
	        }
	    };
	    /**
	     * Add a collection of points to a layer of the map as circles. The layer and its options can be specified through a
	     * CircleLayerOptions object. Options for the layer
	     * can only be specified upon the layer's initial creation. Map must be ready before the circles can be
	     * added. Use the events.add method with event type 'ready'.
	     * @param circles The circles to add.
	     * @param options The layer options for the circles.
	     * @deprecated Use atlas.layer.BubbleLayer instead.
	     */
	    Map.prototype.addCircles = function (circles, options) {
	        var layerOptions = new CircleLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new BubbleLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                opacity: layerOptions.opacity,
	                radius: ["case",
	                    ["has", "radius"], ["get", "radius"],
	                    layerOptions.radius
	                ],
	                color: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeColor: ["case",
	                    ["has", "outlineColor"], ["get", "outlineColor"],
	                    layerOptions.outlineColor
	                ],
	                strokeWidth: ["case",
	                    ["has", "outlineWidth"], ["get", "outlineWidth"],
	                    layerOptions.outlineWidth
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof BubbleLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a BubbleLayer." +
	                "A BubbleLayer should be used for rendering circles.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it in case defer is specified.
	        // If defer is specified data will be added to the source but the map won't be updated.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        // If defer was chosen do not update the map.
	        var circleCollection = new FeatureCollection(circles);
	        if (layerOptions.defer) {
	            if (layerOptions.overwrite) {
	                source._clearNoUpdate();
	            }
	            source._addNoUpdate(circleCollection);
	        }
	        else {
	            if (layerOptions.overwrite) {
	                source.setShapes(circleCollection);
	            }
	            else {
	                source.add(circleCollection);
	            }
	        }
	    };
	    /**
	     * Add a collection of linestrings to a layer of the map. The layer and its options can be specified through a
	     * LinestringLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the
	     * linestrings can be added. Use the events.add method with event type 'ready'.
	     * @param linestrings The linestrings to add.
	     * @param options The layer options for the linestrings.
	     * @deprecated Use atlas.layer.LineLayer instead.
	     */
	    Map.prototype.addLinestrings = function (linestrings, options) {
	        var layerOptions = new LinestringLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new LineLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                lineCap: layerOptions.cap,
	                lineJoin: layerOptions.join,
	                strokeOpacity: layerOptions.opacity,
	                strokeColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeWidth: ["case",
	                    ["has", "width"], ["get", "width"],
	                    layerOptions.width
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof LineLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a LineLayer." +
	                "A LineLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it in case defer is specified.
	        // If defer is specified data will be added to the source but the map won't be updated.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        // If defer was chosen do not update the map.
	        var lineCollection = new FeatureCollection(linestrings);
	        if (layerOptions.defer) {
	            if (layerOptions.overwrite) {
	                source._clearNoUpdate();
	            }
	            source._addNoUpdate(lineCollection);
	        }
	        else {
	            if (layerOptions.overwrite) {
	                source.setShapes(lineCollection);
	            }
	            else {
	                source.add(lineCollection);
	            }
	        }
	    };
	    /**
	     * Add a collection of polygons to a layer of the map. The layer and its options can be specified through a
	     * PolygonLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the polygons
	     * can be added. Use the events.add method with event type 'ready'.
	     * @param polygons The polygons to add.
	     * @param options The layer options for the polygons.
	     * @deprecated Use atlas.layer.PolygonLayer instead.
	     */
	    Map.prototype.addPolygons = function (polygons, options) {
	        var layerOptions = new PolygonLayerOptions$1().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new PolygonLayer(layerOptions.name + "-source", layerOptions.name, {
	                source: layerOptions.name + "-source",
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                fillOpacity: layerOptions.opacity,
	                fillColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof PolygonLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a PolygonLayer." +
	                "A PolygonLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '" + sourceId + "' already exists but it is not a DataSource." +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it in case defer is specified.
	        // If defer is specified data will be added to the source but the map won't be updated.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        // If defer was chosen do not update the map.
	        var polygonCollection = new FeatureCollection(polygons);
	        if (layerOptions.defer) {
	            if (layerOptions.overwrite) {
	                source._clearNoUpdate();
	            }
	            source._addNoUpdate(polygonCollection);
	        }
	        else {
	            if (layerOptions.overwrite) {
	                source.setShapes(polygonCollection);
	            }
	            else {
	                source.add(polygonCollection);
	            }
	        }
	    };
	    /**
	     * Adds a raster layer to the map. The layer and its options can be specified through a
	     * RasterLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation.
	     * @param tileSources  A list of endpoints specified as strings from which raster images can be requested. The
	     * endpoints can be parameterized with the tags '{z}', '{x}' and '{y}' to specify the zoom, x-index, and y-index of
	     * the needed tile respectively. The map control will request and place the tiles that are contained in the map's
	     * viewport.
	     * @param options The options for the raster layer.
	     * @deprecated Use atlas.layer.TileLayer instead.
	     */
	    Map.prototype.addRaster = function (tileSources, options) {
	        var layerOptions = new RasterLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new TileLayer({
	                maxZoom: layerOptions.maxZoom,
	                minZoom: layerOptions.minZoom,
	                opacity: layerOptions.opacity,
	                tileSize: 256,
	                tileUrl: "{subdomain}"
	            }, layerOptions.name);
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof TileLayer)) {
	            throw new Error("A layer with name '" + layerOptions.name + "' already exists but it is not a TileLayer." +
	                "A TileLayer should be used for rendering raster images.");
	        }
	        // Multiple tile urls are made possible by the {subdomain} substitution
	        // If a layer doesn't use "{subdomain}" as its tileUrl it must have be created with new TileLayer(...)
	        // In that case throw an error.
	        if (layer.getOptions().tileUrl !== "{subdomain}") {
	            throw new Error("A TileLayer with name '" + layerOptions.name + "' already exists but was configured " +
	                "for a single tile url [default for new TileLayer(...)].");
	        }
	        // Get the new tile urls.
	        var urls;
	        if (layerOptions.overwrite) {
	            urls = [];
	        }
	        else {
	            urls = layer.getOptions().subdomains || [];
	        }
	        // Add the tile urls to the layer, but don't update the map yet.
	        urls.push.apply(urls, tileSources);
	        layer._setOptionsNoUpdate({
	            subdomains: urls
	        });
	        if (!layerOptions.defer) {
	            // If defer isn't specified then the layer will be re-added to the layer manager.
	            // This will cause the layer to actually be added to the map.
	            this.layers.add(layer, layerOptions.before);
	        }
	        else if (newLayer) {
	            // If a new layer was created add it to the layer manager, but don't update the map
	            // The map shouldn't be updated because there may not be any subdomains specified.
	            // This would lead to an empty tiles property in the mapbox source.
	            // That will lead to many errors and a significant performance hit.
	            this.layers.add(layer, layerOptions.before, false);
	        }
	    };
	    /**
	     * Returns a list of the map's layers from bottom to top.
	     * @deprecated Use layers.getLayers() instead.
	     */
	    Map.prototype.getLayers = function () {
	        return this.layers.getLayers().map(function (l) { return l.getId(); });
	    };
	    /**
	     * Removes a collection of layers from the map.
	     * For each layer if a source by the name of "<layerName>-source" exists it will be removed too.
	     * @param layerNames An array of layer names to remove from the map.
	     * @deprecated Use layers.remove instead.
	     */
	    Map.prototype.removeLayers = function (layerNames) {
	        for (var _i = 0, layerNames_1 = layerNames; _i < layerNames_1.length; _i++) {
	            var layerName = layerNames_1[_i];
	            // Previously calling removeLayers for layers that didn't exist in the map just did nothing.
	            // Now, LayerManager will throw an error, so we need to check if the layer exists before calling remove.
	            if (this.layers.getLayerById(layerName)) {
	                this.layers.remove(layerName);
	                // Previously adding a layer also added a source with the name "<layerName>-source".
	                // Calling removeLayers would also remove that source, so we attempt to do this too.
	                var sourceName = layerName + "-source";
	                if (this.sources.getById(sourceName)) {
	                    this.sources.remove(sourceName);
	                }
	            }
	        }
	    };
	    /**
	     * @deprecated recommend map.markers.add
	     * Adds a custom HTMLElement to the map at a specified position.
	     * @param element The HTMLElement to add.
	     * @param position The position to place the element.
	     */
	    Map.prototype.addHtml = function (element, position) {
	        if (!element.id) {
	            element.id = "marker_" + uuidRandom();
	        }
	        var marker = new HtmlMarker({
	            htmlContent: element,
	        });
	        this.markers.add(marker, position);
	        return element.id;
	    };
	    /**
	     * @deprecated recommend map.markers.remove
	     * Removes a custom HTMLElement from the map.
	     * @param elementId The id of element to remove.
	     */
	    Map.prototype.removeHtml = function (elementId) {
	        this.markers.remove(elementId);
	    };
	    Map.prototype.addEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._addLegacy(eventType, layerOrCallback, callback);
	    };
	    Map.prototype.removeEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._removeLegacy(eventType, layerOrCallback, callback);
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    Map.prototype.setUserInteraction = function (options) {
	        this.userInteractionDelegate.setOptions(options);
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    Map.prototype.getUserInteraction = function () {
	        return this.userInteractionDelegate.getOptions();
	    };
	    /**
	     * Add a control to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     * @deprecated Use map.controls.add instead.
	     */
	    Map.prototype.addControl = function (control, options) {
	        this.controls.add(control, options);
	    };
	    /**
	     * Remove a control from the map.
	     * @param control The control to remove.
	     * @deprecated Use map.controls.remove instead.
	     */
	    Map.prototype.removeControl = function (control) {
	        this.controls.remove(control);
	    };
	    /**
	     * Set the traffic options for the map. Any options not specified will default to their current values.
	     * @param options The options for defining the map's traffic display.
	     */
	    Map.prototype.setTraffic = function (options) {
	        var previousIncidentsOption = this.trafficOptions.incidents;
	        var previousFlowOption = this.trafficOptions.flow;
	        this.trafficOptions = new TrafficOptions().merge(this.trafficOptions, options);
	        if (this.trafficOptions.incidents) {
	            if (!previousIncidentsOption) {
	                this.incidentDelegate.addToMap();
	            }
	        }
	        else {
	            this.incidentDelegate.removeFromMap();
	        }
	        if (this.trafficOptions.flow && this.trafficOptions.flow !== "none") {
	            try {
	                // The flow delegate is designed to handle multiple calls to addToMap
	                // even if the traffic flow options hasn't changed.
	                this.flowDelegate.addToMap();
	            }
	            catch (error) {
	                // If an error occurs reset the flow option to its previous value.
	                this.trafficOptions.flow = previousFlowOption;
	                throw error;
	            }
	        }
	        else {
	            this.flowDelegate.removeFromMap();
	        }
	    };
	    /**
	     * Return the map control's current traffic settings.
	     */
	    Map.prototype.getTraffic = function () {
	        return cloneDeep_1(this.trafficOptions);
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     * @deprecated use map.dispose()
	     */
	    Map.prototype.remove = function () {
	        this.dispose();
	    };
	    /**
	     * Removes all user added sources, layers, markers, and popups from the map.
	     * User added images are preserved.
	     */
	    Map.prototype.clear = function () {
	        // Clear the layers, sources, and marker via their managers.
	        this.popups.clear();
	        this.layers.clear();
	        this.sources.clear();
	        this.markers.clear();
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     */
	    Map.prototype.dispose = function () {
	        this.clear();
	        this.map.remove();
	        this.removed = true;
	        while (this.getMapContainer().firstChild) {
	            var currChild = this.getMapContainer().firstChild;
	            this.getMapContainer().removeChild(currChild);
	        }
	    };
	    Map.prototype.resize = function (heightOrData, width, eventData) {
	        if ((typeof heightOrData === "number" || typeof heightOrData === "string") &&
	            (typeof width === "number" || typeof width === "string")) {
	            var height = heightOrData;
	            this.getMapContainer().style.height = typeof height === "number" ? height + "px" : height;
	            this.getMapContainer().style.width = typeof width === "number" ? width + "px" : width;
	        }
	        else {
	            eventData = heightOrData;
	        }
	        // Occasionally, when resizing the window causes the map container to also resize, the canvas will re-resized
	        // as if expecting a scroll bar to be drawn for the canvas container.
	        // This leaves some whitespace gap on the bottom and right sides of the canvas.
	        // No actual scrollbars will be shown.
	        //
	        // This is because the canvas container and map container are resized before the canvas,
	        // so for a small fraction of time the canvas is bigger than its containers and a scroll bar would be required.
	        //
	        // To prevent this first the canvas container has overflow set to hidden.
	        // This ensures that scroll bars would never be needed.
	        // Then the Mapbox resize function is called, and the canvas should be the full, correct size.
	        // Finally the canvas container has overflow set back to the original value.
	        var oldOverflow = this.getMapContainer().style.overflow;
	        this.getMapContainer().style.overflow = "hidden";
	        this.map.resize(eventData);
	        this.getMapContainer().style.overflow = oldOverflow;
	    };
	    /**
	     * Converts an array of Pixel objects to an array of geographic Positions objects on the map.
	     * @param pixels The pixels to be converted.
	     */
	    Map.prototype.pixelsToPositions = function (pixels) {
	        var positions = [];
	        for (var _i = 0, pixels_1 = pixels; _i < pixels_1.length; _i++) {
	            var pixel = pixels_1[_i];
	            var lngLat = this.map.unproject(pixel);
	            positions.push(new Position(lngLat.lng, lngLat.lat));
	        }
	        return positions;
	    };
	    /**
	     * Converts an array of Positions objects to an array of Pixel objects relative to the map container.
	     * @param positions The positions to be converted.
	     */
	    Map.prototype.positionsToPixels = function (positions) {
	        var pixels = [];
	        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
	            var position = positions_1[_i];
	            var point = this.map.project(position);
	            pixels.push(new Pixel(point.x, point.y));
	        }
	        return pixels;
	    };
	    /**
	     * Returns a boolean indicating if all tiles in the current viewport for all sources have loaded or not.
	     */
	    Map.prototype.areTilesLoaded = function () {
	        return this.map.areTilesLoaded();
	    };
	    /**
	     * Stops any animated transition that is currently underway.
	     */
	    Map.prototype.stop = function () {
	        this.map.stop();
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._getMap = function () {
	        return this.map;
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._rebuildStyle = function () {
	        this.map.setStyle(this.styleBuilder.build(this.styleOptions));
	        this.imageSprite._restoreImages();
	    };
	    /**
	     * Returns true if the map has completed loading for the first time.
	     * Will always return true after the initial load is completed.
	     * @internal
	     */
	    Map.prototype._isLoaded = function () {
	        return this.loaded;
	    };
	    /**
	     * Returns true if the map has set its style for the first time.
	     * Will always return true after the style has been set.
	     * @internal
	     */
	    Map.prototype._isReady = function () {
	        return this.ready;
	    };
	    /**
	     * Returns a promise which will resolve to a collection of localized strings based on the map's current language.
	     * @internal
	     */
	    Map.prototype._getLocalizedStrings = function () {
	        return this.localizedStringsPromise;
	    };
	    /**
	     * Sends a fetch request to the specified url with the specified headers.
	     * Processes the request through transformRequest(...) first before sending.
	     * @internal
	     */
	    Map.prototype._sendRequest = function (url, resourceType, headers) {
	        var requestParams;
	        if (typeof this.serviceOptions.transformRequest === "function") {
	            // If a transformRequest(...) was specified use it.
	            requestParams = this.serviceOptions.transformRequest(url, resourceType);
	        }
	        if (requestParams) {
	            // Send the fetch using the transformed parameters.
	            return fetch(requestParams.url || url, {
	                credentials: requestParams.credentials,
	                headers: __assign(__assign({}, headers), requestParams.headers),
	                method: "GET",
	                mode: "cors",
	            });
	        }
	        else {
	            // If not transformRequest has been supplied just make the request as specified.
	            return fetch(url, {
	                headers: headers,
	                method: "GET",
	                mode: "cors"
	            });
	        }
	    };
	    /**
	     * Sets whether the map will automatically resize when the browser window resizes.
	     * @private
	     */
	    Map.prototype._setAutoResize = function (autoResize) {
	        if (autoResize) {
	            window.addEventListener("resize", this._windowResizeCallback);
	        }
	        else {
	            window.removeEventListener("resize", this._windowResizeCallback);
	        }
	    };
	    /**
	     * Adds or replaces the relevant fundamental map components (layers and sources) based on the input options.
	     * Removes sources and layers that aren't used by the new style or any remaining layers.
	     * @private
	     */
	    Map.prototype._setStyleComponents = function (styleOptions) {
	        var _this = this;
	        this.styles.getStyleComponents(styleOptions).then(function (comps) {
	            // Check that the map hasn't been removed for any reason.
	            // If so no need to finish styling the map.
	            if (_this.removed) {
	                return;
	            }
	            _this.copyrightControl.setOptions({ copyrightMessage: _this.styles.getCopyrightCaption(styleOptions) });
	            _this.styleBuilder.setGlyphs(_this.styles.getGlyphs(styleOptions));
	            _this.styleBuilder.setSprite(_this.styles.getSprite(styleOptions));
	            // Build id sets for the new components.
	            var newLayerIds = new Set();
	            var newSourceIds = new Set();
	            for (var _i = 0, comps_1 = comps; _i < comps_1.length; _i++) {
	                var comp = comps_1[_i];
	                newLayerIds.add(comp.layer.getId());
	                for (var _a = 0, _b = comp.sources; _a < _b.length; _a++) {
	                    var source = _b[_a];
	                    newSourceIds.add(source.getId());
	                }
	            }
	            // Remove old layers.
	            _this.styleLayerIds.forEach(function (id) {
	                if (!newLayerIds.has(id)) {
	                    // If the new style layers don't include a previous style layer remove it.
	                    // Don't immediately update the map since we'll call _rebuildStyle() later.
	                    if (_this.layers.getLayerById(id)) {
	                        _this.layers.remove(id, false);
	                    }
	                    _this.styleLayerIds.delete(id);
	                }
	            });
	            var _loop_1 = function (i) {
	                var layer = comps[i].layer;
	                _this.styleLayerIds.add(layer.getId());
	                // Add layers
	                if (_this.layers.getLayerById(layer.getId())) {
	                    // If a layer with the same ID already exists keep its current order.
	                    _this.layers.add(layer, undefined, false);
	                }
	                else if (i === 0) {
	                    // The very first layer should always be added to the bottom of the order.
	                    _this.layers.add(layer, _this.layers.getLayers()[0], false);
	                }
	                else {
	                    // All other layers should be inserted just above their previous style layer.
	                    var prevLayer_1 = comps[i - 1].layer;
	                    var currentLayers = _this.layers.getLayers();
	                    var prevLayerIdx = currentLayers.findIndex(function (l) { return l.getId() === prevLayer_1.getId(); });
	                    _this.layers.add(layer, currentLayers[prevLayerIdx + 1], false);
	                }
	            };
	            // Add or replace new layers.
	            for (var i = 0; i < comps.length; i++) {
	                _loop_1(i);
	            }
	            // Remove old sources.
	            var usedSourceIds = _this.layers._getSourceIds();
	            _this.styleSourceIds.forEach(function (id) {
	                if (!usedSourceIds.has(id) && !newSourceIds.has(id)) {
	                    // If the new style sources don't include a previous style source remove it.
	                    // Don't immediately update the map since we'll call _rebuildStyle() later.
	                    if (_this.sources.getById(id)) {
	                        _this.sources.remove(id, false);
	                    }
	                    _this.styleSourceIds.delete(id);
	                }
	            });
	            // Add or replace new sources.
	            for (var _c = 0, comps_2 = comps; _c < comps_2.length; _c++) {
	                var comp = comps_2[_c];
	                _this.sources.add(comp.sources, false);
	                for (var _d = 0, _e = comp.sources; _d < _e.length; _d++) {
	                    var source = _e[_d];
	                    _this.styleSourceIds.add(source.getId());
	                }
	            }
	            _this._rebuildStyle();
	        });
	    };
	    /**
	     * Set the default service/style options.
	     * Only set defaults if the users provided a value for them and no other default have been set.
	     */
	    Map.prototype._updateGlobalDefaults = function (options) {
	        if (options) {
	            // Must account for deprecated property names because these checks occur before the merge operations.
	            if (options.authOptions && !_hasSetAuthenticationOptions()) {
	                setAuthenticationOptions(options.authOptions);
	            }
	            if (options.domain && !_hasSetDomain()) {
	                setDomain(options.domain);
	            }
	            if ((options.subscriptionKey || options["subscription-key"]) && !_hasSetAuthenticationOptions()) {
	                setSubscriptionKey(options.subscriptionKey || options["subscription-key"]);
	            }
	            if ((options.sessionId || options["session-id"]) && !_hasSetSessionId()) {
	                setSessionId(options.sessionId || options["session-id"]);
	            }
	            if (options.language && !_hasSetLanguage()) {
	                setLanguage(options.language);
	            }
	            if ((options.userRegion || options.view) && !_hasSetView()) {
	                setUserRegion(options.userRegion || options.view);
	            }
	        }
	    };
	    Map.prototype._generateSafeBounds = function (bounds) {
	        if (bounds) {
	            var s = BoundingBox.getSouth(bounds);
	            var w = BoundingBox.getWest(bounds);
	            var n = BoundingBox.getNorth(bounds);
	            var e = BoundingBox.getEast(bounds);
	            if (isNaN(s) || isNaN(w) || isNaN(n) || isNaN(e)) {
	                throw new Error("The bounds specified are invalid: [" + bounds + "]");
	            }
	            while (w > e) {
	                e += 360;
	            }
	            return new BoundingBox([w, s, e, n]);
	        }
	        return bounds;
	    };
	    return Map;
	}());

	/** A layout template for a popup. */
	var PopupTemplate = /** @class */ (function () {
	    function PopupTemplate() {
	        //////////////////////
	        /// Properties
	        //////////////////////
	        /**
	         * Specifies if hyperlinks and email addresses should automatically be detected and rendered as clickable links.
	         * Default: `true`
	         * @default true
	         */
	        this.detectHyperlinks = true;
	    }
	    //////////////////////
	    /// Public static functions
	    //////////////////////
	    /**
	     * Generates popup content by applying a template to a set of properties.
	     * If no template is specified, `title` or `name` properties will be used as fallbacks for the title if available.
	     * For content, a `description` property will be used or else all properties will be converted into a table.
	     * @param prop The properties object generate the popup content from.
	     * @param template The template to apply.
	     */
	    PopupTemplate.applyTemplate = function (prop, template) {
	        var _this = this;
	        var container = document.createElement("div");
	        container.classList.add(PopupTemplate.Css.template);
	        if (prop) {
	            if (!template) {
	                template = {};
	            }
	            if (typeof template.singleDescription !== "boolean") {
	                template.singleDescription = true;
	            }
	            template.sandboxContent = (typeof template.sandboxContent === "boolean") ? template.sandboxContent : true;
	            if (!(template.title && typeof template.content === "string" &&
	                (template.content.includes("{title}") || template.content.includes("{name}")))) {
	                if (prop.title) {
	                    template.title = "{title}";
	                }
	                else if (prop.name) {
	                    template.title = "{name}";
	                }
	            }
	            if (typeof template.detectHyperlinks !== "boolean") {
	                template.detectHyperlinks = true;
	            }
	            if (template.textColor) {
	                container.style.color = template.textColor;
	            }
	            if (template.fillColor) {
	                container.style.backgroundColor = template.fillColor;
	            }
	            if (template.title) {
	                // For security, strip out all HTML from the title and use the popup templates styling.
	                var c = this._applyStringTemplate(prop, template.title, template);
	                c.innerText = c.textContent || c.innerText || "";
	                this._appendChild(container, c, PopupTemplate.Css.title);
	            }
	            var contentItems_1 = document.createElement("div");
	            contentItems_1.classList.add(PopupTemplate.Css.content);
	            if (Array.isArray(template.content)) {
	                // Check to see if content is a PropertyInfo array.
	                if (template.content.length > 0 && template.content[0]["propertyPath"]) {
	                    this._appendChild(contentItems_1, this._generateContent(prop, template.content, template), PopupTemplate.Css.item);
	                }
	                else {
	                    template.content.forEach(function (x) {
	                        _this._appendChild(contentItems_1, _this._generateContent(prop, x, template), PopupTemplate.Css.item);
	                    });
	                }
	            }
	            else {
	                // If there is a description property, and no other properties, don't generate a table.
	                var propCount_1 = 0;
	                if (prop.description) {
	                    Object.keys(prop).forEach(function (k) {
	                        if (!_this._ignoreProperty(k, prop[k])) {
	                            propCount_1++;
	                        }
	                    });
	                }
	                var c = void 0;
	                // If there is only one property (description), or two (description + Snippet (KML)),
	                // or a flag to only display description, only add the description to the content.
	                if (propCount_1 === 1 ||
	                    (template.singleDescription && prop.description) ||
	                    (propCount_1 === 2 && prop.Snippet)) {
	                    c = document.createElement("div");
	                    c.innerHTML = prop.description;
	                }
	                else {
	                    c = this._generateContent(prop, template.content, template);
	                }
	                this._appendChild(contentItems_1, c, PopupTemplate.Css.item);
	            }
	            if (contentItems_1.innerHTML !== "") {
	                if (template.sandboxContent) {
	                    container.appendChild(PopupTemplate._createSandboxedIframe(contentItems_1, template));
	                }
	                else {
	                    container.appendChild(contentItems_1);
	                }
	            }
	        }
	        return container;
	    };
	    //////////////////////
	    /// Private functions
	    //////////////////////
	    /**
	     * Generates a sandboxed iframe that contains the specified content.
	     * @param content The content to sandbox.
	     */
	    PopupTemplate._createSandboxedIframe = function (content, template) {
	        var iframe = document.createElement("iframe");
	        iframe.sandbox.add("allow-popups");
	        var c = content.innerHTML;
	        // Need to estimate size of content and defined iframe size accordingly.
	        // Can't measure content in iframe without using cross-site scripting,
	        // so analyzing content HTML string instead for safety.
	        var hasMedia = false;
	        var lineLength = 100;
	        var width = 550;
	        var height = 10;
	        var longestStringLength = 0;
	        if (document.body.scrollWidth <= 340) {
	            width = 300;
	            lineLength = 50;
	        }
	        var lines = c.split(/<(tr|div|br|li|h[0-9]|p>)/);
	        longestStringLength = Math.max.apply(Math, (lines.map(function (el) { return el.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length; }))) - 1;
	        var w = Math.ceil(longestStringLength * 3.5);
	        if (w < width) {
	            width = w;
	            lineLength = longestStringLength;
	        }
	        // Check to see if the content contains an image.
	        if (c.includes("<img") || c.includes("<video")) {
	            hasMedia = true;
	            iframe.width = "550px";
	        }
	        else {
	            var rowHeight = (c.indexOf(PopupTemplate.Css.table) > -1) ? 25 : 20;
	            height += Math.max(lines.length * 0.5 * rowHeight, Math.ceil(c.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length / lineLength) * rowHeight);
	        }
	        iframe.width = width + "px";
	        if (hasMedia || height > 280) {
	            // If there is an image in the content, then max out content height.
	            iframe.height = "280px";
	        }
	        else {
	            iframe.height = height + "px";
	        }
	        var textColor = (template.textColor) ? "color:" + template.textColor + ";" : "";
	        var bgColor = (template.fillColor) ? "background-color:" + template.fillColor + ";" : "";
	        // Wrap content with some HTML and CSS.
	        var doc = '<html><head><title></title><meta charset="utf-8" /><meta http-equiv="x-ua-compatible" content="IE=Edge" />' +
	            ("<link rel=\"stylesheet\" href=\"" + PopupTemplate._cssUrl + "\" type=\"text/css\"/>") +
	            ("<style>html, body{margin:0;padding:0;" + textColor + bgColor + "}</style></head>") +
	            ("<body><div class=\"" + PopupTemplate.Css.template + "\" style=\"padding:0;width:" + (width - 20) + "px\">" + c + "</div></body></html>");
	        // Check to see if srcdoc of iframe is supported (versions of Edge, pre-chromium, do not support srcdoc)
	        if (iframe.srcdoc === undefined) {
	            // Non-chromium versions of Edge do not support srcdoc property on iframes.
	            // In order to inject inline HTML into an iframe in a secure way, we have to pass in an encoded string.
	            // This has a limitation of only working with shorter strings
	            // (< 1,600 characters when encoded, assuming our CSS doesn't increase in size).
	            iframe.src = "data:text/html;charset=utf-8," + encodeURI(doc);
	        }
	        else {
	            iframe.srcdoc = doc;
	        }
	        return iframe;
	    };
	    /**
	     * Appends an HTML element as a child of another element and adds a class name to the child if specified.
	     * @param container The container to add the child element to.
	     * @param child The child element to add.
	     * @param className The class name to add to the child element.
	     */
	    PopupTemplate._appendChild = function (container, child, className) {
	        if (child) {
	            if (className) {
	                child.className = ((child.className) ? child.className + " " : "") + className;
	            }
	            container.appendChild(child);
	        }
	    };
	    /**
	     * Generates the popup content based on the template and available properties.
	     * @param properties The properties to apply to the template.
	     * @param content The template content.
	     * @param template The templates.
	     */
	    PopupTemplate._generateContent = function (properties, content, template) {
	        if (content) {
	            if (Array.isArray(content)) {
	                // Content is an array of PropertyInfo.
	                return this._generatePropertyInfoTable(properties, content, template);
	            }
	            else {
	                return this._applyStringTemplate(properties, content, template);
	            }
	        }
	        var t = this._generateDynamicTableHtml(properties, null, template);
	        if (t) {
	            var d = document.createElement("div");
	            d.innerHTML = t;
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Replaces placeholders with the property values in a string template.
	     * @param properties The properties to use.
	     * @param stringTemplate The string template to apply.
	     * @param template The template.
	     */
	    PopupTemplate._applyStringTemplate = function (properties, stringTemplate, template) {
	        if (stringTemplate) {
	            var content = stringTemplate;
	            var matches = this._placeholderRx.exec(stringTemplate);
	            // Search the template string using a regular expression.
	            while (matches) {
	                if (matches.length >= 2) {
	                    // Get the property path within a placeholder.
	                    var propValue = this._getPropertyValue(properties, matches[1], template);
	                    content = content.replace(matches[0], propValue);
	                }
	                matches = this._placeholderRx.exec(stringTemplate);
	            }
	            if (content) {
	                content = content.trim();
	                // If there is no HTML tags, replace newline characters with HTML line breaks.
	                if (content.includes("<")) {
	                    content = content.replace(/[\r\n]+/g, "<br/>");
	                }
	                var d = document.createElement("div");
	                d.innerHTML = content;
	                return d;
	            }
	        }
	        return null;
	    };
	    /**
	     * Retrieves the value of a property using its path.
	     * @param properties The set of properties to search from.
	     * @param propertyPath The path of the property.
	     * @param template The template.
	     * @param propertyInfo Property info to apply which specifies how the values should be displayed.
	     */
	    PopupTemplate._getPropertyValue = function (properties, propertyPath, template, propertyInfo) {
	        var path = propertyPath.split("/");
	        var len = path.length;
	        if (len > 0 && properties) {
	            var key = path[0];
	            var obj = properties[key];
	            // Special case where a link may be a flattened link value from a atom feed.
	            if (template.detectHyperlinks && propertyPath === "link" &&
	                (!propertyInfo || propertyInfo.hyperlinkFormat)) {
	                var links_1 = [];
	                if (Array.isArray(obj)) {
	                    obj.forEach(function (l) {
	                        if (l.href) {
	                            links_1.push(l);
	                        }
	                        else if (typeof l === "string") {
	                            links_1.push({
	                                href: l
	                            });
	                        }
	                    });
	                }
	                else if (obj.href) {
	                    links_1.push(obj);
	                }
	                if (links_1.length > 0) {
	                    var f_1;
	                    if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                        f_1 = propertyInfo.hyperlinkFormat;
	                    }
	                    else if (template && template.hyperlinkFormat) {
	                        f_1 = template.hyperlinkFormat;
	                    }
	                    var t_1;
	                    if (f_1 && f_1.target) {
	                        t_1 = f_1.target;
	                    }
	                    else {
	                        t_1 = "_blank";
	                    }
	                    var html_1 = [];
	                    links_1.forEach(function (l) {
	                        if (!l.title && (!f_1 || !f_1.label) && l.rel) {
	                            html_1.push(l.rel, " - ");
	                        }
	                        html_1.push('<a href="', l.href, '" target="', t_1, '">');
	                        if (l.title) {
	                            html_1.push(l.title);
	                        }
	                        else if (f_1 && f_1.label) {
	                            html_1.push(f_1.label);
	                        }
	                        else {
	                            html_1.push(l.href);
	                        }
	                        html_1.push("</a>", "<br/>");
	                    });
	                    // Remove trailing <br/>
	                    html_1.pop();
	                    return html_1.join("");
	                }
	            }
	            if (obj != null) {
	                var i = void 0;
	                // Step through the property.
	                for (i = 1; i < len; i++) {
	                    obj = obj[path[i]];
	                    key = path[i];
	                    if (obj == null) {
	                        break;
	                    }
	                }
	                // Make sure that all properties were stepped through.
	                if (i === len && obj != null) {
	                    var propValue = void 0;
	                    if (typeof obj.value !== "undefined") {
	                        // Object is a SimpleField
	                        propValue = obj.value;
	                    }
	                    else {
	                        propValue = obj;
	                    }
	                    if (propValue instanceof Date) {
	                        if (propertyInfo && propertyInfo.dateFormat) {
	                            return propValue.toLocaleString(undefined, propertyInfo.dateFormat);
	                        }
	                        if (template.dateFormat) {
	                            return propValue.toLocaleString(undefined, template.dateFormat);
	                        }
	                        return propValue.toISOString();
	                    }
	                    else if (typeof propValue === "object") {
	                        // If the value of the property is an object, create a sub-table recursively.
	                        var t = this._generateDynamicTableHtml(propValue, path.slice(1), template);
	                        return (t) ? t : "";
	                    }
	                    else if (typeof propValue === "number") {
	                        if (propertyInfo) {
	                            if (propertyInfo.dateFormat) {
	                                // If the user assigned a date format to the field and the value is a number,
	                                // then assume that the number is the number of milliseconds.
	                                return new Date(propValue).toLocaleString(undefined, propertyInfo.dateFormat);
	                            }
	                            if (propertyInfo.numberFormat) {
	                                return propValue.toLocaleString(undefined, propertyInfo.numberFormat);
	                            }
	                        }
	                        else if (/(timestamp|date)/gi.test(key)) {
	                            // If the property name includes "timestamp" or "date" in it assume the number represents a Date object.
	                            return new Date(propValue).toISOString();
	                        }
	                        return propValue.toLocaleString(undefined, template.numberFormat);
	                    }
	                    else if (typeof propValue === "string" && propValue !== "" && !(/[\n\r<>\s]/g.test(propValue)) &&
	                        (template.detectHyperlinks || (propertyInfo && propertyInfo.hyperlinkFormat))) {
	                        // If the value is a string and doesn't include newline, spaces or xml <> characters,
	                        // then consider rendering as a hyperlink.
	                        propValue = propValue.trim();
	                        var isLink = this._isUrlRx.test(propValue) || (propertyInfo && propertyInfo.hyperlinkFormat);
	                        var isImage = this._isImageUrlRx.test(propValue) && (isLink || propValue.startsWith("data:image"));
	                        var isEmail = this._emailRx.test(propValue);
	                        if (isLink || isImage || isEmail) {
	                            var h = void 0;
	                            if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                                h = propertyInfo.hyperlinkFormat;
	                            }
	                            else if (template && template.hyperlinkFormat) {
	                                h = template.hyperlinkFormat;
	                            }
	                            var t = void 0;
	                            if (h && h.target) {
	                                t = " target=\"" + h.target + "\"";
	                            }
	                            else {
	                                t = ' target="_blank"';
	                            }
	                            var c = "" + (h && h.label ? h.label : propValue);
	                            if (h && h.scheme) {
	                                propValue = h.scheme + propValue;
	                            }
	                            else if (isEmail) {
	                                propValue = "mailto:" + propValue;
	                            }
	                            var alt = h && h.label ? " alt=\"" + h.label + "\"" : "";
	                            if ((h && h.isImage) || isImage) {
	                                c = "<img src=\"" + propValue + "\" style=\"max-width:100%\"" + alt + "\"/>";
	                            }
	                            return "<a href=\"" + propValue + "\"" + t + ">" + c + "</a>";
	                        }
	                    }
	                    var p = propValue.toString();
	                    return p;
	                }
	            }
	        }
	        return "";
	    };
	    /**
	     * Generates a table from a set of properties filtered on an array of property info values.
	     * @param properties The properties.
	     * @param propertyInfo The property info values that specify which properties to display and how to display them.
	     * @param template The template.
	     */
	    PopupTemplate._generatePropertyInfoTable = function (properties, propertyInfo, template) {
	        if (properties && propertyInfo && propertyInfo.length > 0) {
	            var html_2 = [];
	            var self_1 = this;
	            // Create a HTML table from an objects property names and values.
	            html_2.push("<table class=\"" + self_1.Css.table + "\">");
	            propertyInfo.forEach(function (pi) {
	                var c = self_1._getPropertyValue(properties, pi.propertyPath, template, pi);
	                if (pi.hideLabel) {
	                    html_2.push('<tr><td colspan="2">', c, "</td></tr>");
	                }
	                else {
	                    var l = pi.label || pi.propertyPath.split("/")[0];
	                    html_2.push("<tr><th>", l, "</th><td>", c, "</td></tr>");
	                }
	            });
	            html_2.push("</table>");
	            var d = document.createElement("div");
	            d.innerHTML = html_2.join("");
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Dynamically creates a table from the property information. Recursively steps through the property tree.
	     * @param properties The properties to generate a table for.
	     * @param subPath The sub-path within the properties to generate the table for.
	     * @param template The template.
	     */
	    PopupTemplate._generateDynamicTableHtml = function (properties, subPath, template) {
	        var _this = this;
	        if (properties) {
	            var html_3 = [];
	            var self_2 = this;
	            // Create a HTML table from an objects property names and values.
	            html_3.push("<table class=\"" + self_2.Css.table + "\">");
	            var sp_1 = (subPath && subPath.length > 0) ? subPath.join("/") + "/" : "";
	            // Count the number of rows actually added to table.
	            var cnt_1 = 0;
	            Object.keys(properties).forEach(function (key) {
	                // Ignore private properties which are commonly denoted using an underscore, and style properties.
	                if (!_this._ignoreProperty(key, properties[key])) {
	                    html_3.push("<tr><th>", key, "</th><td>", self_2._getPropertyValue(properties, sp_1 + key, template), "</td></tr>");
	                    cnt_1++;
	                }
	            });
	            // If no rows added, don't return a table.
	            if (cnt_1 === 0) {
	                return null;
	            }
	            html_3.push("</table>");
	            return html_3.join("");
	        }
	        return null;
	    };
	    /**
	     * Checks to see if the property should be ignored based on the key or value.
	     * @param key The property name key.
	     * @param value The value of the property.
	     */
	    PopupTemplate._ignoreProperty = function (key, value) {
	        switch (key) {
	            // Ignore style and title properties.
	            case "title":
	            case "name":
	            case "base":
	            case "popupTemplate":
	            case "anchor":
	            case "image":
	            case "imageUrl":
	            case "rotation":
	            case "color":
	            case "size":
	            case "offset":
	            case "strokeColor":
	            case "strokeWidth":
	            case "strokeOpacity":
	            case "fillColor":
	            case "fillOpacity":
	            case "visibility":
	            case "visible":
	                return true;
	            default:
	                if (key.indexOf("_") === 0 || value == null || value === "") {
	                    return true;
	                }
	                break;
	        }
	        return false;
	    };
	    //////////////////////
	    /// Private properties
	    //////////////////////
	    /** Regular expression for content property placeholders. */
	    PopupTemplate._placeholderRx = /\{([a-zA-Z0-9_\/]+)\}/gi;
	    /** Regular expression for external URLs. */
	    PopupTemplate._isUrlRx = /^(http|https|ftp|tel|mailto):\/\//i;
	    /** Regular expression for image urls. */
	    PopupTemplate._isImageUrlRx = /(^data:image|.png$|.jpg$|.jpeg$|.gif$|.bmp$|.svg|.tif|.tiff$)/i;
	    /** Regular expression for email addresses. */
	    PopupTemplate._emailRx = /^[^\.\s@:](?:[^\s@:]*[^\s@:\.])?@[^\.\s@]+(?:\.[^\.\s@]+)*$/;
	    /** The URL to load our CSS from for iframed popups. */
	    PopupTemplate._cssUrl = new Url({
	        domain: env.staticAssetsDomain,
	        path: "sdk/javascript/mapcontrol/" + Version.getEndpointVersion() + "/atlas.min.css"
	    }).toString();
	    PopupTemplate.Css = {
	        template: "azure-maps-control-popup-template",
	        title: "azure-maps-control-popup-template-title",
	        content: "azure-maps-control-popup-template-content",
	        item: "azure-maps-control-popup-template-content-item",
	        table: "azure-maps-control-popup-template-table"
	    };
	    return PopupTemplate;
	}());

	// Set the mapbox Right-To-Left Text Plugin
	var rtlPluginUrl = new Url({
	    domain: env.staticAssetsDomain,
	    path: "sdk/javascript/mapcontrol/" + Version.getEndpointVersion() + "/mapbox-gl-rtl-text.js"
	});
	mapboxGl_2(rtlPluginUrl.toString(), function (e) {
	    // If right to left text plugin fails to load, ignore error and continue
	});

	exports.HtmlMarker = HtmlMarker;
	exports.Map = Map$2;
	exports.Pixel = Pixel;
	exports.Popup = Popup;
	exports.PopupTemplate = PopupTemplate;
	exports.Shape = Shape;
	exports._getAssetDomain = _getAssetDomain;
	exports._getDomain = _getDomain;
	exports._hasSetAuthenticationOptions = _hasSetAuthenticationOptions;
	exports._hasSetDomain = _hasSetDomain;
	exports._hasSetLanguage = _hasSetLanguage;
	exports._hasSetSessionId = _hasSetSessionId;
	exports._hasSetView = _hasSetView;
	exports.addImageTemplate = addImageTemplate;
	exports.control = index;
	exports.data = index$3;
	exports.getAllImageTemplateNames = getAllImageTemplateNames;
	exports.getAuthenticationOptions = getAuthenticationOptions;
	exports.getDomain = getDomain;
	exports.getImageTemplate = getImageTemplate;
	exports.getLanguage = getLanguage;
	exports.getSessionId = getSessionId;
	exports.getSubscriptionKey = getSubscriptionKey;
	exports.getUserRegion = getUserRegion;
	exports.getVersion = getVersion;
	exports.getView = getView;
	exports.internal = index$1;
	exports.isSupported = isSupported;
	exports.layer = index$5;
	exports.math = index$2;
	exports.setAuthenticationOptions = setAuthenticationOptions;
	exports.setDomain = setDomain;
	exports.setLanguage = setLanguage;
	exports.setSessionId = setSessionId;
	exports.setSubscriptionKey = setSubscriptionKey;
	exports.setUserRegion = setUserRegion;
	exports.setView = setView;
	exports.source = index$4;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
